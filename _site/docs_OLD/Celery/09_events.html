<h1 id="chapter-9-events---listening-to-celerys-heartbeat">Chapter 9: Events - Listening to Celery’s Heartbeat</h1>

<p>In <a href="08_canvas__signatures___primitives_.md">Chapter 8: Canvas (Signatures &amp; Primitives)</a>, we saw how to build complex workflows by chaining tasks together or running them in parallel. But as your Celery system gets busier, you might wonder: “What are my workers doing <em>right now</em>? Which tasks have started? Which ones finished successfully or failed?”</p>

<p>Imagine you’re running an important data processing job involving many tasks. Wouldn’t it be great to have a live dashboard showing the progress, or get immediate notifications if something goes wrong? This is where <strong>Celery Events</strong> come in.</p>

<h2 id="what-problem-do-events-solve">What Problem Do Events Solve?</h2>

<p>Celery Events provide a <strong>real-time monitoring system</strong> for your tasks and workers. Think of it like a live activity log or a notification system built into Celery.</p>

<p>Without events, finding out what happened requires checking logs or querying the <a href="06_result_backend.md">Result Backend</a> for each task individually. This isn’t ideal for getting a live overview of the entire cluster.</p>

<p>Events solve this by having workers broadcast messages (events) about important actions they take, such as:</p>
<ul>
  <li>A worker coming online or going offline.</li>
  <li>A worker receiving a task.</li>
  <li>A worker starting to execute a task.</li>
  <li>A task succeeding or failing.</li>
  <li>A worker sending out a heartbeat signal.</li>
</ul>

<p>Other programs can then listen to this stream of event messages to monitor the health and activity of the Celery cluster in real-time, build dashboards (like the popular tool Flower), or trigger custom alerts.</p>

<h2 id="key-concepts">Key Concepts</h2>

<ol>
  <li><strong>Events:</strong> Special messages sent by workers (and sometimes clients) describing an action. Each event has a <code class="language-plaintext highlighter-rouge">type</code> (e.g., <code class="language-plaintext highlighter-rouge">task-received</code>, <code class="language-plaintext highlighter-rouge">worker-online</code>) and contains details relevant to that action (like the task ID, worker hostname, timestamp).</li>
  <li><strong>Event Exchange:</strong> Events aren’t sent to the regular task queues. They are published to a dedicated, named exchange on the <a href="04_broker_connection__amqp_.md">Broker Connection (AMQP)</a>. Think of it as a separate broadcast channel just for monitoring messages.</li>
  <li><strong>Event Sender (<code class="language-plaintext highlighter-rouge">EventDispatcher</code>):</strong> A component within the <a href="05_worker.md">Worker</a> responsible for creating and sending event messages to the broker’s event exchange. This is usually disabled by default for performance reasons.</li>
  <li><strong>Event Listener (<code class="language-plaintext highlighter-rouge">EventReceiver</code>):</strong> Any program that connects to the event exchange on the broker and consumes the stream of event messages. This could be the <code class="language-plaintext highlighter-rouge">celery events</code> command-line tool, Flower, or your own custom monitoring script.</li>
  <li><strong>Event Types:</strong> Celery defines many event types. Some common ones include:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">worker-online</code>, <code class="language-plaintext highlighter-rouge">worker-offline</code>, <code class="language-plaintext highlighter-rouge">worker-heartbeat</code>: Worker status updates.</li>
      <li><code class="language-plaintext highlighter-rouge">task-sent</code>: Client sent a task request (requires <code class="language-plaintext highlighter-rouge">task_send_sent_event</code> setting).</li>
      <li><code class="language-plaintext highlighter-rouge">task-received</code>: Worker received the task message.</li>
      <li><code class="language-plaintext highlighter-rouge">task-started</code>: Worker started executing the task code.</li>
      <li><code class="language-plaintext highlighter-rouge">task-succeeded</code>: Task finished successfully.</li>
      <li><code class="language-plaintext highlighter-rouge">task-failed</code>: Task failed with an error.</li>
      <li><code class="language-plaintext highlighter-rouge">task-retried</code>: Task is being retried.</li>
      <li><code class="language-plaintext highlighter-rouge">task-revoked</code>: Task was cancelled/revoked.</li>
    </ul>
  </li>
</ol>

<h2 id="how-to-use-events-simple-monitoring">How to Use Events: Simple Monitoring</h2>

<p>Let’s see how to enable events and watch the live stream using Celery’s built-in tool.</p>

<p><strong>1. Enable Events in the Worker</strong></p>

<p>By default, workers don’t send events to save resources. You need to explicitly tell them to start sending. You can do this in two main ways:</p>

<ul>
  <li>
    <p><strong>Command-line flag (<code class="language-plaintext highlighter-rouge">-E</code>):</strong> When starting your worker, add the <code class="language-plaintext highlighter-rouge">-E</code> flag.</p>

    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Start a worker AND enable sending events</span>
celery <span class="nt">-A</span> celery_app worker <span class="nt">--loglevel</span><span class="o">=</span>info <span class="nt">-E</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Configuration Setting:</strong> Set <code class="language-plaintext highlighter-rouge">worker_send_task_events = True</code> in your Celery configuration (<a href="02_configuration.md">Chapter 2: Configuration</a>). This is useful if you always want events enabled for workers using that configuration. You can also enable worker-specific events (<code class="language-plaintext highlighter-rouge">worker-online</code>, <code class="language-plaintext highlighter-rouge">worker-heartbeat</code>) with <code class="language-plaintext highlighter-rouge">worker_send_worker_events = True</code> (which defaults to True).</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># celeryconfig.py (example)
</span><span class="n">broker_url</span> <span class="o">=</span> <span class="s">'redis://localhost:6379/0'</span>
<span class="n">result_backend</span> <span class="o">=</span> <span class="s">'redis://localhost:6379/1'</span>
<span class="n">imports</span> <span class="o">=</span> <span class="p">(</span><span class="s">'tasks'</span><span class="p">,)</span>

<span class="c1"># Enable sending task-related events
</span><span class="n">task_send_sent_event</span> <span class="o">=</span> <span class="bp">False</span> <span class="c1"># Optional: If you want task-sent events too
</span><span class="n">worker_send_task_events</span> <span class="o">=</span> <span class="bp">True</span>
<span class="n">worker_send_worker_events</span> <span class="o">=</span> <span class="bp">True</span> <span class="c1"># Usually True by default
</span></code></pre></div>    </div>
  </li>
</ul>

<p>Now, any worker started with this configuration (or the <code class="language-plaintext highlighter-rouge">-E</code> flag) will publish events to the broker.</p>

<p><strong>2. Watch the Event Stream</strong></p>

<p>Celery provides a command-line tool called <code class="language-plaintext highlighter-rouge">celery events</code> that acts as a simple event listener and prints the events it receives to your console.</p>

<p>Open <strong>another terminal</strong> (while your worker with events enabled is running) and run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Watch for events associated with your app</span>
celery <span class="nt">-A</span> celery_app events
</code></pre></div></div>

<p>Alternatively, you can use the more descriptive (but older) command <code class="language-plaintext highlighter-rouge">celery control enable_events</code> to tell already running workers to start sending events, and <code class="language-plaintext highlighter-rouge">celery control disable_events</code> to stop them.</p>

<p><strong>What You’ll See:</strong></p>

<p>Initially, <code class="language-plaintext highlighter-rouge">celery events</code> might show nothing. Now, try sending a task from another script or shell (like the <code class="language-plaintext highlighter-rouge">run_tasks.py</code> from <a href="03_task.md">Chapter 3: Task</a>):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In a third terminal/shell
</span><span class="kn">from</span> <span class="nn">tasks</span> <span class="kn">import</span> <span class="n">add</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">add</span><span class="p">.</span><span class="n">delay</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Sent task </span><span class="si">{</span><span class="n">result</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>Switch back to the terminal running <code class="language-plaintext highlighter-rouge">celery events</code>. You should see output similar to this (details and timestamps will vary):</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-&gt; celery events v5.x.x
-&gt; connected to redis://localhost:6379/0

-------------- task-received celery@myhostname [2023-10-27 12:00:01.100]
    uuid:a1b2c3d4-e5f6-7890-1234-567890abcdef
    name:tasks.add
    args:[5, 10]
    kwargs:{}
    retries:0
    eta:null
    hostname:celery@myhostname
    timestamp:1666872001.1
    pid:12345
    ...

-------------- task-started celery@myhostname [2023-10-27 12:00:01.150]
    uuid:a1b2c3d4-e5f6-7890-1234-567890abcdef
    hostname:celery@myhostname
    timestamp:1666872001.15
    pid:12345
    ...

-------------- task-succeeded celery@myhostname [2023-10-27 12:00:04.200]
    uuid:a1b2c3d4-e5f6-7890-1234-567890abcdef
    result:'15'
    runtime:3.05
    hostname:celery@myhostname
    timestamp:1666872004.2
    pid:12345
    ...
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">celery events</code> connects to the broker defined in <code class="language-plaintext highlighter-rouge">celery_app</code>.</li>
  <li>It listens for messages on the event exchange.</li>
  <li>As the worker processes the <code class="language-plaintext highlighter-rouge">add(5, 10)</code> task, it sends <code class="language-plaintext highlighter-rouge">task-received</code>, <code class="language-plaintext highlighter-rouge">task-started</code>, and <code class="language-plaintext highlighter-rouge">task-succeeded</code> events.</li>
  <li><code class="language-plaintext highlighter-rouge">celery events</code> receives these messages and prints their details.</li>
</ul>

<p>This gives you a raw, real-time feed of what’s happening in your Celery cluster!</p>

<p><strong>Flower: A Visual Monitor</strong></p>

<p>While <code class="language-plaintext highlighter-rouge">celery events</code> is useful, it’s quite basic. A very popular tool called <strong>Flower</strong> uses the same event stream to provide a web-based dashboard for monitoring your Celery cluster. It shows running tasks, completed tasks, worker status, task details, and more, all updated in real-time thanks to Celery Events. You can typically install it (<code class="language-plaintext highlighter-rouge">pip install flower</code>) and run it (<code class="language-plaintext highlighter-rouge">celery -A celery_app flower</code>).</p>

<h2 id="how-it-works-internally-simplified">How It Works Internally (Simplified)</h2>

<ol>
  <li><strong>Worker Action:</strong> A worker performs an action (e.g., starts executing task <code class="language-plaintext highlighter-rouge">T1</code>).</li>
  <li><strong>Event Dispatch:</strong> If events are enabled, the worker’s internal <code class="language-plaintext highlighter-rouge">EventDispatcher</code> component is notified.</li>
  <li><strong>Create Event Message:</strong> The <code class="language-plaintext highlighter-rouge">EventDispatcher</code> creates a dictionary representing the event (e.g., <code class="language-plaintext highlighter-rouge">{'type': 'task-started', 'uuid': 'T1', 'hostname': 'worker1', ...}</code>).</li>
  <li><strong>Publish to Broker:</strong> The <code class="language-plaintext highlighter-rouge">EventDispatcher</code> uses its connection to the <a href="04_broker_connection__amqp_.md">Broker Connection (AMQP)</a> to publish this event message to a specific <strong>event exchange</strong> (usually named <code class="language-plaintext highlighter-rouge">celeryev</code>). It uses a routing key based on the event type (e.g., <code class="language-plaintext highlighter-rouge">task.started</code>).</li>
  <li><strong>Listener Connects:</strong> A monitoring tool (like <code class="language-plaintext highlighter-rouge">celery events</code> or Flower) starts up. It creates an <code class="language-plaintext highlighter-rouge">EventReceiver</code>.</li>
  <li><strong>Declare Queue:</strong> The <code class="language-plaintext highlighter-rouge">EventReceiver</code> connects to the same broker and declares a temporary, unique queue bound to the event exchange (<code class="language-plaintext highlighter-rouge">celeryev</code>), often configured to receive all event types (<code class="language-plaintext highlighter-rouge">#</code> routing key).</li>
  <li><strong>Consume Events:</strong> The <code class="language-plaintext highlighter-rouge">EventReceiver</code> starts consuming messages from its dedicated queue.</li>
  <li><strong>Process Event:</strong> When an event message (like the <code class="language-plaintext highlighter-rouge">task-started</code> message for <code class="language-plaintext highlighter-rouge">T1</code>) arrives from the broker, the <code class="language-plaintext highlighter-rouge">EventReceiver</code> decodes it and passes it to a handler (e.g., <code class="language-plaintext highlighter-rouge">celery events</code> prints it, Flower updates its web UI).</li>
</ol>

<pre><code class="language-mermaid">sequenceDiagram
    participant Worker
    participant Dispatcher as EventDispatcher (in Worker)
    participant Broker as Message Broker
    participant Receiver as EventReceiver (e.g., celery events tool)
    participant Display as Console/UI

    Worker-&gt;&gt;Worker: Starts executing Task T1
    Worker-&gt;&gt;Dispatcher: Notify: Task T1 started
    Dispatcher-&gt;&gt;Dispatcher: Create event message {'type': 'task-started', ...}
    Dispatcher-&gt;&gt;Broker: Publish event msg to 'celeryev' exchange (routing_key='task.started')
    Broker--&gt;&gt;Dispatcher: Ack (Message Sent)

    Receiver-&gt;&gt;Broker: Connect and declare unique queue bound to 'celeryev' exchange
    Broker--&gt;&gt;Receiver: Queue ready

    Broker-&gt;&gt;Receiver: Deliver event message {'type': 'task-started', ...}
    Receiver-&gt;&gt;Receiver: Decode message
    Receiver-&gt;&gt;Display: Process event (e.g., print to console)
</code></pre>

<h2 id="code-dive-sending-and-receiving-events">Code Dive: Sending and Receiving Events</h2>

<ul>
  <li>
    <p><strong>Enabling Events (<code class="language-plaintext highlighter-rouge">celery/worker/consumer/events.py</code>):</strong> The <code class="language-plaintext highlighter-rouge">Events</code> bootstep in the worker process is responsible for initializing the <code class="language-plaintext highlighter-rouge">EventDispatcher</code>. The <code class="language-plaintext highlighter-rouge">-E</code> flag or configuration settings control whether this bootstep actually enables the dispatcher.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified from worker/consumer/events.py
</span><span class="k">class</span> <span class="nc">Events</span><span class="p">(</span><span class="n">bootsteps</span><span class="p">.</span><span class="n">StartStopStep</span><span class="p">):</span>
    <span class="n">requires</span> <span class="o">=</span> <span class="p">(</span><span class="n">Connection</span><span class="p">,)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">task_events</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="c1"># Controlled by config/flags
</span>                 <span class="c1"># ... other flags ...
</span>                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">send_events</span> <span class="o">=</span> <span class="n">task_events</span> <span class="c1"># or other flags
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">enabled</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">send_events</span>
        <span class="c1"># ...
</span>        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">):</span>
        <span class="c1"># ... gets connection ...
</span>        <span class="c1"># Creates the actual dispatcher instance
</span>        <span class="n">dis</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">event_dispatcher</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">app</span><span class="p">.</span><span class="n">events</span><span class="p">.</span><span class="n">Dispatcher</span><span class="p">(</span>
            <span class="n">c</span><span class="p">.</span><span class="n">connection_for_write</span><span class="p">(),</span>
            <span class="n">hostname</span><span class="o">=</span><span class="n">c</span><span class="p">.</span><span class="n">hostname</span><span class="p">,</span>
            <span class="n">enabled</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">send_events</span><span class="p">,</span> <span class="c1"># Only sends if enabled
</span>            <span class="c1"># ... other options ...
</span>        <span class="p">)</span>
        <span class="c1"># ... flush buffer ...
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Sending Events (<code class="language-plaintext highlighter-rouge">celery/events/dispatcher.py</code>):</strong> The <code class="language-plaintext highlighter-rouge">EventDispatcher</code> class has the <code class="language-plaintext highlighter-rouge">send</code> method, which creates the event dictionary and calls <code class="language-plaintext highlighter-rouge">publish</code>.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified from events/dispatcher.py
</span><span class="k">class</span> <span class="nc">EventDispatcher</span><span class="p">:</span>
    <span class="c1"># ... __init__ setup ...
</span>
    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">blind</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="p">...,</span> <span class="o">**</span><span class="n">fields</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">enabled</span><span class="p">:</span>
            <span class="n">groups</span><span class="p">,</span> <span class="n">group</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">groups</span><span class="p">,</span> <span class="n">group_from</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">groups</span> <span class="ow">and</span> <span class="n">group</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                 <span class="k">return</span> <span class="c1"># Don't send if this group isn't enabled
</span>
            <span class="c1"># ... potential buffering logic (omitted) ...
</span>
            <span class="c1"># Call publish to actually send
</span>            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">publish</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">producer</span><span class="p">,</span> <span class="n">blind</span><span class="o">=</span><span class="n">blind</span><span class="p">,</span>
                                <span class="n">Event</span><span class="o">=</span><span class="n">Event</span><span class="p">,</span> <span class="p">...)</span>

    <span class="k">def</span> <span class="nf">publish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">fields</span><span class="p">,</span> <span class="n">producer</span><span class="p">,</span> <span class="n">blind</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">Event</span><span class="o">=</span><span class="n">Event</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Create the event dictionary
</span>        <span class="n">clock</span> <span class="o">=</span> <span class="bp">None</span> <span class="k">if</span> <span class="n">blind</span> <span class="k">else</span> <span class="bp">self</span><span class="p">.</span><span class="n">clock</span><span class="p">.</span><span class="n">forward</span><span class="p">()</span>
        <span class="n">event</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="n">hostname</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">hostname</span><span class="p">,</span> <span class="n">utcoffset</span><span class="o">=</span><span class="n">utcoffset</span><span class="p">(),</span>
                      <span class="n">pid</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">clock</span><span class="o">=</span><span class="n">clock</span><span class="p">,</span> <span class="o">**</span><span class="n">fields</span><span class="p">)</span>

        <span class="c1"># Publish using the underlying Kombu producer
</span>        <span class="k">with</span> <span class="bp">self</span><span class="p">.</span><span class="n">mutex</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_publish</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="n">producer</span><span class="p">,</span>
                                 <span class="n">routing_key</span><span class="o">=</span><span class="nb">type</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="s">'-'</span><span class="p">,</span> <span class="s">'.'</span><span class="p">),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_publish</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">producer</span><span class="p">,</span> <span class="n">routing_key</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">exchange</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">exchange</span> <span class="c1"># The dedicated event exchange
</span>        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Kombu's publish method sends the message
</span>            <span class="n">producer</span><span class="p">.</span><span class="n">publish</span><span class="p">(</span>
                <span class="n">event</span><span class="p">,</span> <span class="c1"># The dictionary payload
</span>                <span class="n">routing_key</span><span class="o">=</span><span class="n">routing_key</span><span class="p">,</span>
                <span class="n">exchange</span><span class="o">=</span><span class="n">exchange</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">declare</span><span class="o">=</span><span class="p">[</span><span class="n">exchange</span><span class="p">],</span> <span class="c1"># Ensure exchange exists
</span>                <span class="n">serializer</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">serializer</span><span class="p">,</span> <span class="c1"># e.g., 'json'
</span>                <span class="n">headers</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">headers</span><span class="p">,</span>
                <span class="n">delivery_mode</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">delivery_mode</span><span class="p">,</span> <span class="c1"># e.g., transient
</span>                <span class="o">**</span><span class="n">kwargs</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">exc</span><span class="p">:</span>
            <span class="c1"># ... error handling / buffering ...
</span>            <span class="k">raise</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Receiving Events (<code class="language-plaintext highlighter-rouge">celery/events/receiver.py</code>):</strong> The <code class="language-plaintext highlighter-rouge">EventReceiver</code> class (used by tools like <code class="language-plaintext highlighter-rouge">celery events</code>) sets up a consumer to listen for messages on the event exchange.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified from events/receiver.py
</span><span class="k">class</span> <span class="nc">EventReceiver</span><span class="p">(</span><span class="n">ConsumerMixin</span><span class="p">):</span> <span class="c1"># Uses Kombu's ConsumerMixin
</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">channel</span><span class="p">,</span> <span class="n">handlers</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">routing_key</span><span class="o">=</span><span class="s">'#'</span><span class="p">,</span> <span class="p">...):</span>
        <span class="c1"># ... setup app, channel, handlers ...
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">exchange</span> <span class="o">=</span> <span class="n">get_exchange</span><span class="p">(...,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">app</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">event_exchange</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span> <span class="c1"># Create a unique, auto-deleting queue
</span>            <span class="s">'.'</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="bp">self</span><span class="p">.</span><span class="n">queue_prefix</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">node_id</span><span class="p">]),</span>
            <span class="n">exchange</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">exchange</span><span class="p">,</span>
            <span class="n">routing_key</span><span class="o">=</span><span class="n">routing_key</span><span class="p">,</span> <span class="c1"># Often '#' to get all events
</span>            <span class="n">auto_delete</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">durable</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="c1"># ... other queue options ...
</span>        <span class="p">)</span>
        <span class="c1"># ...
</span>
    <span class="k">def</span> <span class="nf">get_consumers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Consumer</span><span class="p">,</span> <span class="n">channel</span><span class="p">):</span>
        <span class="c1"># Tell ConsumerMixin to consume from our event queue
</span>        <span class="k">return</span> <span class="p">[</span><span class="n">Consumer</span><span class="p">(</span><span class="n">queues</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">queue</span><span class="p">],</span>
                         <span class="n">callbacks</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">_receive</span><span class="p">],</span> <span class="c1"># Method to call on message
</span>                         <span class="n">no_ack</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="c1"># Events usually don't need explicit ack
</span>                         <span class="n">accept</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">accept</span><span class="p">)]</span>

    <span class="c1"># This method is registered as the callback for new messages
</span>    <span class="k">def</span> <span class="nf">_receive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
        <span class="c1"># Decode message body (can be single event or list in newer Celery)
</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">process</span><span class="p">,</span> <span class="n">from_message</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">process</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">event_from_message</span>
            <span class="p">[</span><span class="n">process</span><span class="p">(</span><span class="o">*</span><span class="n">from_message</span><span class="p">(</span><span class="n">event</span><span class="p">))</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">body</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">process</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="p">.</span><span class="n">event_from_message</span><span class="p">(</span><span class="n">body</span><span class="p">))</span>

    <span class="c1"># process() calls the appropriate handler from self.handlers
</span>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="s">"""Process event by dispatching to configured handler."""</span>
        <span class="n">handler</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">handlers</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">.</span><span class="n">handlers</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'*'</span><span class="p">)</span>
        <span class="n">handler</span> <span class="ow">and</span> <span class="n">handler</span><span class="p">(</span><span class="n">event</span><span class="p">)</span> <span class="c1"># Call the handler function
</span></code></pre></div>    </div>
  </li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Celery Events provide a powerful mechanism for <strong>real-time monitoring</strong> of your distributed task system.</p>

<ul>
  <li>Workers (when enabled via <code class="language-plaintext highlighter-rouge">-E</code> or configuration) send <strong>event messages</strong> describing their actions (like task start/finish, worker online).</li>
  <li>These messages go to a dedicated <strong>event exchange</strong> on the broker.</li>
  <li>Tools like <code class="language-plaintext highlighter-rouge">celery events</code> or Flower act as <strong>listeners</strong> (<code class="language-plaintext highlighter-rouge">EventReceiver</code>), consuming this stream to provide insights into the cluster’s activity.</li>
  <li>Events are the foundation for building dashboards, custom monitoring, and diagnostic tools.</li>
</ul>

<p>Understanding events helps you observe and manage your Celery application more effectively.</p>

<p>So far, we’ve explored the major components and concepts of Celery. But how does a worker actually start up? How does it initialize all these different parts like the connection, the consumer, the event dispatcher, and the execution pool in the right order? That’s orchestrated by a system called Bootsteps.</p>

<p><strong>Next:</strong> <a href="10_bootsteps.md">Chapter 10: Bootsteps</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
