<h1 id="chapter-3-task---the-job-description">Chapter 3: Task - The Job Description</h1>

<p>In <a href="01_celery_app.md">Chapter 1: The Celery App</a>, we set up our Celery headquarters, and in <a href="02_configuration.md">Chapter 2: Configuration</a>, we learned how to give it instructions. Now, we need to define the <em>actual work</em> we want Celery to do. This is where <strong>Tasks</strong> come in.</p>

<h2 id="what-problem-does-a-task-solve">What Problem Does a Task Solve?</h2>

<p>Imagine you have a specific job that needs doing, like “Resize this image to thumbnail size” or “Send a welcome email to this new user.” In Celery, each of these specific jobs is represented by a <strong>Task</strong>.</p>

<p>A Task is like a <strong>job description</strong> or a <strong>recipe</strong>. It contains the exact steps (the code) needed to complete a specific piece of work. You write this recipe once as a Python function, and then you can tell Celery to follow that recipe whenever you need that job done, potentially many times with different inputs (like resizing different images or sending emails to different users).</p>

<p>The key benefit is that you don’t run the recipe immediately yourself. You hand the recipe (the Task) and the ingredients (the arguments, like the image file or the user’s email) over to Celery. Celery then finds an available helper (a <a href="05_worker.md">Worker</a>) who knows how to follow that specific recipe and lets them do the work in the background. This keeps your main application free to do other things.</p>

<h2 id="defining-your-first-task">Defining Your First Task</h2>

<p>Defining a task in Celery is surprisingly simple. You just take a regular Python function and “decorate” it using <code class="language-plaintext highlighter-rouge">@app.task</code>. Remember our <code class="language-plaintext highlighter-rouge">app</code> object from <a href="01_celery_app.md">Chapter 1</a>? We use its <code class="language-plaintext highlighter-rouge">task</code> decorator.</p>

<p>Let’s create a file, perhaps named <code class="language-plaintext highlighter-rouge">tasks.py</code>, to hold our task definitions:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># tasks.py
</span><span class="kn">import</span> <span class="nn">time</span>
<span class="kn">from</span> <span class="nn">celery_app</span> <span class="kn">import</span> <span class="n">app</span> <span class="c1"># Import the app instance we created
</span>
<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">task</span>
<span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="s">"""A simple task that adds two numbers."""</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Task 'add' starting with (</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s">, </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s">)"</span><span class="p">)</span>
    <span class="c1"># Simulate some work taking time
</span>    <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Task 'add' finished with result: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>

<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">task</span>
<span class="k">def</span> <span class="nf">send_welcome_email</span><span class="p">(</span><span class="n">user_id</span><span class="p">):</span>
    <span class="s">"""A task simulating sending a welcome email."""</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Task 'send_welcome_email' starting for user </span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="c1"># Simulate email sending process
</span>    <span class="n">time</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Welcome email supposedly sent to user </span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s">"Email sent to </span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s">"</span>

<span class="c1"># You can have many tasks in one file!
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">from celery_app import app</code></strong>: We import the <code class="language-plaintext highlighter-rouge">Celery</code> app instance we configured earlier. This instance holds the knowledge about our broker and backend.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">@app.task</code></strong>: This is the magic decorator! When Celery sees this above a function (<code class="language-plaintext highlighter-rouge">add</code> or <code class="language-plaintext highlighter-rouge">send_welcome_email</code>), it says, “Ah! This isn’t just a regular function; it’s a job description that my workers need to know about.”</li>
  <li><strong>The Function (<code class="language-plaintext highlighter-rouge">add</code>, <code class="language-plaintext highlighter-rouge">send_welcome_email</code>)</strong>: This is the actual Python code that performs the work. It’s the core of the task – the steps in the recipe. It can take arguments (like <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code>, or <code class="language-plaintext highlighter-rouge">user_id</code>) and can return a value.</li>
  <li><strong>Registration</strong>: The <code class="language-plaintext highlighter-rouge">@app.task</code> decorator automatically <em>registers</em> this function with our Celery <code class="language-plaintext highlighter-rouge">app</code>. Now, <code class="language-plaintext highlighter-rouge">app</code> knows about a task named <code class="language-plaintext highlighter-rouge">tasks.add</code> and another named <code class="language-plaintext highlighter-rouge">tasks.send_welcome_email</code> (Celery creates the name from <code class="language-plaintext highlighter-rouge">module_name.function_name</code>). Workers connected to this <code class="language-plaintext highlighter-rouge">app</code> will be able to find and execute this code when requested.</li>
</ol>

<p><em>Self-Host Note:</em> If you are running this code, make sure you have a <code class="language-plaintext highlighter-rouge">celery_app.py</code> file containing your Celery app instance as shown in previous chapters, and that the <code class="language-plaintext highlighter-rouge">tasks.py</code> file can import <code class="language-plaintext highlighter-rouge">app</code> from it.</p>

<h2 id="sending-a-task-for-execution">Sending a Task for Execution</h2>

<p>Okay, we’ve written our recipes (<code class="language-plaintext highlighter-rouge">add</code> and <code class="language-plaintext highlighter-rouge">send_welcome_email</code>). How do we tell Celery, “Please run the <code class="language-plaintext highlighter-rouge">add</code> recipe with the numbers 5 and 7”?</p>

<p>We <strong>don’t call the function directly</strong> like <code class="language-plaintext highlighter-rouge">add(5, 7)</code>. If we did that, it would just run immediately in our current program, which defeats the purpose of using Celery!</p>

<p>Instead, we use special methods on the task object itself, most commonly <code class="language-plaintext highlighter-rouge">.delay()</code> or <code class="language-plaintext highlighter-rouge">.apply_async()</code>.</p>

<p>Let’s try this in a separate Python script or an interactive Python session:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># run_tasks.py
</span><span class="kn">from</span> <span class="nn">tasks</span> <span class="kn">import</span> <span class="n">add</span><span class="p">,</span> <span class="n">send_welcome_email</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Let's send some tasks!"</span><span class="p">)</span>

<span class="c1"># --- Using .delay() ---
# Tell Celery to run add(5, 7) in the background
</span><span class="n">result_promise_add</span> <span class="o">=</span> <span class="n">add</span><span class="p">.</span><span class="n">delay</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Sent task add(5, 7). Task ID: </span><span class="si">{</span><span class="n">result_promise_add</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># Tell Celery to run send_welcome_email(123) in the background
</span><span class="n">result_promise_email</span> <span class="o">=</span> <span class="n">send_welcome_email</span><span class="p">.</span><span class="n">delay</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Sent task send_welcome_email(123). Task ID: </span><span class="si">{</span><span class="n">result_promise_email</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>


<span class="c1"># --- Using .apply_async() ---
# Does the same thing as .delay() but allows more options
</span><span class="n">result_promise_add_later</span> <span class="o">=</span> <span class="n">add</span><span class="p">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span> <span class="n">countdown</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span> <span class="c1"># Run after 10s
</span><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Sent task add(10, 20) to run in 10s. Task ID: </span><span class="si">{</span><span class="n">result_promise_add_later</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Tasks have been sent to the broker!"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"A Celery worker needs to be running to pick them up."</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">from tasks import add, send_welcome_email</code></strong>: We import our <em>task functions</em>. Because they were decorated with <code class="language-plaintext highlighter-rouge">@app.task</code>, they are now special Celery Task objects.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">add.delay(5, 7)</code></strong>: This is the simplest way to send a task.
    <ul>
      <li>It <em>doesn’t</em> run <code class="language-plaintext highlighter-rouge">add(5, 7)</code> right now.</li>
      <li>It takes the arguments <code class="language-plaintext highlighter-rouge">(5, 7)</code>.</li>
      <li>It packages them up into a <strong>message</strong> along with the task’s name (<code class="language-plaintext highlighter-rouge">tasks.add</code>).</li>
      <li>It sends this message to the <strong>message broker</strong> (like Redis or RabbitMQ) that we configured in our <code class="language-plaintext highlighter-rouge">celery_app.py</code>. Think of it like dropping a request slip into a mailbox.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">send_welcome_email.delay(123)</code></strong>: Same idea, but for our email task. A message with <code class="language-plaintext highlighter-rouge">tasks.send_welcome_email</code> and the argument <code class="language-plaintext highlighter-rouge">123</code> is sent to the broker.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">add.apply_async(args=(10, 20), countdown=10)</code></strong>: This is a more powerful way to send tasks.
    <ul>
      <li>It does the same fundamental thing: sends a message to the broker.</li>
      <li>It allows for more options, like <code class="language-plaintext highlighter-rouge">args</code> (positional arguments as a tuple), <code class="language-plaintext highlighter-rouge">kwargs</code> (keyword arguments as a dict), <code class="language-plaintext highlighter-rouge">countdown</code> (delay execution by seconds), <code class="language-plaintext highlighter-rouge">eta</code> (run at a specific future time), and many others.</li>
      <li><code class="language-plaintext highlighter-rouge">.delay(*args, **kwargs)</code> is just a convenient shortcut for <code class="language-plaintext highlighter-rouge">.apply_async(args=args, kwargs=kwargs)</code>.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">result_promise_... = ...</code></strong>: Both <code class="language-plaintext highlighter-rouge">.delay()</code> and <code class="language-plaintext highlighter-rouge">apply_async()</code> return an <code class="language-plaintext highlighter-rouge">AsyncResult</code> object immediately. This is <em>not</em> the actual result of the task (like <code class="language-plaintext highlighter-rouge">12</code> for <code class="language-plaintext highlighter-rouge">add(5, 7)</code>). It’s more like a receipt or a tracking number (notice the <code class="language-plaintext highlighter-rouge">.id</code> attribute). You can use this object later to check if the task finished and what its result was, but only if you’ve set up a <a href="06_result_backend.md">Result Backend</a> (Chapter 6).</li>
  <li><strong>The Worker</strong>: Sending the task only puts the message on the queue. A separate process, the Celery <a href="05_worker.md">Worker</a> (Chapter 5), needs to be running. The worker constantly watches the queue, picks up messages, finds the corresponding task function (using the name like <code class="language-plaintext highlighter-rouge">tasks.add</code>), and executes it with the provided arguments.</li>
</ol>

<h2 id="how-it-works-internally-simplified">How It Works Internally (Simplified)</h2>

<p>Let’s trace the journey of defining and sending our <code class="language-plaintext highlighter-rouge">add</code> task:</p>

<ol>
  <li><strong>Definition (<code class="language-plaintext highlighter-rouge">@app.task</code> in <code class="language-plaintext highlighter-rouge">tasks.py</code>)</strong>:
    <ul>
      <li>Python defines the <code class="language-plaintext highlighter-rouge">add</code> function.</li>
      <li>The <code class="language-plaintext highlighter-rouge">@app.task</code> decorator sees this function.</li>
      <li>It tells the <code class="language-plaintext highlighter-rouge">Celery</code> instance (<code class="language-plaintext highlighter-rouge">app</code>) about this function, registering it under the name <code class="language-plaintext highlighter-rouge">tasks.add</code> in an internal dictionary (<code class="language-plaintext highlighter-rouge">app.tasks</code>). The <code class="language-plaintext highlighter-rouge">app</code> instance knows the broker/backend settings.</li>
    </ul>
  </li>
  <li><strong>Sending (<code class="language-plaintext highlighter-rouge">add.delay(5, 7)</code> in <code class="language-plaintext highlighter-rouge">run_tasks.py</code>)</strong>:
    <ul>
      <li>You call <code class="language-plaintext highlighter-rouge">.delay()</code> on the <code class="language-plaintext highlighter-rouge">add</code> task object.</li>
      <li><code class="language-plaintext highlighter-rouge">.delay()</code> (or <code class="language-plaintext highlighter-rouge">.apply_async()</code>) internally uses the <code class="language-plaintext highlighter-rouge">app</code> the task is bound to.</li>
      <li>It asks the <code class="language-plaintext highlighter-rouge">app</code> for the configured broker URL.</li>
      <li>It creates a message containing:
        <ul>
          <li>Task Name: <code class="language-plaintext highlighter-rouge">tasks.add</code></li>
          <li>Arguments: <code class="language-plaintext highlighter-rouge">(5, 7)</code></li>
          <li>Other options (like a unique Task ID).</li>
        </ul>
      </li>
      <li>It connects to the <strong>Broker</strong> (e.g., Redis) using the broker URL.</li>
      <li>It sends the message to a specific queue (usually named ‘celery’ by default) on the broker.</li>
      <li>It returns an <code class="language-plaintext highlighter-rouge">AsyncResult</code> object referencing the Task ID.</li>
    </ul>
  </li>
  <li><strong>Waiting</strong>: The message sits in the queue on the broker, waiting.</li>
  <li><strong>Execution (by a <a href="05_worker.md">Worker</a>)</strong>:
    <ul>
      <li>A separate Celery Worker process is running, connected to the same broker and <code class="language-plaintext highlighter-rouge">app</code>.</li>
      <li>The Worker fetches the message from the queue.</li>
      <li>It reads the task name: <code class="language-plaintext highlighter-rouge">tasks.add</code>.</li>
      <li>It looks up <code class="language-plaintext highlighter-rouge">tasks.add</code> in its copy of the <code class="language-plaintext highlighter-rouge">app.tasks</code> registry to find the actual <code class="language-plaintext highlighter-rouge">add</code> function code.</li>
      <li>It calls the <code class="language-plaintext highlighter-rouge">add</code> function with the arguments from the message: <code class="language-plaintext highlighter-rouge">add(5, 7)</code>.</li>
      <li>The function runs (prints logs, sleeps, calculates <code class="language-plaintext highlighter-rouge">12</code>).</li>
      <li>If a <a href="06_result_backend.md">Result Backend</a> is configured, the Worker takes the return value (<code class="language-plaintext highlighter-rouge">12</code>) and stores it in the backend, associated with the Task ID.</li>
      <li>The Worker acknowledges the message to the broker, removing it from the queue.</li>
    </ul>
  </li>
</ol>

<pre><code class="language-mermaid">sequenceDiagram
    participant Client as Your Code (run_tasks.py)
    participant TaskDef as @app.task def add()
    participant App as Celery App Instance
    participant Broker as Message Broker (e.g., Redis)
    participant Worker as Celery Worker (separate process)

    Note over TaskDef, App: 1. @app.task registers 'add' function with App's task registry

    Client-&gt;&gt;TaskDef: 2. Call add.delay(5, 7)
    TaskDef-&gt;&gt;App: 3. Get broker config
    App--&gt;&gt;TaskDef: Broker URL
    TaskDef-&gt;&gt;Broker: 4. Send message ('tasks.add', (5, 7), task_id, ...)
    Broker--&gt;&gt;TaskDef: Ack (Message Queued)
    TaskDef--&gt;&gt;Client: 5. Return AsyncResult(task_id)

    Worker-&gt;&gt;Broker: 6. Fetch next message
    Broker--&gt;&gt;Worker: Message ('tasks.add', (5, 7), task_id)
    Worker-&gt;&gt;App: 7. Lookup 'tasks.add' in registry
    App--&gt;&gt;Worker: add function code
    Worker-&gt;&gt;Worker: 8. Execute add(5, 7) -&gt; returns 12
    Note over Worker: (Optionally store result in Backend)
    Worker-&gt;&gt;Broker: 9. Acknowledge message completion
</code></pre>

<h2 id="code-dive-task-creation-and-sending">Code Dive: Task Creation and Sending</h2>

<ul>
  <li>
    <p><strong>Task Definition (<code class="language-plaintext highlighter-rouge">@app.task</code>)</strong>: This decorator is defined in <code class="language-plaintext highlighter-rouge">celery/app/base.py</code> within the <code class="language-plaintext highlighter-rouge">Celery</code> class method <code class="language-plaintext highlighter-rouge">task</code>. It ultimately calls <code class="language-plaintext highlighter-rouge">_task_from_fun</code>.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified from celery/app/base.py
</span><span class="k">class</span> <span class="nc">Celery</span><span class="p">:</span>
    <span class="c1"># ...
</span>    <span class="k">def</span> <span class="nf">task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">):</span>
        <span class="c1"># ... handles decorator arguments ...
</span>        <span class="k">def</span> <span class="nf">_create_task_cls</span><span class="p">(</span><span class="n">fun</span><span class="p">):</span>
            <span class="c1"># Returns a Task instance or a Proxy that creates one later
</span>            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_task_from_fun</span><span class="p">(</span><span class="n">fun</span><span class="p">,</span> <span class="o">**</span><span class="n">opts</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">_create_task_cls</span>

    <span class="k">def</span> <span class="nf">_task_from_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fun</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">bind</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="c1"># Generate name like 'tasks.add' if not given
</span>        <span class="n">name</span> <span class="o">=</span> <span class="n">name</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">.</span><span class="n">gen_task_name</span><span class="p">(</span><span class="n">fun</span><span class="p">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">fun</span><span class="p">.</span><span class="n">__module__</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">base</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">.</span><span class="n">Task</span> <span class="c1"># The base Task class (from celery.app.task)
</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">_tasks</span><span class="p">:</span> <span class="c1"># If not already registered...
</span>            <span class="c1"># Dynamically create a Task class wrapping the function
</span>            <span class="n">task</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">fun</span><span class="p">.</span><span class="n">__name__</span><span class="p">,</span> <span class="p">(</span><span class="n">base</span><span class="p">,),</span> <span class="p">{</span>
                <span class="s">'app'</span><span class="p">:</span> <span class="bp">self</span><span class="p">,</span> <span class="c1"># Link task back to this app instance!
</span>                <span class="s">'name'</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
                <span class="s">'run'</span><span class="p">:</span> <span class="nb">staticmethod</span><span class="p">(</span><span class="n">fun</span><span class="p">),</span> <span class="c1"># The actual function to run
</span>                <span class="s">'__doc__'</span><span class="p">:</span> <span class="n">fun</span><span class="p">.</span><span class="n">__doc__</span><span class="p">,</span>
                <span class="s">'__module__'</span><span class="p">:</span> <span class="n">fun</span><span class="p">.</span><span class="n">__module__</span><span class="p">,</span>
                <span class="c1"># ... other options ...
</span>            <span class="p">})()</span> <span class="c1"># Instantiate the new Task class
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">_tasks</span><span class="p">[</span><span class="n">task</span><span class="p">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">task</span> <span class="c1"># Add to app's registry!
</span>            <span class="n">task</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="c1"># Perform binding steps
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">task</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_tasks</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="c1"># Task already exists
</span>        <span class="k">return</span> <span class="n">task</span>
</code></pre></div>    </div>
    <p>This shows how the decorator essentially creates a specialized object (an instance of a class derived from <code class="language-plaintext highlighter-rouge">celery.app.task.Task</code>) that wraps your original function and registers it with the <code class="language-plaintext highlighter-rouge">app</code> under a specific name.</p>
  </li>
  <li>
    <p><strong>Task Sending (<code class="language-plaintext highlighter-rouge">.delay</code>)</strong>: The <code class="language-plaintext highlighter-rouge">.delay()</code> method is defined on the <code class="language-plaintext highlighter-rouge">Task</code> class itself in <code class="language-plaintext highlighter-rouge">celery/app/task.py</code>. It’s a simple shortcut.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified from celery/app/task.py
</span><span class="k">class</span> <span class="nc">Task</span><span class="p">:</span>
    <span class="c1"># ...
</span>    <span class="k">def</span> <span class="nf">delay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s">"""Shortcut for apply_async(args, kwargs)"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">apply_async</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="p">...,</span> <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="c1"># ... argument checking, option processing ...
</span>
        <span class="c1"># Get the app associated with this task instance
</span>        <span class="n">app</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_get_app</span><span class="p">()</span>

        <span class="c1"># If always_eager is set, run locally instead of sending
</span>        <span class="k">if</span> <span class="n">app</span><span class="p">.</span><span class="n">conf</span><span class="p">.</span><span class="n">task_always_eager</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="nb">apply</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="p">...)</span> <span class="c1"># Runs inline
</span>
        <span class="c1"># The main path: tell the app to send the task message
</span>        <span class="k">return</span> <span class="n">app</span><span class="p">.</span><span class="n">send_task</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">task_type</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="o">**</span><span class="n">options</span> <span class="c1"># Includes things like countdown, eta, queue etc.
</span>        <span class="p">)</span>
</code></pre></div>    </div>
    <p>You can see how <code class="language-plaintext highlighter-rouge">.delay</code> just calls <code class="language-plaintext highlighter-rouge">.apply_async</code>, which then (usually) delegates the actual message sending to the <code class="language-plaintext highlighter-rouge">app.send_task</code> method we saw briefly in <a href="01_celery_app.md">Chapter 1</a>. The <code class="language-plaintext highlighter-rouge">app</code> uses its configuration to know <em>how</em> and <em>where</em> to send the message.</p>
  </li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve learned the core concept of a Celery <strong>Task</strong>:</p>

<ul>
  <li>It represents a single, well-defined <strong>unit of work</strong> or <strong>job description</strong>.</li>
  <li>You define a task by decorating a normal Python function with <code class="language-plaintext highlighter-rouge">@app.task</code>. This <strong>registers</strong> the task with your Celery application.</li>
  <li>You <strong>send</strong> a task request (not run it directly) using <code class="language-plaintext highlighter-rouge">.delay()</code> or <code class="language-plaintext highlighter-rouge">.apply_async()</code>.</li>
  <li>Sending a task puts a <strong>message</strong> onto a queue managed by a <strong>message broker</strong>.</li>
  <li>A separate <strong>Worker</strong> process picks up the message and executes the corresponding task function.</li>
</ul>

<p>Tasks are the fundamental building blocks of work in Celery. Now that you know how to define a task and request its execution, let’s look more closely at the crucial component that handles passing these requests around: the message broker.</p>

<p><strong>Next:</strong> <a href="04_broker_connection__amqp_.md">Chapter 4: Broker Connection (AMQP)</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
