<h1 id="chapter-7-data-structures-views---the-projects-blueprints">Chapter 7: Data Structures (Views) - The Project’s Blueprints</h1>

<p>In the <a href="06_message_manager.md">previous chapter</a>, we saw how the <code class="language-plaintext highlighter-rouge">MessageManager</code> acts like a secretary, carefully organizing the conversation between the <a href="01_agent.md">Agent</a> and the LLM. It manages different pieces of information – the browser’s current state, the LLM’s plan, the results of actions, and more.</p>

<p>But how do all these different components – the Agent, the LLM parser, the <a href="03_browsercontext.md">BrowserContext</a>, the <a href="05_action_controller___registry.md">Action Controller &amp; Registry</a>, and the <a href="06_message_manager.md">Message Manager</a> – ensure they understand each other perfectly? If the LLM gives a plan in one format, and the Controller expects it in another, things will break!</p>

<p>Imagine trying to build furniture using instructions written in a language you don’t fully understand, or trying to fill out a form where every section uses a different layout. It would be confusing and error-prone. We need a shared, consistent language and format.</p>

<p>This is where <strong>Data Structures (Views)</strong> come in. They act as the official blueprints or standardized forms for all the important information passed around within the <code class="language-plaintext highlighter-rouge">Browser Use</code> project.</p>

<h2 id="what-problem-do-data-structures-solve">What Problem Do Data Structures Solve?</h2>

<p>In a complex system like <code class="language-plaintext highlighter-rouge">Browser Use</code>, many components need to exchange data:</p>

<ul>
  <li>The <a href="03_browsercontext.md">BrowserContext</a> needs to package up the current state of the webpage.</li>
  <li>The <a href="01_agent.md">Agent</a> needs to understand the LLM’s multi-step plan.</li>
  <li>The <a href="05_action_controller___registry.md">Action Controller &amp; Registry</a> needs to know exactly which action to perform and with what specific parameters (like which element index to click).</li>
  <li>The Controller needs to report back the result of an action in a predictable way.</li>
</ul>

<p>Without a standard format for each piece of data, you might encounter problems like:</p>

<ul>
  <li>Misinterpreting data (e.g., is <code class="language-plaintext highlighter-rouge">5</code> an element index or a quantity?).</li>
  <li>Missing required information.</li>
  <li>Inconsistent naming (<code class="language-plaintext highlighter-rouge">element_id</code> vs <code class="language-plaintext highlighter-rouge">index</code> vs <code class="language-plaintext highlighter-rouge">element_number</code>).</li>
  <li>Difficulty debugging when data looks different every time.</li>
</ul>

<p>Data Structures (Views) solve this by defining <strong>strict, consistent blueprints</strong> for the data. Everyone agrees to use these blueprints, ensuring smooth communication and preventing errors.</p>

<h2 id="meet-pydantic-the-blueprint-maker-and-checker">Meet Pydantic: The Blueprint Maker and Checker</h2>

<p>In <code class="language-plaintext highlighter-rouge">Browser Use</code>, these blueprints are primarily defined using a popular Python library called <strong>Pydantic</strong>.</p>

<p>Think of Pydantic like a combination of:</p>

<ol>
  <li><strong>A Blueprint Designer:</strong> It provides an easy way to define the structure of your data using standard Python type hints (like <code class="language-plaintext highlighter-rouge">str</code> for text, <code class="language-plaintext highlighter-rouge">int</code> for whole numbers, <code class="language-plaintext highlighter-rouge">bool</code> for True/False, <code class="language-plaintext highlighter-rouge">list</code> for lists).</li>
  <li><strong>A Quality Inspector:</strong> When data comes in (e.g., from the LLM or from an action’s result), Pydantic automatically checks if it matches the blueprint. Does it have all the required fields? Are the data types correct? If not, Pydantic raises an error, stopping bad data before it causes problems later.</li>
</ol>

<p>These Pydantic models (our blueprints) are often stored in files named <code class="language-plaintext highlighter-rouge">views.py</code> within different component directories (like <code class="language-plaintext highlighter-rouge">agent/views.py</code>, <code class="language-plaintext highlighter-rouge">browser/views.py</code>), which is why we sometimes call them “Views”.</p>

<h2 id="key-blueprints-in-browser-use">Key Blueprints in <code class="language-plaintext highlighter-rouge">Browser Use</code></h2>

<p>Let’s look at some of the most important data structures used in the project. Don’t worry about memorizing every detail; focus on <em>what kind</em> of information each blueprint holds and <em>who</em> uses it.</p>

<p><em>(Note: These are simplified representations. The actual models might have more fields or features.)</em></p>

<h3 id="1-browserstate-from-browserviewspy">1. <code class="language-plaintext highlighter-rouge">BrowserState</code> (from <code class="language-plaintext highlighter-rouge">browser/views.py</code>)</h3>

<ul>
  <li><strong>Purpose:</strong> Represents a complete snapshot of the browser’s state at a specific moment.</li>
  <li><strong>Blueprint Contents (Simplified):</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">url</code>: The current web address (string).</li>
      <li><code class="language-plaintext highlighter-rouge">title</code>: The title of the webpage (string).</li>
      <li><code class="language-plaintext highlighter-rouge">element_tree</code>: The simplified map of the webpage content (from <a href="04_dom_representation.md">DOM Representation</a>).</li>
      <li><code class="language-plaintext highlighter-rouge">selector_map</code>: The lookup map for interactive elements (from <a href="04_dom_representation.md">DOM Representation</a>).</li>
      <li><code class="language-plaintext highlighter-rouge">screenshot</code>: An optional image of the page (string, base64 encoded).</li>
      <li><code class="language-plaintext highlighter-rouge">tabs</code>: Information about other open tabs in this context (list).</li>
    </ul>
  </li>
  <li><strong>Who Uses It:</strong>
    <ul>
      <li>Created by: <a href="03_browsercontext.md">BrowserContext</a> (<code class="language-plaintext highlighter-rouge">get_state()</code> method).</li>
      <li>Used by: <a href="01_agent.md">Agent</a> (to see the current situation), <a href="06_message_manager.md">Message Manager</a> (to store in history).</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- Conceptual Pydantic Model ---
# File: browser/views.py (Simplified Example)
</span><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Dict</span> <span class="c1"># For type hints
# Assume DOMElementNode and TabInfo are defined elsewhere
</span>
<span class="k">class</span> <span class="nc">BrowserState</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">url</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">title</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">element_tree</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="c1"># Simplified: Actual type is DOMElementNode
</span>    <span class="n">selector_map</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">object</span><span class="p">]]</span> <span class="c1"># Simplified: Actual type is SelectorMap
</span>    <span class="n">screenshot</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># Optional field
</span>    <span class="n">tabs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Simplified: Actual type is TabInfo
</span>
<span class="c1"># Pydantic ensures that when a BrowserState is created,
# 'url' and 'title' MUST be provided as strings.
</span></code></pre></div></div>

<h3 id="2-actionmodel-from-controllerregistryviewspy">2. <code class="language-plaintext highlighter-rouge">ActionModel</code> (from <code class="language-plaintext highlighter-rouge">controller/registry/views.py</code>)</h3>

<ul>
  <li><strong>Purpose:</strong> Represents a <em>single</em> specific action the LLM wants to perform, including its parameters. This model is often created <em>dynamically</em> based on the actions available in the <a href="05_action_controller___registry.md">Action Controller &amp; Registry</a>.</li>
  <li><strong>Blueprint Contents (Example for <code class="language-plaintext highlighter-rouge">click_element</code>):</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">index</code>: The <code class="language-plaintext highlighter-rouge">highlight_index</code> of the element to click (integer).</li>
      <li><code class="language-plaintext highlighter-rouge">xpath</code>: An optional hint about the element’s location (string).</li>
    </ul>
  </li>
  <li><strong>Blueprint Contents (Example for <code class="language-plaintext highlighter-rouge">input_text</code>):</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">index</code>: The <code class="language-plaintext highlighter-rouge">highlight_index</code> of the input field (integer).</li>
      <li><code class="language-plaintext highlighter-rouge">text</code>: The text to type (string).</li>
    </ul>
  </li>
  <li><strong>Who Uses It:</strong>
    <ul>
      <li>Defined by/Registered in: <a href="05_action_controller___registry.md">Action Controller &amp; Registry</a>.</li>
      <li>Created based on: LLM output (often part of <code class="language-plaintext highlighter-rouge">AgentOutput</code>).</li>
      <li>Used by: <a href="05_action_controller___registry.md">Action Controller &amp; Registry</a> (to validate parameters and know what function to call).</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- Conceptual Pydantic Models ---
# File: controller/views.py (Simplified Examples)
</span><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>

<span class="k">class</span> <span class="nc">ClickElementAction</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">xpath</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># Optional hint
</span>
<span class="k">class</span> <span class="nc">InputTextAction</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">text</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">xpath</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># Optional hint
</span>
<span class="c1"># Base model that dynamically holds ONE of the above actions
</span><span class="k">class</span> <span class="nc">ActionModel</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="c1"># Pydantic allows models like this where only one field is expected
</span>    <span class="c1"># e.g., ActionModel(click_element=ClickElementAction(index=5))
</span>    <span class="c1"># or    ActionModel(input_text=InputTextAction(index=12, text="hello"))
</span>    <span class="n">click_element</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ClickElementAction</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">input_text</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InputTextAction</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="c1"># ... fields for other possible actions (scroll, done, etc.) ...
</span>    <span class="k">pass</span> <span class="c1"># More complex logic handles ensuring only one action is present
</span></code></pre></div></div>

<h3 id="3-agentoutput-from-agentviewspy">3. <code class="language-plaintext highlighter-rouge">AgentOutput</code> (from <code class="language-plaintext highlighter-rouge">agent/views.py</code>)</h3>

<ul>
  <li><strong>Purpose:</strong> Represents the complete plan received from the LLM after it analyzes the current state. This is the structure the <a href="02_system_prompt.md">System Prompt</a> tells the LLM to follow.</li>
  <li><strong>Blueprint Contents (Simplified):</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">current_state</code>: The LLM’s thoughts/reasoning (a nested structure, often called <code class="language-plaintext highlighter-rouge">AgentBrain</code>).</li>
      <li><code class="language-plaintext highlighter-rouge">action</code>: A <em>list</em> of one or more <code class="language-plaintext highlighter-rouge">ActionModel</code> objects representing the steps the LLM wants to take.</li>
    </ul>
  </li>
  <li><strong>Who Uses It:</strong>
    <ul>
      <li>Created by: The <a href="01_agent.md">Agent</a> parses the LLM’s raw JSON output into this structure.</li>
      <li>Used by: <a href="01_agent.md">Agent</a> (to understand the plan), <a href="06_message_manager.md">Message Manager</a> (to store the plan in history), <a href="05_action_controller___registry.md">Action Controller &amp; Registry</a> (reads the <code class="language-plaintext highlighter-rouge">action</code> list).</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- Conceptual Pydantic Model ---
# File: agent/views.py (Simplified Example)
</span><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="c1"># Assume ActionModel and AgentBrain are defined elsewhere
</span>
<span class="k">class</span> <span class="nc">AgentOutput</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">current_state</span><span class="p">:</span> <span class="nb">object</span> <span class="c1"># Simplified: Actual type is AgentBrain
</span>    <span class="n">action</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ActionModel</span><span class="p">]</span> <span class="c1"># A list of actions to execute
</span>
<span class="c1"># Pydantic ensures the LLM output MUST have 'current_state' and 'action',
# and that 'action' MUST be a list containing valid ActionModel objects.
</span></code></pre></div></div>

<h3 id="4-actionresult-from-agentviewspy">4. <code class="language-plaintext highlighter-rouge">ActionResult</code> (from <code class="language-plaintext highlighter-rouge">agent/views.py</code>)</h3>

<ul>
  <li><strong>Purpose:</strong> Represents the outcome after the <a href="05_action_controller___registry.md">Action Controller &amp; Registry</a> attempts to execute a single action.</li>
  <li><strong>Blueprint Contents (Simplified):</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">is_done</code>: Did this action signal the end of the overall task? (boolean, optional).</li>
      <li><code class="language-plaintext highlighter-rouge">success</code>: If done, was the task successful overall? (boolean, optional).</li>
      <li><code class="language-plaintext highlighter-rouge">extracted_content</code>: Any text result from the action (e.g., “Clicked button X”) (string, optional).</li>
      <li><code class="language-plaintext highlighter-rouge">error</code>: Any error message if the action failed (string, optional).</li>
      <li><code class="language-plaintext highlighter-rouge">include_in_memory</code>: Should this result be explicitly shown to the LLM next time? (boolean).</li>
    </ul>
  </li>
  <li><strong>Who Uses It:</strong>
    <ul>
      <li>Created by: Functions within the <a href="05_action_controller___registry.md">Action Controller &amp; Registry</a> (like <code class="language-plaintext highlighter-rouge">click_element</code>).</li>
      <li>Used by: <a href="01_agent.md">Agent</a> (to check status, record results), <a href="06_message_manager.md">Message Manager</a> (includes info in the next state message sent to LLM).</li>
    </ul>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- Conceptual Pydantic Model ---
# File: agent/views.py (Simplified Example)
</span><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>

<span class="k">class</span> <span class="nc">ActionResult</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">is_done</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">success</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">extracted_content</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">error</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">include_in_memory</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span> <span class="c1"># Default to False
</span>
<span class="c1"># Pydantic helps ensure results are consistently structured.
# For example, 'is_done' must be True or False if provided.
</span></code></pre></div></div>

<h2 id="the-power-of-blueprints-ensuring-consistency">The Power of Blueprints: Ensuring Consistency</h2>

<p>Using Pydantic models for these data structures provides a huge benefit: <strong>automatic validation</strong>.</p>

<p>Imagine the LLM sends back a plan, but it forgets to include the <code class="language-plaintext highlighter-rouge">index</code> for a <code class="language-plaintext highlighter-rouge">click_element</code> action.</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">//</span><span class="w"> </span><span class="err">Bad</span><span class="w"> </span><span class="err">LLM</span><span class="w"> </span><span class="err">Response</span><span class="w"> </span><span class="err">(Missing</span><span class="w"> </span><span class="err">'index')</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="nl">"current_state"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">...</span><span class="w"> </span><span class="p">},</span><span class="w">
  </span><span class="nl">"action"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"click_element"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
         </span><span class="nl">"xpath"</span><span class="p">:</span><span class="w"> </span><span class="s2">"//button[@id='submit']"</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">'index'</span><span class="w"> </span><span class="err">is</span><span class="w"> </span><span class="err">missing!</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>When the <a href="01_agent.md">Agent</a> tries to parse this JSON into the <code class="language-plaintext highlighter-rouge">AgentOutput</code> Pydantic model, Pydantic will immediately notice that the <code class="language-plaintext highlighter-rouge">index</code> field (which is required by the <code class="language-plaintext highlighter-rouge">ClickElementAction</code> blueprint) is missing. It will raise a <code class="language-plaintext highlighter-rouge">ValidationError</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- Conceptual Agent Code ---
</span><span class="kn">import</span> <span class="nn">pydantic</span>
<span class="c1"># Assume AgentOutput is the Pydantic model defined earlier
# Assume 'llm_json_response' contains the bad JSON from above
</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Try to create the AgentOutput object from the LLM's response
</span>    <span class="n">llm_plan</span> <span class="o">=</span> <span class="n">AgentOutput</span><span class="p">.</span><span class="n">model_validate_json</span><span class="p">(</span><span class="n">llm_json_response</span><span class="p">)</span>
    <span class="c1"># If validation succeeds, proceed...
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"LLM Plan Validated:"</span><span class="p">,</span> <span class="n">llm_plan</span><span class="p">)</span>
<span class="k">except</span> <span class="n">pydantic</span><span class="p">.</span><span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="c1"># Pydantic catches the error!
</span>    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Validation Error: The LLM response didn't match the blueprint!"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="c1"># The Agent can now handle this error gracefully,
</span>    <span class="c1"># maybe asking the LLM to try again, instead of crashing later.
</span></code></pre></div></div>

<p>This automatic checking catches errors early, preventing the <a href="05_action_controller___registry.md">Action Controller &amp; Registry</a> from receiving incomplete instructions and making the whole system much more robust and easier to debug. It enforces the “contract” between different components.</p>

<h2 id="under-the-hood-simple-classes">Under the Hood: Simple Classes</h2>

<p>These data structures are simply Python classes, mostly inheriting from <code class="language-plaintext highlighter-rouge">pydantic.BaseModel</code> or defined using Python’s built-in <code class="language-plaintext highlighter-rouge">dataclass</code>. They don’t contain complex logic themselves; their main job is to define the <em>shape</em> and <em>type</em> of the data. You’ll find their definitions scattered across the various <code class="language-plaintext highlighter-rouge">views.py</code> files within the project’s component directories (like <code class="language-plaintext highlighter-rouge">agent/</code>, <code class="language-plaintext highlighter-rouge">browser/</code>, <code class="language-plaintext highlighter-rouge">controller/</code>, <code class="language-plaintext highlighter-rouge">dom/</code>).</p>

<p>Think of them as the official vocabulary and grammar rules that all the components agree to use when communicating.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Data Structures (Views), primarily defined using Pydantic models, are the essential blueprints that ensure consistent and reliable communication within the <code class="language-plaintext highlighter-rouge">Browser Use</code> project. They act like standardized forms for <code class="language-plaintext highlighter-rouge">BrowserState</code>, <code class="language-plaintext highlighter-rouge">AgentOutput</code>, <code class="language-plaintext highlighter-rouge">ActionModel</code>, and <code class="language-plaintext highlighter-rouge">ActionResult</code>, making sure every component knows exactly what kind of data to expect and how to interpret it.</p>

<p>By defining these clear structures and leveraging Pydantic’s automatic validation, <code class="language-plaintext highlighter-rouge">Browser Use</code> prevents misunderstandings between components, catches errors early, and makes the overall system more robust and maintainable. These standardized structures also make it easier to log and understand what’s happening in the system.</p>

<p>Speaking of logging and understanding the system’s behavior, how can we monitor the Agent’s performance and gather data for improvement? In the next and final chapter, we’ll explore the <a href="08_telemetry_service.md">Telemetry Service</a>.</p>

<p><a href="08_telemetry_service.md">Next Chapter: Telemetry Service</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
