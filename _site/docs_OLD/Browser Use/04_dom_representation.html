<h1 id="chapter-4-dom-representation---mapping-the-webpage">Chapter 4: DOM Representation - Mapping the Webpage</h1>

<p>In the <a href="03_browsercontext.md">previous chapter</a>, we learned about the <code class="language-plaintext highlighter-rouge">BrowserContext</code>, the Agent’s private workspace for browsing. We saw that the Agent uses <code class="language-plaintext highlighter-rouge">browser_context.get_state()</code> to get a snapshot of the current webpage. But how does the Agent actually <em>understand</em> the content of that snapshot?</p>

<p>Imagine you’re looking at the Google homepage. You instantly recognize the logo, the search bar, and the buttons. But a computer program just sees a wall of code (HTML). How can our <code class="language-plaintext highlighter-rouge">Agent</code> figure out: “This rectangular box is the search bar I need to type into,” or “This specific image link is the first result I should click”?</p>

<p>This is the problem solved by <strong>DOM Representation</strong>.</p>

<h2 id="what-problem-does-dom-representation-solve">What Problem Does DOM Representation Solve?</h2>

<p>Webpages are built using HTML (HyperText Markup Language), which describes the structure and content. Your browser reads this HTML and creates an internal, structured representation called the <strong>Document Object Model (DOM)</strong>. It’s like the browser builds a detailed blueprint or an outline from the HTML instructions.</p>

<p>However, this raw DOM blueprint is incredibly complex and contains lots of information irrelevant to our Agent’s task. The Agent doesn’t need to know about every single tiny visual detail; it needs a <em>simplified map</em> focused on what’s important for interaction:</p>

<ol>
  <li><strong>What elements are on the page?</strong> (buttons, links, input fields, text)</li>
  <li><strong>Are they visible to a user?</strong> (Hidden elements shouldn’t be interacted with)</li>
  <li><strong>Are they interactive?</strong> (Can you click it? Can you type in it?)</li>
  <li><strong>How can the Agent refer to them?</strong> (We need a simple way to say “click <em>this</em> button”)</li>
</ol>

<p>DOM Representation solves the problem of translating the complex, raw DOM blueprint into a simplified, structured map that highlights the interactive “landmarks” and pathways the Agent can use.</p>

<h2 id="meet-domservice-the-map-maker">Meet <code class="language-plaintext highlighter-rouge">DomService</code>: The Map Maker</h2>

<p>The component responsible for creating this map is the <code class="language-plaintext highlighter-rouge">DomService</code>. Think of it as a cartographer specializing in webpages.</p>

<p>When the <code class="language-plaintext highlighter-rouge">Agent</code> (via the <code class="language-plaintext highlighter-rouge">BrowserContext</code>) asks for the current state of the page, the <code class="language-plaintext highlighter-rouge">BrowserContext</code> employs the <code class="language-plaintext highlighter-rouge">DomService</code> to analyze the page’s live DOM.</p>

<p>Here’s what the <code class="language-plaintext highlighter-rouge">DomService</code> does:</p>

<ol>
  <li><strong>Examines the Live Page:</strong> It looks at the current structure rendered in the browser tab, not just the initial HTML source code (because JavaScript can change the page after it loads).</li>
  <li><strong>Identifies Elements:</strong> It finds all the meaningful elements like buttons, links, input fields, and text blocks.</li>
  <li><strong>Checks Properties:</strong> For each element, it determines crucial properties:
    <ul>
      <li><strong>Visibility:</strong> Is it actually displayed on the screen?</li>
      <li><strong>Interactivity:</strong> Is it something a user can click, type into, or otherwise interact with?</li>
      <li><strong>Position:</strong> Where is it located (roughly)?</li>
    </ul>
  </li>
  <li><strong>Assigns Interaction Indices:</strong> This is key! For elements deemed interactive and visible, <code class="language-plaintext highlighter-rouge">DomService</code> assigns a unique number, called a <code class="language-plaintext highlighter-rouge">highlight_index</code> (like <code class="language-plaintext highlighter-rouge">[5]</code>, <code class="language-plaintext highlighter-rouge">[12]</code>, etc.). This gives the Agent and the LLM a simple, unambiguous way to refer to specific elements.</li>
  <li><strong>Builds a Structured Tree:</strong> It organizes this information into a simplified tree structure (<code class="language-plaintext highlighter-rouge">element_tree</code>) that reflects the page layout but is much easier to process than the full DOM.</li>
  <li><strong>Creates an Index Map:</strong> It generates a <code class="language-plaintext highlighter-rouge">selector_map</code>, which is like an index in a book, mapping each <code class="language-plaintext highlighter-rouge">highlight_index</code> directly to its corresponding element node in the tree.</li>
</ol>

<p>The final output is a <code class="language-plaintext highlighter-rouge">DOMState</code> object containing the simplified <code class="language-plaintext highlighter-rouge">element_tree</code> and the handy <code class="language-plaintext highlighter-rouge">selector_map</code>. This <code class="language-plaintext highlighter-rouge">DOMState</code> is then included in the <code class="language-plaintext highlighter-rouge">BrowserState</code> that <code class="language-plaintext highlighter-rouge">BrowserContext.get_state()</code> returns to the Agent.</p>

<h2 id="the-output-domstate---the-agents-map">The Output: <code class="language-plaintext highlighter-rouge">DOMState</code> - The Agent’s Map</h2>

<p>The <code class="language-plaintext highlighter-rouge">DOMState</code> object produced by <code class="language-plaintext highlighter-rouge">DomService</code> has two main parts:</p>

<ol>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">element_tree</code>:</strong> This is the root of our simplified map, represented as a <code class="language-plaintext highlighter-rouge">DOMElementNode</code> object (defined in <code class="language-plaintext highlighter-rouge">dom/views.py</code>). Each node in the tree can be either an element (<code class="language-plaintext highlighter-rouge">DOMElementNode</code>) or a piece of text (<code class="language-plaintext highlighter-rouge">DOMTextNode</code>). <code class="language-plaintext highlighter-rouge">DOMElementNode</code>s contain information like the tag name (<code class="language-plaintext highlighter-rouge">&lt;button&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;input&gt;</code>), attributes (<code class="language-plaintext highlighter-rouge">aria-label="Search"</code>), visibility, interactivity, and importantly, the <code class="language-plaintext highlighter-rouge">highlight_index</code> if applicable. The tree structure helps understand the page layout (e.g., this button is inside that section).</p>

    <p><em>Conceptual Example Tree:</em></p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;body&gt; [no index]
 |-- &lt;div&gt; [no index]
 |    |-- &lt;input aria-label="Search"&gt; [highlight_index: 5]
 |    +-- &lt;button&gt; [highlight_index: 6]
 |         +-- "Google Search" (TextNode)
 +-- &lt;a&gt; href="/images"&gt; [highlight_index: 7]
      +-- "Images" (TextNode)
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">selector_map</code>:</strong> This is a Python dictionary that acts as a quick lookup. It maps the integer <code class="language-plaintext highlighter-rouge">highlight_index</code> directly to the corresponding <code class="language-plaintext highlighter-rouge">DOMElementNode</code> object in the <code class="language-plaintext highlighter-rouge">element_tree</code>.</p>

    <p><em>Conceptual Example Map:</em></p>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
    <span class="mi">5</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">DOMElementNode</span> <span class="n">tag_name</span><span class="o">=</span><span class="s">'input'</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="p">{</span><span class="s">'aria-label'</span><span class="p">:</span><span class="s">'Search'</span><span class="p">},</span> <span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="mi">6</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">DOMElementNode</span> <span class="n">tag_name</span><span class="o">=</span><span class="s">'button'</span><span class="p">,</span> <span class="p">...</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="mi">7</span><span class="p">:</span> <span class="o">&lt;</span><span class="n">DOMElementNode</span> <span class="n">tag_name</span><span class="o">=</span><span class="s">'a'</span><span class="p">,</span> <span class="n">attributes</span><span class="o">=</span><span class="p">{</span><span class="s">'href'</span><span class="p">:</span><span class="s">'/images'</span><span class="p">},</span> <span class="p">...</span><span class="o">&gt;</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p>This <code class="language-plaintext highlighter-rouge">selector_map</code> is incredibly useful because when the LLM decides “click element 5”, the Agent can instantly find the correct <code class="language-plaintext highlighter-rouge">DOMElementNode</code> using <code class="language-plaintext highlighter-rouge">selector_map[5]</code> and tell the <a href="05_action_controller___registry.md">Action Controller &amp; Registry</a> exactly which element to interact with.</p>

<h2 id="how-the-agent-uses-the-map">How the Agent Uses the Map</h2>

<p>The <code class="language-plaintext highlighter-rouge">Agent</code> takes the <code class="language-plaintext highlighter-rouge">DOMState</code> (usually simplifying the <code class="language-plaintext highlighter-rouge">element_tree</code> further into a text representation) and includes it in the information sent to the LLM. Remember the JSON response format from <a href="02_system_prompt.md">Chapter 2</a>? The LLM uses the <code class="language-plaintext highlighter-rouge">highlight_index</code> from this map to specify actions:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">//</span><span class="w"> </span><span class="err">LLM</span><span class="w"> </span><span class="err">might</span><span class="w"> </span><span class="err">receive</span><span class="w"> </span><span class="err">a</span><span class="w"> </span><span class="err">simplified</span><span class="w"> </span><span class="err">text</span><span class="w"> </span><span class="err">view</span><span class="w"> </span><span class="err">like:</span><span class="w">
</span><span class="err">//</span><span class="w"> </span><span class="s2">"[5]&lt;input aria-label='Search'&gt;</span><span class="se">\n</span><span class="s2">[6]&lt;button&gt;Google Search&lt;/button&gt;</span><span class="se">\n</span><span class="s2">[7]&lt;a&gt;Images&lt;/a&gt;"</span><span class="w">

</span><span class="err">//</span><span class="w"> </span><span class="err">And</span><span class="w"> </span><span class="err">respond</span><span class="w"> </span><span class="err">with:</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="nl">"current_state"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"evaluation_previous_goal"</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="p">,</span><span class="w">
    </span><span class="nl">"memory"</span><span class="p">:</span><span class="w"> </span><span class="s2">"On Google homepage, need to search for cats."</span><span class="p">,</span><span class="w">
    </span><span class="nl">"next_goal"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Type 'cute cats' into the search bar [5]."</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"action"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"input_text"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"index"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">&lt;--</span><span class="w"> </span><span class="err">Uses</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">highlight_index</span><span class="w"> </span><span class="err">from</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">DOM</span><span class="w"> </span><span class="err">map!</span><span class="w">
        </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cute cats"</span><span class="w">
      </span><span class="p">}</span><span class="w">
    </span><span class="p">}</span><span class="w">
    </span><span class="err">//</span><span class="w"> </span><span class="err">...</span><span class="w"> </span><span class="err">maybe</span><span class="w"> </span><span class="err">press</span><span class="w"> </span><span class="err">Enter</span><span class="w"> </span><span class="err">action</span><span class="w"> </span><span class="err">...</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<h2 id="code-example-seeing-the-map">Code Example: Seeing the Map</h2>

<p>We don’t usually interact with <code class="language-plaintext highlighter-rouge">DomService</code> directly. Instead, we get its output via the <code class="language-plaintext highlighter-rouge">BrowserContext</code>. Let’s revisit the example from Chapter 3 and see where the DOM representation fits:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">browser_use</span> <span class="kn">import</span> <span class="n">Browser</span><span class="p">,</span> <span class="n">BrowserConfig</span><span class="p">,</span> <span class="n">BrowserContext</span><span class="p">,</span> <span class="n">BrowserContextConfig</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">browser_config</span> <span class="o">=</span> <span class="n">BrowserConfig</span><span class="p">(</span><span class="n">headless</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">browser</span> <span class="o">=</span> <span class="n">Browser</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="n">browser_config</span><span class="p">)</span>
    <span class="n">context_config</span> <span class="o">=</span> <span class="n">BrowserContextConfig</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">with</span> <span class="n">browser</span><span class="p">.</span><span class="n">new_context</span><span class="p">(</span><span class="n">config</span><span class="o">=</span><span class="n">context_config</span><span class="p">)</span> <span class="k">as</span> <span class="n">browser_context</span><span class="p">:</span>
        <span class="c1"># Navigate to a page (e.g., Google)
</span>        <span class="k">await</span> <span class="n">browser_context</span><span class="p">.</span><span class="n">navigate_to</span><span class="p">(</span><span class="s">"https://www.google.com"</span><span class="p">)</span>

        <span class="k">print</span><span class="p">(</span><span class="s">"Getting current page state..."</span><span class="p">)</span>
        <span class="c1"># This call uses DomService internally to generate the DOM representation
</span>        <span class="n">current_state</span> <span class="o">=</span> <span class="k">await</span> <span class="n">browser_context</span><span class="p">.</span><span class="n">get_state</span><span class="p">()</span>

        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">Current Page URL: </span><span class="si">{</span><span class="n">current_state</span><span class="p">.</span><span class="n">url</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Current Page Title: </span><span class="si">{</span><span class="n">current_state</span><span class="p">.</span><span class="n">title</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

        <span class="c1"># Accessing the DOM Representation parts within the BrowserState
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">--- DOM Representation Details ---"</span><span class="p">)</span>
        <span class="c1"># The element_tree is the root node of our simplified DOM map
</span>        <span class="k">if</span> <span class="n">current_state</span><span class="p">.</span><span class="n">element_tree</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Root element tag of simplified tree: &lt;</span><span class="si">{</span><span class="n">current_state</span><span class="p">.</span><span class="n">element_tree</span><span class="p">.</span><span class="n">tag_name</span><span class="si">}</span><span class="s">&gt;"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Element tree is empty."</span><span class="p">)</span>

        <span class="c1"># The selector_map provides direct access to interactive elements by index
</span>        <span class="k">if</span> <span class="n">current_state</span><span class="p">.</span><span class="n">selector_map</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Number of interactive elements found: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">current_state</span><span class="p">.</span><span class="n">selector_map</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

            <span class="c1"># Let's try to find the element the LLM might call [5] (often the search bar)
</span>            <span class="n">example_index</span> <span class="o">=</span> <span class="mi">5</span> <span class="c1"># Note: Indices can change depending on the page!
</span>            <span class="k">if</span> <span class="n">example_index</span> <span class="ow">in</span> <span class="n">current_state</span><span class="p">.</span><span class="n">selector_map</span><span class="p">:</span>
                <span class="n">element_node</span> <span class="o">=</span> <span class="n">current_state</span><span class="p">.</span><span class="n">selector_map</span><span class="p">[</span><span class="n">example_index</span><span class="p">]</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Element [</span><span class="si">{</span><span class="n">example_index</span><span class="si">}</span><span class="s">]: Tag=&lt;</span><span class="si">{</span><span class="n">element_node</span><span class="p">.</span><span class="n">tag_name</span><span class="si">}</span><span class="s">&gt;, Attributes=</span><span class="si">{</span><span class="n">element_node</span><span class="p">.</span><span class="n">attributes</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
                <span class="c1"># The Agent uses this node reference to perform actions
</span>            <span class="k">else</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Element [</span><span class="si">{</span><span class="n">example_index</span><span class="si">}</span><span class="s">] not found in the selector map for this page state."</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"No interactive elements found (selector map is empty)."</span><span class="p">)</span>

        <span class="c1"># The Agent would typically convert element_tree into a compact text format
</span>        <span class="c1"># (using methods like element_tree.clickable_elements_to_string())
</span>        <span class="c1"># to send to the LLM along with the task instructions.
</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">BrowserContext closed."</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">browser</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Browser closed."</span><span class="p">)</span>

<span class="c1"># Run the asynchronous code
</span><span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div></div>

<p><strong>What happens here?</strong></p>

<ol>
  <li>We set up the <code class="language-plaintext highlighter-rouge">Browser</code> and <code class="language-plaintext highlighter-rouge">BrowserContext</code>.</li>
  <li>We navigate to Google.</li>
  <li><code class="language-plaintext highlighter-rouge">browser_context.get_state()</code> is called. <strong>Internally</strong>, this triggers the <code class="language-plaintext highlighter-rouge">DomService</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">DomService</code> analyzes the Google page, finds interactive elements (like the search bar, buttons), assigns them <code class="language-plaintext highlighter-rouge">highlight_index</code> numbers, and builds the <code class="language-plaintext highlighter-rouge">element_tree</code> and <code class="language-plaintext highlighter-rouge">selector_map</code>.</li>
  <li>This <code class="language-plaintext highlighter-rouge">DOMState</code> (containing the tree and map) is packaged into the <code class="language-plaintext highlighter-rouge">BrowserState</code> object returned by <code class="language-plaintext highlighter-rouge">get_state()</code>.</li>
  <li>Our code then accesses <code class="language-plaintext highlighter-rouge">current_state.element_tree</code> and <code class="language-plaintext highlighter-rouge">current_state.selector_map</code> to peek at the map created by <code class="language-plaintext highlighter-rouge">DomService</code>.</li>
  <li>We demonstrate looking up an element using its potential index (<code class="language-plaintext highlighter-rouge">selector_map[5]</code>).</li>
</ol>

<h2 id="how-it-works-under-the-hood-domservice-in-action">How It Works Under the Hood: <code class="language-plaintext highlighter-rouge">DomService</code> in Action</h2>

<p>Let’s trace the flow when <code class="language-plaintext highlighter-rouge">BrowserContext.get_state()</code> is called:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Agent
    participant BC as BrowserContext
    participant DomService
    participant PlaywrightPage as Browser Page (JS Env)
    participant buildDomTree_js as buildDomTree.js

    Agent-&gt;&gt;BC: get_state()
    Note over BC: Needs to analyze the page content
    BC-&gt;&gt;DomService: get_clickable_elements(...)
    Note over DomService: Needs to run analysis script in browser
    DomService-&gt;&gt;PlaywrightPage: evaluate(js_code='buildDomTree.js', args={...})
    Note over PlaywrightPage: Execute JavaScript code
    PlaywrightPage-&gt;&gt;buildDomTree_js: Run analysis function
    Note over buildDomTree_js: Analyzes live DOM, finds visible &amp; interactive elements, assigns highlight_index
    buildDomTree_js--&gt;&gt;PlaywrightPage: Return structured data (nodes, indices, map)
    PlaywrightPage--&gt;&gt;DomService: Return JS execution result (JSON-like data)
    Note over DomService: Process the raw data from JS
    DomService-&gt;&gt;DomService: _construct_dom_tree(result)
    Note over DomService: Builds Python DOMElementNode tree and selector_map
    DomService--&gt;&gt;BC: Return DOMState (element_tree, selector_map)
    Note over BC: Combine DOMState with URL, title, screenshot etc.
    BC-&gt;&gt;BC: Create BrowserState object
    BC--&gt;&gt;Agent: Return BrowserState (containing DOM map)
</code></pre>

<p><strong>Key Code Points:</strong></p>

<ol>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">BrowserContext</code> calls <code class="language-plaintext highlighter-rouge">DomService</code>:</strong> Inside <code class="language-plaintext highlighter-rouge">browser/context.py</code>, the <code class="language-plaintext highlighter-rouge">_update_state</code> method (called by <code class="language-plaintext highlighter-rouge">get_state</code>) initializes and uses the <code class="language-plaintext highlighter-rouge">DomService</code>:</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- File: browser/context.py (Simplified _update_state) ---
</span><span class="kn">from</span> <span class="nn">browser_use.dom.service</span> <span class="kn">import</span> <span class="n">DomService</span> <span class="c1"># Import the service
</span><span class="kn">from</span> <span class="nn">browser_use.browser.views</span> <span class="kn">import</span> <span class="n">BrowserState</span>

<span class="k">class</span> <span class="nc">BrowserContext</span><span class="p">:</span>
    <span class="c1"># ... other methods ...
</span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">_update_state</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BrowserState</span><span class="p">:</span>
        <span class="n">page</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_current_page</span><span class="p">()</span> <span class="c1"># Get the active Playwright page object
</span>        <span class="c1"># ... error handling ...
</span>        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># 1. Create DomService instance for the current page
</span>            <span class="n">dom_service</span> <span class="o">=</span> <span class="n">DomService</span><span class="p">(</span><span class="n">page</span><span class="p">)</span>

            <span class="c1"># 2. Call DomService to get the DOM map (DOMState)
</span>            <span class="n">content_info</span> <span class="o">=</span> <span class="k">await</span> <span class="n">dom_service</span><span class="p">.</span><span class="n">get_clickable_elements</span><span class="p">(</span>
                <span class="n">highlight_elements</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">highlight_elements</span><span class="p">,</span>
                <span class="n">viewport_expansion</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">viewport_expansion</span><span class="p">,</span>
                <span class="c1"># ... other options ...
</span>            <span class="p">)</span>

            <span class="c1"># 3. Get other info (screenshot, URL, title etc.)
</span>            <span class="n">screenshot_b64</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">take_screenshot</span><span class="p">()</span>
            <span class="n">url</span> <span class="o">=</span> <span class="n">page</span><span class="p">.</span><span class="n">url</span>
            <span class="n">title</span> <span class="o">=</span> <span class="k">await</span> <span class="n">page</span><span class="p">.</span><span class="n">title</span><span class="p">()</span>
            <span class="c1"># ... gather more state ...
</span>
            <span class="c1"># 4. Package everything into BrowserState
</span>            <span class="n">browser_state</span> <span class="o">=</span> <span class="n">BrowserState</span><span class="p">(</span>
                <span class="n">element_tree</span><span class="o">=</span><span class="n">content_info</span><span class="p">.</span><span class="n">element_tree</span><span class="p">,</span> <span class="c1"># &lt;--- From DomService
</span>                <span class="n">selector_map</span><span class="o">=</span><span class="n">content_info</span><span class="p">.</span><span class="n">selector_map</span><span class="p">,</span> <span class="c1"># &lt;--- From DomService
</span>                <span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span>
                <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
                <span class="n">screenshot</span><span class="o">=</span><span class="n">screenshot_b64</span><span class="p">,</span>
                <span class="c1"># ... other state info ...
</span>            <span class="p">)</span>
            <span class="k">return</span> <span class="n">browser_state</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="p">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s">'Failed to update state: </span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
            <span class="k">raise</span> <span class="c1"># Or handle error
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">DomService</code> runs JavaScript:</strong> Inside <code class="language-plaintext highlighter-rouge">dom/service.py</code>, the <code class="language-plaintext highlighter-rouge">_build_dom_tree</code> method executes the JavaScript code stored in <code class="language-plaintext highlighter-rouge">buildDomTree.js</code> within the browser page’s context.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- File: dom/service.py (Simplified _build_dom_tree) ---
</span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">importlib</span> <span class="kn">import</span> <span class="n">resources</span>
<span class="c1"># ... other imports ...
</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DomService</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">page</span><span class="p">:</span> <span class="s">'Page'</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span>
        <span class="c1"># Load the JavaScript code from the file when DomService is created
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">js_code</span> <span class="o">=</span> <span class="n">resources</span><span class="p">.</span><span class="n">read_text</span><span class="p">(</span><span class="s">'browser_use.dom'</span><span class="p">,</span> <span class="s">'buildDomTree.js'</span><span class="p">)</span>
        <span class="c1"># ...
</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_build_dom_tree</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">highlight_elements</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">focus_element</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">viewport_expansion</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DOMElementNode</span><span class="p">,</span> <span class="n">SelectorMap</span><span class="p">]:</span>

        <span class="c1"># Prepare arguments for the JavaScript function
</span>        <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">'doHighlightElements'</span><span class="p">:</span> <span class="n">highlight_elements</span><span class="p">,</span>
            <span class="s">'focusHighlightIndex'</span><span class="p">:</span> <span class="n">focus_element</span><span class="p">,</span>
            <span class="s">'viewportExpansion'</span><span class="p">:</span> <span class="n">viewport_expansion</span><span class="p">,</span>
            <span class="s">'debugMode'</span><span class="p">:</span> <span class="n">logger</span><span class="p">.</span><span class="n">getEffectiveLevel</span><span class="p">()</span> <span class="o">==</span> <span class="n">logging</span><span class="p">.</span><span class="n">DEBUG</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Execute the JavaScript code in the browser page!
</span>            <span class="c1"># The JS code analyzes the live DOM and returns a structured result.
</span>            <span class="n">eval_page</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">page</span><span class="p">.</span><span class="n">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">js_code</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logger</span><span class="p">.</span><span class="n">error</span><span class="p">(</span><span class="s">'Error evaluating JavaScript: %s'</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
            <span class="k">raise</span>

        <span class="c1"># ... (optional debug logging) ...
</span>
        <span class="c1"># Parse the result from JavaScript into Python objects
</span>        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">_construct_dom_tree</span><span class="p">(</span><span class="n">eval_page</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">_construct_dom_tree</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eval_page</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">DOMElementNode</span><span class="p">,</span> <span class="n">SelectorMap</span><span class="p">]:</span>
        <span class="c1"># ... (logic to parse js_node_map from eval_page) ...
</span>        <span class="c1"># ... (loops through nodes, creates DOMElementNode/DOMTextNode objects) ...
</span>        <span class="c1"># ... (builds the tree structure by linking parents/children) ...
</span>        <span class="c1"># ... (populates the selector_map dictionary) ...
</span>        <span class="c1"># This uses the structures defined in dom/views.py
</span>        <span class="c1"># ...
</span>        <span class="n">root_node</span> <span class="o">=</span> <span class="p">...</span> <span class="c1"># Parsed root DOMElementNode
</span>        <span class="n">selector_map</span> <span class="o">=</span> <span class="p">...</span> <span class="c1"># Populated dictionary {index: DOMElementNode}
</span>        <span class="k">return</span> <span class="n">root_node</span><span class="p">,</span> <span class="n">selector_map</span>
    <span class="c1"># ... other methods like get_clickable_elements ...
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">buildDomTree.js</code> (Conceptual):</strong> This JavaScript file (located at <code class="language-plaintext highlighter-rouge">dom/buildDomTree.js</code> in the library) is the core map-making logic that runs <em>inside the browser</em>. It traverses the live DOM, checks element visibility and interactivity using browser APIs (like <code class="language-plaintext highlighter-rouge">element.getBoundingClientRect()</code>, <code class="language-plaintext highlighter-rouge">window.getComputedStyle()</code>, <code class="language-plaintext highlighter-rouge">document.elementFromPoint()</code>), assigns the <code class="language-plaintext highlighter-rouge">highlight_index</code>, and packages the results into a structured format that the Python <code class="language-plaintext highlighter-rouge">DomService</code> can understand. <em>We don’t need to understand the JS code itself, just its purpose.</em></p>
  </li>
  <li>
    <p><strong>Python Data Structures (<code class="language-plaintext highlighter-rouge">DOMElementNode</code>, <code class="language-plaintext highlighter-rouge">DOMTextNode</code>):</strong> The results from the JavaScript are parsed into Python objects defined in <code class="language-plaintext highlighter-rouge">dom/views.py</code>. These dataclasses (<code class="language-plaintext highlighter-rouge">DOMElementNode</code>, <code class="language-plaintext highlighter-rouge">DOMTextNode</code>) hold the information about each mapped element or text segment.</p>
  </li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<p>DOM Representation, primarily handled by the <code class="language-plaintext highlighter-rouge">DomService</code>, is crucial for bridging the gap between the complex reality of a webpage (the DOM) and the Agent/LLM’s need for a simplified, actionable understanding. By creating a structured <code class="language-plaintext highlighter-rouge">element_tree</code> and an indexed <code class="language-plaintext highlighter-rouge">selector_map</code>, it provides a clear map of interactive landmarks on the page, identified by simple <code class="language-plaintext highlighter-rouge">highlight_index</code> numbers.</p>

<p>This map allows the LLM to make specific plans like “type into element [5]” or “click element [12]”, which the Agent can then reliably translate into concrete actions.</p>

<p>Now that we understand how the Agent sees the page, how does it actually <em>perform</em> those actions like clicking or typing? In the next chapter, we’ll explore the component responsible for executing the LLM’s plan: the <a href="05_action_controller___registry.md">Action Controller &amp; Registry</a>.</p>

<p><a href="05_action_controller___registry.md">Next Chapter: Action Controller &amp; Registry</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
