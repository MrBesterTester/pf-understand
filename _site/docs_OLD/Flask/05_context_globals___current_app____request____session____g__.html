<h1 id="chapter-5-context-globals-current_app-request-session-g">Chapter 5: Context Globals (<code class="language-plaintext highlighter-rouge">current_app</code>, <code class="language-plaintext highlighter-rouge">request</code>, <code class="language-plaintext highlighter-rouge">session</code>, <code class="language-plaintext highlighter-rouge">g</code>)</h1>

<p>Welcome back! In <a href="04_templating__jinja2_integration_.md">Chapter 4: Templating (Jinja2 Integration)</a>, we learned how to separate our HTML structure from our Python code using templates and the <code class="language-plaintext highlighter-rouge">render_template</code> function. We saw how variables like <code class="language-plaintext highlighter-rouge">request</code> and functions like <code class="language-plaintext highlighter-rouge">url_for</code> seemed to be magically available in our templates.</p>

<p>But how does that work? And more importantly, how can we easily access important information like the current application instance or the details of the incoming web request <em>inside</em> our Python view functions without passing these objects around manually to every single function? Imagine having to add <code class="language-plaintext highlighter-rouge">app</code> and <code class="language-plaintext highlighter-rouge">request</code> as arguments to all your helper functions – it would be very repetitive!</p>

<p>This chapter introduces Flask’s solution: <strong>Context Globals</strong>.</p>

<h2 id="what-problem-do-they-solve-avoiding-tedious-parameter-passing">What Problem Do They Solve? Avoiding Tedious Parameter Passing</h2>

<p>Think about working on a team project. There are certain tools or pieces of information everyone on the team needs access to frequently: the project plan, the shared calendar, the main contact person. It would be inefficient if every time someone needed the project plan, they had to specifically ask someone else to pass it to them. Instead, you might have a central place or a well-known name (like “The Plan”) that everyone knows how to find.</p>

<p>Similarly, in a Flask application, several objects are very commonly needed while handling a web request:</p>

<ul>
  <li>The application instance itself (to access configuration, loggers, etc.).</li>
  <li>The incoming request object (to get form data, query parameters, headers, etc.).</li>
  <li>A way to store temporary information related to the current user across multiple requests (the session).</li>
  <li>A temporary storage space just for the <em>current</em> request.</li>
</ul>

<p>Passing these objects explicitly as parameters to every function that might need them (especially view functions, <code class="language-plaintext highlighter-rouge">before_request</code> functions, <code class="language-plaintext highlighter-rouge">after_request</code> functions, template context processors) would make our code cluttered and harder to manage.</p>

<p>Flask provides special “global” variables – <strong><code class="language-plaintext highlighter-rouge">current_app</code></strong>, <strong><code class="language-plaintext highlighter-rouge">request</code></strong>, <strong><code class="language-plaintext highlighter-rouge">session</code></strong>, and <strong><code class="language-plaintext highlighter-rouge">g</code></strong> – that act like smart pointers. They automatically find and give you access to the <em>correct</em> object relevant to the specific request you are currently handling, without you needing to pass anything around. They feel like magic variables!</p>

<h2 id="meet-the-context-globals">Meet the Context Globals</h2>

<p>These special variables are technically called <strong>proxies</strong>. Think of a proxy as a stand-in or an agent. When you talk to the <code class="language-plaintext highlighter-rouge">request</code> proxy, it secretly finds the <em>actual</em> request object for the HTTP request that is currently being processed and acts on its behalf. This magic happens using Flask’s “context” system, which we’ll touch on later and explore more in <a href="07_application_and_request_contexts.md">Chapter 7</a>.</p>

<p>Let’s meet the main context globals:</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">request</code></strong>: Represents the incoming HTTP request from the client (browser). It contains all the data the client sent, like form data, URL parameters, HTTP headers, the requested URL, etc. We already used this in <a href="03_request_and_response_objects.md">Chapter 3: Request and Response Objects</a>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">session</code></strong>: A dictionary-like object that lets you store information specific to a user <em>across multiple requests</em>. It’s commonly used for things like remembering if a user is logged in, or storing items in a shopping cart. Flask typically uses secure cookies to handle this.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">current_app</code></strong>: Represents the <em>instance</em> of your Flask application that is handling the current request. This is useful for accessing application-wide configurations, resources, or extensions. It points to the same object you created with <code class="language-plaintext highlighter-rouge">app = Flask(__name__)</code> in <a href="01_application_object___flask__.md">Chapter 1</a>, but you can access it from anywhere <em>during</em> a request without needing the <code class="language-plaintext highlighter-rouge">app</code> variable directly.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">g</code></strong>: A simple namespace object (think of it like an empty box or scratchpad) that is available only for the duration of the <em>current request</em>. You can use it to store temporary data that multiple functions within the same request cycle might need access to, without passing it around. For example, you might store the current logged-in user object or a database connection here. It gets reset for every new request. The ‘g’ stands for “global”, but it’s global <em>only within the request context</em>.</li>
</ol>

<h2 id="using-the-context-globals">Using the Context Globals</h2>

<p>First, you usually need to import them from the <code class="language-plaintext highlighter-rouge">flask</code> package:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">session</span><span class="p">,</span> <span class="n">current_app</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">render_template</span>
<span class="kn">import</span> <span class="nn">os</span> <span class="c1"># For generating a secret key
</span>
<span class="c1"># Create the application object
</span><span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="c1"># !! IMPORTANT !! Sessions require a secret key for security.
# In a real app, set this from an environment variable or config file!
# Never hardcode it like this in production.
</span><span class="n">app</span><span class="p">.</span><span class="n">config</span><span class="p">[</span><span class="s">'SECRET_KEY'</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">urandom</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span>
<span class="c1"># We'll learn more about config in Chapter 6: Configuration (Config)
</span></code></pre></div></div>

<p>Now let’s see how to use them.</p>

<h3 id="request-accessing-incoming-data"><code class="language-plaintext highlighter-rouge">request</code>: Accessing Incoming Data</h3>

<p>We saw this in Chapter 3. Notice how the <code class="language-plaintext highlighter-rouge">index</code> function can use <code class="language-plaintext highlighter-rouge">request</code> directly without it being passed as an argument.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># hello.py (continued)
</span>
<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">index</span><span class="p">():</span>
  <span class="n">user_agent</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'User-Agent'</span><span class="p">,</span> <span class="s">'Unknown'</span><span class="p">)</span>
  <span class="n">method</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">method</span>
  <span class="k">return</span> <span class="sa">f</span><span class="s">'Welcome! Method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s">, Browser: </span><span class="si">{</span><span class="n">user_agent</span><span class="si">}</span><span class="s">'</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">request.headers.get(...)</code>: Accesses the HTTP headers from the incoming request.</li>
  <li><code class="language-plaintext highlighter-rouge">request.method</code>: Gets the HTTP method used (e.g., ‘GET’, ‘POST’).</li>
</ul>

<p>Flask automatically makes the correct <code class="language-plaintext highlighter-rouge">request</code> object available here when the <code class="language-plaintext highlighter-rouge">/</code> route is visited.</p>

<h3 id="current_app-accessing-application-settings"><code class="language-plaintext highlighter-rouge">current_app</code>: Accessing Application Settings</h3>

<p>Imagine you want to log something using the application’s logger or access a configuration value.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># hello.py (continued)
</span>
<span class="c1"># Add another config value for demonstration
</span><span class="n">app</span><span class="p">.</span><span class="n">config</span><span class="p">[</span><span class="s">'MY_SETTING'</span><span class="p">]</span> <span class="o">=</span> <span class="s">'Flask is Cool'</span>

<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">'/app-info'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">app_info</span><span class="p">():</span>
  <span class="c1"># Access the application's logger
</span>  <span class="n">current_app</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">'Someone accessed the app-info page.'</span><span class="p">)</span>

  <span class="c1"># Access a configuration value
</span>  <span class="n">setting</span> <span class="o">=</span> <span class="n">current_app</span><span class="p">.</span><span class="n">config</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'MY_SETTING'</span><span class="p">,</span> <span class="s">'Default Value'</span><span class="p">)</span>
  <span class="n">debug_mode</span> <span class="o">=</span> <span class="n">current_app</span><span class="p">.</span><span class="n">config</span><span class="p">[</span><span class="s">'DEBUG'</span><span class="p">]</span> <span class="c1"># Accessing debug status
</span>
  <span class="k">return</span> <span class="sa">f</span><span class="s">'My Setting: </span><span class="si">{</span><span class="n">setting</span><span class="si">}</span><span class="s">&lt;br&gt;Debug Mode: </span><span class="si">{</span><span class="n">debug_mode</span><span class="si">}</span><span class="s">'</span>

<span class="c1"># Make sure debug is enabled for the logger example to show easily
# if __name__ == '__main__':
#   app.run(debug=True)
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">current_app.logger.info(...)</code>: Uses the logger configured on the <code class="language-plaintext highlighter-rouge">app</code> object.</li>
  <li><code class="language-plaintext highlighter-rouge">current_app.config.get(...)</code>: Accesses the application’s configuration dictionary.</li>
</ul>

<p>Again, <code class="language-plaintext highlighter-rouge">app_info</code> doesn’t need <code class="language-plaintext highlighter-rouge">app</code> passed in; <code class="language-plaintext highlighter-rouge">current_app</code> provides access to it within the request context.</p>

<h3 id="session-remembering-things-across-requests"><code class="language-plaintext highlighter-rouge">session</code>: Remembering Things Across Requests</h3>

<p>Sessions allow you to store data associated with a specific user’s browser session. Flask uses a secret key (<code class="language-plaintext highlighter-rouge">app.secret_key</code> or <code class="language-plaintext highlighter-rouge">app.config['SECRET_KEY']</code>) to cryptographically sign the session cookie, preventing users from modifying it. <strong>Always set a strong, random secret key!</strong></p>

<p>Let’s create a simple view counter that increments each time the <em>same</em> user visits the page.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># hello.py (continued)
</span>
<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">'/counter'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">counter</span><span class="p">():</span>
  <span class="c1"># Get the current count from the session, default to 0 if not found
</span>  <span class="n">count</span> <span class="o">=</span> <span class="n">session</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'view_count'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

  <span class="c1"># Increment the count
</span>  <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

  <span class="c1"># Store the new count back in the session
</span>  <span class="n">session</span><span class="p">[</span><span class="s">'view_count'</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>

  <span class="c1"># Log the session content (for demonstration)
</span>  <span class="n">current_app</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s">"Session data: </span><span class="si">{</span><span class="n">session</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

  <span class="k">return</span> <span class="sa">f</span><span class="s">'You have visited this page </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s"> times during this session.'</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">session.get('view_count', 0)</code>: Reads the <code class="language-plaintext highlighter-rouge">view_count</code> value from the session. If it’s the first visit, it doesn’t exist yet, so we default to <code class="language-plaintext highlighter-rouge">0</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">session['view_count'] = count</code>: Stores the updated count back into the session.</li>
  <li>Flask handles sending the updated session data back to the browser in a secure cookie behind the scenes.</li>
</ul>

<p><strong>Running this:</strong></p>

<ol>
  <li>Make sure <code class="language-plaintext highlighter-rouge">app.config['SECRET_KEY']</code> is set in your <code class="language-plaintext highlighter-rouge">hello.py</code>.</li>
  <li>Run <code class="language-plaintext highlighter-rouge">python hello.py</code>.</li>
  <li>Visit <code class="language-plaintext highlighter-rouge">http://127.0.0.1:5000/counter</code>. You’ll see “You have visited this page 1 times…”.</li>
  <li>Refresh the page. You’ll see “You have visited this page 2 times…”.</li>
  <li>Refresh again. It will become 3, and so on.</li>
  <li>If you close your browser completely and reopen it (or use a private/incognito window), the count will reset to 1 because the session cookie is typically cleared or different.</li>
</ol>

<h3 id="g-temporary-storage-for-a-single-request"><code class="language-plaintext highlighter-rouge">g</code>: Temporary Storage for a Single Request</h3>

<p>The <code class="language-plaintext highlighter-rouge">g</code> object is useful for storing data that needs to be accessed by multiple functions <em>within the same request cycle</em>. A common example is loading the current user’s information from a database or verifying an API key. You might do this in a <code class="language-plaintext highlighter-rouge">@app.before_request</code> function and then access the result in your view function using <code class="language-plaintext highlighter-rouge">g</code>.</p>

<p>Let’s simulate loading some data before the request and accessing it in the view.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># hello.py (continued)
</span><span class="kn">import</span> <span class="nn">time</span>

<span class="c1"># This function runs BEFORE every request
</span><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">before_request</span>
<span class="k">def</span> <span class="nf">load_request_data</span><span class="p">():</span>
  <span class="c1"># Imagine loading data from a database or external source here
</span>  <span class="n">g</span><span class="p">.</span><span class="n">request_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
  <span class="n">g</span><span class="p">.</span><span class="n">user</span> <span class="o">=</span> <span class="s">'Guest'</span> <span class="c1"># Default user
</span>  <span class="c1"># Maybe check for an API key or user session here and set g.user accordingly
</span>  <span class="c1"># For example: if session.get('logged_in_user'): g.user = session['logged_in_user']
</span>  <span class="n">current_app</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s">"Before request: Set g.user to </span><span class="si">{</span><span class="n">g</span><span class="p">.</span><span class="n">user</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">'/show-g'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">show_g</span><span class="p">():</span>
  <span class="c1"># Access the data stored in 'g' by the before_request handler
</span>  <span class="n">req_time</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'request_time'</span><span class="p">,</span> <span class="s">'Not Set'</span><span class="p">)</span>
  <span class="n">current_user</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'user'</span><span class="p">,</span> <span class="s">'Unknown'</span><span class="p">)</span>

  <span class="c1"># Check if it's still there after the request (it shouldn't be for the *next* request)
</span>  <span class="c1"># We can't easily show this here, but g is cleared between requests.
</span>
  <span class="k">return</span> <span class="sa">f</span><span class="s">'Data from g:&lt;br&gt;Request Time: </span><span class="si">{</span><span class="n">req_time</span><span class="si">}</span><span class="s">&lt;br&gt;User: </span><span class="si">{</span><span class="n">current_user</span><span class="si">}</span><span class="s">'</span>

<span class="c1"># This function runs AFTER every request, even if errors occur
# It receives the response object
</span><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">teardown_request</span>
<span class="k">def</span> <span class="nf">teardown_request_data</span><span class="p">(</span><span class="n">exception</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c1"># This is a good place to clean up resources stored in g, like DB connections
</span>    <span class="n">req_time</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'request_time'</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="c1"># Safely remove request_time
</span>    <span class="n">user</span> <span class="o">=</span> <span class="n">g</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">'user'</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="c1"># Safely remove user
</span>    <span class="k">if</span> <span class="n">req_time</span><span class="p">:</span>
      <span class="n">duration</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">req_time</span>
      <span class="n">current_app</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s">"Teardown request: User=</span><span class="si">{</span><span class="n">user</span><span class="si">}</span><span class="s">, Duration=</span><span class="si">{</span><span class="n">duration</span><span class="si">:</span><span class="p">.</span><span class="mi">4</span><span class="n">f</span><span class="si">}</span><span class="s">s"</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
      <span class="n">current_app</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Teardown request: g values already popped or not set."</span><span class="p">)</span>

<span class="c1"># ... (rest of the app, including if __name__ == '__main__': app.run(debug=True))
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@app.before_request</code>: This decorator registers <code class="language-plaintext highlighter-rouge">load_request_data</code> to run before each request is processed.</li>
  <li><code class="language-plaintext highlighter-rouge">g.request_time = ...</code> and <code class="language-plaintext highlighter-rouge">g.user = ...</code>: We store arbitrary data on the <code class="language-plaintext highlighter-rouge">g</code> object. It acts like a Python object where you can set attributes.</li>
  <li><code class="language-plaintext highlighter-rouge">g.get('request_time', ...)</code>: In the view function <code class="language-plaintext highlighter-rouge">show_g</code>, we retrieve the data stored on <code class="language-plaintext highlighter-rouge">g</code>. Using <code class="language-plaintext highlighter-rouge">.get()</code> is safer as it allows providing a default if the attribute wasn’t set.</li>
  <li><code class="language-plaintext highlighter-rouge">@app.teardown_request</code>: This decorator registers <code class="language-plaintext highlighter-rouge">teardown_request_data</code> to run after the request has been handled and the response sent, even if an exception occurred. It’s a good place to clean up resources stored in <code class="language-plaintext highlighter-rouge">g</code>. <code class="language-plaintext highlighter-rouge">g.pop()</code> is used to get the value and remove it, preventing potential issues if the teardown runs multiple times in complex scenarios.</li>
</ul>

<p>When you visit <code class="language-plaintext highlighter-rouge">/show-g</code>, the <code class="language-plaintext highlighter-rouge">before_request</code> function runs first, setting <code class="language-plaintext highlighter-rouge">g.user</code> and <code class="language-plaintext highlighter-rouge">g.request_time</code>. Then <code class="language-plaintext highlighter-rouge">show_g</code> runs and reads those values from <code class="language-plaintext highlighter-rouge">g</code>. Finally, <code class="language-plaintext highlighter-rouge">teardown_request</code> runs. If you make another request, <code class="language-plaintext highlighter-rouge">g</code> will be empty again until <code class="language-plaintext highlighter-rouge">before_request</code> runs for that <em>new</em> request.</p>

<h2 id="why-context-the-magic-behind-the-scenes">Why “Context”? The Magic Behind the Scenes</h2>

<p>How do these globals always know which <code class="language-plaintext highlighter-rouge">request</code> or <code class="language-plaintext highlighter-rouge">app</code> to point to, especially if your web server is handling multiple requests at the same time?</p>

<p>Flask manages this using <strong>Contexts</strong>. There are two main types:</p>

<ol>
  <li><strong>Application Context:</strong> Holds information about the application itself. When an application context is active, <code class="language-plaintext highlighter-rouge">current_app</code> and <code class="language-plaintext highlighter-rouge">g</code> point to the correct application instance and its request-global storage (<code class="language-plaintext highlighter-rouge">g</code>). An application context is automatically created when a request context is pushed, or you can create one manually using <code class="language-plaintext highlighter-rouge">with app.app_context():</code>. This is needed for tasks that aren’t tied to a specific request but need the application, like running background jobs or initializing database tables via a script.</li>
  <li><strong>Request Context:</strong> Holds information about a single, specific HTTP request. When a request context is active, <code class="language-plaintext highlighter-rouge">request</code> and <code class="language-plaintext highlighter-rouge">session</code> point to the correct request object and session data for <em>that specific request</em>. Flask automatically creates and activates (pushes) a request context when it receives an incoming HTTP request and removes (pops) it when the request is finished.</li>
</ol>

<p>Think of these contexts like temporary bubbles or environments. When Flask handles a request, it inflates a request context bubble (which automatically includes an application context bubble inside it). Inside this bubble, the names <code class="language-plaintext highlighter-rouge">request</code>, <code class="language-plaintext highlighter-rouge">session</code>, <code class="language-plaintext highlighter-rouge">current_app</code>, and <code class="language-plaintext highlighter-rouge">g</code> are set up to point to the objects belonging to <em>that specific bubble</em>. If another request comes in concurrently (in a different thread or process), Flask creates a <em>separate</em> bubble for it, and the context globals inside that second bubble point to <em>its</em> own request, session, app, and g objects.</p>

<p>This system ensures that even with multiple simultaneous requests, <code class="language-plaintext highlighter-rouge">request</code> in the code handling request A always refers to request A’s data, while <code class="language-plaintext highlighter-rouge">request</code> in the code handling request B always refers to request B’s data.</p>

<p>We will explore contexts in more detail in <a href="07_application_and_request_contexts.md">Chapter 7: Application and Request Contexts</a>.</p>

<h2 id="under-the-hood-proxies-and-contextvars">Under the Hood: Proxies and <code class="language-plaintext highlighter-rouge">contextvars</code></h2>

<p>How do these variables like <code class="language-plaintext highlighter-rouge">request</code> actually <em>do</em> the lookup within the current context?</p>

<p>Flask uses a concept called <strong>Local Proxies</strong>, specifically <code class="language-plaintext highlighter-rouge">werkzeug.local.LocalProxy</code>. These proxy objects are essentially clever stand-ins. When you access an attribute or method on a proxy (like <code class="language-plaintext highlighter-rouge">request.method</code>), the proxy doesn’t have the method itself. Instead, it performs a lookup to find the <em>real</em> object it should be representing <em>at that moment</em> based on the current context.</p>

<p>Under the hood, Flask (since version 1.1, leveraging Werkzeug updates) uses Python’s built-in <code class="language-plaintext highlighter-rouge">contextvars</code> module (or a backport for older Python versions). <code class="language-plaintext highlighter-rouge">contextvars</code> provides special kinds of variables (<code class="language-plaintext highlighter-rouge">ContextVar</code>) that can hold different values depending on the current execution context (like the specific request/thread/async task being handled).</p>

<ol>
  <li>Flask defines context variables, for example, <code class="language-plaintext highlighter-rouge">_cv_request</code> in <code class="language-plaintext highlighter-rouge">flask.globals</code>.</li>
  <li>When a request context is pushed (<code class="language-plaintext highlighter-rouge">RequestContext.push()</code> in <code class="language-plaintext highlighter-rouge">ctx.py</code>), Flask stores the actual <code class="language-plaintext highlighter-rouge">Request</code> object for the current request into <code class="language-plaintext highlighter-rouge">_cv_request</code> <em>for the current context</em>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">request</code> global variable (defined in <code class="language-plaintext highlighter-rouge">flask.globals</code>) is a <code class="language-plaintext highlighter-rouge">LocalProxy</code> that is configured to look up the object stored in <code class="language-plaintext highlighter-rouge">_cv_request</code>.</li>
  <li>When your code uses <code class="language-plaintext highlighter-rouge">request.method</code>, the proxy sees it needs the real request object, looks at the current context’s value for <code class="language-plaintext highlighter-rouge">_cv_request</code>, gets the real <code class="language-plaintext highlighter-rouge">Request</code> object stored there, and then calls the <code class="language-plaintext highlighter-rouge">.method</code> attribute on <em>that</em> object.</li>
</ol>

<p>A similar process happens for <code class="language-plaintext highlighter-rouge">current_app</code>, <code class="language-plaintext highlighter-rouge">session</code>, and <code class="language-plaintext highlighter-rouge">g</code> using <code class="language-plaintext highlighter-rouge">_cv_app</code>.</p>

<p>Here’s how <code class="language-plaintext highlighter-rouge">request</code> and <code class="language-plaintext highlighter-rouge">session</code> are defined in <code class="language-plaintext highlighter-rouge">flask/globals.py</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># flask/globals.py (simplified)
</span><span class="kn">from</span> <span class="nn">contextvars</span> <span class="kn">import</span> <span class="n">ContextVar</span>
<span class="kn">from</span> <span class="nn">werkzeug.local</span> <span class="kn">import</span> <span class="n">LocalProxy</span>
<span class="c1"># ... other imports
</span>
<span class="c1"># Context Variables hold the actual context objects
</span><span class="n">_cv_app</span><span class="p">:</span> <span class="n">ContextVar</span><span class="p">[</span><span class="n">AppContext</span><span class="p">]</span> <span class="o">=</span> <span class="n">ContextVar</span><span class="p">(</span><span class="s">"flask.app_ctx"</span><span class="p">)</span>
<span class="n">_cv_request</span><span class="p">:</span> <span class="n">ContextVar</span><span class="p">[</span><span class="n">RequestContext</span><span class="p">]</span> <span class="o">=</span> <span class="n">ContextVar</span><span class="p">(</span><span class="s">"flask.request_ctx"</span><span class="p">)</span>

<span class="c1"># Proxies point to objects within the currently active context
# The LocalProxy is told how to find the real object (e.g., via _cv_request)
# and which attribute on that context object to return (e.g., 'request')
</span><span class="n">request</span><span class="p">:</span> <span class="n">Request</span> <span class="o">=</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="n">_cv_request</span><span class="p">,</span> <span class="s">"request"</span><span class="p">)</span> <span class="c1"># type: ignore
</span><span class="n">session</span><span class="p">:</span> <span class="n">SessionMixin</span> <span class="o">=</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="n">_cv_request</span><span class="p">,</span> <span class="s">"session"</span><span class="p">)</span> <span class="c1"># type: ignore
</span><span class="n">current_app</span><span class="p">:</span> <span class="n">Flask</span> <span class="o">=</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="n">_cv_app</span><span class="p">,</span> <span class="s">"app"</span><span class="p">)</span> <span class="c1"># type: ignore
</span><span class="n">g</span><span class="p">:</span> <span class="n">_AppCtxGlobals</span> <span class="o">=</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="n">_cv_app</span><span class="p">,</span> <span class="s">"g"</span><span class="p">)</span> <span class="c1"># type: ignore
</span></code></pre></div></div>

<p>This proxy mechanism allows you to write clean code using simple global names, while Flask handles the complexity of ensuring those names point to the correct, context-specific objects behind the scenes.</p>

<p>Here’s a diagram showing two concurrent requests and how the <code class="language-plaintext highlighter-rouge">request</code> proxy resolves differently in each context:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant UserCodeA as View Func (Req A)
    participant Proxy as request (LocalProxy)
    participant ContextVars as Context Storage
    participant UserCodeB as View Func (Req B)

    Note over UserCodeA, UserCodeB: Requests A and B handled concurrently

    UserCodeA-&gt;&gt;+Proxy: Access request.method
    Proxy-&gt;&gt;+ContextVars: Get current value of _cv_request
    ContextVars--&gt;&gt;-Proxy: Return RequestContext A
    Proxy-&gt;&gt;RequestContextA: Get 'request' attribute (Real Request A)
    RequestContextA--&gt;&gt;Proxy: Return Real Request A
    Proxy-&gt;&gt;RealRequestA: Access 'method' attribute
    RealRequestA--&gt;&gt;Proxy: Return 'GET'
    Proxy--&gt;&gt;-UserCodeA: Return 'GET'

    UserCodeB-&gt;&gt;+Proxy: Access request.form['name']
    Proxy-&gt;&gt;+ContextVars: Get current value of _cv_request
    ContextVars--&gt;&gt;-Proxy: Return RequestContext B
    Proxy-&gt;&gt;RequestContextB: Get 'request' attribute (Real Request B)
    RequestContextB--&gt;&gt;Proxy: Return Real Request B
    Proxy-&gt;&gt;RealRequestB: Access 'form' attribute
    RealRequestB--&gt;&gt;Proxy: Return FormDict B
    Proxy-&gt;&gt;FormDictB: Get item 'name'
    FormDictB--&gt;&gt;Proxy: Return 'Bob'
    Proxy--&gt;&gt;-UserCodeB: Return 'Bob'

</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve learned about Flask’s Context Globals: <code class="language-plaintext highlighter-rouge">current_app</code>, <code class="language-plaintext highlighter-rouge">request</code>, <code class="language-plaintext highlighter-rouge">session</code>, and <code class="language-plaintext highlighter-rouge">g</code>. These are powerful proxy objects that simplify your code by providing easy access to application- or request-specific information without needing to pass objects around manually.</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">request</code></strong>: Accesses incoming request data.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">session</code></strong>: Stores user-specific data across requests (requires <code class="language-plaintext highlighter-rouge">SECRET_KEY</code>).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">current_app</code></strong>: Accesses the active application instance and its config/resources.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">g</code></strong>: A temporary storage space for the duration of a single request.</li>
</ul>

<p>These globals work their magic through Flask’s <strong>context</strong> system (Application Context and Request Context) and <strong>proxies</strong> that look up the correct object in the currently active context, often powered by Python’s <code class="language-plaintext highlighter-rouge">contextvars</code>.</p>

<p>Understanding these globals is key to writing idiomatic Flask code. You’ll frequently use <code class="language-plaintext highlighter-rouge">request</code> to handle user input, <code class="language-plaintext highlighter-rouge">session</code> for user state, <code class="language-plaintext highlighter-rouge">current_app</code> for configuration, and <code class="language-plaintext highlighter-rouge">g</code> for managing request-scoped resources like database connections.</p>

<p>Speaking of configuration, how exactly do we set things like the <code class="language-plaintext highlighter-rouge">SECRET_KEY</code>, database URLs, or other settings for our application? That’s the topic of our next chapter.</p>

<p>Let’s learn how to manage settings effectively in <a href="06_configuration___config__.md">Chapter 6: Configuration (<code class="language-plaintext highlighter-rouge">Config</code>)</a>.</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
