<h1 id="chapter-3-configuring-your-blueprint---model-settings">Chapter 3: Configuring Your Blueprint - Model Settings</h1>

<p>In <a href="01_basemodel.md">Chapter 1</a>, we learned about <code class="language-plaintext highlighter-rouge">BaseModel</code> as our data blueprint, and in <a href="02_fields__fieldinfo___field_function_.md">Chapter 2</a>, we saw how <code class="language-plaintext highlighter-rouge">Field()</code> lets us add specific notes (like defaults or aliases) to individual rooms (fields) on that blueprint.</p>

<p>But what about instructions that apply to the <em>entire</em> blueprint? Imagine needing rules like:</p>

<ul>
  <li>“Absolutely no extra furniture allowed that’s not in the plan!” (Forbid extra fields)</li>
  <li>“Once built, nothing inside can be changed!” (Make the model immutable/frozen)</li>
  <li>“All room names on the final report should be lowercase.” (Apply a naming convention during output)</li>
</ul>

<p>These are model-wide settings, not specific to just one field. Pydantic provides a way to configure this overall behavior using model configuration.</p>

<h2 id="why-configure-the-whole-model">Why Configure the Whole Model?</h2>

<p>Let’s consider a simple <code class="language-plaintext highlighter-rouge">Product</code> model:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>

<span class="k">class</span> <span class="nc">Product</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">item_id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">price</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
</code></pre></div></div>

<p>This works, but we might want to enforce stricter rules or change default behaviors:</p>

<ol>
  <li><strong>Strictness:</strong> What if we receive data like <code class="language-plaintext highlighter-rouge">{'item_id': 123, 'name': 'Thingy', 'color': 'blue'}</code>? By default, Pydantic ignores the extra <code class="language-plaintext highlighter-rouge">color</code> field. We might want to <em>reject</em> data with unexpected fields.</li>
  <li><strong>Immutability:</strong> What if, once a <code class="language-plaintext highlighter-rouge">Product</code> object is created, we want to prevent accidental changes like <code class="language-plaintext highlighter-rouge">product.price = 99.99</code>?</li>
  <li><strong>Naming Conventions:</strong> What if our API expects JSON keys in <code class="language-plaintext highlighter-rouge">camelCase</code> (like <code class="language-plaintext highlighter-rouge">itemId</code>) instead of Python’s standard <code class="language-plaintext highlighter-rouge">snake_case</code> (<code class="language-plaintext highlighter-rouge">item_id</code>)?</li>
</ol>

<p>These global behaviors are controlled via Pydantic’s configuration system.</p>

<h2 id="introducing-configdict-and-model_config">Introducing <code class="language-plaintext highlighter-rouge">ConfigDict</code> and <code class="language-plaintext highlighter-rouge">model_config</code></h2>

<p>Pydantic allows you to customize model behavior by adding a special class attribute called <code class="language-plaintext highlighter-rouge">model_config</code>. This attribute should be assigned a dictionary-like object called <code class="language-plaintext highlighter-rouge">ConfigDict</code>.</p>

<p>Think of <code class="language-plaintext highlighter-rouge">model_config = ConfigDict(...)</code> as the <strong>master instruction sheet</strong> or the <strong>global settings panel</strong> attached to your <code class="language-plaintext highlighter-rouge">BaseModel</code> blueprint. It provides overarching rules for how Pydantic should handle the model.</p>

<p><strong><code class="language-plaintext highlighter-rouge">ConfigDict</code>:</strong> A special dictionary (specifically, a <code class="language-plaintext highlighter-rouge">TypedDict</code>) provided by Pydantic where you specify configuration options using key-value pairs.
<strong><code class="language-plaintext highlighter-rouge">model_config</code>:</strong> The class attribute on your <code class="language-plaintext highlighter-rouge">BaseModel</code> where you assign your <code class="language-plaintext highlighter-rouge">ConfigDict</code>.</p>

<p>Let’s add some configuration to our <code class="language-plaintext highlighter-rouge">Product</code> model:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Import ConfigDict
</span><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">ConfigDict</span>

<span class="k">class</span> <span class="nc">Product</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="c1"># Define model-wide settings here
</span>    <span class="n">model_config</span> <span class="o">=</span> <span class="n">ConfigDict</span><span class="p">(</span>
        <span class="n">frozen</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>             <span class="c1"># Setting 1: Make instances immutable
</span>        <span class="n">extra</span><span class="o">=</span><span class="s">'forbid'</span><span class="p">,</span>          <span class="c1"># Setting 2: Forbid extra fields during input validation
</span>        <span class="n">validate_assignment</span><span class="o">=</span><span class="bp">True</span> <span class="c1"># Setting 3: Re-validate fields when they are assigned a new value
</span>    <span class="p">)</span>

    <span class="n">item_id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">price</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>

<span class="c1"># --- How these settings affect behavior ---
</span>
<span class="c1"># 1. Forbid Extra Fields ('extra=forbid')
</span><span class="k">try</span><span class="p">:</span>
    <span class="c1"># Input data has an extra 'color' field
</span>    <span class="n">product_data_extra</span> <span class="o">=</span> <span class="p">{</span><span class="s">'item_id'</span><span class="p">:</span> <span class="mi">123</span><span class="p">,</span> <span class="s">'name'</span><span class="p">:</span> <span class="s">'Thingy'</span><span class="p">,</span> <span class="s">'color'</span><span class="p">:</span> <span class="s">'blue'</span><span class="p">}</span>
    <span class="n">Product</span><span class="p">(</span><span class="o">**</span><span class="n">product_data_extra</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Error on extra field:</span><span class="se">\n</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="c1"># Expected Output (simplified):
</span>    <span class="c1"># Error on extra field:
</span>    <span class="c1"># 1 validation error for Product
</span>    <span class="c1"># color
</span>    <span class="c1">#   Extra inputs are not permitted [type=extra_forbidden, ...]
</span>
<span class="c1"># 2. Immutability ('frozen=True')
</span><span class="n">product</span> <span class="o">=</span> <span class="n">Product</span><span class="p">(</span><span class="n">item_id</span><span class="o">=</span><span class="mi">456</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">"Gadget"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Initial product: </span><span class="si">{</span><span class="n">product</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output: Initial product: item_id=456 name='Gadget' price=None
</span>
<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Attempt to change a field on the frozen instance
</span>    <span class="n">product</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">"New Gadget"</span>
<span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">Error on assignment to frozen model:</span><span class="se">\n</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="c1"># Expected Output (simplified):
</span>    <span class="c1"># Error on assignment to frozen model:
</span>    <span class="c1"># 1 validation error for Product
</span>    <span class="c1"># name
</span>    <span class="c1">#   Instance is frozen [type=frozen_instance, ...]
</span>
<span class="c1"># 3. Validate Assignment ('validate_assignment=True')
</span><span class="n">product_mutable</span> <span class="o">=</span> <span class="n">Product</span><span class="p">.</span><span class="n">model_construct</span><span class="p">(</span><span class="n">item_id</span><span class="o">=</span><span class="mi">789</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">"Widget"</span><span class="p">)</span> <span class="c1"># Use model_construct to bypass initial __init__ validation for demo
</span><span class="k">try</span><span class="p">:</span>
    <span class="c1"># Attempt to assign an invalid type (int instead of str)
</span>    <span class="n">product_mutable</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="mi">999</span>
<span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">Error on invalid assignment:</span><span class="se">\n</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="c1"># Expected Output (simplified):
</span>    <span class="c1"># Error on invalid assignment:
</span>    <span class="c1"># 1 validation error for Product
</span>    <span class="c1"># name
</span>    <span class="c1">#  Input should be a valid string [type=string_type, input_value=999, input_type=int]
</span></code></pre></div></div>

<p>By adding the <code class="language-plaintext highlighter-rouge">model_config</code> dictionary, we changed the fundamental behavior of our <code class="language-plaintext highlighter-rouge">Product</code> model without altering the field definitions themselves.</p>

<h2 id="common-configuration-options">Common Configuration Options</h2>

<p>Here are a few more useful options you can set in <code class="language-plaintext highlighter-rouge">ConfigDict</code>:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">alias_generator</code></strong>: Automatically generate aliases for fields. Often used to convert between <code class="language-plaintext highlighter-rouge">snake_case</code> and <code class="language-plaintext highlighter-rouge">camelCase</code>.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">ConfigDict</span>
<span class="kn">from</span> <span class="nn">pydantic.alias_generators</span> <span class="kn">import</span> <span class="n">to_camel</span> <span class="c1"># Import a helper
</span>
<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">user_id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">first_name</span><span class="p">:</span> <span class="nb">str</span>

    <span class="n">model_config</span> <span class="o">=</span> <span class="n">ConfigDict</span><span class="p">(</span>
        <span class="n">alias_generator</span><span class="o">=</span><span class="n">to_camel</span><span class="p">,</span> <span class="c1"># Use the camelCase generator
</span>        <span class="n">populate_by_name</span><span class="o">=</span><span class="bp">True</span> <span class="c1"># Allow using EITHER alias or python name for input (see warning below)
</span>                              <span class="c1"># Replaced by validate_by_name=True + validate_by_alias=True
</span>    <span class="p">)</span>

<span class="c1"># Input using camelCase aliases
</span><span class="n">user_data_camel</span> <span class="o">=</span> <span class="p">{</span><span class="s">'userId'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'firstName'</span><span class="p">:</span> <span class="s">'Arthur'</span><span class="p">}</span>
<span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="o">**</span><span class="n">user_data_camel</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"User created from camelCase: </span><span class="si">{</span><span class="n">user</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output: User created from camelCase: user_id=1 first_name='Arthur'
</span>
<span class="c1"># Output (dumping) using aliases requires `by_alias=True`
</span><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Dumped with aliases: </span><span class="si">{</span><span class="n">user</span><span class="p">.</span><span class="n">model_dump</span><span class="p">(</span><span class="n">by_alias</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output: Dumped with aliases: {'userId': 1, 'firstName': 'Arthur'}
</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Dumped without aliases: </span><span class="si">{</span><span class="n">user</span><span class="p">.</span><span class="n">model_dump</span><span class="p">()</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output: Dumped without aliases: {'user_id': 1, 'first_name': 'Arthur'}
</span></code></pre></div>    </div>
    <ul>
      <li><strong>Modern Alias Control (Pydantic &gt;= v2.11):</strong> Instead of <code class="language-plaintext highlighter-rouge">populate_by_name</code>, use <code class="language-plaintext highlighter-rouge">validate_by_alias</code>, <code class="language-plaintext highlighter-rouge">validate_by_name</code>, and <code class="language-plaintext highlighter-rouge">serialize_by_alias</code> for finer control:
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">ConfigDict</span>
<span class="kn">from</span> <span class="nn">pydantic.alias_generators</span> <span class="kn">import</span> <span class="n">to_camel</span>

<span class="k">class</span> <span class="nc">UserV2</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">user_id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">first_name</span><span class="p">:</span> <span class="nb">str</span>

    <span class="n">model_config</span> <span class="o">=</span> <span class="n">ConfigDict</span><span class="p">(</span>
        <span class="n">alias_generator</span><span class="o">=</span><span class="n">to_camel</span><span class="p">,</span>
        <span class="n">validate_by_name</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>     <span class="c1"># Allow input using 'user_id', 'first_name'
</span>        <span class="n">validate_by_alias</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>    <span class="c1"># Allow input using 'userId', 'firstName' (default is True)
</span>        <span class="n">serialize_by_alias</span><span class="o">=</span><span class="bp">True</span>    <span class="c1"># Use aliases ('userId', 'firstName') when dumping by default
</span>    <span class="p">)</span>

<span class="n">user_data_camel</span> <span class="o">=</span> <span class="p">{</span><span class="s">'userId'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'firstName'</span><span class="p">:</span> <span class="s">'Zaphod'</span><span class="p">}</span>
<span class="n">user_camel</span> <span class="o">=</span> <span class="n">UserV2</span><span class="p">(</span><span class="o">**</span><span class="n">user_data_camel</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"User from camel: </span><span class="si">{</span><span class="n">user_camel</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># &gt; User from camel: user_id=1 first_name='Zaphod'
</span>
<span class="n">user_data_snake</span> <span class="o">=</span> <span class="p">{</span><span class="s">'user_id'</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s">'first_name'</span><span class="p">:</span> <span class="s">'Ford'</span><span class="p">}</span>
<span class="n">user_snake</span> <span class="o">=</span> <span class="n">UserV2</span><span class="p">(</span><span class="o">**</span><span class="n">user_data_snake</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"User from snake: </span><span class="si">{</span><span class="n">user_snake</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># &gt; User from snake: user_id=2 first_name='Ford'
</span>
<span class="c1"># serialize_by_alias=True means model_dump() uses aliases by default
</span><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Dumped (default alias): </span><span class="si">{</span><span class="n">user_camel</span><span class="p">.</span><span class="n">model_dump</span><span class="p">()</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># &gt; Dumped (default alias): {'userId': 1, 'firstName': 'Zaphod'}
</span><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Dumped (force no alias): </span><span class="si">{</span><span class="n">user_camel</span><span class="p">.</span><span class="n">model_dump</span><span class="p">(</span><span class="n">by_alias</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># &gt; Dumped (force no alias): {'user_id': 1, 'first_name': 'Zaphod'}
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">use_enum_values</code></strong>: When serializing (e.g., with <code class="language-plaintext highlighter-rouge">model_dump</code>), use the <em>value</em> of an enum member instead of the member itself.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">ConfigDict</span>

<span class="k">class</span> <span class="nc">Status</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">PENDING</span> <span class="o">=</span> <span class="s">"pending"</span>
    <span class="n">PROCESSING</span> <span class="o">=</span> <span class="s">"processing"</span>
    <span class="n">COMPLETE</span> <span class="o">=</span> <span class="s">"complete"</span>

<span class="k">class</span> <span class="nc">Order</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">order_id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">status</span><span class="p">:</span> <span class="n">Status</span>

    <span class="n">model_config</span> <span class="o">=</span> <span class="n">ConfigDict</span><span class="p">(</span>
        <span class="n">use_enum_values</span><span class="o">=</span><span class="bp">True</span> <span class="c1"># Use the string value of Status
</span>    <span class="p">)</span>

<span class="n">order</span> <span class="o">=</span> <span class="n">Order</span><span class="p">(</span><span class="n">order_id</span><span class="o">=</span><span class="mi">101</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="n">Status</span><span class="p">.</span><span class="n">PROCESSING</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Order object status type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">order</span><span class="p">.</span><span class="n">status</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output: Order object status type: &lt;enum 'Status'&gt;
</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Order dumped: </span><span class="si">{</span><span class="n">order</span><span class="p">.</span><span class="n">model_dump</span><span class="p">()</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output: Order dumped: {'order_id': 101, 'status': 'processing'}
# Note: 'status' is the string "processing", not Status.PROCESSING
</span></code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">str_strip_whitespace</code> / <code class="language-plaintext highlighter-rouge">str_to_lower</code> / <code class="language-plaintext highlighter-rouge">str_to_upper</code></strong>: Automatically clean string inputs.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">ConfigDict</span>

<span class="k">class</span> <span class="nc">Comment</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">text</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">author</span><span class="p">:</span> <span class="nb">str</span>

    <span class="n">model_config</span> <span class="o">=</span> <span class="n">ConfigDict</span><span class="p">(</span>
        <span class="n">str_strip_whitespace</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="c1"># Remove leading/trailing whitespace
</span>        <span class="n">str_to_lower</span><span class="o">=</span><span class="bp">True</span>          <span class="c1"># Convert to lowercase
</span>    <span class="p">)</span>

<span class="n">comment_data</span> <span class="o">=</span> <span class="p">{</span><span class="s">'text'</span><span class="p">:</span> <span class="s">'  Hello World!  '</span><span class="p">,</span> <span class="s">'author'</span><span class="p">:</span> <span class="s">' ALICE '</span><span class="p">}</span>
<span class="n">comment</span> <span class="o">=</span> <span class="n">Comment</span><span class="p">(</span><span class="o">**</span><span class="n">comment_data</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
<span class="c1"># Expected Output: text='hello world!' author='alice'
</span></code></pre></div>    </div>
  </li>
</ul>

<p>You can find the full list of configuration options in the Pydantic documentation for <a href="https://docs.pydantic.dev/latest/api/config/#pydantic.config.ConfigDict"><code class="language-plaintext highlighter-rouge">ConfigDict</code></a>.</p>

<p><strong>Important Note:</strong> Configuration set in <code class="language-plaintext highlighter-rouge">model_config</code> generally applies <em>during validation and serialization</em>. For example, <code class="language-plaintext highlighter-rouge">alias_generator</code> helps Pydantic understand incoming data with aliases and optionally use aliases when producing output, but the internal attribute name in your Python code remains the Python name (e.g., <code class="language-plaintext highlighter-rouge">user_id</code>).</p>

<h2 id="what-about-configwrapper-internal-detail">What About <code class="language-plaintext highlighter-rouge">ConfigWrapper</code>? (Internal Detail)</h2>

<p>You might see <code class="language-plaintext highlighter-rouge">ConfigWrapper</code> mentioned in Pydantic’s internal code or documentation.</p>

<p><strong>Analogy:</strong> If <code class="language-plaintext highlighter-rouge">ConfigDict</code> is the settings form you fill out (<code class="language-plaintext highlighter-rouge">frozen=True</code>, <code class="language-plaintext highlighter-rouge">extra='forbid'</code>), then <code class="language-plaintext highlighter-rouge">ConfigWrapper</code> is the internal manager object that Pydantic creates <em>from</em> your form. This manager holds onto your settings, knows the default values for settings you <em>didn’t</em> specify, and provides a consistent way for the rest of Pydantic (like the schema builder) to ask “Is this model frozen?” or “What should happen with extra fields?”.</p>

<p><strong>Key Point:</strong> As a user writing Pydantic models, you almost always interact with <strong><code class="language-plaintext highlighter-rouge">ConfigDict</code></strong> via the <code class="language-plaintext highlighter-rouge">model_config</code> attribute. You generally don’t need to create or use <code class="language-plaintext highlighter-rouge">ConfigWrapper</code> directly. It’s an internal helper that makes Pydantic’s life easier.</p>

<h2 id="under-the-hood-how-configuration-is-applied">Under the Hood: How Configuration is Applied</h2>

<p>Let’s refine our understanding of how a <code class="language-plaintext highlighter-rouge">BaseModel</code> class gets created, now including configuration.</p>

<p><strong>High-Level Steps:</strong></p>

<p>When Python creates your <code class="language-plaintext highlighter-rouge">Product</code> class:</p>

<ol>
  <li><strong>Inspection:</strong> Pydantic’s <code class="language-plaintext highlighter-rouge">ModelMetaclass</code> inspects the class definition. It finds the fields (<code class="language-plaintext highlighter-rouge">item_id: int</code>, etc.) and also looks for the <code class="language-plaintext highlighter-rouge">model_config</code> attribute.</li>
  <li><strong>Config Processing:</strong> If <code class="language-plaintext highlighter-rouge">model_config</code> (a <code class="language-plaintext highlighter-rouge">ConfigDict</code>) is found, Pydantic uses it (along with config from any parent classes) to create an internal <code class="language-plaintext highlighter-rouge">ConfigWrapper</code> instance. This wrapper standardizes access to all config settings, applying defaults for any missing options.</li>
  <li><strong>FieldInfo Creation:</strong> It processes field definitions, potentially using <code class="language-plaintext highlighter-rouge">Field()</code> as discussed in <a href="02_fields__fieldinfo___field_function_.md">Chapter 2</a>, creating <code class="language-plaintext highlighter-rouge">FieldInfo</code> objects.</li>
  <li><strong>Schema Generation:</strong> Pydantic now uses <em>both</em> the <code class="language-plaintext highlighter-rouge">FieldInfo</code> objects <em>and</em> the settings from the <code class="language-plaintext highlighter-rouge">ConfigWrapper</code> to generate the detailed internal <a href="05_core_schema___validation_serialization.md">Core Schema</a>. For example, if the <code class="language-plaintext highlighter-rouge">ConfigWrapper</code> says <code class="language-plaintext highlighter-rouge">frozen=True</code>, this instruction is baked into the Core Schema.</li>
  <li><strong>Validator/Serializer Creation:</strong> Optimized validator and serializer functions are created based on this final Core Schema.</li>
</ol>

<p><strong>Sequence Diagram:</strong></p>

<p>This diagram shows how <code class="language-plaintext highlighter-rouge">model_config</code> influences the process:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Dev as Developer
    participant Py as Python
    participant Meta as ModelMetaclass
    participant CfgWrap as ConfigWrapper
    participant Core as Pydantic Core Engine

    Dev-&gt;&gt;Py: Define `class Product(BaseModel): model_config = ConfigDict(frozen=True, extra='forbid') ...`
    Py-&gt;&gt;Meta: Ask to create `Product` class
    Meta-&gt;&gt;Meta: Find `model_config` dict in namespace
    Meta-&gt;&gt;CfgWrap: Create `ConfigWrapper` using `model_config` (and defaults)
    CfgWrap--&gt;&gt;Meta: Return `ConfigWrapper(config_dict={'frozen': True, 'extra': 'forbid', ...other defaults...})`
    Meta-&gt;&gt;Meta: Collect fields (`item_id`, `name`, `price`) and their FieldInfo
    Meta-&gt;&gt;Core: Request Core Schema using FieldInfo AND ConfigWrapper settings (e.g., frozen, extra)
    Core--&gt;&gt;Meta: Provide Core Schema incorporating model-wide rules
    Meta-&gt;&gt;Core: Request validator/serializer from Core Schema
    Core--&gt;&gt;Meta: Provide optimized validator/serializer reflecting config
    Meta--&gt;&gt;Py: Return fully prepared `Product` class
    Py--&gt;&gt;Dev: `Product` class is ready, respecting the config
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">ConfigWrapper</code> acts as a bridge, translating the user-friendly <code class="language-plaintext highlighter-rouge">ConfigDict</code> into instructions the Core Engine understands when building the schema and validators.</p>

<p><strong>Code Location:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ConfigDict</code>: Defined in <code class="language-plaintext highlighter-rouge">pydantic/config.py</code>. It’s essentially a <code class="language-plaintext highlighter-rouge">TypedDict</code> listing all valid configuration keys.</li>
  <li><code class="language-plaintext highlighter-rouge">ConfigWrapper</code>: Defined in <code class="language-plaintext highlighter-rouge">pydantic._internal._config.py</code>. Its <code class="language-plaintext highlighter-rouge">__init__</code> takes the config dictionary. The <code class="language-plaintext highlighter-rouge">ConfigWrapper.for_model</code> class method is used by the metaclass to gather configuration from base classes and the current class definition. Its <code class="language-plaintext highlighter-rouge">core_config</code> method translates the stored config into the format needed by <code class="language-plaintext highlighter-rouge">pydantic-core</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">ModelMetaclass</code>: In <code class="language-plaintext highlighter-rouge">pydantic._internal._model_construction.py</code>, the <code class="language-plaintext highlighter-rouge">__new__</code> method calls <code class="language-plaintext highlighter-rouge">ConfigWrapper.for_model</code> and passes the resulting wrapper to <code class="language-plaintext highlighter-rouge">build_schema_generator</code> and ultimately <code class="language-plaintext highlighter-rouge">complete_model_class</code>, which coordinates schema and validator/serializer creation.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified view from pydantic/config.py
# ConfigDict is a TypedDict listing allowed keys and their types
</span><span class="k">class</span> <span class="nc">ConfigDict</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">,</span> <span class="n">total</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="n">frozen</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">extra</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s">'allow'</span><span class="p">,</span> <span class="s">'ignore'</span><span class="p">,</span> <span class="s">'forbid'</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span>
    <span class="n">alias_generator</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span>
    <span class="c1"># ... many more options
</span>
<span class="c1"># Simplified view from pydantic._internal._config.py
</span><span class="k">class</span> <span class="nc">ConfigWrapper</span><span class="p">:</span>
    <span class="n">config_dict</span><span class="p">:</span> <span class="n">ConfigDict</span> <span class="c1"># Stores the actual config values
</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">ConfigDict</span> <span class="o">|</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="nb">type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">check</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="c1"># Simplification: Stores the input config, potentially validating keys
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">config_dict</span> <span class="o">=</span> <span class="n">prepare_config</span><span class="p">(</span><span class="n">config</span><span class="p">)</span> <span class="c1"># prepare_config handles defaults/deprecation
</span>
    <span class="c1"># Provides attribute access like wrapper.frozen, falling back to defaults
</span>    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">config_dict</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
            <span class="c1"># Fallback to default values defined in config_defaults
</span>            <span class="c1"># return config_defaults[name] # Simplified
</span>            <span class="k">pass</span> <span class="c1"># Actual implementation is more complex
</span>
    <span class="c1"># Used during model creation to gather config from all sources
</span>    <span class="o">@</span><span class="nb">classmethod</span>
    <span class="k">def</span> <span class="nf">for_model</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">bases</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">type</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span> <span class="p">...],</span> <span class="n">namespace</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span> <span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="n">config_new</span> <span class="o">=</span> <span class="n">ConfigDict</span><span class="p">()</span>
        <span class="c1"># 1. Inherit config from base classes
</span>        <span class="c1"># 2. Get config from 'model_config' in the current class namespace
</span>        <span class="c1"># 3. Get config from kwargs passed during class definition (e.g., class Model(BaseModel, frozen=True): ...)
</span>        <span class="c1"># ... logic to merge these sources ...
</span>        <span class="k">return</span> <span class="n">cls</span><span class="p">(</span><span class="n">config_new</span><span class="p">)</span> <span class="c1"># Return a wrapper with the final merged config
</span>
    <span class="c1"># Creates the config dictionary specifically for pydantic-core
</span>    <span class="k">def</span> <span class="nf">core_config</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">title</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">core_schema</span><span class="p">.</span><span class="n">CoreConfig</span><span class="p">:</span>
         <span class="c1"># Extracts relevant keys from self.config_dict and maps them
</span>         <span class="c1"># to the names expected by pydantic_core.CoreConfig
</span>         <span class="c1"># e.g., {'extra': 'forbid'} becomes {'extra_fields_behavior': 'forbid'}
</span>         <span class="n">core_options</span> <span class="o">=</span> <span class="p">{</span> <span class="p">...</span> <span class="p">}</span>
         <span class="k">return</span> <span class="n">core_schema</span><span class="p">.</span><span class="n">CoreConfig</span><span class="p">(</span><span class="o">**</span><span class="n">core_options</span><span class="p">)</span>

<span class="c1"># Simplified view from pydantic._internal._model_construction.py (ModelMetaclass.__new__)
</span><span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="c1"># ... lots of setup ...
</span>
    <span class="c1"># Step 1: Gather configuration
</span>    <span class="n">config_wrapper</span> <span class="o">=</span> <span class="n">ConfigWrapper</span><span class="p">.</span><span class="n">for_model</span><span class="p">(</span><span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span> <span class="c1"># Merges config from bases, class def, kwargs
</span>
    <span class="c1"># Step 2: Prepare schema generator using the config
</span>    <span class="n">schema_generator</span> <span class="o">=</span> <span class="n">build_schema_generator</span><span class="p">(</span>
        <span class="n">cls</span><span class="p">,</span> <span class="c1"># The class being built
</span>        <span class="n">config_wrapper</span><span class="p">,</span>
        <span class="c1"># ... other args ...
</span>    <span class="p">)</span>

    <span class="c1"># Step 3: Build core schema, validator, serializer (using schema_generator which uses config_wrapper)
</span>    <span class="c1"># core_schema = schema_generator.generate_schema(cls) # Simplified
</span>    <span class="c1"># validator = SchemaValidator(core_schema, config_wrapper.core_config()) # Simplified
</span>    <span class="c1"># serializer = SchemaSerializer(core_schema, config_wrapper.core_config()) # Simplified
</span>
    <span class="c1"># ... attach schema, validator, serializer to the class ...
</span>    <span class="n">cls</span> <span class="o">=</span> <span class="nb">super</span><span class="p">().</span><span class="n">__new__</span><span class="p">(</span><span class="n">mcs</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">bases</span><span class="p">,</span> <span class="n">namespace</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1"># cls.__pydantic_validator__ = validator
</span>    <span class="c1"># ...
</span>
    <span class="k">return</span> <span class="n">cls</span>
</code></pre></div></div>

<p>This setup ensures that the model-wide rules defined in <code class="language-plaintext highlighter-rouge">model_config</code> are consistently applied during both validation (creating model instances) and serialization (dumping model instances).</p>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve learned how to configure the overall behavior of your <code class="language-plaintext highlighter-rouge">BaseModel</code> blueprints:</p>

<ul>
  <li>Use the <code class="language-plaintext highlighter-rouge">model_config</code> class attribute, assigning it a <code class="language-plaintext highlighter-rouge">ConfigDict</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">ConfigDict</code> acts as the <strong>master instruction sheet</strong> or <strong>settings panel</strong> for the model.</li>
  <li>Common settings include <code class="language-plaintext highlighter-rouge">frozen</code>, <code class="language-plaintext highlighter-rouge">extra</code>, <code class="language-plaintext highlighter-rouge">alias_generator</code>, <code class="language-plaintext highlighter-rouge">use_enum_values</code>, and string cleaning options.</li>
  <li>Pydantic uses this configuration, often via the internal <code class="language-plaintext highlighter-rouge">ConfigWrapper</code>, to tailor the validation and serialization logic defined in the <a href="05_core_schema___validation_serialization.md">Core Schema</a>.</li>
</ul>

<p>With <code class="language-plaintext highlighter-rouge">BaseModel</code>, <code class="language-plaintext highlighter-rouge">Field</code>, and <code class="language-plaintext highlighter-rouge">ConfigDict</code>, you have powerful tools to define the structure, field-specific details, and overall behavior of your data models.</p>

<p>But what if you need logic that goes beyond simple configuration? What if you need custom validation rules that depend on multiple fields, or complex transformations before or after validation/serialization? That’s where Pydantic’s decorators come in.</p>

<p>Next: <a href="04_custom_logic__decorators___annotated_helpers_.md">Chapter 4: Custom Logic (Decorators &amp; Annotated Helpers)</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
