<h1 id="chapter-5-core-schema--validationserialization">Chapter 5: Core Schema &amp; Validation/Serialization</h1>

<p>In the previous chapters, we’ve seen how to define data structures using <a href="01_basemodel.md">BaseModel</a>, customize fields with <a href="02_fields__fieldinfo___field_function_.md">Field()</a>, set model-wide behavior with <a href="03_configuration__configdict___configwrapper_.md">Configuration</a>, and even add <a href="04_custom_logic__decorators___annotated_helpers_.md">Custom Logic</a> using decorators. You might be wondering: how does Pydantic take all these Python definitions and use them to perform such fast and reliable validation and serialization?</p>

<p>The secret lies in an internal representation called the <strong>Core Schema</strong> and a high-performance engine called <code class="language-plaintext highlighter-rouge">pydantic-core</code>. Let’s peek under the hood!</p>

<h2 id="why-look-under-the-hood">Why Look Under the Hood?</h2>

<p>Imagine you’ve designed a beautiful blueprint for a house (your Pydantic <code class="language-plaintext highlighter-rouge">BaseModel</code>). You’ve specified room sizes (type hints), special fixtures (<code class="language-plaintext highlighter-rouge">Field</code> constraints), and overall building codes (<code class="language-plaintext highlighter-rouge">ConfigDict</code>). You’ve even added custom inspection notes (decorators).</p>

<p>Now, how does the construction crew actually <em>build</em> the house and check everything rigorously? They don’t just glance at the user-friendly blueprint. They work from a highly detailed <strong>technical specification</strong> derived from it. This spec leaves no room for ambiguity.</p>

<p>In Pydantic, the <strong><code class="language-plaintext highlighter-rouge">CoreSchema</code></strong> is that technical specification, and the <strong><code class="language-plaintext highlighter-rouge">pydantic-core</code></strong> engine (written in Rust) is the super-efficient construction crew that uses it. Understanding this helps explain:</p>

<ul>
  <li><strong>Speed:</strong> Why Pydantic is so fast.</li>
  <li><strong>Consistency:</strong> How validation and serialization rules are strictly enforced.</li>
  <li><strong>Power:</strong> How complex requirements are translated into concrete instructions.</li>
</ul>

<h2 id="what-is-the-core-schema-the-technical-specification">What is the Core Schema? The Technical Specification</h2>

<p>When Pydantic processes your <code class="language-plaintext highlighter-rouge">BaseModel</code> definition (including type hints, <code class="language-plaintext highlighter-rouge">Field</code> calls, <code class="language-plaintext highlighter-rouge">ConfigDict</code>, decorators, etc.), it translates all that information into an internal data structure called the <strong>Core Schema</strong>.</p>

<p>Think of the Core Schema as:</p>

<ol>
  <li><strong>The Bridge:</strong> It connects your user-friendly Python code to the high-performance Rust engine (<code class="language-plaintext highlighter-rouge">pydantic-core</code>).</li>
  <li><strong>The Detailed Plan:</strong> It’s a precise, language-agnostic description of your data structure and all associated rules. It’s like a very detailed dictionary or JSON object.</li>
  <li><strong>The Single Source of Truth:</strong> It captures <em>everything</em> needed for validation and serialization:
    <ul>
      <li>Field types (<code class="language-plaintext highlighter-rouge">str</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">datetime</code>, nested models, etc.)</li>
      <li>Constraints (<code class="language-plaintext highlighter-rouge">min_length</code>, <code class="language-plaintext highlighter-rouge">gt</code>, <code class="language-plaintext highlighter-rouge">pattern</code>, etc. from <code class="language-plaintext highlighter-rouge">Field()</code>)</li>
      <li>Aliases (<code class="language-plaintext highlighter-rouge">alias='userName'</code> from <code class="language-plaintext highlighter-rouge">Field()</code>)</li>
      <li>Defaults (from <code class="language-plaintext highlighter-rouge">Field()</code> or <code class="language-plaintext highlighter-rouge">= default_value</code>)</li>
      <li>Model-wide settings (<code class="language-plaintext highlighter-rouge">extra='forbid'</code>, <code class="language-plaintext highlighter-rouge">frozen=True</code> from <code class="language-plaintext highlighter-rouge">ConfigDict</code>)</li>
      <li>Custom logic (references to your <code class="language-plaintext highlighter-rouge">@field_validator</code>, <code class="language-plaintext highlighter-rouge">@field_serializer</code> functions, etc.)</li>
    </ul>
  </li>
</ol>

<p><strong>Analogy:</strong> Your Python <code class="language-plaintext highlighter-rouge">BaseModel</code> is the architect’s blueprint. The <code class="language-plaintext highlighter-rouge">CoreSchema</code> is the exhaustive technical specification document derived from that blueprint, detailing every material, dimension, and construction step.</p>

<h3 id="a-glimpse-of-the-schema-conceptual">A Glimpse of the Schema (Conceptual)</h3>

<p>You don’t normally interact with the Core Schema directly, but let’s imagine what a simplified piece might look like for a field <code class="language-plaintext highlighter-rouge">name: str = Field(min_length=3)</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Conceptual representation - the actual structure is more complex!
</span><span class="n">name_field_schema</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s">'type'</span><span class="p">:</span> <span class="s">'str'</span><span class="p">,</span>          <span class="c1"># The basic type expected
</span>  <span class="s">'min_length'</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>        <span class="c1"># Constraint from Field(min_length=3)
</span>  <span class="s">'strict'</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>        <span class="c1"># Default strictness mode from config
</span>  <span class="s">'strip_whitespace'</span><span class="p">:</span> <span class="bp">None</span> <span class="c1"># Default string handling from config
</span>  <span class="c1"># ... other settings relevant to strings
</span><span class="p">}</span>

<span class="c1"># A schema for a whole model wraps field schemas:
</span><span class="n">model_schema</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">'type'</span><span class="p">:</span> <span class="s">'model'</span><span class="p">,</span>
    <span class="s">'cls'</span><span class="p">:</span> <span class="n">YourModelClass</span><span class="p">,</span> <span class="c1"># Reference to the Python class
</span>    <span class="s">'schema'</span><span class="p">:</span> <span class="p">{</span>
        <span class="s">'type'</span><span class="p">:</span> <span class="s">'model-fields'</span><span class="p">,</span>
        <span class="s">'fields'</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">'name'</span><span class="p">:</span> <span class="p">{</span> <span class="s">'type'</span><span class="p">:</span> <span class="s">'model-field'</span><span class="p">,</span> <span class="s">'schema'</span><span class="p">:</span> <span class="n">name_field_schema</span> <span class="p">},</span>
            <span class="c1"># ... schema for other fields ...
</span>        <span class="p">},</span>
        <span class="c1"># ... details about custom model validators ...
</span>    <span class="p">},</span>
    <span class="s">'config'</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># Merged config settings
</span>        <span class="s">'title'</span><span class="p">:</span> <span class="s">'YourModelClass'</span><span class="p">,</span>
        <span class="s">'extra_behavior'</span><span class="p">:</span> <span class="s">'ignore'</span><span class="p">,</span>
        <span class="s">'frozen'</span><span class="p">:</span> <span class="bp">False</span><span class="p">,</span>
        <span class="c1"># ...
</span>    <span class="p">},</span>
    <span class="c1"># ... details about custom serializers ...
</span><span class="p">}</span>
</code></pre></div></div>

<p>This internal schema precisely defines what <code class="language-plaintext highlighter-rouge">pydantic-core</code> needs to know to handle the <code class="language-plaintext highlighter-rouge">name</code> field and the overall model during validation and serialization.</p>

<p><strong>Inspecting the Real Schema:</strong></p>

<p>Pydantic actually stores this generated schema on your model class. You can (carefully) inspect it:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">username</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">min_length</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="s">'userName'</span><span class="p">)</span>

<span class="c1"># Access the generated core schema
# Warning: Internal structure, subject to change!
</span><span class="k">print</span><span class="p">(</span><span class="n">User</span><span class="p">.</span><span class="n">__pydantic_core_schema__</span><span class="p">)</span>
<span class="c1"># Output will be a complex dictionary representing the detailed schema
# (Output is large and complex, not shown here for brevity)
</span></code></pre></div></div>

<p>While you <em>can</em> look at <code class="language-plaintext highlighter-rouge">__pydantic_core_schema__</code>, treat it as an internal implementation detail. Its exact structure might change between Pydantic versions.</p>

<h2 id="what-is-pydantic-core-the-efficient-construction-crew">What is <code class="language-plaintext highlighter-rouge">pydantic-core</code>? The Efficient Construction Crew</h2>

<p><code class="language-plaintext highlighter-rouge">pydantic-core</code> is the heart of Pydantic’s performance. It’s a separate library, written in Rust (a language known for speed and safety), that does the heavy lifting of validation and serialization.</p>

<p><strong>How it Works:</strong></p>

<ol>
  <li><strong>Input:</strong> When your <code class="language-plaintext highlighter-rouge">BaseModel</code> class is first defined, Pydantic generates the <code class="language-plaintext highlighter-rouge">CoreSchema</code> (as described above).</li>
  <li><strong>Compilation:</strong> This <code class="language-plaintext highlighter-rouge">CoreSchema</code> is passed to the <code class="language-plaintext highlighter-rouge">pydantic-core</code> engine. The engine takes this schema and <em>compiles</em> it into highly optimized, specialized validator and serializer functions <em>specifically for your model</em>. Think of this as the crew studying the spec and preparing the exact tools needed for <em>this specific house</em>.</li>
  <li><strong>Storage:</strong> These compiled Rust objects are attached to your Python model class, typically as <code class="language-plaintext highlighter-rouge">__pydantic_validator__</code> and <code class="language-plaintext highlighter-rouge">__pydantic_serializer__</code>.</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># You can access these too (again, internal details!)
</span><span class="k">print</span><span class="p">(</span><span class="n">User</span><span class="p">.</span><span class="n">__pydantic_validator__</span><span class="p">)</span>
<span class="c1"># Output: &lt;SchemaValidator 'User' ...&gt; (a pydantic-core object)
</span>
<span class="k">print</span><span class="p">(</span><span class="n">User</span><span class="p">.</span><span class="n">__pydantic_serializer__</span><span class="p">)</span>
<span class="c1"># Output: &lt;SchemaSerializer 'User' ...&gt; (a pydantic-core object)
</span></code></pre></div></div>

<p>This “compilation” step happens only <em>once</em> when the class is created. This makes subsequent validation and serialization extremely fast.</p>

<h2 id="validation-flow-checking-incoming-materials">Validation Flow: Checking Incoming Materials</h2>

<p>When you create an instance of your model or validate data:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Example: Validation
</span><span class="k">try</span><span class="p">:</span>
    <span class="n">user_data</span> <span class="o">=</span> <span class="p">{</span><span class="s">'id'</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">'userName'</span><span class="p">:</span> <span class="s">'validUser'</span><span class="p">}</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="o">**</span><span class="n">user_data</span><span class="p">)</span> <span class="c1"># Calls __init__ -&gt; pydantic validation
</span>    <span class="c1"># or: user = User.model_validate(user_data)
</span><span class="k">except</span> <span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</code></pre></div></div>

<p>Here’s what happens behind the scenes:</p>

<ol>
  <li><strong>Call:</strong> Your Python code triggers validation (e.g., via <code class="language-plaintext highlighter-rouge">__init__</code> or <code class="language-plaintext highlighter-rouge">model_validate</code>).</li>
  <li><strong>Delegate:</strong> Pydantic passes the input data (<code class="language-plaintext highlighter-rouge">user_data</code>) to the pre-compiled <code class="language-plaintext highlighter-rouge">User.__pydantic_validator__</code> (the Rust object).</li>
  <li><strong>Execute:</strong> The <code class="language-plaintext highlighter-rouge">pydantic-core</code> validator executes its optimized Rust code, guided by the rules baked in from the <code class="language-plaintext highlighter-rouge">CoreSchema</code>. It checks:
    <ul>
      <li>Types (is <code class="language-plaintext highlighter-rouge">id</code> an <code class="language-plaintext highlighter-rouge">int</code>? is <code class="language-plaintext highlighter-rouge">userName</code> a <code class="language-plaintext highlighter-rouge">str</code>?)</li>
      <li>Coercion (can <code class="language-plaintext highlighter-rouge">'1'</code> be turned into <code class="language-plaintext highlighter-rouge">1</code> for <code class="language-plaintext highlighter-rouge">id</code>?)</li>
      <li>Constraints (is <code class="language-plaintext highlighter-rouge">len('validUser') &gt;= 5</code>?)</li>
      <li>Aliases (use <code class="language-plaintext highlighter-rouge">userName</code> from input for the <code class="language-plaintext highlighter-rouge">username</code> field)</li>
      <li>Required fields (is <code class="language-plaintext highlighter-rouge">id</code> present?)</li>
      <li>Extra fields (handle according to <code class="language-plaintext highlighter-rouge">model_config['extra']</code>)</li>
      <li>Custom validators (<code class="language-plaintext highlighter-rouge">@field_validator</code>, etc. are called back into Python if needed, though core logic is Rust)</li>
    </ul>
  </li>
  <li><strong>Result:</strong>
    <ul>
      <li>If all checks pass, the validator returns the validated data, which Pydantic uses to create/populate the <code class="language-plaintext highlighter-rouge">User</code> instance.</li>
      <li>If any check fails, the Rust validator gathers detailed error information and raises a <code class="language-plaintext highlighter-rouge">pydantic_core.ValidationError</code>, which Pydantic surfaces to your Python code.</li>
    </ul>
  </li>
</ol>

<p><strong>Analogy:</strong> The construction crew takes the delivery of materials (<code class="language-plaintext highlighter-rouge">user_data</code>) and uses the technical spec (<code class="language-plaintext highlighter-rouge">CoreSchema</code> baked into the validator) to rigorously check if everything is correct (right type, right size, etc.). If not, they issue a detailed non-compliance report (<code class="language-plaintext highlighter-rouge">ValidationError</code>).</p>

<h2 id="serialization-flow-generating-reports">Serialization Flow: Generating Reports</h2>

<p>When you dump your model instance:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Example: Serialization
</span><span class="n">user</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">username</span><span class="o">=</span><span class="s">'validUser'</span><span class="p">)</span>
<span class="n">user_dict</span> <span class="o">=</span> <span class="n">user</span><span class="p">.</span><span class="n">model_dump</span><span class="p">()</span>
<span class="c1"># or: user_json = user.model_dump_json()
</span></code></pre></div></div>

<p>Here’s the flow:</p>

<ol>
  <li><strong>Call:</strong> Your Python code calls <code class="language-plaintext highlighter-rouge">model_dump()</code> or <code class="language-plaintext highlighter-rouge">model_dump_json()</code>.</li>
  <li><strong>Delegate:</strong> Pydantic passes the model instance (<code class="language-plaintext highlighter-rouge">user</code>) to the pre-compiled <code class="language-plaintext highlighter-rouge">User.__pydantic_serializer__</code> (the Rust object).</li>
  <li><strong>Execute:</strong> The <code class="language-plaintext highlighter-rouge">pydantic-core</code> serializer executes its optimized Rust code, again guided by the <code class="language-plaintext highlighter-rouge">CoreSchema</code>. It:
    <ul>
      <li>Iterates through the fields specified by the schema.</li>
      <li>Applies serialization rules (e.g., use aliases if <code class="language-plaintext highlighter-rouge">by_alias=True</code>).</li>
      <li>Handles <code class="language-plaintext highlighter-rouge">include</code>, <code class="language-plaintext highlighter-rouge">exclude</code>, <code class="language-plaintext highlighter-rouge">exclude_unset</code>, <code class="language-plaintext highlighter-rouge">exclude_defaults</code>, <code class="language-plaintext highlighter-rouge">exclude_none</code> logic efficiently.</li>
      <li>Formats values for the target output (Python objects for <code class="language-plaintext highlighter-rouge">model_dump</code>, JSON types for <code class="language-plaintext highlighter-rouge">model_dump_json</code>).</li>
      <li>Calls custom serializers (<code class="language-plaintext highlighter-rouge">@field_serializer</code>, etc.) back into Python if needed.</li>
    </ul>
  </li>
  <li><strong>Result:</strong> The serializer returns the final dictionary or JSON string.</li>
</ol>

<p><strong>Analogy:</strong> The crew uses the technical spec (<code class="language-plaintext highlighter-rouge">CoreSchema</code> baked into the serializer) to generate a standardized report (<code class="language-plaintext highlighter-rouge">dict</code> or JSON) about the constructed house (<code class="language-plaintext highlighter-rouge">model instance</code>), formatting details (like using aliases) as requested.</p>

<h2 id="under-the-hood-the-assembly-line">Under the Hood: The Assembly Line</h2>

<p>Let’s visualize the entire process from defining a class to using it.</p>

<p><strong>Step-by-Step:</strong></p>

<ol>
  <li><strong>Definition:</strong> You define your <code class="language-plaintext highlighter-rouge">class User(BaseModel): ...</code> in Python.</li>
  <li><strong>Metaclass Magic:</strong> When Python creates the <code class="language-plaintext highlighter-rouge">User</code> class, Pydantic’s <code class="language-plaintext highlighter-rouge">ModelMetaclass</code> intercepts.</li>
  <li><strong>Inspection:</strong> The metaclass inspects the class definition: fields, type hints, <code class="language-plaintext highlighter-rouge">Field()</code> calls, <code class="language-plaintext highlighter-rouge">model_config</code>, decorators.</li>
  <li><strong>Schema Generation (Python):</strong> This information is fed into Pydantic’s Python-based schema generation logic (<code class="language-plaintext highlighter-rouge">pydantic._internal._generate_schema</code>).</li>
  <li><strong>CoreSchema Creation:</strong> The generator produces the detailed <code class="language-plaintext highlighter-rouge">CoreSchema</code> data structure.</li>
  <li><strong>Hand-off to Rust:</strong> This <code class="language-plaintext highlighter-rouge">CoreSchema</code> is passed to the <code class="language-plaintext highlighter-rouge">pydantic-core</code> Rust library.</li>
  <li><strong>Compilation (Rust):</strong> <code class="language-plaintext highlighter-rouge">pydantic-core</code> creates optimized <code class="language-plaintext highlighter-rouge">SchemaValidator</code> and <code class="language-plaintext highlighter-rouge">SchemaSerializer</code> instances based <em>specifically</em> on that schema.</li>
  <li><strong>Attachment:</strong> These Rust-backed objects are attached to the <code class="language-plaintext highlighter-rouge">User</code> class as <code class="language-plaintext highlighter-rouge">__pydantic_validator__</code> and <code class="language-plaintext highlighter-rouge">__pydantic_serializer__</code>.</li>
  <li><strong>Ready:</strong> The <code class="language-plaintext highlighter-rouge">User</code> class is now fully prepared.</li>
  <li><strong>Usage (Validation):</strong> Calling <code class="language-plaintext highlighter-rouge">User(...)</code> uses <code class="language-plaintext highlighter-rouge">User.__pydantic_validator__</code> (Rust) to process input.</li>
  <li><strong>Usage (Serialization):</strong> Calling <code class="language-plaintext highlighter-rouge">user.model_dump()</code> uses <code class="language-plaintext highlighter-rouge">User.__pydantic_serializer__</code> (Rust) to generate output.</li>
</ol>

<p><strong>Sequence Diagram:</strong></p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Dev as Developer
    participant PyClassDef as Python Class Definition
    participant PydanticPy as Pydantic (Python Layer)
    participant CoreSchemaDS as CoreSchema (Data Structure)
    participant PydanticCore as pydantic-core (Rust Engine)
    participant UserCode as User Code

    Dev-&gt;&gt;PyClassDef: Define `class User(BaseModel): ...`
    PyClassDef-&gt;&gt;PydanticPy: Python creates class, Pydantic metaclass intercepts
    PydanticPy-&gt;&gt;PydanticPy: Inspects fields, config, decorators
    PydanticPy-&gt;&gt;CoreSchemaDS: Generates detailed CoreSchema
    PydanticPy-&gt;&gt;PydanticCore: Pass CoreSchema to Rust engine
    PydanticCore-&gt;&gt;PydanticCore: Compile SchemaValidator from CoreSchema
    PydanticCore-&gt;&gt;PydanticCore: Compile SchemaSerializer from CoreSchema
    PydanticCore--&gt;&gt;PydanticPy: Return compiled Validator &amp; Serializer objects
    PydanticPy-&gt;&gt;PyClassDef: Attach Validator/Serializer to class object (`User`)

    UserCode-&gt;&gt;PyClassDef: Instantiate: `User(...)` or `User.model_validate(...)`
    PyClassDef-&gt;&gt;PydanticCore: Use attached SchemaValidator
    PydanticCore-&gt;&gt;PydanticCore: Execute fast validation logic
    alt Validation OK
        PydanticCore--&gt;&gt;UserCode: Return validated instance/data
    else Validation Error
        PydanticCore--&gt;&gt;UserCode: Raise ValidationError
    end

    UserCode-&gt;&gt;PyClassDef: Serialize: `user.model_dump()`
    PyClassDef-&gt;&gt;PydanticCore: Use attached SchemaSerializer
    PydanticCore-&gt;&gt;PydanticCore: Execute fast serialization logic
    PydanticCore--&gt;&gt;UserCode: Return dict/JSON string
</code></pre>

<p><strong>Code Location:</strong></p>

<ul>
  <li><strong>Metaclass &amp; Orchestration:</strong> <code class="language-plaintext highlighter-rouge">pydantic._internal._model_construction.py</code> (handles class creation)</li>
  <li><strong>Schema Generation (Python side):</strong> <code class="language-plaintext highlighter-rouge">pydantic._internal._generate_schema.py</code> (builds the schema structure)</li>
  <li><strong>Core Engine:</strong> The <code class="language-plaintext highlighter-rouge">pydantic-core</code> library (Rust code, compiled). You interact with it via the <code class="language-plaintext highlighter-rouge">SchemaValidator</code> and <code class="language-plaintext highlighter-rouge">SchemaSerializer</code> objects attached to your models.</li>
  <li><strong>Schema Representation:</strong> The <code class="language-plaintext highlighter-rouge">CoreSchema</code> itself is defined using types from <code class="language-plaintext highlighter-rouge">pydantic_core.core_schema</code>.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve now seen the engine behind Pydantic’s power!</p>

<ul>
  <li>Pydantic translates your Python model definitions (<code class="language-plaintext highlighter-rouge">BaseModel</code>, <code class="language-plaintext highlighter-rouge">Field</code>, <code class="language-plaintext highlighter-rouge">ConfigDict</code>, decorators) into a detailed, internal <strong><code class="language-plaintext highlighter-rouge">CoreSchema</code></strong>.</li>
  <li>This <code class="language-plaintext highlighter-rouge">CoreSchema</code> acts as the <strong>technical specification</strong> for your data.</li>
  <li>The high-performance <strong><code class="language-plaintext highlighter-rouge">pydantic-core</code></strong> engine (written in Rust) takes this schema and “compiles” it into optimized <code class="language-plaintext highlighter-rouge">SchemaValidator</code> and <code class="language-plaintext highlighter-rouge">SchemaSerializer</code> objects.</li>
  <li>These specialized objects perform fast <strong>validation</strong> (checking input) and <strong>serialization</strong> (dumping output) according to the rules defined in the schema.</li>
</ul>

<p>This combination of a clear Python API and a powerful Rust core allows Pydantic to be both user-friendly and incredibly performant.</p>

<p>What if you want to leverage this powerful validation and serialization engine for types that <em>aren’t</em> full <code class="language-plaintext highlighter-rouge">BaseModel</code> classes? Maybe just validate a standalone <code class="language-plaintext highlighter-rouge">list[int]</code> or serialize a <code class="language-plaintext highlighter-rouge">datetime</code> object according to specific rules? That’s where <code class="language-plaintext highlighter-rouge">TypeAdapter</code> comes in handy.</p>

<p>Next: <a href="06_typeadapter.md">Chapter 6: TypeAdapter</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
