<h1 id="chapter-4-custom-logic-decorators--annotated-helpers">Chapter 4: Custom Logic (Decorators &amp; Annotated Helpers)</h1>

<p>In <a href="03_configuration__configdict___configwrapper_.md">Chapter 3: Configuration (ConfigDict / ConfigWrapper)</a>, we learned how to set global rules for our data blueprints using <code class="language-plaintext highlighter-rouge">model_config</code>. But what if we need more specific, custom rules or transformations that go beyond simple settings?</p>

<p>Imagine you need rules like:</p>
<ul>
  <li>“This username must not contain any spaces.”</li>
  <li>“The <code class="language-plaintext highlighter-rouge">end_date</code> must always be later than the <code class="language-plaintext highlighter-rouge">start_date</code>.”</li>
  <li>“When sending this data as JSON, format this specific date field as <code class="language-plaintext highlighter-rouge">YYYY-MM-DD</code>.”</li>
  <li>“When validating, convert incoming usernames to lowercase automatically.”</li>
</ul>

<p>These require custom code logic. Pydantic provides flexible ways to inject this custom logic directly into the validation and serialization processes.</p>

<h2 id="why-custom-logic">Why Custom Logic?</h2>

<p>Standard type hints (<code class="language-plaintext highlighter-rouge">str</code>, <code class="language-plaintext highlighter-rouge">int</code>), <a href="02_fields__fieldinfo___field_function_.md">Fields</a> (<code class="language-plaintext highlighter-rouge">Field(gt=0)</code>), and <a href="03_configuration__configdict___configwrapper_.md">Configuration</a> (<code class="language-plaintext highlighter-rouge">ConfigDict(extra='forbid')</code>) cover many common cases. However, sometimes the rules are more complex or specific to your application’s needs.</p>

<p>For example, checking if a password meets complexity requirements (length, uppercase, numbers, symbols) or ensuring consistency between multiple fields (<code class="language-plaintext highlighter-rouge">start_date &lt; end_date</code>) requires writing your own Python functions.</p>

<p>Pydantic offers two main ways to add this custom logic:</p>
<ol>
  <li><strong>Decorators:</strong> Special markers (<code class="language-plaintext highlighter-rouge">@...</code>) you put above methods in your <code class="language-plaintext highlighter-rouge">BaseModel</code> class.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Annotated</code> Helpers:</strong> Using Python’s <code class="language-plaintext highlighter-rouge">typing.Annotated</code> along with special Pydantic classes to attach logic directly to a type hint.</li>
</ol>

<p><strong>Analogy:</strong> Think of these as adding custom steps to the construction (validation) and reporting (serialization) process for your data blueprint.</p>
<ul>
  <li><strong>Validators</strong> are like adding extra <em>inspection checks</em> at different stages of construction (before basic checks, after basic checks, or wrapping the entire process).</li>
  <li><strong>Serializers</strong> are like specifying custom <em>formatting rules</em> for the final report (converting your data back to simple types like dicts or JSON).</li>
</ul>

<p>Let’s explore these mechanisms.</p>

<h2 id="decorators-adding-logic-via-methods">Decorators: Adding Logic via Methods</h2>

<p>Decorators are a standard Python feature. They are functions that modify or enhance other functions or methods. Pydantic uses decorators to let you designate specific methods in your <code class="language-plaintext highlighter-rouge">BaseModel</code> as custom validators or serializers.</p>

<h3 id="field_validator-checking-individual-fields"><code class="language-plaintext highlighter-rouge">@field_validator</code>: Checking Individual Fields</h3>

<p>The <code class="language-plaintext highlighter-rouge">@field_validator</code> decorator lets you add custom validation logic for one or more specific fields <em>after</em> Pydantic has performed its initial type checks and coercion.</p>

<p><strong>Use Case:</strong> Let’s ensure a <code class="language-plaintext highlighter-rouge">username</code> field doesn’t contain spaces.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">field_validator</span><span class="p">,</span> <span class="n">ValidationError</span>

<span class="k">class</span> <span class="nc">UserRegistration</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">username</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">email</span><span class="p">:</span> <span class="nb">str</span>

    <span class="c1"># This method will be called automatically for the 'username' field
</span>    <span class="c1"># AFTER Pydantic checks it's a string.
</span>    <span class="o">@</span><span class="n">field_validator</span><span class="p">(</span><span class="s">'username'</span><span class="p">)</span>
    <span class="o">@</span><span class="nb">classmethod</span> <span class="c1"># Field validators should usually be class methods
</span>    <span class="k">def</span> <span class="nf">check_username_spaces</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Checking username: '</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s">'"</span><span class="p">)</span>
        <span class="k">if</span> <span class="s">' '</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
            <span class="c1"># Raise a ValueError if the rule is broken
</span>            <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">'Username cannot contain spaces'</span><span class="p">)</span>
        <span class="c1"># Return the valid value (can also modify it here if needed)
</span>        <span class="k">return</span> <span class="n">v</span>

<span class="c1"># --- Try it out ---
</span>
<span class="c1"># Valid username
</span><span class="n">user_ok</span> <span class="o">=</span> <span class="n">UserRegistration</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">'cool_cat123'</span><span class="p">,</span> <span class="n">email</span><span class="o">=</span><span class="s">'cat@meow.com'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Valid user created: </span><span class="si">{</span><span class="n">user_ok</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output:
# Checking username: 'cool_cat123'
# Valid user created: username='cool_cat123' email='cat@meow.com'
</span>
<span class="c1"># Invalid username
</span><span class="k">try</span><span class="p">:</span>
    <span class="n">UserRegistration</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">'cool cat 123'</span><span class="p">,</span> <span class="n">email</span><span class="o">=</span><span class="s">'cat@meow.com'</span><span class="p">)</span>
<span class="k">except</span> <span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">Validation Error:</span><span class="se">\n</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="c1"># Expected Output (simplified):
</span>    <span class="c1"># Checking username: 'cool cat 123'
</span>    <span class="c1"># Validation Error:
</span>    <span class="c1"># 1 validation error for UserRegistration
</span>    <span class="c1"># username
</span>    <span class="c1">#   Value error, Username cannot contain spaces [type=value_error, ...]
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ol>
  <li>We defined a <code class="language-plaintext highlighter-rouge">check_username_spaces</code> method inside our <code class="language-plaintext highlighter-rouge">UserRegistration</code> model.</li>
  <li>We decorated it with <code class="language-plaintext highlighter-rouge">@field_validator('username')</code>. This tells Pydantic: “After you validate <code class="language-plaintext highlighter-rouge">username</code> as a <code class="language-plaintext highlighter-rouge">str</code>, call this method with the value.”</li>
  <li>The <code class="language-plaintext highlighter-rouge">@classmethod</code> decorator is typically used so the method receives the class (<code class="language-plaintext highlighter-rouge">cls</code>) as the first argument instead of an instance (<code class="language-plaintext highlighter-rouge">self</code>).</li>
  <li>Inside the method, <code class="language-plaintext highlighter-rouge">v</code> holds the value of the <code class="language-plaintext highlighter-rouge">username</code> field <em>after</em> Pydantic’s basic <code class="language-plaintext highlighter-rouge">str</code> validation.</li>
  <li>We check our custom rule (<code class="language-plaintext highlighter-rouge">' ' in v</code>).</li>
  <li>If the rule is violated, we raise a <code class="language-plaintext highlighter-rouge">ValueError</code> (Pydantic catches this and wraps it in a <code class="language-plaintext highlighter-rouge">ValidationError</code>).</li>
  <li>If the value is okay, we <strong>must return it</strong>. You could also transform the value here (e.g., <code class="language-plaintext highlighter-rouge">return v.lower()</code>).</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">@field_validator</code> has a <code class="language-plaintext highlighter-rouge">mode</code> argument (<code class="language-plaintext highlighter-rouge">'before'</code> or <code class="language-plaintext highlighter-rouge">'after'</code>, default is <code class="language-plaintext highlighter-rouge">'after'</code>). <code class="language-plaintext highlighter-rouge">'after'</code> (as shown) runs <em>after</em> Pydantic’s internal validation for the field type. <code class="language-plaintext highlighter-rouge">'before'</code> runs <em>before</em>, giving you the raw input value.</p>

<h3 id="model_validator-checking-the-whole-model"><code class="language-plaintext highlighter-rouge">@model_validator</code>: Checking the Whole Model</h3>

<p>Sometimes, validation depends on multiple fields interacting. The <code class="language-plaintext highlighter-rouge">@model_validator</code> decorator lets you run logic that involves the entire model’s data.</p>

<p><strong>Use Case:</strong> Ensure <code class="language-plaintext highlighter-rouge">end_date</code> is after <code class="language-plaintext highlighter-rouge">start_date</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span>
<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">model_validator</span><span class="p">,</span> <span class="n">ValidationError</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Self</span> <span class="c1"># Used for type hint in Python 3.11+
</span>
<span class="k">class</span> <span class="nc">Trip</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">start_date</span><span class="p">:</span> <span class="n">date</span>
    <span class="n">end_date</span><span class="p">:</span> <span class="n">date</span>
    <span class="n">destination</span><span class="p">:</span> <span class="nb">str</span>

    <span class="c1"># This method runs AFTER the model fields are validated individually
</span>    <span class="o">@</span><span class="n">model_validator</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s">'after'</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">check_dates</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span> <span class="c1"># Use 'Self' or 'Trip' as return hint
</span>        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Checking dates: start=</span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">start_date</span><span class="si">}</span><span class="s">, end=</span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">end_date</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">start_date</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="p">.</span><span class="n">end_date</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">'End date must be after start date'</span><span class="p">)</span>
        <span class="c1"># Return the validated model instance
</span>        <span class="k">return</span> <span class="bp">self</span>

<span class="c1"># --- Try it out ---
</span>
<span class="c1"># Valid dates
</span><span class="n">trip_ok</span> <span class="o">=</span> <span class="n">Trip</span><span class="p">(</span><span class="n">start_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2024</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">end_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2024</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">destination</span><span class="o">=</span><span class="s">'Beach'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Valid trip: </span><span class="si">{</span><span class="n">trip_ok</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output:
# Checking dates: start=2024-07-01, end=2024-07-10
# Valid trip: start_date=datetime.date(2024, 7, 1) end_date=datetime.date(2024, 7, 10) destination='Beach'
</span>
<span class="c1"># Invalid dates
</span><span class="k">try</span><span class="p">:</span>
    <span class="n">Trip</span><span class="p">(</span><span class="n">start_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2024</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">end_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2024</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">destination</span><span class="o">=</span><span class="s">'Mountains'</span><span class="p">)</span>
<span class="k">except</span> <span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">Validation Error:</span><span class="se">\n</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="c1"># Expected Output (simplified):
</span>    <span class="c1"># Checking dates: start=2024-07-10, end=2024-07-01
</span>    <span class="c1"># Validation Error:
</span>    <span class="c1"># 1 validation error for Trip
</span>    <span class="c1">#   Value error, End date must be after start date [type=value_error, ...]
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ol>
  <li>We defined a <code class="language-plaintext highlighter-rouge">check_dates</code> method.</li>
  <li>We decorated it with <code class="language-plaintext highlighter-rouge">@model_validator(mode='after')</code>. This tells Pydantic: “After validating all individual fields and creating the model instance, call this method.”</li>
  <li>In <code class="language-plaintext highlighter-rouge">'after'</code> mode, the method receives <code class="language-plaintext highlighter-rouge">self</code> (the model instance). We can access all fields like <code class="language-plaintext highlighter-rouge">self.start_date</code>.</li>
  <li>We perform our cross-field check.</li>
  <li>If invalid, raise <code class="language-plaintext highlighter-rouge">ValueError</code>.</li>
  <li>If valid, <strong>must return <code class="language-plaintext highlighter-rouge">self</code></strong> (the model instance).</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">@model_validator</code> also supports <code class="language-plaintext highlighter-rouge">mode='before'</code>, where the method runs <em>before</em> individual field validation. In <code class="language-plaintext highlighter-rouge">'before'</code> mode, the method receives the class (<code class="language-plaintext highlighter-rouge">cls</code>) and the raw input data (usually a dictionary) and must return the (potentially modified) data dictionary to be used for further validation.</p>

<h3 id="field_serializer-customizing-field-output"><code class="language-plaintext highlighter-rouge">@field_serializer</code>: Customizing Field Output</h3>

<p>This decorator lets you control how a specific field is converted (serialized) when you call methods like <code class="language-plaintext highlighter-rouge">model_dump()</code> or <code class="language-plaintext highlighter-rouge">model_dump_json()</code>.</p>

<p><strong>Use Case:</strong> Serialize a <code class="language-plaintext highlighter-rouge">date</code> object as a simple <code class="language-plaintext highlighter-rouge">"YYYY-MM-DD"</code> string.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span>
<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">field_serializer</span>

<span class="k">class</span> <span class="nc">Event</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">event_date</span><span class="p">:</span> <span class="n">date</span>

    <span class="c1"># Customize serialization for the 'event_date' field
</span>    <span class="o">@</span><span class="n">field_serializer</span><span class="p">(</span><span class="s">'event_date'</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">serialize_date</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="n">date</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># Return the custom formatted string
</span>        <span class="k">return</span> <span class="n">dt</span><span class="p">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">'%Y-%m-%d'</span><span class="p">)</span>

<span class="c1"># --- Try it out ---
</span><span class="n">event</span> <span class="o">=</span> <span class="n">Event</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'Party'</span><span class="p">,</span> <span class="n">event_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2024</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">25</span><span class="p">))</span>

<span class="c1"># Default dump (dictionary)
</span><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Model object: </span><span class="si">{</span><span class="n">event</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output: Model object: name='Party' event_date=datetime.date(2024, 12, 25)
</span>
<span class="n">dumped_dict</span> <span class="o">=</span> <span class="n">event</span><span class="p">.</span><span class="n">model_dump</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Dumped dict: </span><span class="si">{</span><span class="n">dumped_dict</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output: Dumped dict: {'name': 'Party', 'event_date': '2024-12-25'}
</span>
<span class="n">dumped_json</span> <span class="o">=</span> <span class="n">event</span><span class="p">.</span><span class="n">model_dump_json</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Dumped JSON:</span><span class="se">\n</span><span class="si">{</span><span class="n">dumped_json</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output:
# Dumped JSON:
# {
#   "name": "Party",
#   "event_date": "2024-12-25"
# }
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ol>
  <li>We defined <code class="language-plaintext highlighter-rouge">serialize_date</code> and decorated it with <code class="language-plaintext highlighter-rouge">@field_serializer('event_date')</code>.</li>
  <li>The method receives <code class="language-plaintext highlighter-rouge">self</code> (the instance) and <code class="language-plaintext highlighter-rouge">dt</code> (the value of the <code class="language-plaintext highlighter-rouge">event_date</code> field). You can also add an optional <code class="language-plaintext highlighter-rouge">info: SerializationInfo</code> argument for more context.</li>
  <li>It returns the desired serialized format (a string in this case).</li>
  <li>When <code class="language-plaintext highlighter-rouge">model_dump()</code> or <code class="language-plaintext highlighter-rouge">model_dump_json()</code> is called, Pydantic uses this method for the <code class="language-plaintext highlighter-rouge">event_date</code> field instead of its default date serialization.</li>
</ol>

<h3 id="model_serializer-customizing-model-output"><code class="language-plaintext highlighter-rouge">@model_serializer</code>: Customizing Model Output</h3>

<p>This allows custom logic for serializing the entire model object.</p>

<p><strong>Use Case:</strong> Add a calculated <code class="language-plaintext highlighter-rouge">duration_days</code> field during serialization.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span><span class="p">,</span> <span class="n">timedelta</span>
<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">model_serializer</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span>

<span class="k">class</span> <span class="nc">Trip</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">start_date</span><span class="p">:</span> <span class="n">date</span>
    <span class="n">end_date</span><span class="p">:</span> <span class="n">date</span>
    <span class="n">destination</span><span class="p">:</span> <span class="nb">str</span>

    <span class="c1"># Customize the entire model's serialization
</span>    <span class="o">@</span><span class="n">model_serializer</span>
    <span class="k">def</span> <span class="nf">serialize_with_duration</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="c1"># Start with the default field values
</span>        <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s">'start_date'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">start_date</span><span class="p">,</span> <span class="s">'end_date'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">end_date</span><span class="p">,</span> <span class="s">'destination'</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">destination</span><span class="p">}</span>
        <span class="c1"># Calculate and add the custom field
</span>        <span class="n">duration</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">end_date</span> <span class="o">-</span> <span class="bp">self</span><span class="p">.</span><span class="n">start_date</span>
        <span class="n">data</span><span class="p">[</span><span class="s">'duration_days'</span><span class="p">]</span> <span class="o">=</span> <span class="n">duration</span><span class="p">.</span><span class="n">days</span>
        <span class="k">return</span> <span class="n">data</span>

<span class="c1"># --- Try it out ---
</span><span class="n">trip</span> <span class="o">=</span> <span class="n">Trip</span><span class="p">(</span><span class="n">start_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2024</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">end_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2024</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">destination</span><span class="o">=</span><span class="s">'Lake'</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Model object: </span><span class="si">{</span><span class="n">trip</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output: Model object: start_date=datetime.date(2024, 8, 1) end_date=datetime.date(2024, 8, 5) destination='Lake'
</span>
<span class="n">dumped_dict</span> <span class="o">=</span> <span class="n">trip</span><span class="p">.</span><span class="n">model_dump</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Dumped dict: </span><span class="si">{</span><span class="n">dumped_dict</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output: Dumped dict: {'start_date': datetime.date(2024, 8, 1), 'end_date': datetime.date(2024, 8, 5), 'destination': 'Lake', 'duration_days': 4}
</span>
<span class="n">dumped_json</span> <span class="o">=</span> <span class="n">trip</span><span class="p">.</span><span class="n">model_dump_json</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Dumped JSON:</span><span class="se">\n</span><span class="si">{</span><span class="n">dumped_json</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output:
# Dumped JSON:
# {
#   "start_date": "2024-08-01",
#   "end_date": "2024-08-05",
#   "destination": "Lake",
#   "duration_days": 4
# }
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ol>
  <li>We decorated <code class="language-plaintext highlighter-rouge">serialize_with_duration</code> with <code class="language-plaintext highlighter-rouge">@model_serializer</code>.</li>
  <li>The default <code class="language-plaintext highlighter-rouge">mode='plain'</code> means this method <em>replaces</em> the standard model serialization. It receives <code class="language-plaintext highlighter-rouge">self</code>.</li>
  <li>We manually construct the dictionary we want as output, adding our calculated <code class="language-plaintext highlighter-rouge">duration_days</code>.</li>
  <li>This dictionary is used by <code class="language-plaintext highlighter-rouge">model_dump()</code> and <code class="language-plaintext highlighter-rouge">model_dump_json()</code>.</li>
</ol>

<p>There’s also a <code class="language-plaintext highlighter-rouge">mode='wrap'</code> for <code class="language-plaintext highlighter-rouge">@model_serializer</code> (and <code class="language-plaintext highlighter-rouge">@field_serializer</code>) which is more advanced. It gives you a <code class="language-plaintext highlighter-rouge">handler</code> function to call the <em>next</em> serialization step (either Pydantic’s default or another wrapper), allowing you to modify the result <em>around</em> the standard logic.</p>

<h2 id="annotated-helpers-attaching-logic-to-type-hints"><code class="language-plaintext highlighter-rouge">Annotated</code> Helpers: Attaching Logic to Type Hints</h2>

<p>Python’s <code class="language-plaintext highlighter-rouge">typing.Annotated</code> allows adding extra metadata to type hints. Pydantic leverages this to let you attach validation and serialization logic directly inline with your field definitions.</p>

<p><strong>Analogy:</strong> Instead of separate instruction sheets (decorators), this is like putting specific instruction tags directly onto an item in the blueprint.</p>

<p>Common helpers include:</p>
<ul>
  <li><strong>Validators:</strong> <code class="language-plaintext highlighter-rouge">BeforeValidator</code>, <code class="language-plaintext highlighter-rouge">AfterValidator</code>, <code class="language-plaintext highlighter-rouge">PlainValidator</code>, <code class="language-plaintext highlighter-rouge">WrapValidator</code></li>
  <li><strong>Serializers:</strong> <code class="language-plaintext highlighter-rouge">PlainSerializer</code>, <code class="language-plaintext highlighter-rouge">WrapSerializer</code></li>
</ul>

<p>Let’s see how <code class="language-plaintext highlighter-rouge">AfterValidator</code> compares to <code class="language-plaintext highlighter-rouge">@field_validator</code>.</p>

<p><strong>Use Case:</strong> Ensure <code class="language-plaintext highlighter-rouge">username</code> has no spaces, using <code class="language-plaintext highlighter-rouge">Annotated</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Annotated</span>
<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span><span class="p">,</span> <span class="n">ValidationError</span>
<span class="c1"># Import the helper
</span><span class="kn">from</span> <span class="nn">pydantic.functional_validators</span> <span class="kn">import</span> <span class="n">AfterValidator</span>

<span class="c1"># Define the validation function (can be outside the class)
</span><span class="k">def</span> <span class="nf">check_no_spaces</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Checking username via Annotated: '</span><span class="si">{</span><span class="n">v</span><span class="si">}</span><span class="s">'"</span><span class="p">)</span>
    <span class="k">if</span> <span class="s">' '</span> <span class="ow">in</span> <span class="n">v</span><span class="p">:</span>
        <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">'Username cannot contain spaces'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">v</span>

<span class="k">class</span> <span class="nc">UserRegistrationAnnotated</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="c1"># Attach the validator function directly to the type hint
</span>    <span class="n">username</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">AfterValidator</span><span class="p">(</span><span class="n">check_no_spaces</span><span class="p">)]</span>
    <span class="n">email</span><span class="p">:</span> <span class="nb">str</span>

<span class="c1"># --- Try it out ---
</span>
<span class="c1"># Valid username
</span><span class="n">user_ok</span> <span class="o">=</span> <span class="n">UserRegistrationAnnotated</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">'another_cat'</span><span class="p">,</span> <span class="n">email</span><span class="o">=</span><span class="s">'cat@meow.com'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Valid user: </span><span class="si">{</span><span class="n">user_ok</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output:
# Checking username via Annotated: 'another_cat'
# Valid user: username='another_cat' email='cat@meow.com'
</span>
<span class="c1"># Invalid username
</span><span class="k">try</span><span class="p">:</span>
    <span class="n">UserRegistrationAnnotated</span><span class="p">(</span><span class="n">username</span><span class="o">=</span><span class="s">'another cat'</span><span class="p">,</span> <span class="n">email</span><span class="o">=</span><span class="s">'cat@meow.com'</span><span class="p">)</span>
<span class="k">except</span> <span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">Validation Error:</span><span class="se">\n</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="c1"># Expected Output (simplified):
</span>    <span class="c1"># Checking username via Annotated: 'another cat'
</span>    <span class="c1"># Validation Error:
</span>    <span class="c1"># 1 validation error for UserRegistrationAnnotated
</span>    <span class="c1"># username
</span>    <span class="c1">#   Value error, Username cannot contain spaces [type=value_error, ...]
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ol>
  <li>We import <code class="language-plaintext highlighter-rouge">Annotated</code> from <code class="language-plaintext highlighter-rouge">typing</code> and <code class="language-plaintext highlighter-rouge">AfterValidator</code> from Pydantic.</li>
  <li>We define a standalone function <code class="language-plaintext highlighter-rouge">check_no_spaces</code> (it doesn’t need to be a method).</li>
  <li>In the model, we define <code class="language-plaintext highlighter-rouge">username</code> as <code class="language-plaintext highlighter-rouge">Annotated[str, AfterValidator(check_no_spaces)]</code>. This tells Pydantic: “The type is <code class="language-plaintext highlighter-rouge">str</code>, and after validating it as a string, apply the <code class="language-plaintext highlighter-rouge">check_no_spaces</code> function.”</li>
  <li>The behavior is identical to the <code class="language-plaintext highlighter-rouge">@field_validator</code> example, but the logic is attached differently.</li>
</ol>

<p>Similarly, you can use <code class="language-plaintext highlighter-rouge">BeforeValidator</code> (runs before Pydantic’s type validation) or <code class="language-plaintext highlighter-rouge">PlainSerializer</code> / <code class="language-plaintext highlighter-rouge">WrapSerializer</code> to attach serialization logic.</p>

<p><strong>Use Case:</strong> Serialize <code class="language-plaintext highlighter-rouge">date</code> as <code class="language-plaintext highlighter-rouge">"YYYY-MM-DD"</code> using <code class="language-plaintext highlighter-rouge">Annotated</code> and <code class="language-plaintext highlighter-rouge">PlainSerializer</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Annotated</span>
<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>
<span class="c1"># Import the helper
</span><span class="kn">from</span> <span class="nn">pydantic.functional_serializers</span> <span class="kn">import</span> <span class="n">PlainSerializer</span>

<span class="c1"># Define the serializer function
</span><span class="k">def</span> <span class="nf">format_date_yyyymmdd</span><span class="p">(</span><span class="n">dt</span><span class="p">:</span> <span class="n">date</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">dt</span><span class="p">.</span><span class="n">strftime</span><span class="p">(</span><span class="s">'%Y-%m-%d'</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">EventAnnotated</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># Attach the serializer function directly to the type hint
</span>    <span class="n">event_date</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">date</span><span class="p">,</span> <span class="n">PlainSerializer</span><span class="p">(</span><span class="n">format_date_yyyymmdd</span><span class="p">)]</span>

<span class="c1"># --- Try it out ---
</span><span class="n">event</span> <span class="o">=</span> <span class="n">EventAnnotated</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">'Conference'</span><span class="p">,</span> <span class="n">event_date</span><span class="o">=</span><span class="n">date</span><span class="p">(</span><span class="mi">2024</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Model object: </span><span class="si">{</span><span class="n">event</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output: Model object: name='Conference' event_date=datetime.date(2024, 10, 15)
</span>
<span class="n">dumped_dict</span> <span class="o">=</span> <span class="n">event</span><span class="p">.</span><span class="n">model_dump</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Dumped dict: </span><span class="si">{</span><span class="n">dumped_dict</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output: Dumped dict: {'name': 'Conference', 'event_date': '2024-10-15'}
</span>
<span class="n">dumped_json</span> <span class="o">=</span> <span class="n">event</span><span class="p">.</span><span class="n">model_dump_json</span><span class="p">(</span><span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Dumped JSON:</span><span class="se">\n</span><span class="si">{</span><span class="n">dumped_json</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Expected Output:
# Dumped JSON:
# {
#   "name": "Conference",
#   "event_date": "2024-10-15"
# }
</span></code></pre></div></div>

<p>This achieves the same result as the <code class="language-plaintext highlighter-rouge">@field_serializer</code> example, but by attaching the logic via <code class="language-plaintext highlighter-rouge">Annotated</code>.</p>

<p><strong>Which to choose? Decorators vs. Annotated Helpers:</strong></p>
<ul>
  <li><strong>Decorators (<code class="language-plaintext highlighter-rouge">@field_validator</code>, etc.):</strong> Keep logic tightly coupled with the model class definition. Good if the logic intrinsically belongs to the model or needs access to <code class="language-plaintext highlighter-rouge">cls</code> or <code class="language-plaintext highlighter-rouge">self</code>. Can feel more object-oriented.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Annotated</code> Helpers (<code class="language-plaintext highlighter-rouge">AfterValidator</code>, etc.):</strong> Allow defining reusable validation/serialization functions outside the model. Good for applying the same logic across different models or fields. Can make type hints more verbose but keeps the model body cleaner.</li>
</ul>

<h2 id="under-the-hood-wiring-up-the-logic">Under the Hood: Wiring Up the Logic</h2>

<p>How does Pydantic discover and apply this custom logic?</p>

<p><strong>Decorators:</strong></p>
<ol>
  <li><strong>Class Creation:</strong> When Python creates your <code class="language-plaintext highlighter-rouge">BaseModel</code> class (like <code class="language-plaintext highlighter-rouge">UserRegistration</code>), Pydantic’s <code class="language-plaintext highlighter-rouge">ModelMetaclass</code> scans the class attributes.</li>
  <li><strong>Decorator Detection:</strong> It finds methods decorated with Pydantic decorators (<code class="language-plaintext highlighter-rouge">@field_validator</code>, <code class="language-plaintext highlighter-rouge">@model_serializer</code>, etc.). It uses helper classes like <code class="language-plaintext highlighter-rouge">PydanticDescriptorProxy</code> (from <code class="language-plaintext highlighter-rouge">pydantic._internal._decorators</code>) to wrap these methods and store metadata about the decorator (like which fields it applies to, the mode, etc., using internal classes like <code class="language-plaintext highlighter-rouge">FieldValidatorDecoratorInfo</code>).</li>
  <li><strong>Info Storage:</strong> Information about all found decorators is collected and stored internally, often associated with the class (e.g., in a hidden <code class="language-plaintext highlighter-rouge">__pydantic_decorators__</code> attribute holding a <code class="language-plaintext highlighter-rouge">DecoratorInfos</code> object).</li>
  <li><strong>Schema Integration:</strong> When generating the <a href="05_core_schema___validation_serialization.md">Core Schema</a> for the model, Pydantic consults this stored decorator information. It translates the decorator rules (e.g., “run <code class="language-plaintext highlighter-rouge">check_username_spaces</code> after validating <code class="language-plaintext highlighter-rouge">username</code>”) into corresponding schema components (like <code class="language-plaintext highlighter-rouge">after_validator_function</code>). The core validation/serialization engine then uses this schema.</li>
</ol>

<pre><code class="language-mermaid">sequenceDiagram
    participant Dev as Developer
    participant Py as Python Interpreter
    participant Meta as BaseModel Metaclass
    participant DecInfo as DecoratorInfos
    participant Core as Pydantic Core Engine

    Dev-&gt;&gt;Py: Define `class User(BaseModel): ... @field_validator('username') def check_spaces(cls, v): ...`
    Py-&gt;&gt;Meta: Ask to create the `User` class
    Meta-&gt;&gt;Meta: Scan class attributes, find `check_spaces` wrapped by PydanticDescriptorProxy
    Meta-&gt;&gt;DecInfo: Store info: func=check_spaces, applies_to='username', mode='after'
    Meta-&gt;&gt;Core: Request Core Schema, providing field info AND DecoratorInfos
    Core-&gt;&gt;Core: Build schema, incorporating an 'after_validator' step for 'username' linked to `check_spaces`
    Core--&gt;&gt;Meta: Provide internal Core Schema for User
    Meta-&gt;&gt;Core: Request validator/serializer functions from schema
    Core--&gt;&gt;Meta: Provide optimized functions incorporating custom logic
    Meta--&gt;&gt;Py: Return the fully prepared `User` class
    Py--&gt;&gt;Dev: `User` class is ready
</code></pre>

<p><strong><code class="language-plaintext highlighter-rouge">Annotated</code> Helpers:</strong></p>
<ol>
  <li><strong>Field Processing:</strong> During class creation, when Pydantic processes a field like <code class="language-plaintext highlighter-rouge">username: Annotated[str, AfterValidator(check_no_spaces)]</code>, it analyzes the <code class="language-plaintext highlighter-rouge">Annotated</code> metadata.</li>
  <li><strong>Helper Recognition:</strong> It recognizes Pydantic helper classes like <code class="language-plaintext highlighter-rouge">AfterValidator</code>. These helpers often implement a special method <code class="language-plaintext highlighter-rouge">__get_pydantic_core_schema__</code>.</li>
  <li><strong>Schema Generation:</strong> Pydantic’s schema generation logic (often involving <code class="language-plaintext highlighter-rouge">GetCoreSchemaHandler</code> from <code class="language-plaintext highlighter-rouge">pydantic.annotated_handlers</code>) calls <code class="language-plaintext highlighter-rouge">AfterValidator.__get_pydantic_core_schema__</code>. This method tells the handler how to integrate the custom logic (<code class="language-plaintext highlighter-rouge">check_no_spaces</code>) into the <a href="05_core_schema___validation_serialization.md">Core Schema</a> being built for the <code class="language-plaintext highlighter-rouge">username</code> field.</li>
  <li><strong>Schema Integration:</strong> The handler modifies the schema-in-progress to include the custom logic (e.g., adding an <code class="language-plaintext highlighter-rouge">after_validator_function</code> component pointing to <code class="language-plaintext highlighter-rouge">check_no_spaces</code>). The final schema used by the core engine contains this logic directly associated with the field.</li>
</ol>

<pre><code class="language-mermaid">sequenceDiagram
    participant Dev as Developer
    participant Py as Python Interpreter
    participant Meta as BaseModel Metaclass
    participant SchemaGen as Core Schema Generator
    participant Helper as AfterValidator Instance
    participant Core as Pydantic Core Engine

    Dev-&gt;&gt;Py: Define `class User(BaseModel): username: Annotated[str, AfterValidator(check_no_spaces)]`
    Py-&gt;&gt;Meta: Ask to create the `User` class
    Meta-&gt;&gt;SchemaGen: Start building schema for `User`
    SchemaGen-&gt;&gt;SchemaGen: Process 'username' field, see `Annotated[str, AfterValidator(...)]`
    SchemaGen-&gt;&gt;Helper: Call `__get_pydantic_core_schema__` on `AfterValidator` instance
    Helper-&gt;&gt;SchemaGen: Generate schema for base type (`str`)
    SchemaGen--&gt;&gt;Helper: Return base `str` schema
    Helper-&gt;&gt;Helper: Modify schema, adding 'after_validator' pointing to `check_no_spaces`
    Helper--&gt;&gt;SchemaGen: Return modified schema for 'username'
    SchemaGen-&gt;&gt;Core: Finalize schema for `User` model incorporating custom logic
    Core--&gt;&gt;SchemaGen: Provide completed Core Schema
    SchemaGen--&gt;&gt;Meta: Return Core Schema
    Meta-&gt;&gt;Core: Request validator/serializer from final schema
    Core--&gt;&gt;Meta: Provide optimized functions
    Meta--&gt;&gt;Py: Return the fully prepared `User` class
    Py--&gt;&gt;Dev: `User` class is ready
</code></pre>

<p><strong>Code Location:</strong></p>
<ul>
  <li>Decorator logic (detection, storage, proxy): <code class="language-plaintext highlighter-rouge">pydantic._internal._decorators.py</code></li>
  <li><code class="language-plaintext highlighter-rouge">Annotated</code> helper classes (<code class="language-plaintext highlighter-rouge">AfterValidator</code>, <code class="language-plaintext highlighter-rouge">PlainSerializer</code>, etc.): <code class="language-plaintext highlighter-rouge">pydantic.functional_validators.py</code>, <code class="language-plaintext highlighter-rouge">pydantic.functional_serializers.py</code></li>
  <li>Schema generation integrating these: Primarily involves internal schema builders calling <code class="language-plaintext highlighter-rouge">__get_pydantic_core_schema__</code> on annotated types/metadata, often orchestrated via <code class="language-plaintext highlighter-rouge">pydantic._internal._generate_schema.GenerateSchema</code>. The <code class="language-plaintext highlighter-rouge">GetCoreSchemaHandler</code> from <code class="language-plaintext highlighter-rouge">pydantic.annotated_handlers.py</code> is passed around to facilitate this.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified concept from pydantic.functional_validators.py
</span>
<span class="o">@</span><span class="n">dataclasses</span><span class="p">.</span><span class="n">dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AfterValidator</span><span class="p">:</span>
    <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span> <span class="c1"># The user's validation function
</span>
    <span class="c1"># This method is called by Pydantic during schema building
</span>    <span class="k">def</span> <span class="nf">__get_pydantic_core_schema__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">source_type</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="c1"># The base type (e.g., str)
</span>        <span class="n">handler</span><span class="p">:</span> <span class="n">GetCoreSchemaHandler</span> <span class="c1"># Helper to get schema for base type
</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">core_schema</span><span class="p">.</span><span class="n">CoreSchema</span><span class="p">:</span>
        <span class="c1"># 1. Get the schema for the base type (e.g., str_schema())
</span>        <span class="n">schema</span> <span class="o">=</span> <span class="n">handler</span><span class="p">(</span><span class="n">source_type</span><span class="p">)</span>
        <span class="c1"># 2. Wrap it with an 'after_validator' step using self.func
</span>        <span class="n">info_arg</span> <span class="o">=</span> <span class="n">_inspect_validator</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">func</span><span class="p">,</span> <span class="s">'after'</span><span class="p">)</span> <span class="c1"># Check signature
</span>        <span class="k">if</span> <span class="n">info_arg</span><span class="p">:</span>
            <span class="c1"># Use core_schema function for validators with info arg
</span>            <span class="k">return</span> <span class="n">core_schema</span><span class="p">.</span><span class="n">with_info_after_validator_function</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">func</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Use core_schema function for validators without info arg
</span>            <span class="k">return</span> <span class="n">core_schema</span><span class="p">.</span><span class="n">no_info_after_validator_function</span><span class="p">(</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">func</span><span class="p">,</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span>
            <span class="p">)</span>

<span class="c1"># Simplified concept from pydantic._internal._decorators.py
</span>
<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">FieldValidatorDecoratorInfo</span><span class="p">:</span> <span class="c1"># Stores info about @field_validator
</span>    <span class="n">fields</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="p">...]</span>
    <span class="n">mode</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s">'before'</span><span class="p">,</span> <span class="s">'after'</span><span class="p">,</span> <span class="s">'wrap'</span><span class="p">,</span> <span class="s">'plain'</span><span class="p">]</span>
    <span class="c1"># ... other options
</span>
<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">PydanticDescriptorProxy</span><span class="p">:</span> <span class="c1"># Wraps the decorated method
</span>    <span class="n">wrapped</span><span class="p">:</span> <span class="n">Callable</span>
    <span class="n">decorator_info</span><span class="p">:</span> <span class="n">FieldValidatorDecoratorInfo</span> <span class="o">|</span> <span class="p">...</span> <span class="c1"># Stores the info object
</span>
<span class="c1"># Simplified concept from ModelMetaclass during class creation
</span>
<span class="c1"># ... scan class attributes ...
</span><span class="n">decorators</span> <span class="o">=</span> <span class="n">DecoratorInfos</span><span class="p">()</span> <span class="c1"># Object to hold all found decorators
</span><span class="k">for</span> <span class="n">var_name</span><span class="p">,</span> <span class="n">var_value</span> <span class="ow">in</span> <span class="nb">vars</span><span class="p">(</span><span class="n">model_cls</span><span class="p">).</span><span class="n">items</span><span class="p">():</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var_value</span><span class="p">,</span> <span class="n">PydanticDescriptorProxy</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">var_value</span><span class="p">.</span><span class="n">decorator_info</span>
        <span class="c1"># Store the decorator info (function, fields, mode, etc.)
</span>        <span class="c1"># in the appropriate category within 'decorators' object
</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">FieldValidatorDecoratorInfo</span><span class="p">):</span>
            <span class="n">decorators</span><span class="p">.</span><span class="n">field_validators</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Decorator</span><span class="p">(</span>
                <span class="n">func</span><span class="o">=</span><span class="n">var_value</span><span class="p">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">info</span><span class="o">=</span><span class="n">info</span> <span class="c1"># Simplified
</span>            <span class="p">)</span>
        <span class="c1"># ... handle other decorator types ...
</span>
<span class="c1"># ... later, when building the core schema ...
# schema_generator uses the 'decorators' object to add validation/serialization
# steps to the core schema based on the stored decorator info.
</span></code></pre></div></div>

<p>Both decorators and <code class="language-plaintext highlighter-rouge">Annotated</code> helpers ultimately achieve the same goal: embedding custom Python functions into the Pydantic validation and serialization pipeline by modifying the underlying <a href="05_core_schema___validation_serialization.md">Core Schema</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve learned two powerful ways to add custom logic to your Pydantic models:</p>

<ul>
  <li><strong>Decorators</strong> (<code class="language-plaintext highlighter-rouge">@field_validator</code>, <code class="language-plaintext highlighter-rouge">@model_validator</code>, <code class="language-plaintext highlighter-rouge">@field_serializer</code>, <code class="language-plaintext highlighter-rouge">@model_serializer</code>) allow you to designate methods within your model class for custom validation or serialization tasks, applying logic to specific fields or the entire model.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Annotated</code> Helpers</strong> (<code class="language-plaintext highlighter-rouge">BeforeValidator</code>, <code class="language-plaintext highlighter-rouge">AfterValidator</code>, <code class="language-plaintext highlighter-rouge">PlainSerializer</code>, etc.) let you attach validation or serialization functions directly to a field’s type hint using <code class="language-plaintext highlighter-rouge">typing.Annotated</code>, often promoting reusable logic functions.</li>
</ul>

<p>These tools give you fine-grained control over how your data is processed, going beyond basic type checks and configuration. They are essential for handling real-world data validation and formatting complexities.</p>

<p>Understanding how these mechanisms work often involves looking at the internal representation Pydantic uses: the Core Schema. In the next chapter, we’ll delve into what this schema looks like and how Pydantic uses it.</p>

<p>Next: <a href="05_core_schema___validation_serialization.md">Chapter 5: Core Schema &amp; Validation/Serialization</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
