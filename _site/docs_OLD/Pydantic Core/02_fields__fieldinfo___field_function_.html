<h1 id="chapter-2-customizing-your-blueprints-rooms---fields">Chapter 2: Customizing Your Blueprint’s Rooms - Fields</h1>

<p>In <a href="01_basemodel.md">Chapter 1: BaseModel - Your Data Blueprint</a>, we learned how <code class="language-plaintext highlighter-rouge">BaseModel</code> acts like a blueprint for our data, defining the expected structure and types using simple Python type hints. We saw how Pydantic uses this blueprint to parse, validate, and serialize data.</p>

<p>But what if we need more specific instructions for certain parts of our blueprint? What if a room needs a specific paint color (a default value)? Or what if the blueprint uses one name for a room (“Lounge”), but the construction crew knows it by another name (“Living Room”) (an alias)?</p>

<p>This is where Pydantic’s <strong>Fields</strong> come in. They allow us to add these extra details and constraints to the attributes within our models.</p>

<h2 id="why-customize-fields">Why Customize Fields?</h2>

<p>Let’s go back to our <code class="language-plaintext highlighter-rouge">User</code> model:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">age</span><span class="p">:</span> <span class="nb">int</span>
</code></pre></div></div>

<p>This is great, but real-world data often has quirks:</p>

<ol>
  <li><strong>Missing Data:</strong> What if <code class="language-plaintext highlighter-rouge">age</code> isn’t always provided? Should it default to something sensible, like <code class="language-plaintext highlighter-rouge">18</code>?</li>
  <li><strong>Naming Conflicts:</strong> What if the incoming data (e.g., JSON from a JavaScript frontend) uses <code class="language-plaintext highlighter-rouge">userName</code> instead of <code class="language-plaintext highlighter-rouge">name</code> (camelCase vs. snake_case)?</li>
  <li><strong>Basic Rules:</strong> What if we know <code class="language-plaintext highlighter-rouge">age</code> must always be a positive number?</li>
</ol>

<p>Simply using type hints (<code class="language-plaintext highlighter-rouge">str</code>, <code class="language-plaintext highlighter-rouge">int</code>) doesn’t cover these cases. We need a way to add more <em>metadata</em> (extra information) to our fields.</p>

<h2 id="introducing-field-adding-notes-to-the-blueprint">Introducing <code class="language-plaintext highlighter-rouge">Field()</code>: Adding Notes to the Blueprint</h2>

<p>Pydantic provides the <code class="language-plaintext highlighter-rouge">Field()</code> function precisely for this purpose. You use it as the <em>default value</em> when defining an attribute on your model, and pass arguments to it to specify the extra details.</p>

<p>Think of it like adding specific notes or requirements to a room on your building blueprint.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Import Field along with BaseModel
</span><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span>

<span class="c1"># Our User model, now with customizations using Field()
</span><span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="s">'Guest'</span><span class="p">,</span>       <span class="c1"># Note 1: Default name is 'Guest'
</span>        <span class="n">alias</span><span class="o">=</span><span class="s">'userName'</span><span class="p">,</span>      <span class="c1"># Note 2: Expect 'userName' in input data
</span>        <span class="n">min_length</span><span class="o">=</span><span class="mi">3</span>           <span class="c1"># Note 3: Name must be at least 3 characters
</span>    <span class="p">)</span>
    <span class="n">age</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="mi">18</span><span class="p">,</span>            <span class="c1"># Note 1: Default age is 18
</span>        <span class="n">gt</span><span class="o">=</span><span class="mi">0</span>                   <span class="c1"># Note 2: Age must be greater than 0
</span>    <span class="p">)</span>
    <span class="n">email</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>          <span class="c1"># Note 3: Email is optional (defaults to None)
</span>        <span class="n">description</span><span class="o">=</span><span class="s">'The user email address'</span> <span class="c1"># Note 4: Add a description
</span>    <span class="p">)</span>
</code></pre></div></div>

<p>Let’s break down how we use <code class="language-plaintext highlighter-rouge">Field()</code>:</p>

<ol>
  <li><strong>Import:</strong> You need to import <code class="language-plaintext highlighter-rouge">Field</code> from <code class="language-plaintext highlighter-rouge">pydantic</code>.</li>
  <li><strong>Assignment:</strong> Instead of just <code class="language-plaintext highlighter-rouge">name: str</code>, you write <code class="language-plaintext highlighter-rouge">name: str = Field(...)</code>. The <code class="language-plaintext highlighter-rouge">Field()</code> call replaces a simple default value (though <code class="language-plaintext highlighter-rouge">Field()</code> <em>can</em> specify a default).</li>
  <li><strong>Arguments:</strong> You pass keyword arguments to <code class="language-plaintext highlighter-rouge">Field()</code> to specify the metadata:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">default</code>: Sets a default value if the field isn’t provided in the input data. If you <em>only</em> need a default, you can often just write <code class="language-plaintext highlighter-rouge">name: str = 'Guest'</code> or <code class="language-plaintext highlighter-rouge">age: int = 18</code>, but <code class="language-plaintext highlighter-rouge">Field(default=...)</code> is useful when combined with other options. Use <code class="language-plaintext highlighter-rouge">...</code> (Ellipsis) or omit <code class="language-plaintext highlighter-rouge">default</code> entirely to mark a field as required.</li>
      <li><code class="language-plaintext highlighter-rouge">alias</code>: Tells Pydantic to look for this name (<code class="language-plaintext highlighter-rouge">'userName'</code>) in the input data (like a dictionary or JSON) when parsing, and use this alias when serializing (e.g., in <code class="language-plaintext highlighter-rouge">model_dump(by_alias=True)</code>).</li>
      <li><code class="language-plaintext highlighter-rouge">gt</code> (greater than), <code class="language-plaintext highlighter-rouge">ge</code> (greater than or equal), <code class="language-plaintext highlighter-rouge">lt</code> (less than), <code class="language-plaintext highlighter-rouge">le</code> (less than or equal): Basic numeric constraints.</li>
      <li><code class="language-plaintext highlighter-rouge">min_length</code>, <code class="language-plaintext highlighter-rouge">max_length</code>: Constraints for strings, lists, etc.</li>
      <li><code class="language-plaintext highlighter-rouge">description</code>: A human-readable description, often used for generating documentation or schemas.</li>
      <li>…and many more!</li>
    </ul>
  </li>
</ol>

<h2 id="using-models-with-field">Using Models with <code class="language-plaintext highlighter-rouge">Field()</code></h2>

<p>Let’s see how our customized <code class="language-plaintext highlighter-rouge">User</code> model behaves:</p>

<p><strong>1. Using Defaults:</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span>

<span class="k">class</span> <span class="nc">User</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s">'Guest'</span><span class="p">,</span> <span class="n">alias</span><span class="o">=</span><span class="s">'userName'</span><span class="p">,</span> <span class="n">min_length</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">age</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">18</span><span class="p">,</span> <span class="n">gt</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">email</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s">'The user email address'</span><span class="p">)</span>

<span class="c1"># Input data missing name and age
</span><span class="n">input_data_1</span> <span class="o">=</span> <span class="p">{</span><span class="s">'email'</span><span class="p">:</span> <span class="s">'new@example.com'</span><span class="p">}</span>

<span class="c1"># Pydantic uses the defaults!
</span><span class="n">user1</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="o">**</span><span class="n">input_data_1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">user1</span><span class="p">)</span>
<span class="c1"># Expected Output: name='Guest' age=18 email='new@example.com'
</span></code></pre></div></div>

<p>Pydantic automatically filled in <code class="language-plaintext highlighter-rouge">name</code> and <code class="language-plaintext highlighter-rouge">age</code> using the <code class="language-plaintext highlighter-rouge">default</code> values we specified in <code class="language-plaintext highlighter-rouge">Field()</code>.</p>

<p><strong>2. Using Aliases:</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Continuing from above...
</span>
<span class="c1"># Input data using the alias 'userName'
</span><span class="n">input_data_2</span> <span class="o">=</span> <span class="p">{</span><span class="s">'userName'</span><span class="p">:</span> <span class="s">'Alice'</span><span class="p">,</span> <span class="s">'age'</span><span class="p">:</span> <span class="mi">30</span><span class="p">}</span>

<span class="c1"># Pydantic correctly uses the alias to populate 'name'
</span><span class="n">user2</span> <span class="o">=</span> <span class="n">User</span><span class="p">(</span><span class="o">**</span><span class="n">input_data_2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">user2</span><span class="p">)</span>
<span class="c1"># Expected Output: name='Alice' age=30 email=None
</span>
<span class="c1"># Dumping the model back, using the alias
</span><span class="k">print</span><span class="p">(</span><span class="n">user2</span><span class="p">.</span><span class="n">model_dump</span><span class="p">(</span><span class="n">by_alias</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="c1"># Expected Output: {'userName': 'Alice', 'age': 30, 'email': None}
</span>
<span class="c1"># Dumping without by_alias uses the actual field names
</span><span class="k">print</span><span class="p">(</span><span class="n">user2</span><span class="p">.</span><span class="n">model_dump</span><span class="p">())</span>
<span class="c1"># Expected Output: {'name': 'Alice', 'age': 30, 'email': None}
</span></code></pre></div></div>

<p>Pydantic successfully read the <code class="language-plaintext highlighter-rouge">userName</code> key from the input thanks to <code class="language-plaintext highlighter-rouge">alias='userName'</code>. When dumping <em>with</em> <code class="language-plaintext highlighter-rouge">by_alias=True</code>, it uses the alias again.</p>

<p><strong>3. Using Validation Constraints:</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Continuing from above...
</span><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">ValidationError</span>

<span class="c1"># Input data with invalid values
</span><span class="n">invalid_data_1</span> <span class="o">=</span> <span class="p">{</span><span class="s">'userName'</span><span class="p">:</span> <span class="s">'Bo'</span><span class="p">,</span> <span class="s">'age'</span><span class="p">:</span> <span class="mi">30</span><span class="p">}</span> <span class="c1"># Name too short
</span><span class="n">invalid_data_2</span> <span class="o">=</span> <span class="p">{</span><span class="s">'userName'</span><span class="p">:</span> <span class="s">'Charlie'</span><span class="p">,</span> <span class="s">'age'</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="p">}</span> <span class="c1"># Age not &gt; 0
</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">User</span><span class="p">(</span><span class="o">**</span><span class="n">invalid_data_1</span><span class="p">)</span>
<span class="k">except</span> <span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Error 1:</span><span class="se">\n</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="s">"""
    Expected Output (simplified):
    Error 1:
    1 validation error for User
    name
      String should have at least 3 characters [type=string_too_short, context={'min_length': 3}, ...]
    """</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">User</span><span class="p">(</span><span class="o">**</span><span class="n">invalid_data_2</span><span class="p">)</span>
<span class="k">except</span> <span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Error 2:</span><span class="se">\n</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="s">"""
    Expected Output (simplified):
    Error 2:
    1 validation error for User
    age
      Input should be greater than 0 [type=greater_than, context={'gt': 0}, ...]
    """</span>
</code></pre></div></div>

<p>Pydantic enforced the <code class="language-plaintext highlighter-rouge">min_length=3</code> and <code class="language-plaintext highlighter-rouge">gt=0</code> constraints we added via <code class="language-plaintext highlighter-rouge">Field()</code>, giving helpful errors when the rules were violated.</p>

<h2 id="what-is-fieldinfo-the-architects-specification">What is <code class="language-plaintext highlighter-rouge">FieldInfo</code>? The Architect’s Specification</h2>

<p>So, you use the <code class="language-plaintext highlighter-rouge">Field()</code> function to add notes to your blueprint. But how does Pydantic <em>store</em> and <em>use</em> this information internally?</p>

<p>When Pydantic processes your model definition, it takes the information you provided in <code class="language-plaintext highlighter-rouge">Field()</code> (and the type hint) and bundles it all up into an internal object called <code class="language-plaintext highlighter-rouge">FieldInfo</code>.</p>

<p><strong>Analogy:</strong> <code class="language-plaintext highlighter-rouge">Field()</code> is the sticky note you put on the blueprint (“Living Room - Must have fireplace”). <code class="language-plaintext highlighter-rouge">FieldInfo</code> is the formal entry in the architect’s detailed specification document that captures this requirement along with the room’s dimensions (type hint), default paint color (default value), etc.</p>

<p>You don’t usually create <code class="language-plaintext highlighter-rouge">FieldInfo</code> objects directly. You use the convenient <code class="language-plaintext highlighter-rouge">Field()</code> function, and Pydantic creates the <code class="language-plaintext highlighter-rouge">FieldInfo</code> for you.</p>

<p>Every Pydantic model has a special attribute called <code class="language-plaintext highlighter-rouge">model_fields</code> which is a dictionary mapping field names to their corresponding <code class="language-plaintext highlighter-rouge">FieldInfo</code> objects.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Continuing from the User model above
</span>
<span class="c1"># Access the internal FieldInfo objects
</span><span class="k">print</span><span class="p">(</span><span class="n">User</span><span class="p">.</span><span class="n">model_fields</span><span class="p">[</span><span class="s">'name'</span><span class="p">])</span>
<span class="c1"># Expected Output (representation may vary slightly):
# FieldInfo(annotation=str, required=False, default='Guest', alias='userName', alias_priority=2, validation_alias='userName', serialization_alias='userName', metadata=[MinLen(min_length=3)])
</span>
<span class="k">print</span><span class="p">(</span><span class="n">User</span><span class="p">.</span><span class="n">model_fields</span><span class="p">[</span><span class="s">'age'</span><span class="p">])</span>
<span class="c1"># Expected Output:
# FieldInfo(annotation=int, required=False, default=18, metadata=[Gt(gt=0)])
</span>
<span class="k">print</span><span class="p">(</span><span class="n">User</span><span class="p">.</span><span class="n">model_fields</span><span class="p">[</span><span class="s">'email'</span><span class="p">])</span>
<span class="c1"># Expected Output:
# FieldInfo(annotation=Union[str, NoneType], required=False, default=None, description='The user email address')
</span></code></pre></div></div>

<p>You can see how the <code class="language-plaintext highlighter-rouge">FieldInfo</code> object holds all the details: the <code class="language-plaintext highlighter-rouge">annotation</code> (type), <code class="language-plaintext highlighter-rouge">default</code>, <code class="language-plaintext highlighter-rouge">alias</code>, <code class="language-plaintext highlighter-rouge">description</code>, and even the constraints like <code class="language-plaintext highlighter-rouge">MinLen(min_length=3)</code> and <code class="language-plaintext highlighter-rouge">Gt(gt=0)</code> stored in its <code class="language-plaintext highlighter-rouge">metadata</code> attribute.</p>

<h2 id="under-the-hood-from-field-to-fieldinfo">Under the Hood: From <code class="language-plaintext highlighter-rouge">Field()</code> to <code class="language-plaintext highlighter-rouge">FieldInfo</code></h2>

<p>Let’s revisit the model creation process from Chapter 1, now including <code class="language-plaintext highlighter-rouge">Field()</code>.</p>

<p><strong>High-Level Steps:</strong></p>

<p>When Python creates your <code class="language-plaintext highlighter-rouge">User</code> class:</p>

<ol>
  <li><strong>Inspection:</strong> Pydantic’s <code class="language-plaintext highlighter-rouge">ModelMetaclass</code> inspects the class definition. It finds <code class="language-plaintext highlighter-rouge">name: str = Field(alias='userName', ...)</code>, <code class="language-plaintext highlighter-rouge">age: int = Field(default=18, ...)</code>, etc.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">FieldInfo</code> Creation:</strong> For each attribute defined with <code class="language-plaintext highlighter-rouge">Field()</code>, Pydantic calls internal logic (like <code class="language-plaintext highlighter-rouge">FieldInfo.from_annotated_attribute</code>) using the type hint (<code class="language-plaintext highlighter-rouge">str</code>, <code class="language-plaintext highlighter-rouge">int</code>) and the result of the <code class="language-plaintext highlighter-rouge">Field(...)</code> call. This creates the <code class="language-plaintext highlighter-rouge">FieldInfo</code> object containing all the configuration (type, default, alias, constraints, etc.).</li>
  <li><strong>Storage:</strong> These <code class="language-plaintext highlighter-rouge">FieldInfo</code> objects are stored in an internal dictionary, which becomes accessible via <code class="language-plaintext highlighter-rouge">YourModel.model_fields</code>.</li>
  <li><strong>Schema Generation:</strong> Pydantic uses these comprehensive <code class="language-plaintext highlighter-rouge">FieldInfo</code> objects (along with model-level <a href="03_configuration__configdict___configwrapper_.md">Configuration</a>) to generate the internal <a href="05_core_schema___validation_serialization.md">Core Schema</a>. This schema is the detailed instruction set for the fast validation and serialization engine.</li>
</ol>

<p><strong>Sequence Diagram:</strong></p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Dev as Developer
    participant Py as Python
    participant Meta as ModelMetaclass
    participant FInfo as FieldInfo

    Dev-&gt;&gt;Py: Define `class User(BaseModel): name: str = Field(alias='userName')`
    Py-&gt;&gt;Meta: Ask to create the `User` class
    Meta-&gt;&gt;Meta: Inspect `name` attribute: finds `str` and `Field(alias='userName')` assignment
    Meta-&gt;&gt;FInfo: Create `FieldInfo` using `str` and the `Field()` arguments
    FInfo--&gt;&gt;Meta: Return `FieldInfo(annotation=str, alias='userName', default=PydanticUndefined, ...)`
    Meta-&gt;&gt;Meta: Store this `FieldInfo` instance in `cls.__pydantic_fields__['name']`
    Meta-&gt;&gt;Meta: (Repeat for other fields like 'age', 'email')
    Meta--&gt;&gt;Py: Return the fully prepared `User` class (with `model_fields` populated)
    Py--&gt;&gt;Dev: `User` class is ready
</code></pre>

<p><strong>Code Location:</strong></p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">Field()</code> function itself is defined in <code class="language-plaintext highlighter-rouge">pydantic/fields.py</code>. It’s a relatively simple function that just captures its arguments and returns a <code class="language-plaintext highlighter-rouge">FieldInfo</code> instance.</li>
  <li>The <code class="language-plaintext highlighter-rouge">FieldInfo</code> class is also defined in <code class="language-plaintext highlighter-rouge">pydantic/fields.py</code>. It holds attributes like <code class="language-plaintext highlighter-rouge">annotation</code>, <code class="language-plaintext highlighter-rouge">default</code>, <code class="language-plaintext highlighter-rouge">alias</code>, <code class="language-plaintext highlighter-rouge">metadata</code>, etc.</li>
  <li>The logic that finds fields in a class definition, handles the <code class="language-plaintext highlighter-rouge">Field()</code> assignments, and creates the <code class="language-plaintext highlighter-rouge">FieldInfo</code> objects primarily happens within the <code class="language-plaintext highlighter-rouge">collect_model_fields</code> function (in <code class="language-plaintext highlighter-rouge">pydantic._internal._fields.py</code>), which is called by the <code class="language-plaintext highlighter-rouge">ModelMetaclass</code> (in <code class="language-plaintext highlighter-rouge">pydantic._internal._model_construction.py</code>) during class creation.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified view from pydantic/fields.py
</span>
<span class="c1"># The user-facing function
</span><span class="k">def</span> <span class="nf">Field</span><span class="p">(</span>
    <span class="n">default</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">PydanticUndefined</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">alias</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="n">_Unset</span><span class="p">,</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="n">_Unset</span><span class="p">,</span>
    <span class="n">gt</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="n">_Unset</span><span class="p">,</span>
    <span class="c1"># ... many other arguments
</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span> <span class="c1"># Returns Any for type checker convenience
</span>    <span class="c1"># It captures all arguments and passes them to create a FieldInfo instance
</span>    <span class="n">field_info</span> <span class="o">=</span> <span class="n">FieldInfo</span><span class="p">.</span><span class="n">from_field</span><span class="p">(</span>
        <span class="n">default</span><span class="p">,</span>
        <span class="n">alias</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span>
        <span class="n">gt</span><span class="o">=</span><span class="n">gt</span><span class="p">,</span>
        <span class="c1"># ... passing all arguments through
</span>    <span class="p">)</span>
    <span class="k">return</span> <span class="n">field_info</span> <span class="c1"># Actually returns a FieldInfo instance at runtime
</span>
<span class="c1"># The internal storage class
</span><span class="k">class</span> <span class="nc">FieldInfo</span><span class="p">:</span>
    <span class="c1"># Attributes to store all the configuration
</span>    <span class="n">annotation</span><span class="p">:</span> <span class="nb">type</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span>
    <span class="n">default</span><span class="p">:</span> <span class="n">Any</span>
    <span class="n">alias</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="c1"># Stores constraints like Gt, MinLen, etc.
</span>    <span class="c1"># ... other attributes
</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Simplified: Assigns kwargs to attributes
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">annotation</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'annotation'</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'default'</span><span class="p">,</span> <span class="n">PydanticUndefined</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">alias</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'alias'</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'description'</span><span class="p">)</span>
        <span class="c1"># ... and collects constraints into self.metadata
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_collect_metadata</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="o">@</span><span class="nb">staticmethod</span>
    <span class="k">def</span> <span class="nf">from_field</span><span class="p">(</span><span class="n">default</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">PydanticUndefined</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s">'FieldInfo'</span><span class="p">:</span>
        <span class="c1"># Creates an instance, handling the default value logic
</span>        <span class="c1"># ... implementation ...
</span>        <span class="k">return</span> <span class="n">FieldInfo</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_collect_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Any</span><span class="p">]:</span>
        <span class="c1"># Simplified: Takes kwargs like 'gt=0' and converts them
</span>        <span class="c1"># to internal metadata objects like 'annotated_types.Gt(0)'
</span>        <span class="n">metadata</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s">'gt'</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
             <span class="c1"># metadata.append(annotated_types.Gt(kwargs.pop('gt'))) # Real code is more complex
</span>             <span class="k">pass</span> <span class="c1"># Simplified
</span>        <span class="c1"># ... handles other constraint kwargs ...
</span>        <span class="k">return</span> <span class="n">metadata</span>

<span class="c1"># --- Simplified view from pydantic._internal._fields.py ---
</span>
<span class="k">def</span> <span class="nf">collect_model_fields</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">config_wrapper</span><span class="p">,</span> <span class="n">ns_resolver</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">typevars_map</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">fields</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">FieldInfo</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">type_hints</span> <span class="o">=</span> <span class="n">get_model_type_hints</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">ns_resolver</span><span class="o">=</span><span class="n">ns_resolver</span><span class="p">)</span> <span class="c1"># Get {'name': str, 'age': int, ...}
</span>
    <span class="k">for</span> <span class="n">ann_name</span><span class="p">,</span> <span class="p">(</span><span class="n">ann_type</span><span class="p">,</span> <span class="n">evaluated</span><span class="p">)</span> <span class="ow">in</span> <span class="n">type_hints</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">is_valid_field_name</span><span class="p">(</span><span class="n">ann_name</span><span class="p">):</span>
            <span class="n">assigned_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">ann_name</span><span class="p">,</span> <span class="n">PydanticUndefined</span><span class="p">)</span> <span class="c1"># Check if Field() was used
</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">assigned_value</span><span class="p">,</span> <span class="n">FieldInfo</span><span class="p">):</span> <span class="c1"># If name = Field(...) was used
</span>                <span class="c1"># Create FieldInfo using the type hint AND the assigned FieldInfo object
</span>                <span class="n">field_info</span> <span class="o">=</span> <span class="n">FieldInfo</span><span class="p">.</span><span class="n">from_annotated_attribute</span><span class="p">(</span><span class="n">ann_type</span><span class="p">,</span> <span class="n">assigned_value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">assigned_value</span> <span class="ow">is</span> <span class="n">PydanticUndefined</span><span class="p">:</span> <span class="c1"># If only name: str was used
</span>                <span class="c1"># Create FieldInfo just from the type hint
</span>                <span class="n">field_info</span> <span class="o">=</span> <span class="n">FieldInfo</span><span class="p">.</span><span class="n">from_annotation</span><span class="p">(</span><span class="n">ann_type</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span> <span class="c1"># If name: str = 'some_default' was used
</span>                <span class="c1"># Create FieldInfo from type hint and simple default
</span>                <span class="n">field_info</span> <span class="o">=</span> <span class="n">FieldInfo</span><span class="p">.</span><span class="n">from_annotated_attribute</span><span class="p">(</span><span class="n">ann_type</span><span class="p">,</span> <span class="n">assigned_value</span><span class="p">)</span>

            <span class="n">fields</span><span class="p">[</span><span class="n">ann_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">field_info</span>
            <span class="c1"># ... more logic for inheritance, docstrings, etc. ...
</span>
    <span class="k">return</span> <span class="n">fields</span><span class="p">,</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># Returns dict of field names to FieldInfo objects
</span>
</code></pre></div></div>

<p>This process ensures that all the configuration you provide via <code class="language-plaintext highlighter-rouge">Field()</code> is captured systematically in <code class="language-plaintext highlighter-rouge">FieldInfo</code> objects, ready to be used for generating the validation/serialization schema.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve now learned how to add detailed configuration to your <code class="language-plaintext highlighter-rouge">BaseModel</code> fields using the <code class="language-plaintext highlighter-rouge">Field()</code> function:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Field()</code> allows you to specify <strong>defaults</strong>, <strong>aliases</strong>, basic <strong>validation constraints</strong> (like <code class="language-plaintext highlighter-rouge">gt</code>, <code class="language-plaintext highlighter-rouge">max_length</code>), <strong>descriptions</strong>, and more.</li>
  <li>It acts like adding specific <strong>notes or requirements</strong> to the rooms in your data blueprint.</li>
  <li>Internally, Pydantic captures this information in <code class="language-plaintext highlighter-rouge">FieldInfo</code> objects.</li>
  <li><code class="language-plaintext highlighter-rouge">FieldInfo</code> holds the complete specification for a field (type, default, alias, constraints, etc.) and is stored in the model’s <code class="language-plaintext highlighter-rouge">model_fields</code> attribute.</li>
  <li>This detailed <code class="language-plaintext highlighter-rouge">FieldInfo</code> is crucial for Pydantic’s powerful validation and serialization capabilities.</li>
</ul>

<p>You now have more control over individual fields. But what about configuring the overall behavior of the <em>entire</em> model? For example, how can we tell Pydantic to <em>always</em> use aliases when serializing, or to forbid extra fields not defined in the model? That’s where model configuration comes in.</p>

<p>Next: <a href="03_configuration__configdict___configwrapper_.md">Chapter 3: Configuration (ConfigDict / ConfigWrapper)</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
