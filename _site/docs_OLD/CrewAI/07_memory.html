<h1 id="chapter-7-memory---giving-your-crew-recall">Chapter 7: Memory - Giving Your Crew Recall</h1>

<p>In the <a href="06_llm.md">previous chapter</a>, we looked at the Large Language Model (<a href="06_llm.md">LLM</a>) – the “brain” that allows each <a href="02_agent.md">Agent</a> to understand, reason, and generate text. Now we have agents that can think, perform <a href="03_task.md">Task</a>s using <a href="04_tool.md">Tool</a>s, and follow a <a href="05_process.md">Process</a>.</p>

<p>But imagine a team working on a complex project over several days. What if every morning, they completely forgot everything they discussed and learned the previous day? They’d waste a lot of time repeating work and asking the same questions. By default, AI agents often behave like this – they only remember the immediate conversation.</p>

<p>How can we give our CrewAI team the ability to remember past information? That’s where <strong>Memory</strong> comes in!</p>

<h2 id="why-do-we-need-memory">Why Do We Need Memory?</h2>

<p>AI Agents, especially when working together in a <a href="01_crew.md">Crew</a>, often need to build upon previous interactions or knowledge gained during their work. Without memory:</p>

<ul>
  <li>An agent might ask for the same information multiple times.</li>
  <li>Context from an earlier task might be lost by the time a later task runs.</li>
  <li>The crew can’t easily learn from past experiences across different projects or runs.</li>
  <li>Tracking specific details about key people, places, or concepts mentioned during the process becomes difficult.</li>
</ul>

<p><strong>Problem Solved:</strong> Memory provides <a href="02_agent.md">Agent</a>s and the <a href="01_crew.md">Crew</a> with the ability to store and recall past interactions, information, and insights. It’s like giving your AI team shared notes, a collective memory, or institutional knowledge.</p>

<h2 id="what-is-memory-in-crewai">What is Memory in CrewAI?</h2>

<p>Think of Memory as the <strong>storage system</strong> for your Crew’s experiences and knowledge. It allows the Crew to persist information beyond a single interaction or task execution. CrewAI implements different kinds of memory to handle different needs:</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">ShortTermMemory</code></strong>:
    <ul>
      <li><strong>Analogy:</strong> Like your computer’s RAM or a person’s short-term working memory.</li>
      <li><strong>Purpose:</strong> Holds immediate context and information relevant <em>within the current run</em> of the Crew. What happened in the previous task? What was just discussed?</li>
      <li><strong>How it helps:</strong> Ensures that the output of one task is available and easily accessible as context for the next task within the same <code class="language-plaintext highlighter-rouge">kickoff()</code> execution. It helps maintain the flow of conversation and information <em>during</em> a single job.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">LongTermMemory</code></strong>:
    <ul>
      <li><strong>Analogy:</strong> Like a team’s documented “lessons learned” database or a long-term knowledge base.</li>
      <li><strong>Purpose:</strong> Stores insights, evaluations, and key takeaways <em>across multiple runs</em> of the Crew. Did a similar task succeed or fail in the past? What strategies worked well?</li>
      <li><strong>How it helps:</strong> Allows the Crew to improve over time by recalling past performance on similar tasks. (Note: Effective use often involves evaluating task outcomes, which can be an advanced topic).</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">EntityMemory</code></strong>:
    <ul>
      <li><strong>Analogy:</strong> Like a CRM (Customer Relationship Management) system, a character sheet in a game, or index cards about important topics.</li>
      <li><strong>Purpose:</strong> Tracks specific entities (like people, companies, projects, concepts) mentioned during the Crew’s execution and stores details and relationships about them. Who is “Dr. Evans”? What is “Project Phoenix”?</li>
      <li><strong>How it helps:</strong> Maintains consistency and detailed knowledge about key subjects, preventing the Crew from forgetting important details about who or what it’s dealing with.</li>
    </ul>
  </li>
</ol>

<h2 id="how-does-memory-help">How Does Memory Help?</h2>

<p>Using memory makes your Crew more effective:</p>

<ul>
  <li><strong>Better Context:</strong> Agents have access to relevant past information, leading to more informed decisions and responses.</li>
  <li><strong>Efficiency:</strong> Avoids redundant questions and re-work by recalling previously established facts or results.</li>
  <li><strong>Learning (LTM):</strong> Enables the Crew to get better over time based on past performance.</li>
  <li><strong>Consistency (Entity):</strong> Keeps track of important details about recurring topics or entities.</li>
  <li><strong>Shared Understanding:</strong> Helps create a common ground of knowledge for all agents in the Crew.</li>
</ul>

<h2 id="using-memory-in-your-crew">Using Memory in Your Crew</h2>

<p>The simplest way to start using memory is by enabling it when you define your <code class="language-plaintext highlighter-rouge">Crew</code>. Setting <code class="language-plaintext highlighter-rouge">memory=True</code> activates the core memory components (ShortTerm and Entity Memory) for context building within a run.</p>

<p>Let’s add memory to our trip planning <code class="language-plaintext highlighter-rouge">Crew</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Assuming 'researcher' and 'planner' agents are defined (Chapter 2)
# Assuming 'task1' and 'task2' are defined (Chapter 3)
# Assuming an LLM is configured (Chapter 6)
</span>
<span class="kn">from</span> <span class="nn">crewai</span> <span class="kn">import</span> <span class="n">Crew</span><span class="p">,</span> <span class="n">Process</span>

<span class="c1"># researcher = Agent(...)
# planner = Agent(...)
# task1 = Task(...)
# task2 = Task(...)
</span>
<span class="c1"># Define the crew WITH memory enabled
</span><span class="n">trip_crew_with_memory</span> <span class="o">=</span> <span class="n">Crew</span><span class="p">(</span>
  <span class="n">agents</span><span class="o">=</span><span class="p">[</span><span class="n">researcher</span><span class="p">,</span> <span class="n">planner</span><span class="p">],</span>
  <span class="n">tasks</span><span class="o">=</span><span class="p">[</span><span class="n">task1</span><span class="p">,</span> <span class="n">task2</span><span class="p">],</span>
  <span class="n">process</span><span class="o">=</span><span class="n">Process</span><span class="p">.</span><span class="n">sequential</span><span class="p">,</span>
  <span class="n">memory</span><span class="o">=</span><span class="bp">True</span>  <span class="c1"># &lt;-- Enable memory features!
</span>  <span class="c1"># verbose=2
</span><span class="p">)</span>

<span class="c1"># Start the work. Agents will now leverage memory.
# result = trip_crew_with_memory.kickoff()
# print(result)
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li>We simply add the <code class="language-plaintext highlighter-rouge">memory=True</code> parameter when creating the <code class="language-plaintext highlighter-rouge">Crew</code>.</li>
  <li><strong>What does this do?</strong> Behind the scenes, CrewAI initializes <code class="language-plaintext highlighter-rouge">ShortTermMemory</code> and <code class="language-plaintext highlighter-rouge">EntityMemory</code> for this crew.</li>
  <li><strong>How is it used?</strong>
    <ul>
      <li><strong>ShortTermMemory:</strong> As tasks complete within this <code class="language-plaintext highlighter-rouge">kickoff()</code> run, their outputs and key interactions can be stored. When the next task starts, CrewAI automatically queries this memory for relevant recent context to add to the prompt for the next agent. This makes the context flow smoother than just passing the raw output of the previous task.</li>
      <li><strong>EntityMemory:</strong> As agents discuss entities (e.g., “Lisbon,” “May birthday trip”), the memory tries to capture details about them. If “Lisbon” is mentioned again later, the memory can provide the stored details (“Coastal city, known for trams and Fado music…”) as context.</li>
    </ul>
  </li>
  <li><strong>LongTermMemory:</strong> While <code class="language-plaintext highlighter-rouge">memory=True</code> sets up the <em>potential</em> for LTM, actively using it to learn across multiple runs often requires additional steps like task evaluation or explicit saving mechanisms, which are more advanced topics beyond this basic introduction. For now, focus on the benefits of STM and Entity Memory for within-run context.</li>
</ul>

<p>By just adding <code class="language-plaintext highlighter-rouge">memory=True</code>, your agents automatically get better at remembering what’s going on <em>within the current job</em>.</p>

<h2 id="how-memory-works-internally-simplified">How Memory Works Internally (Simplified)</h2>

<p>So, what happens “under the hood” when <code class="language-plaintext highlighter-rouge">memory=True</code> and an agent starts a task?</p>

<ol>
  <li><strong>Task Execution Start:</strong> The <a href="01_crew.md">Crew</a> assigns a <a href="03_task.md">Task</a> to an <a href="02_agent.md">Agent</a>.</li>
  <li><strong>Context Gathering:</strong> Before calling the <a href="06_llm.md">LLM</a>, the Crew interacts with its <strong>Memory Module</strong> (specifically, the <code class="language-plaintext highlighter-rouge">ContextualMemory</code> orchestrator). It asks, “What relevant memories do we have for this task, considering the description and any immediate context?”</li>
  <li><strong>Memory Module Queries:</strong> The <code class="language-plaintext highlighter-rouge">ContextualMemory</code> then queries the different active memory types:
    <ul>
      <li>It asks <code class="language-plaintext highlighter-rouge">ShortTermMemory</code>: “Show me recent interactions or results related to this query.” (Uses RAG/vector search on recent data).</li>
      <li>It asks <code class="language-plaintext highlighter-rouge">EntityMemory</code>: “Tell me about entities mentioned in this query.” (Uses RAG/vector search on stored entity data).</li>
      <li><em>If LTM were being actively queried (less common automatically):</em> “Any long-term insights related to this type of task?” (Usually queries a database like SQLite).</li>
    </ul>
  </li>
  <li><strong>Context Consolidation:</strong> The Memory Module gathers the relevant snippets from each memory type.</li>
  <li><strong>Prompt Augmentation:</strong> This retrieved memory context is combined with the original task description, expected output, and any direct context (like the previous task’s raw output).</li>
  <li><strong>LLM Call:</strong> This augmented, richer prompt is sent to the agent’s <a href="06_llm.md">LLM</a>.</li>
  <li><strong>Agent Response:</strong> The agent generates its response, now informed by the retrieved memories.</li>
  <li><strong>Memory Update:</strong> As the task completes, its key interactions and outputs are processed and potentially saved back into ShortTermMemory and EntityMemory for future use within this run.</li>
</ol>

<p>Let’s visualize this context-building flow:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant C as Crew
    participant A as Agent
    participant CtxMem as ContextualMemory
    participant STM as ShortTermMemory
    participant EM as EntityMemory
    participant LLM as Agent's LLM

    C-&gt;&gt;A: Execute Task(description, current_context)
    Note over A: Need to build full prompt context.
    A-&gt;&gt;CtxMem: Get memory context for task query
    CtxMem-&gt;&gt;STM: Search(task_query)
    STM--&gt;&gt;CtxMem: Recent memories (e.g., "Found Lisbon earlier")
    CtxMem-&gt;&gt;EM: Search(task_query)
    EM--&gt;&gt;CtxMem: Entity details (e.g., "Lisbon: Capital of Portugal")
    CtxMem--&gt;&gt;A: Combined Memory Snippets
    A-&gt;&gt;A: Assemble Final Prompt (Task Desc + Current Context + Memory Snippets)
    A-&gt;&gt;LLM: Process Augmented Prompt
    LLM--&gt;&gt;A: Generate Response
    A--&gt;&gt;C: Task Result
    Note over C: Crew updates memories (STM, EM) with task results.

</code></pre>

<p><strong>Diving into the Code (High Level)</strong></p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">crewai/crew.py</code>:</strong> When you set <code class="language-plaintext highlighter-rouge">memory=True</code> in the <code class="language-plaintext highlighter-rouge">Crew</code> constructor, the <code class="language-plaintext highlighter-rouge">create_crew_memory</code> validator method (triggered by Pydantic) initializes instances of <code class="language-plaintext highlighter-rouge">ShortTermMemory</code>, <code class="language-plaintext highlighter-rouge">LongTermMemory</code>, and <code class="language-plaintext highlighter-rouge">EntityMemory</code> and stores them in private attributes like <code class="language-plaintext highlighter-rouge">_short_term_memory</code>.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified from crewai/crew.py
</span><span class="k">class</span> <span class="nc">Crew</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">memory</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="p">...)</span>
    <span class="n">_short_term_memory</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InstanceOf</span><span class="p">[</span><span class="n">ShortTermMemory</span><span class="p">]]</span> <span class="o">=</span> <span class="n">PrivateAttr</span><span class="p">()</span>
    <span class="n">_long_term_memory</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InstanceOf</span><span class="p">[</span><span class="n">LongTermMemory</span><span class="p">]]</span> <span class="o">=</span> <span class="n">PrivateAttr</span><span class="p">()</span>
    <span class="n">_entity_memory</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">InstanceOf</span><span class="p">[</span><span class="n">EntityMemory</span><span class="p">]]</span> <span class="o">=</span> <span class="n">PrivateAttr</span><span class="p">()</span>
    <span class="c1"># ... other fields ...
</span>
    <span class="o">@</span><span class="n">model_validator</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s">"after"</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">create_crew_memory</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s">"Crew"</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">memory</span><span class="p">:</span>
            <span class="c1"># Simplified: Initializes memory objects if memory=True
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">_long_term_memory</span> <span class="o">=</span> <span class="n">LongTermMemory</span><span class="p">(...)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_short_term_memory</span> <span class="o">=</span> <span class="n">ShortTermMemory</span><span class="p">(</span><span class="n">crew</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="p">...)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_entity_memory</span> <span class="o">=</span> <span class="n">EntityMemory</span><span class="p">(</span><span class="n">crew</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="p">...)</span>
        <span class="k">return</span> <span class="bp">self</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">crewai/memory/contextual/contextual_memory.py</code>:</strong> This class is responsible for orchestrating the retrieval from different memory types. Its <code class="language-plaintext highlighter-rouge">build_context_for_task</code> method takes the task information and queries the relevant memories.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified from crewai/memory/contextual/contextual_memory.py
</span><span class="k">class</span> <span class="nc">ContextualMemory</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stm</span><span class="p">:</span> <span class="n">ShortTermMemory</span><span class="p">,</span> <span class="n">ltm</span><span class="p">:</span> <span class="n">LongTermMemory</span><span class="p">,</span> <span class="n">em</span><span class="p">:</span> <span class="n">EntityMemory</span><span class="p">,</span> <span class="p">...):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">stm</span> <span class="o">=</span> <span class="n">stm</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">ltm</span> <span class="o">=</span> <span class="n">ltm</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">em</span> <span class="o">=</span> <span class="n">em</span>
        <span class="c1"># ...
</span>
    <span class="k">def</span> <span class="nf">build_context_for_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">query</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">task</span><span class="p">.</span><span class="n">description</span><span class="si">}</span><span class="s"> </span><span class="si">{</span><span class="n">context</span><span class="si">}</span><span class="s">"</span><span class="p">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">query</span><span class="p">:</span> <span class="k">return</span> <span class="s">""</span>

        <span class="n">memory_context</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Fetch relevant info from Short Term Memory
</span>        <span class="n">memory_context</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_fetch_stm_context</span><span class="p">(</span><span class="n">query</span><span class="p">))</span>
        <span class="c1"># Fetch relevant info from Entity Memory
</span>        <span class="n">memory_context</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_fetch_entity_context</span><span class="p">(</span><span class="n">query</span><span class="p">))</span>
        <span class="c1"># Fetch relevant info from Long Term Memory (if applicable)
</span>        <span class="c1"># memory_context.append(self._fetch_ltm_context(task.description))
</span>
        <span class="k">return</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">memory_context</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_fetch_stm_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">stm_results</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">stm</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="c1"># ... format results ...
</span>        <span class="k">return</span> <span class="n">formatted_results</span> <span class="k">if</span> <span class="n">stm_results</span> <span class="k">else</span> <span class="s">""</span>

    <span class="k">def</span> <span class="nf">_fetch_entity_context</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">em_results</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">em</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="n">query</span><span class="p">)</span>
        <span class="c1"># ... format results ...
</span>        <span class="k">return</span> <span class="n">formatted_results</span> <span class="k">if</span> <span class="n">em_results</span> <span class="k">else</span> <span class="s">""</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Memory Types (<code class="language-plaintext highlighter-rouge">short_term_memory.py</code>, <code class="language-plaintext highlighter-rouge">entity_memory.py</code>, <code class="language-plaintext highlighter-rouge">long_term_memory.py</code>):</strong></p>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">ShortTermMemory</code> and <code class="language-plaintext highlighter-rouge">EntityMemory</code> typically use <code class="language-plaintext highlighter-rouge">RAGStorage</code> (<code class="language-plaintext highlighter-rouge">crewai/memory/storage/rag_storage.py</code>), which often relies on a vector database like ChromaDB to store embeddings of text snippets and find similar ones based on a query.</li>
      <li><code class="language-plaintext highlighter-rouge">LongTermMemory</code> typically uses <code class="language-plaintext highlighter-rouge">LTMSQLiteStorage</code> (<code class="language-plaintext highlighter-rouge">crewai/memory/storage/ltm_sqlite_storage.py</code>) to save structured data about task evaluations (like descriptions, scores, suggestions) into an SQLite database file.</li>
    </ul>
  </li>
</ul>

<p>The key idea is that <code class="language-plaintext highlighter-rouge">memory=True</code> sets up these storage systems and the <code class="language-plaintext highlighter-rouge">ContextualMemory</code> orchestrator, which automatically enriches agent prompts with relevant remembered information.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve learned about the crucial concept of <strong>Memory</strong> in CrewAI! Memory gives your agents the ability to recall past information, preventing them from being purely stateless. We explored the three main types:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">ShortTermMemory</code></strong>: For context within the current run.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">LongTermMemory</code></strong>: For insights across multiple runs (more advanced).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">EntityMemory</code></strong>: For tracking specific people, places, or concepts.</li>
</ul>

<p>Enabling memory with <code class="language-plaintext highlighter-rouge">memory=True</code> in your <code class="language-plaintext highlighter-rouge">Crew</code> is the first step to making your agents more context-aware and efficient, primarily leveraging Short Term and Entity memory automatically.</p>

<p>But what if your agents need access to a large body of pre-existing information, like company documentation, technical manuals, or a specific set of research papers? That’s static information, not necessarily memories of <em>interactions</em>. How do we provide that? That’s where the concept of <strong>Knowledge</strong> comes in. Let’s explore that next!</p>

<p><strong>Next:</strong> <a href="08_knowledge.md">Chapter 8: Knowledge - Providing External Information</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
