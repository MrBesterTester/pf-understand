<h1 id="chapter-3-channels---the-communication-system">Chapter 3: Channels - The Communication System</h1>

<p>In <a href="01_graph___stategraph.md">Chapter 1: Graph / StateGraph</a>, we learned about the <code class="language-plaintext highlighter-rouge">StateGraph</code> as the blueprint for our application, holding the shared “whiteboard” or state. In <a href="02_nodes___pregelnode__.md">Chapter 2: Nodes (<code class="language-plaintext highlighter-rouge">PregelNode</code>)</a>, we met the “workers” or Nodes that perform tasks and read/write to this whiteboard.</p>

<p>But how does this “whiteboard” <em>actually</em> work? How does the information written by one node reliably get seen by the next? What happens if multiple nodes try to write to the <em>same part</em> of the whiteboard at roughly the same time?</p>

<p>This is where <strong>Channels</strong> come in. They are the fundamental mechanism for communication and state management within a <code class="language-plaintext highlighter-rouge">StateGraph</code>.</p>

<h2 id="what-problem-do-channels-solve">What Problem Do Channels Solve?</h2>

<p>Imagine our simple graph from Chapter 1:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># State: {'value': int}
# Node 1: adder (reads 'value', returns {'value': value + 1})
# Node 2: multiplier (reads 'value', returns {'value': value * 2})
# Flow: START -&gt; adder -&gt; multiplier -&gt; END
</span></code></pre></div></div>

<p>When <code class="language-plaintext highlighter-rouge">adder</code> runs with <code class="language-plaintext highlighter-rouge">{'value': 5}</code>, it returns <code class="language-plaintext highlighter-rouge">{'value': 6}</code>. How does this update the central state so that <code class="language-plaintext highlighter-rouge">multiplier</code> receives <code class="language-plaintext highlighter-rouge">{'value': 6}</code> and not the original <code class="language-plaintext highlighter-rouge">{'value': 5}</code>?</p>

<p>Furthermore, what if we had a more complex graph where two different nodes, say <code class="language-plaintext highlighter-rouge">node_A</code> and <code class="language-plaintext highlighter-rouge">node_B</code>, both finished their work and <em>both</em> wanted to update the <code class="language-plaintext highlighter-rouge">value</code> key in the same step? Should the final <code class="language-plaintext highlighter-rouge">value</code> be the one from <code class="language-plaintext highlighter-rouge">node_A</code>, the one from <code class="language-plaintext highlighter-rouge">node_B</code>, their sum, or something else?</p>

<p><strong>Channels</strong> solve these problems by defining:</p>

<ol>
  <li><strong>Storage:</strong> How the value for a specific key in the state is stored.</li>
  <li><strong>Update Logic:</strong> How incoming updates for that key are combined or processed.</li>
</ol>

<h2 id="channels-mailboxes-for-your-state">Channels: Mailboxes for Your State</h2>

<p>Think of the shared state (our “whiteboard”) not as one big surface, but as a collection of <strong>mailboxes</strong>.</p>

<ul>
  <li><strong>Each key in your state dictionary (<code class="language-plaintext highlighter-rouge">MyState</code>) gets its own dedicated mailbox.</strong> In our example, there’s a mailbox labeled <code class="language-plaintext highlighter-rouge">"value"</code>.</li>
  <li>When a Node finishes and returns a dictionary (like <code class="language-plaintext highlighter-rouge">{'value': 6}</code>), the <a href="05_pregel_execution_engine.md">Pregel Execution Engine</a> acts like a mail carrier. It takes the value <code class="language-plaintext highlighter-rouge">6</code> and puts it into the mailbox labeled <code class="language-plaintext highlighter-rouge">"value"</code>.</li>
  <li>When another Node needs to read the state, the engine goes to the relevant mailboxes (like <code class="language-plaintext highlighter-rouge">"value"</code>) and gets the current contents.</li>
</ul>

<p>This mailbox concept ensures that updates intended for <code class="language-plaintext highlighter-rouge">"value"</code> only affect <code class="language-plaintext highlighter-rouge">"value"</code>, and updates for another key (say, <code class="language-plaintext highlighter-rouge">"messages"</code>) would go into <em>its</em> own separate mailbox.</p>

<p><strong>Crucially, each mailbox (Channel) has specific rules about how incoming mail (updates) is handled.</strong> Does the new mail replace the old one? Is it added to a list? Is it mathematically combined with the previous value? These rules are defined by the <strong>Channel Type</strong>.</p>

<h2 id="how-channels-work-the-update-cycle">How Channels Work: The Update Cycle</h2>

<p>Here’s a step-by-step view of how channels manage state during graph execution:</p>

<ol>
  <li><strong>Node Returns Update:</strong> A node (e.g., <code class="language-plaintext highlighter-rouge">adder</code>) finishes and returns a dictionary (e.g., <code class="language-plaintext highlighter-rouge">{'value': 6}</code>).</li>
  <li><strong>Engine Routes Update:</strong> The <a href="05_pregel_execution_engine.md">Pregel Execution Engine</a> sees the key <code class="language-plaintext highlighter-rouge">"value"</code> and routes the update <code class="language-plaintext highlighter-rouge">6</code> to the Channel associated with <code class="language-plaintext highlighter-rouge">"value"</code>.</li>
  <li><strong>Channel Receives Update(s):</strong> The <code class="language-plaintext highlighter-rouge">"value"</code> Channel receives <code class="language-plaintext highlighter-rouge">6</code>. If other nodes also returned updates for <code class="language-plaintext highlighter-rouge">"value"</code> in the same step, the Channel would receive all of them in a sequence (e.g., <code class="language-plaintext highlighter-rouge">[6, maybe_another_update]</code>).</li>
  <li><strong>Channel Applies Update Logic:</strong> The Channel uses its specific rule (its type) to process the incoming update(s). For example, a <code class="language-plaintext highlighter-rouge">LastValue</code> channel would just keep the <em>last</em> update it received in the sequence. A <code class="language-plaintext highlighter-rouge">BinaryOperatorAggregate</code> channel might <em>sum</em> all the updates with its current value.</li>
  <li><strong>State is Updated:</strong> The Channel now holds the new, processed value.</li>
  <li><strong>Node Reads State:</strong> When the next node (e.g., <code class="language-plaintext highlighter-rouge">multiplier</code>) needs the state, the Engine queries the relevant Channels (e.g., the <code class="language-plaintext highlighter-rouge">"value"</code> Channel).</li>
  <li><strong>Channel Provides Value:</strong> The Channel provides its current stored value (e.g., <code class="language-plaintext highlighter-rouge">6</code>) to the Engine, which passes it to the node.</li>
</ol>

<p>This ensures that state updates are handled consistently according to predefined rules for each piece of state.</p>

<h2 id="common-channel-types-defining-the-rules">Common Channel Types: Defining the Rules</h2>

<p>LangGraph provides several types of Channels, each with different update logic. You usually define which channel type to use for a state key when you define your state <code class="language-plaintext highlighter-rouge">TypedDict</code>, often using <code class="language-plaintext highlighter-rouge">typing.Annotated</code>.</p>

<p>Here are the most common ones:</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">LastValue[T]</code></strong> (The Default Overwriter)
    <ul>
      <li><strong>Rule:</strong> Keeps only the <strong>last</strong> value it received. If multiple updates arrive in the same step, the final value is simply the last one in the sequence processed by the engine.</li>
      <li><strong>Analogy:</strong> Like a standard variable assignment (<code class="language-plaintext highlighter-rouge">my_variable = new_value</code>). The old value is discarded.</li>
      <li><strong>When to Use:</strong> This is the <strong>default</strong> for keys in your <code class="language-plaintext highlighter-rouge">TypedDict</code> state unless you specify otherwise with <code class="language-plaintext highlighter-rouge">Annotated</code>. It’s perfect for state values that should be replaced entirely, like the current step’s result or a user’s latest query.</li>
      <li><strong>Code:</strong> <code class="language-plaintext highlighter-rouge">langgraph.channels.LastValue</code> (from <code class="language-plaintext highlighter-rouge">channels/last_value.py</code>)</li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># channels/last_value.py (Simplified)
</span><span class="k">class</span> <span class="nc">LastValue</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">Value</span><span class="p">],</span> <span class="n">BaseChannel</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="n">Value</span><span class="p">,</span> <span class="n">Value</span><span class="p">]):</span>
    <span class="c1"># ... (initializer, etc.)
</span>    <span class="n">value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">MISSING</span> <span class="c1"># Stores the single, last value
</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Value</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># No updates this step
</span>            <span class="k">return</span> <span class="bp">False</span>
        <span class="c1"># If multiple updates in one step, only the last one matters!
</span>        <span class="c1"># Example: if values = [update1, update2], self.value becomes update2
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Value</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">MISSING</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">EmptyChannelError</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="c1"># Return the currently stored last value
</span></code></pre></div>    </div>
    <ul>
      <li><strong>How to Use (Implicitly):</strong>
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span>

<span class="k">class</span> <span class="nc">MyState</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
     <span class="c1"># Because we didn't use Annotated, LangGraph defaults to LastValue[int]
</span>     <span class="n">value</span><span class="p">:</span> <span class="nb">int</span>
     <span class="n">user_query</span><span class="p">:</span> <span class="nb">str</span> <span class="c1"># Also defaults to LastValue[str]
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">BinaryOperatorAggregate[T]</code></strong> (The Combiner)
    <ul>
      <li><strong>Rule:</strong> Takes an initial “identity” value (like <code class="language-plaintext highlighter-rouge">0</code> for addition, <code class="language-plaintext highlighter-rouge">1</code> for multiplication) and a <strong>binary operator</strong> function (e.g., <code class="language-plaintext highlighter-rouge">+</code>, <code class="language-plaintext highlighter-rouge">*</code>, <code class="language-plaintext highlighter-rouge">operator.add</code>). When it receives updates, it applies the operator between its current value and each new update, accumulating the result.</li>
      <li><strong>Analogy:</strong> Like a running total (<code class="language-plaintext highlighter-rouge">total += new_number</code>).</li>
      <li><strong>When to Use:</strong> Useful for accumulating scores, counts, or combining numerical results.</li>
      <li><strong>Code:</strong> <code class="language-plaintext highlighter-rouge">langgraph.channels.BinaryOperatorAggregate</code> (from <code class="language-plaintext highlighter-rouge">channels/binop.py</code>)</li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># channels/binop.py (Simplified)
</span><span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span>

<span class="k">class</span> <span class="nc">BinaryOperatorAggregate</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">Value</span><span class="p">],</span> <span class="n">BaseChannel</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="n">Value</span><span class="p">,</span> <span class="n">Value</span><span class="p">]):</span>
    <span class="c1"># ... (initializer stores the operator and identity value)
</span>    <span class="n">value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">MISSING</span>
    <span class="n">operator</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Value</span><span class="p">,</span> <span class="n">Value</span><span class="p">],</span> <span class="n">Value</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Value</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">values</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
        <span class="c1"># Start with the first value if the channel was empty
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="ow">is</span> <span class="n">MISSING</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="c1"># Apply the operator for all subsequent values
</span>        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">operator</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Value</span><span class="p">:</span>
        <span class="c1"># ... (return self.value, handling MISSING)
</span></code></pre></div>    </div>
    <ul>
      <li><strong>How to Use (Explicitly with <code class="language-plaintext highlighter-rouge">Annotated</code>):</strong>
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Annotated</span>
<span class="kn">from</span> <span class="nn">langgraph.channels</span> <span class="kn">import</span> <span class="n">BinaryOperatorAggregate</span>

<span class="k">class</span> <span class="nc">AgentState</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="c1"># Use Annotated to specify the channel type and operator
</span>    <span class="n">total_score</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">BinaryOperatorAggregate</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">operator</span><span class="p">.</span><span class="n">add</span><span class="p">)]</span>
    <span class="c1"># ^^^ state key 'total_score' will use BinaryOperatorAggregate with addition
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">Topic[T]</code></strong> (The Collector)
    <ul>
      <li><strong>Rule:</strong> Collects all updates it receives into a <strong>list</strong>. By default (<code class="language-plaintext highlighter-rouge">accumulate=False</code>), it clears the list after each step, so <code class="language-plaintext highlighter-rouge">get()</code> returns only the updates from the <em>immediately preceding</em> step. If <code class="language-plaintext highlighter-rouge">accumulate=True</code>, it keeps adding to the list across multiple steps.</li>
      <li><strong>Analogy:</strong> Like appending to a log file or a list (<code class="language-plaintext highlighter-rouge">my_list.append(new_item)</code>).</li>
      <li><strong>When to Use:</strong> Great for gathering messages in a conversation (<code class="language-plaintext highlighter-rouge">MessageGraph</code> uses this internally!), collecting events, or tracking a sequence of results.</li>
      <li><strong>Code:</strong> <code class="language-plaintext highlighter-rouge">langgraph.channels.Topic</code> (from <code class="language-plaintext highlighter-rouge">channels/topic.py</code>)</li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># channels/topic.py (Simplified)
</span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span>

<span class="k">class</span> <span class="nc">Topic</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">Value</span><span class="p">],</span> <span class="n">BaseChannel</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Value</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Value</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Value</span><span class="p">]]):</span>
    <span class="c1"># ... (initializer sets accumulate flag)
</span>    <span class="n">values</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Value</span><span class="p">]</span>
    <span class="n">accumulate</span><span class="p">:</span> <span class="nb">bool</span>

    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">updates</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="n">Value</span><span class="p">]]])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="n">old_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">)</span>
        <span class="c1"># Clear list if not accumulating
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">accumulate</span><span class="p">:</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Flatten and extend the list with new updates
</span>        <span class="n">new_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">flatten</span><span class="p">(</span><span class="n">updates</span><span class="p">))</span> <span class="c1"># flatten handles list-of-lists
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">new_values</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">values</span><span class="p">)</span> <span class="o">!=</span> <span class="n">old_len</span> <span class="c1"># Return True if list changed
</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Value</span><span class="p">]:</span>
        <span class="c1"># ... (return list(self.values), handling empty)
</span></code></pre></div>    </div>
    <ul>
      <li><strong>How to Use (Explicitly with <code class="language-plaintext highlighter-rouge">Annotated</code>):</strong>
        <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Annotated</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">langgraph.channels</span> <span class="kn">import</span> <span class="n">Topic</span>

<span class="k">class</span> <span class="nc">ChatState</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="c1"># Use Annotated to specify the Topic channel
</span>    <span class="c1"># The final type hint for the state is List[str]
</span>    <span class="n">chat_history</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Topic</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">accumulate</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span>
    <span class="c1"># ^^^ state key 'chat_history' will use Topic to accumulate strings
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ol>

<p>There are other specialized channels like <code class="language-plaintext highlighter-rouge">EphemeralValue</code> (clears after reading) and <code class="language-plaintext highlighter-rouge">Context</code> (allows passing values down without modifying state), but <code class="language-plaintext highlighter-rouge">LastValue</code>, <code class="language-plaintext highlighter-rouge">BinaryOperatorAggregate</code>, and <code class="language-plaintext highlighter-rouge">Topic</code> are the most fundamental.</p>

<h2 id="channels-in-action-our-simple-graph-revisited">Channels in Action: Our Simple Graph Revisited</h2>

<p>Let’s trace our <code class="language-plaintext highlighter-rouge">adder</code> -&gt; <code class="language-plaintext highlighter-rouge">multiplier</code> graph again, focusing on the implicit <code class="language-plaintext highlighter-rouge">LastValue</code> channel for the <code class="language-plaintext highlighter-rouge">"value"</code> key:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span>
<span class="kn">from</span> <span class="nn">langgraph.graph</span> <span class="kn">import</span> <span class="n">StateGraph</span><span class="p">,</span> <span class="n">END</span><span class="p">,</span> <span class="n">START</span>

<span class="c1"># State uses implicit LastValue[int] for 'value'
</span><span class="k">class</span> <span class="nc">MyState</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># Nodes (same as before)
</span><span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">MyState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">"value"</span><span class="p">:</span> <span class="n">state</span><span class="p">[</span><span class="s">'value'</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">multiply_by_two</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">MyState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">"value"</span><span class="p">:</span> <span class="n">state</span><span class="p">[</span><span class="s">'value'</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">}</span>

<span class="c1"># Graph setup (same as before)
</span><span class="n">workflow</span> <span class="o">=</span> <span class="n">StateGraph</span><span class="p">(</span><span class="n">MyState</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"adder"</span><span class="p">,</span> <span class="n">add_one</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"multiplier"</span><span class="p">,</span> <span class="n">multiply_by_two</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">set_entry_point</span><span class="p">(</span><span class="s">"adder"</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">"adder"</span><span class="p">,</span> <span class="s">"multiplier"</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">"multiplier"</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">workflow</span><span class="p">.</span><span class="nb">compile</span><span class="p">()</span>

<span class="c1"># Execution with initial state {"value": 5}
</span><span class="n">initial_state</span> <span class="o">=</span> <span class="p">{</span><span class="s">"value"</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
<span class="n">final_state</span> <span class="o">=</span> <span class="n">app</span><span class="p">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">initial_state</span><span class="p">)</span>
</code></pre></div></div>

<p>Here’s the flow with the Channel involved:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant App as CompiledGraph
    participant Engine as Pregel Engine
    participant ValueChannel as "value" (LastValue)
    participant AdderNode as adder
    participant MultiplierNode as multiplier

    User-&gt;&gt;App: invoke({"value": 5})
    App-&gt;&gt;Engine: Start execution
    Engine-&gt;&gt;ValueChannel: Initialize/Set state from input (value = 5)
    App-&gt;&gt;Engine: Entry point is "adder"
    Engine-&gt;&gt;ValueChannel: Read current value (5)
    ValueChannel--&gt;&gt;Engine: Returns 5
    Engine-&gt;&gt;AdderNode: Execute(state={'value': 5})
    AdderNode--&gt;&gt;Engine: Return {"value": 6}
    Engine-&gt;&gt;ValueChannel: Update with [6]
    Note over ValueChannel: LastValue rule: value becomes 6
    ValueChannel--&gt;&gt;Engine: Acknowledge update
    Engine-&gt;&gt;Engine: Follow edge "adder" -&gt; "multiplier"
    Engine-&gt;&gt;ValueChannel: Read current value (6)
    ValueChannel--&gt;&gt;Engine: Returns 6
    Engine-&gt;&gt;MultiplierNode: Execute(state={'value': 6})
    MultiplierNode--&gt;&gt;Engine: Return {"value": 12}
    Engine-&gt;&gt;ValueChannel: Update with [12]
    Note over ValueChannel: LastValue rule: value becomes 12
    ValueChannel--&gt;&gt;Engine: Acknowledge update
    Engine-&gt;&gt;Engine: Follow edge "multiplier" -&gt; END
    Engine-&gt;&gt;ValueChannel: Read final value (12)
    ValueChannel--&gt;&gt;Engine: Returns 12
    Engine-&gt;&gt;App: Execution finished, final state {'value': 12}
    App-&gt;&gt;User: Return final state {'value': 12}
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">LastValue</code> channel ensures that the output of <code class="language-plaintext highlighter-rouge">adder</code> correctly overwrites the initial state before <code class="language-plaintext highlighter-rouge">multiplier</code> reads it.</p>

<h2 id="example-using-binaryoperatoraggregate-explicitly">Example: Using <code class="language-plaintext highlighter-rouge">BinaryOperatorAggregate</code> Explicitly</h2>

<p>Let’s modify the state to <em>sum</em> values instead of overwriting them.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">operator</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Annotated</span>
<span class="kn">from</span> <span class="nn">langgraph.graph</span> <span class="kn">import</span> <span class="n">StateGraph</span><span class="p">,</span> <span class="n">END</span><span class="p">,</span> <span class="n">START</span>
<span class="c1"># Import the channel type
</span><span class="kn">from</span> <span class="nn">langgraph.channels</span> <span class="kn">import</span> <span class="n">BinaryOperatorAggregate</span>

<span class="c1"># Define state with an explicitly configured channel
</span><span class="k">class</span> <span class="nc">SummingState</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="c1"># Use Annotated to specify the channel and its operator (addition)
</span>    <span class="n">value</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">BinaryOperatorAggregate</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">operator</span><span class="p">.</span><span class="n">add</span><span class="p">)]</span>

<span class="c1"># Node 1: Returns 5 to be ADDED to the current value
</span><span class="k">def</span> <span class="nf">add_five</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">SummingState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"--- Running Adder Node 1 (current value: </span><span class="si">{</span><span class="n">state</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'value'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="si">}</span><span class="s">) ---"</span><span class="p">)</span>
    <span class="c1"># Note: We return the *increment*, not the new total
</span>    <span class="k">return</span> <span class="p">{</span><span class="s">"value"</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>

<span class="c1"># Node 2: Returns 10 to be ADDED to the current value
</span><span class="k">def</span> <span class="nf">add_ten</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">SummingState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"--- Running Adder Node 2 (current value: </span><span class="si">{</span><span class="n">state</span><span class="p">[</span><span class="s">'value'</span><span class="p">]</span><span class="si">}</span><span class="s">) ---"</span><span class="p">)</span>
     <span class="c1"># Note: We return the *increment*, not the new total
</span>    <span class="k">return</span> <span class="p">{</span><span class="s">"value"</span><span class="p">:</span> <span class="mi">10</span><span class="p">}</span>

<span class="c1"># Create graph
</span><span class="n">workflow</span> <span class="o">=</span> <span class="n">StateGraph</span><span class="p">(</span><span class="n">SummingState</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"adder1"</span><span class="p">,</span> <span class="n">add_five</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"adder2"</span><span class="p">,</span> <span class="n">add_ten</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">set_entry_point</span><span class="p">(</span><span class="s">"adder1"</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">"adder1"</span><span class="p">,</span> <span class="s">"adder2"</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">"adder2"</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">workflow</span><span class="p">.</span><span class="nb">compile</span><span class="p">()</span>

<span class="c1"># Run with initial state value = 0 (BinaryOperatorAggregate defaults int to 0)
</span><span class="k">print</span><span class="p">(</span><span class="s">"Invoking graph..."</span><span class="p">)</span>
<span class="c1"># You could also provide an initial value: app.invoke({"value": 100})
</span><span class="n">final_state</span> <span class="o">=</span> <span class="n">app</span><span class="p">.</span><span class="n">invoke</span><span class="p">({})</span>

<span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">--- Final State ---"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">final_state</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Expected Output:</strong></p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Invoking graph...
--- Running Adder Node 1 (current value: 0) ---
--- Running Adder Node 2 (current value: 5) ---

--- Final State ---
{'value': 15}
</code></pre></div></div>

<p>Because we used <code class="language-plaintext highlighter-rouge">Annotated[int, BinaryOperatorAggregate(int, operator.add)]</code>, the <code class="language-plaintext highlighter-rouge">"value"</code> channel now <em>adds</em> incoming updates (<code class="language-plaintext highlighter-rouge">5</code> then <code class="language-plaintext highlighter-rouge">10</code>) to its current state, resulting in a final sum of <code class="language-plaintext highlighter-rouge">15</code>.</p>

<h2 id="how-stategraph-finds-the-right-channel">How <code class="language-plaintext highlighter-rouge">StateGraph</code> Finds the Right Channel</h2>

<p>You might wonder how <code class="language-plaintext highlighter-rouge">StateGraph</code> knows whether to use <code class="language-plaintext highlighter-rouge">LastValue</code> or something else. When you initialize <code class="language-plaintext highlighter-rouge">StateGraph(MyState)</code>, it inspects your state schema (<code class="language-plaintext highlighter-rouge">MyState</code>).</p>

<ul>
  <li>It uses Python’s <code class="language-plaintext highlighter-rouge">get_type_hints(MyState, include_extras=True)</code> to look at each field (like <code class="language-plaintext highlighter-rouge">value</code>).</li>
  <li>If a field has <code class="language-plaintext highlighter-rouge">Annotated[SomeType, SomeChannelConfig]</code>, it uses <code class="language-plaintext highlighter-rouge">SomeChannelConfig</code> (e.g., <code class="language-plaintext highlighter-rouge">BinaryOperatorAggregate(...)</code>, <code class="language-plaintext highlighter-rouge">Topic(...)</code>) to create the channel for that key.</li>
  <li>If a field is just <code class="language-plaintext highlighter-rouge">SomeType</code> (like <code class="language-plaintext highlighter-rouge">value: int</code>), it defaults to creating a <code class="language-plaintext highlighter-rouge">LastValue[SomeType]</code> channel for that key.</li>
</ul>

<p>This logic is primarily handled within the <code class="language-plaintext highlighter-rouge">StateGraph._add_schema</code> method, which calls internal helpers like <code class="language-plaintext highlighter-rouge">_get_channels</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># graph/state.py (Simplified view of channel detection)
</span>
<span class="k">def</span> <span class="nf">_get_channels</span><span class="p">(</span><span class="n">schema</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="nb">dict</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[...]:</span>
    <span class="c1"># ... gets type hints including Annotated metadata ...
</span>    <span class="n">type_hints</span> <span class="o">=</span> <span class="n">get_type_hints</span><span class="p">(</span><span class="n">schema</span><span class="p">,</span> <span class="n">include_extras</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">all_keys</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">type_hints</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
         <span class="c1"># Checks if the annotation specifies a channel or binop
</span>        <span class="k">if</span> <span class="n">channel</span> <span class="p">:</span><span class="o">=</span> <span class="n">_is_field_channel</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span> <span class="ow">or</span> <span class="n">_is_field_binop</span><span class="p">(</span><span class="n">typ</span><span class="p">):</span>
             <span class="n">channel</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">name</span>
             <span class="n">all_keys</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">channel</span>
        <span class="k">else</span><span class="p">:</span>
             <span class="c1"># Default case: Use LastValue
</span>             <span class="n">fallback</span> <span class="o">=</span> <span class="n">LastValue</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>
             <span class="n">fallback</span><span class="p">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">name</span>
             <span class="n">all_keys</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">fallback</span>
    <span class="c1"># ... separate BaseChannel instances from ManagedValueSpec ...
</span>    <span class="k">return</span> <span class="n">channels</span><span class="p">,</span> <span class="n">managed_values</span><span class="p">,</span> <span class="n">type_hints</span>

<span class="k">def</span> <span class="nf">_is_field_channel</span><span class="p">(</span><span class="n">typ</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BaseChannel</span><span class="p">]:</span>
    <span class="c1"># Checks if Annotated metadata contains a BaseChannel instance or class
</span>    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="s">"__metadata__"</span><span class="p">):</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">typ</span><span class="p">.</span><span class="n">__metadata__</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">meta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">BaseChannel</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">meta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Return the channel instance directly
</span>        <span class="c1"># ... (handle channel classes too) ...
</span>    <span class="k">return</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">_is_field_binop</span><span class="p">(</span><span class="n">typ</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BinaryOperatorAggregate</span><span class="p">]:</span>
    <span class="c1"># Checks if Annotated metadata contains a callable (the reducer function)
</span>    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="s">"__metadata__"</span><span class="p">):</span>
        <span class="n">meta</span> <span class="o">=</span> <span class="n">typ</span><span class="p">.</span><span class="n">__metadata__</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">meta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
            <span class="c1"># ... (validate function signature) ...
</span>            <span class="k">return</span> <span class="n">BinaryOperatorAggregate</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">meta</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># Create binop channel
</span>    <span class="k">return</span> <span class="bp">None</span>

<span class="c1"># --- In StateGraph.__init__ ---
# self._add_schema(state_schema) # This calls _get_channels
</span></code></pre></div></div>

<h2 id="under-the-hood-basechannel">Under the Hood: <code class="language-plaintext highlighter-rouge">BaseChannel</code></h2>

<p>All channel types inherit from a base class called <code class="language-plaintext highlighter-rouge">BaseChannel</code>. This class defines the common interface that the <a href="05_pregel_execution_engine.md">Pregel Execution Engine</a> uses to interact with any channel.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># channels/base.py (Simplified Abstract Base Class)
</span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Generic</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">TypeVar</span>

<span class="n">Value</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s">"Value"</span><span class="p">)</span> <span class="c1"># The type of the stored state
</span><span class="n">Update</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s">"Update"</span><span class="p">)</span> <span class="c1"># The type of incoming updates
</span><span class="n">Checkpoint</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s">"Checkpoint"</span><span class="p">)</span> <span class="c1"># The type of saved state
</span>
<span class="k">class</span> <span class="nc">BaseChannel</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">Value</span><span class="p">,</span> <span class="n">Update</span><span class="p">,</span> <span class="n">Checkpoint</span><span class="p">],</span> <span class="n">ABC</span><span class="p">):</span>
    <span class="c1"># ... (init, type properties) ...
</span>
    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Update</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="s">"""Combines the sequence of updates with the current channel value."""</span>
        <span class="c1"># Must be implemented by subclasses (like LastValue, Topic)
</span>        <span class="k">pass</span>

    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Value</span><span class="p">:</span>
        <span class="s">"""Returns the current value of the channel."""</span>
        <span class="c1"># Must be implemented by subclasses
</span>        <span class="k">pass</span>

    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Checkpoint</span><span class="p">:</span>
        <span class="s">"""Returns a serializable representation of the channel's state."""</span>
        <span class="c1"># Used by the Checkpointer
</span>        <span class="k">pass</span>

    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">from_checkpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">checkpoint</span><span class="p">:</span> <span class="n">Checkpoint</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="s">"""Creates a new channel instance from a saved checkpoint."""</span>
        <span class="c1"># Used by the Checkpointer
</span>        <span class="k">pass</span>
</code></pre></div></div>

<p>The specific logic for <code class="language-plaintext highlighter-rouge">LastValue</code>, <code class="language-plaintext highlighter-rouge">Topic</code>, <code class="language-plaintext highlighter-rouge">BinaryOperatorAggregate</code>, etc., is implemented within their respective <code class="language-plaintext highlighter-rouge">update</code> and <code class="language-plaintext highlighter-rouge">get</code> methods, adhering to this common interface. The <code class="language-plaintext highlighter-rouge">checkpoint</code> and <code class="language-plaintext highlighter-rouge">from_checkpoint</code> methods are crucial for saving and loading the graph’s state, which we’ll explore more in <a href="06_checkpointer___basecheckpointsaver__.md">Chapter 6: Checkpointer (<code class="language-plaintext highlighter-rouge">BaseCheckpointSaver</code>)</a>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve learned about <strong>Channels</strong>, the crucial communication and state management system within LangGraph’s <code class="language-plaintext highlighter-rouge">StateGraph</code>.</p>

<ul>
  <li>Channels act like <strong>mailboxes</strong> for each key in your graph’s state.</li>
  <li>They define <strong>how updates are combined</strong> when nodes write to the state.</li>
  <li>The default channel is <strong><code class="language-plaintext highlighter-rouge">LastValue</code></strong>, which overwrites the previous value.</li>
  <li>You can use <code class="language-plaintext highlighter-rouge">typing.Annotated</code> in your state definition to specify other channel types like <strong><code class="language-plaintext highlighter-rouge">BinaryOperatorAggregate</code></strong> (for combining values, e.g., summing) or <strong><code class="language-plaintext highlighter-rouge">Topic</code></strong> (for collecting updates into a list).</li>
  <li><code class="language-plaintext highlighter-rouge">StateGraph</code> automatically creates the correct channel for each state key based on your type hints.</li>
</ul>

<p>Understanding channels helps you control precisely how information flows and accumulates in your stateful applications.</p>

<p>Now that we know how the state is managed (Channels) and how work gets done (Nodes), how do we control the <em>flow</em> of execution? What if we want to go to different nodes based on the current state? That’s where conditional logic comes in.</p>

<p>Let’s move on to <a href="04_control_flow_primitives___branch____send____interrupt__.md">Chapter 4: Control Flow Primitives (<code class="language-plaintext highlighter-rouge">Branch</code>, <code class="language-plaintext highlighter-rouge">Send</code>, <code class="language-plaintext highlighter-rouge">Interrupt</code>)</a> to learn how to direct the traffic within our graph.</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
