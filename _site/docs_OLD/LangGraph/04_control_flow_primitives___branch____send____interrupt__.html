<h1 id="chapter-4-control-flow-primitives-branch-send-interrupt">Chapter 4: Control Flow Primitives (<code class="language-plaintext highlighter-rouge">Branch</code>, <code class="language-plaintext highlighter-rouge">Send</code>, <code class="language-plaintext highlighter-rouge">Interrupt</code>)</h1>

<p>In <a href="03_channels.md">Chapter 3: Channels</a>, we saw how information is stored and updated in our graph’s shared state using Channels. We have the blueprint (<a href="01_graph___stategraph.md"><code class="language-plaintext highlighter-rouge">StateGraph</code></a>), the workers (<a href="02_nodes___pregelnode__.md"><code class="language-plaintext highlighter-rouge">Nodes</code></a>), and the communication system (<a href="03_channels.md">Channels</a>).</p>

<p>But what if we don’t want our graph to follow a single, fixed path? What if we need it to make decisions? For example, imagine a chatbot: sometimes it needs to use a tool (like a search engine), and other times it can answer directly. How do we tell the graph <em>which</em> path to take based on the current situation?</p>

<p>This is where <strong>Control Flow Primitives</strong> come in. They are special mechanisms that allow you to dynamically direct the execution path of your graph, making it much more flexible and powerful.</p>

<h2 id="what-problem-do-control-flow-primitives-solve">What Problem Do Control Flow Primitives Solve?</h2>

<p>Think of our graph like a train system. So far, we’ve only built tracks that go in a straight line from one station (node) to the next. Control flow primitives are like the <strong>switches</strong> and <strong>signals</strong> that allow the train (our execution flow) to:</p>

<ol>
  <li><strong>Choose a path:</strong> Decide whether to go left or right at a junction based on some condition (like an “if” statement).</li>
  <li><strong>Dispatch specific trains:</strong> Send a specific piece of cargo directly to a particular station, maybe even multiple pieces to the same station to be processed in parallel.</li>
  <li><strong>Wait for instructions:</strong> Pause the train journey until an external signal (like human approval) is given.</li>
</ol>

<p>LangGraph provides three main primitives for this:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Branch</code></strong>: Acts like a conditional router or switch (“if/else”). It directs the flow to different nodes based on the current state.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Send</code></strong>: Allows a node to directly trigger another node with specific input, useful for parallel processing patterns like map-reduce.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Interrupt</code></strong>: Pauses the graph execution, usually to wait for external input (like a human clicking “Approve”) before continuing.</li>
</ul>

<p>Let’s explore each one.</p>

<h2 id="1-branch---the-conditional-router">1. <code class="language-plaintext highlighter-rouge">Branch</code> - The Conditional Router</h2>

<p>Imagine our chatbot needs to decide: “Should I use the search tool, or can I answer from my knowledge?” This decision depends on the conversation history or the user’s specific question stored in the graph’s state.</p>

<p>The <code class="language-plaintext highlighter-rouge">Branch</code> primitive allows us to implement this kind of conditional logic. You add it using the <code class="language-plaintext highlighter-rouge">graph.add_conditional_edges()</code> method.</p>

<p><strong>How it Works:</strong></p>

<ol>
  <li>You define a regular node (let’s call it <code class="language-plaintext highlighter-rouge">should_i_search</code>).</li>
  <li>You define a separate <strong>routing function</strong>. This function takes the current state and decides <em>which node</em> should run next. It returns the name of the next node (or a list of names).</li>
  <li>You connect the <code class="language-plaintext highlighter-rouge">should_i_search</code> node to the routing function using <code class="language-plaintext highlighter-rouge">add_conditional_edges</code>. You tell it: “After <code class="language-plaintext highlighter-rouge">should_i_search</code> finishes, call this routing function to decide where to go next.”</li>
  <li>You provide a mapping (a dictionary) that links the possible return values of your routing function to the actual node names in your graph.</li>
</ol>

<p><strong>Example: Chatbot Deciding to Search</strong></p>

<p>Let’s build a tiny graph that decides whether to go to a <code class="language-plaintext highlighter-rouge">search_tool</code> node or a <code class="language-plaintext highlighter-rouge">respond_directly</code> node.</p>

<p><strong>Step 1: Define State</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Annotated</span><span class="p">,</span> <span class="n">List</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="k">class</span> <span class="nc">ChatState</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">user_query</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># We'll store the decision here
</span>    <span class="n">next_action</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># Keep track of intermediate results
</span>    <span class="n">search_result</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">operator</span><span class="p">.</span><span class="n">add</span><span class="p">]</span> <span class="c1"># Use Topic or add if accumulating
</span>    <span class="n">final_response</span><span class="p">:</span> <span class="nb">str</span>
</code></pre></div></div>

<p>Our state holds the user’s query and a field <code class="language-plaintext highlighter-rouge">next_action</code> to store the decision.</p>

<p><strong>Step 2: Define Nodes</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Node that decides the next step
</span><span class="k">def</span> <span class="nf">determine_action</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">ChatState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"--- Determining Action ---"</span><span class="p">)</span>
    <span class="n">query</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">'user_query'</span><span class="p">]</span>
    <span class="k">if</span> <span class="s">"weather"</span> <span class="ow">in</span> <span class="n">query</span><span class="p">.</span><span class="n">lower</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Decision: Need to use search tool for weather."</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">"next_action"</span><span class="p">:</span> <span class="s">"USE_TOOL"</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Decision: Can respond directly."</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s">"next_action"</span><span class="p">:</span> <span class="s">"RESPOND"</span><span class="p">}</span>

<span class="c1"># Node representing the search tool
</span><span class="k">def</span> <span class="nf">run_search_tool</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">ChatState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"--- Using Search Tool ---"</span><span class="p">)</span>
    <span class="n">query</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">'user_query'</span><span class="p">]</span>
    <span class="c1"># Simulate finding a result
</span>    <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"Search result for '</span><span class="si">{</span><span class="n">query</span><span class="si">}</span><span class="s">': It's sunny!"</span>
    <span class="c1"># We return the result to be ADDED to the state list
</span>    <span class="k">return</span> <span class="p">{</span><span class="s">"search_result"</span><span class="p">:</span> <span class="p">[</span><span class="n">result</span><span class="p">]}</span> <span class="c1"># Return as list for operator.add
</span>
<span class="c1"># Node that generates a final response
</span><span class="k">def</span> <span class="nf">generate_response</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">ChatState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"--- Generating Response ---"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">state</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"search_result"</span><span class="p">):</span>
        <span class="n">response</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"Based on my search: </span><span class="si">{</span><span class="n">state</span><span class="p">[</span><span class="s">'search_result'</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s">"</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">response</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"Responding directly to: </span><span class="si">{</span><span class="n">state</span><span class="p">[</span><span class="s">'user_query'</span><span class="p">]</span><span class="si">}</span><span class="s">"</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">"final_response"</span><span class="p">:</span> <span class="n">response</span><span class="p">}</span>
</code></pre></div></div>

<p><strong>Step 3: Define the Routing Function</strong></p>

<p>This function reads the <code class="language-plaintext highlighter-rouge">next_action</code> from the state and returns the <em>key</em> we’ll use in our mapping.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">route_based_on_action</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">ChatState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"--- Routing ---"</span><span class="p">)</span>
    <span class="n">action</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">'next_action'</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Routing based on action: </span><span class="si">{</span><span class="n">action</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">action</span> <span class="o">==</span> <span class="s">"USE_TOOL"</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"route_to_tool"</span> <span class="c1"># This key must match our path_map
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="s">"route_to_respond"</span> <span class="c1"># This key must match our path_map
</span></code></pre></div></div>

<p><strong>Step 4: Build the Graph with Conditional Edges</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">langgraph.graph</span> <span class="kn">import</span> <span class="n">StateGraph</span><span class="p">,</span> <span class="n">END</span><span class="p">,</span> <span class="n">START</span>

<span class="n">workflow</span> <span class="o">=</span> <span class="n">StateGraph</span><span class="p">(</span><span class="n">ChatState</span><span class="p">)</span>

<span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"decider"</span><span class="p">,</span> <span class="n">determine_action</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"search_tool"</span><span class="p">,</span> <span class="n">run_search_tool</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"responder"</span><span class="p">,</span> <span class="n">generate_response</span><span class="p">)</span>

<span class="n">workflow</span><span class="p">.</span><span class="n">set_entry_point</span><span class="p">(</span><span class="s">"decider"</span><span class="p">)</span>

<span class="c1"># After 'decider', call 'route_based_on_action' to choose the next step
</span><span class="n">workflow</span><span class="p">.</span><span class="n">add_conditional_edges</span><span class="p">(</span>
    <span class="s">"decider"</span><span class="p">,</span> <span class="c1"># Start node
</span>    <span class="n">route_based_on_action</span><span class="p">,</span> <span class="c1"># The routing function
</span>    <span class="p">{</span>
        <span class="c1"># Map the routing function's output to actual node names
</span>        <span class="s">"route_to_tool"</span><span class="p">:</span> <span class="s">"search_tool"</span><span class="p">,</span>
        <span class="s">"route_to_respond"</span><span class="p">:</span> <span class="s">"responder"</span>
    <span class="p">}</span>
<span class="p">)</span>

<span class="c1"># Define what happens *after* the conditional paths
</span><span class="n">workflow</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">"search_tool"</span><span class="p">,</span> <span class="s">"responder"</span><span class="p">)</span> <span class="c1"># After searching, generate response
</span><span class="n">workflow</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">"responder"</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span> <span class="c1"># After responding, end
</span>
<span class="c1"># Compile
</span><span class="n">app</span> <span class="o">=</span> <span class="n">workflow</span><span class="p">.</span><span class="nb">compile</span><span class="p">()</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">add_conditional_edges("decider", route_based_on_action, ...)</code>: This is the key part. It tells LangGraph: after the “decider” node runs, execute the <code class="language-plaintext highlighter-rouge">route_based_on_action</code> function.</li>
  <li><code class="language-plaintext highlighter-rouge">path_map = {"route_to_tool": "search_tool", ...}</code>: This dictionary maps the string returned by <code class="language-plaintext highlighter-rouge">route_based_on_action</code> to the actual next node to execute.</li>
</ul>

<p><strong>Step 5: Run It!</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Scenario 1: Query needs the tool
</span><span class="k">print</span><span class="p">(</span><span class="s">"--- Scenario 1: Weather Query ---"</span><span class="p">)</span>
<span class="n">input1</span> <span class="o">=</span> <span class="p">{</span><span class="s">"user_query"</span><span class="p">:</span> <span class="s">"What's the weather like?"</span><span class="p">}</span>
<span class="n">final_state1</span> <span class="o">=</span> <span class="n">app</span><span class="p">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">input1</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Final State 1:"</span><span class="p">,</span> <span class="n">final_state1</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">--- Scenario 2: Direct Response ---"</span><span class="p">)</span>
<span class="c1"># Scenario 2: Query doesn't need the tool
</span><span class="n">input2</span> <span class="o">=</span> <span class="p">{</span><span class="s">"user_query"</span><span class="p">:</span> <span class="s">"Tell me a joke."</span><span class="p">}</span>
<span class="n">final_state2</span> <span class="o">=</span> <span class="n">app</span><span class="p">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">input2</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Final State 2:"</span><span class="p">,</span> <span class="n">final_state2</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Expected Output:</strong></p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--- Scenario 1: Weather Query ---
--- Determining Action ---
Decision: Need to use search tool for weather.
--- Routing ---
Routing based on action: USE_TOOL
--- Using Search Tool ---
--- Generating Response ---
Final State 1: {'user_query': "What's the weather like?", 'next_action': 'USE_TOOL', 'search_result': ["Search result for 'What's the weather like?': It's sunny!"], 'final_response': "Based on my search: Search result for 'What's the weather like?': It's sunny!"}

--- Scenario 2: Direct Response ---
--- Determining Action ---
Decision: Can respond directly.
--- Routing ---
Routing based on action: RESPOND
--- Generating Response ---
Final State 2: {'user_query': 'Tell me a joke.', 'next_action': 'RESPOND', 'search_result': [], 'final_response': 'Responding directly to: Tell me a joke.'}
</code></pre></div></div>

<p>See how the graph took different paths based on the <code class="language-plaintext highlighter-rouge">next_action</code> set by the <code class="language-plaintext highlighter-rouge">decider</code> node and interpreted by the <code class="language-plaintext highlighter-rouge">route_based_on_action</code> function!</p>

<p><strong>Visualizing the Branch:</strong></p>

<pre><code class="language-mermaid">graph TD
    Start[START] --&gt; Decider(decider);
    Decider -- route_based_on_action --&gt; Route{Routing Logic};
    Route -- "route_to_tool" --&gt; Search(search_tool);
    Route -- "route_to_respond" --&gt; Respond(responder);
    Search --&gt; Respond;
    Respond --&gt; End(END);
</code></pre>

<p><strong>Internals (<code class="language-plaintext highlighter-rouge">graph/branch.py</code>)</strong></p>

<ul>
  <li>When you call <code class="language-plaintext highlighter-rouge">add_conditional_edges</code>, LangGraph stores a <code class="language-plaintext highlighter-rouge">Branch</code> object (<code class="language-plaintext highlighter-rouge">graph/branch.py</code>). This object holds your routing function (<code class="language-plaintext highlighter-rouge">path</code>) and the mapping (<code class="language-plaintext highlighter-rouge">path_map</code> / <code class="language-plaintext highlighter-rouge">ends</code>).</li>
  <li>During execution, after the source node (“decider”) finishes, the <a href="05_pregel_execution_engine.md">Pregel Execution Engine</a> runs the <code class="language-plaintext highlighter-rouge">Branch</code> object.</li>
  <li>The <code class="language-plaintext highlighter-rouge">Branch.run()</code> method eventually calls your routing function (<code class="language-plaintext highlighter-rouge">_route</code> or <code class="language-plaintext highlighter-rouge">_aroute</code> internally) with the current state.</li>
  <li>It takes the return value (e.g., “route_to_tool”), looks it up in the <code class="language-plaintext highlighter-rouge">ends</code> dictionary to get the actual node name (“search_tool”), and tells the engine to schedule that node next.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># graph/branch.py (Simplified view)
</span><span class="k">class</span> <span class="nc">Branch</span><span class="p">(</span><span class="n">NamedTuple</span><span class="p">):</span>
    <span class="n">path</span><span class="p">:</span> <span class="n">Runnable</span> <span class="c1"># Your routing function wrapped as a Runnable
</span>    <span class="n">ends</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="n">Hashable</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="c1"># Your path_map
</span>    <span class="c1"># ... other fields ...
</span>
    <span class="k">def</span> <span class="nf">_route</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">input</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">RunnableConfig</span><span class="p">,</span> <span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Runnable</span><span class="p">:</span>
        <span class="c1"># ... reads current state if needed ...
</span>        <span class="n">value</span> <span class="o">=</span> <span class="p">...</span> <span class="c1"># Get the state
</span>        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span> <span class="c1"># Call your routing function
</span>        <span class="c1"># ... determines destination node(s) using self.ends mapping ...
</span>        <span class="n">destinations</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">ends</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">result</span><span class="p">]</span>
        <span class="c1"># ... tells the engine (via writer) which node(s) to run next ...
</span>        <span class="k">return</span> <span class="n">writer</span><span class="p">(</span><span class="n">destinations</span><span class="p">,</span> <span class="n">config</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">input</span> <span class="c1"># writer is a callback to the engine
</span>
<span class="c1"># graph/state.py (Simplified view)
</span><span class="k">class</span> <span class="nc">StateGraph</span><span class="p">(</span><span class="n">Graph</span><span class="p">):</span>
    <span class="c1"># ...
</span>    <span class="k">def</span> <span class="nf">add_conditional_edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">path_map</span><span class="p">,</span> <span class="p">...):</span>
        <span class="c1"># ... wrap 'path' into a Runnable ...
</span>        <span class="n">runnable_path</span> <span class="o">=</span> <span class="n">coerce_to_runnable</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="p">...)</span>
        <span class="c1"># Create and store the Branch object
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">branches</span><span class="p">[</span><span class="n">source</span><span class="p">][</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Branch</span><span class="p">.</span><span class="n">from_path</span><span class="p">(</span><span class="n">runnable_path</span><span class="p">,</span> <span class="n">path_map</span><span class="p">,</span> <span class="p">...)</span>
        <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></div>

<h2 id="2-send---directing-specific-traffic">2. <code class="language-plaintext highlighter-rouge">Send</code> - Directing Specific Traffic</h2>

<p>Sometimes, you don’t just want to choose <em>one</em> path, but you want to trigger a <em>specific</em> node with <em>specific</em> data, possibly multiple times. This is common in “map-reduce” patterns where you split a task into smaller pieces, process each piece independently, and then combine the results.</p>

<p>The <code class="language-plaintext highlighter-rouge">Send</code> primitive allows a node (or a conditional edge function) to directly “send” a piece of data to another node, telling the engine: “Run <em>this</em> node next, and give it <em>this</em> input.”</p>

<p><strong>How it Works:</strong></p>

<ol>
  <li>You import <code class="language-plaintext highlighter-rouge">Send</code> from <code class="language-plaintext highlighter-rouge">langgraph.graph</code> (or <code class="language-plaintext highlighter-rouge">langgraph.types</code>).</li>
  <li>In a node or a conditional edge function, instead of just returning a state update or a node name, you return <code class="language-plaintext highlighter-rouge">Send(target_node_name, data_for_that_node)</code>.</li>
  <li>You can return a list of <code class="language-plaintext highlighter-rouge">Send</code> objects to trigger multiple node executions, potentially in parallel (depending on the executor).</li>
</ol>

<p><strong>Example: Simple Map-Reduce</strong></p>

<p>Let’s imagine we want to process a list of items. One node splits the list, another node processes each item individually (the “map” step), and a final node aggregates the results (the “reduce” step).</p>

<p><strong>Step 1: Define State</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Annotated</span>
<span class="kn">import</span> <span class="nn">operator</span>

<span class="k">class</span> <span class="nc">MapReduceState</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">items_to_process</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="c1"># Use Topic or operator.add to collect results from worker nodes
</span>    <span class="n">processed_items</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">operator</span><span class="p">.</span><span class="n">add</span><span class="p">]</span>
    <span class="n">final_result</span><span class="p">:</span> <span class="nb">str</span>
</code></pre></div></div>

<p><strong>Step 2: Define Nodes</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Node to prepare items (not really needed here, but shows the flow)
</span><span class="k">def</span> <span class="nf">prepare_items</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">MapReduceState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"--- Preparing Items (No change) ---"</span><span class="p">)</span>
    <span class="c1"># In a real scenario, this might fetch or generate the items
</span>    <span class="k">return</span> <span class="p">{}</span>

<span class="c1"># Node to process a single item (Our "Worker")
</span><span class="k">def</span> <span class="nf">process_single_item</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="c1"># Note: This node receives the dict passed via Send, NOT the full MapReduceState
</span>    <span class="n">item</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">'item'</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"--- Processing Item: </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s"> ---"</span><span class="p">)</span>
    <span class="n">processed</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"Processed_</span><span class="si">{</span><span class="n">item</span><span class="p">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s">"</span>
    <span class="c1"># Return the processed item to be ADDED to the list in the main state
</span>    <span class="k">return</span> <span class="p">{</span><span class="s">"processed_items"</span><span class="p">:</span> <span class="p">[</span><span class="n">processed</span><span class="p">]}</span> <span class="c1"># Return list for operator.add
</span>
<span class="c1"># Node to aggregate results
</span><span class="k">def</span> <span class="nf">aggregate_results</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">MapReduceState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"--- Aggregating Results ---"</span><span class="p">)</span>
    <span class="n">all_processed</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">'processed_items'</span><span class="p">]</span>
    <span class="n">final</span> <span class="o">=</span> <span class="s">", "</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">all_processed</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">"final_result"</span><span class="p">:</span> <span class="n">final</span><span class="p">}</span>
</code></pre></div></div>

<p><strong>Step 3: Define the Dispatching Function (using <code class="language-plaintext highlighter-rouge">Send</code>)</strong></p>

<p>This function will run after <code class="language-plaintext highlighter-rouge">prepare_items</code> and will use <code class="language-plaintext highlighter-rouge">Send</code> to trigger <code class="language-plaintext highlighter-rouge">process_single_item</code> for each item.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">langgraph.graph</span> <span class="kn">import</span> <span class="n">Send</span> <span class="c1"># Import Send
</span>
<span class="k">def</span> <span class="nf">dispatch_work</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">MapReduceState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Send</span><span class="p">]:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"--- Dispatching Work ---"</span><span class="p">)</span>
    <span class="n">items</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">'items_to_process'</span><span class="p">]</span>
    <span class="n">send_packets</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Sending item '</span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s">' to worker node."</span><span class="p">)</span>
        <span class="c1"># Create a Send object for each item
</span>        <span class="c1"># Target node: "worker"
</span>        <span class="c1"># Data payload: a dictionary {'item': current_item}
</span>        <span class="n">packet</span> <span class="o">=</span> <span class="n">Send</span><span class="p">(</span><span class="s">"worker"</span><span class="p">,</span> <span class="p">{</span><span class="s">"item"</span><span class="p">:</span> <span class="n">item</span><span class="p">})</span>
        <span class="n">send_packets</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">packet</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">send_packets</span> <span class="c1"># Return a list of Send objects
</span></code></pre></div></div>

<p><strong>Step 4: Build the Graph</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">langgraph.graph</span> <span class="kn">import</span> <span class="n">StateGraph</span><span class="p">,</span> <span class="n">END</span><span class="p">,</span> <span class="n">START</span>

<span class="n">workflow</span> <span class="o">=</span> <span class="n">StateGraph</span><span class="p">(</span><span class="n">MapReduceState</span><span class="p">)</span>

<span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"preparer"</span><span class="p">,</span> <span class="n">prepare_items</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"worker"</span><span class="p">,</span> <span class="n">process_single_item</span><span class="p">)</span> <span class="c1"># The node targeted by Send
</span><span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"aggregator"</span><span class="p">,</span> <span class="n">aggregate_results</span><span class="p">)</span>

<span class="n">workflow</span><span class="p">.</span><span class="n">set_entry_point</span><span class="p">(</span><span class="s">"preparer"</span><span class="p">)</span>

<span class="c1"># After 'preparer', call 'dispatch_work' which returns Send packets
</span><span class="n">workflow</span><span class="p">.</span><span class="n">add_conditional_edges</span><span class="p">(</span><span class="s">"preparer"</span><span class="p">,</span> <span class="n">dispatch_work</span><span class="p">)</span>
<span class="c1"># NOTE: We don't need a path_map here because dispatch_work directly
#       returns Send objects specifying the target node.
</span>
<span class="c1"># The 'worker' node outputs are aggregated implicitly by the 'processed_items' channel.
# We need an edge to tell the graph when to run the aggregator.
# Let's wait until ALL workers triggered by Send are done.
# We can achieve this implicitly if the aggregator reads state written by workers.
# A simple edge ensures aggregator runs *after* the step involving workers.
# (More complex aggregation might need explicit barrier channels)
</span><span class="n">workflow</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">"worker"</span><span class="p">,</span> <span class="s">"aggregator"</span><span class="p">)</span>

<span class="n">workflow</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">"aggregator"</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>

<span class="c1"># Compile
</span><span class="n">app</span> <span class="o">=</span> <span class="n">workflow</span><span class="p">.</span><span class="nb">compile</span><span class="p">()</span>
</code></pre></div></div>

<p><strong>Step 5: Run It!</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">input_state</span> <span class="o">=</span> <span class="p">{</span><span class="s">"items_to_process"</span><span class="p">:</span> <span class="p">[</span><span class="s">"apple"</span><span class="p">,</span> <span class="s">"banana"</span><span class="p">,</span> <span class="s">"cherry"</span><span class="p">]}</span>
<span class="n">final_state</span> <span class="o">=</span> <span class="n">app</span><span class="p">.</span><span class="n">invoke</span><span class="p">(</span><span class="n">input_state</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Final State:"</span><span class="p">,</span> <span class="n">final_state</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Expected Output (order of processing might vary):</strong></p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--- Preparing Items (No change) ---
--- Dispatching Work ---
Sending item 'apple' to worker node.
Sending item 'banana' to worker node.
Sending item 'cherry' to worker node.
--- Processing Item: apple ---
--- Processing Item: banana ---
--- Processing Item: cherry ---
--- Aggregating Results ---

Final State: {'items_to_process': ['apple', 'banana', 'cherry'], 'processed_items': ['Processed_APPLE', 'Processed_BANANA', 'Processed_CHERRY'], 'final_result': 'Processed_APPLE, Processed_BANANA, Processed_CHERRY'}
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">dispatch_work</code> function returned three <code class="language-plaintext highlighter-rouge">Send</code> objects. The LangGraph engine then scheduled the “worker” node to run three times, each time with a different input dictionary (<code class="language-plaintext highlighter-rouge">{'item': 'apple'}</code>, <code class="language-plaintext highlighter-rouge">{'item': 'banana'}</code>, <code class="language-plaintext highlighter-rouge">{'item': 'cherry'}</code>). The results were automatically collected in <code class="language-plaintext highlighter-rouge">processed_items</code> thanks to the <code class="language-plaintext highlighter-rouge">operator.add</code> reducer on our <code class="language-plaintext highlighter-rouge">Annotated</code> state key. Finally, the <code class="language-plaintext highlighter-rouge">aggregator</code> ran.</p>

<p><strong>Internals (<code class="language-plaintext highlighter-rouge">types.py</code>, <code class="language-plaintext highlighter-rouge">constants.py</code>)</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Send(node, arg)</code> is a simple data class defined in <code class="language-plaintext highlighter-rouge">langgraph/types.py</code>.</li>
  <li>When a node or branch returns <code class="language-plaintext highlighter-rouge">Send</code> objects, the engine collects them. Internally, these are often associated with a special channel key like <code class="language-plaintext highlighter-rouge">TASKS</code> (defined in <code class="language-plaintext highlighter-rouge">langgraph/constants.py</code>).</li>
  <li>The <a href="05_pregel_execution_engine.md">Pregel Execution Engine</a> processes these <code class="language-plaintext highlighter-rouge">TASKS</code>. For each <code class="language-plaintext highlighter-rouge">Send(node, arg)</code>, it schedules the target <code class="language-plaintext highlighter-rouge">node</code> to run in the <em>next</em> step, passing <code class="language-plaintext highlighter-rouge">arg</code> as its input.</li>
  <li>This allows for dynamic, data-driven invocation of nodes outside the standard edge connections.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># types.py (Simplified view)
</span><span class="k">class</span> <span class="nc">Send</span><span class="p">:</span>
    <span class="n">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s">"node"</span><span class="p">,</span> <span class="s">"arg"</span><span class="p">)</span>
    <span class="n">node</span><span class="p">:</span> <span class="nb">str</span> <span class="c1"># Target node name
</span>    <span class="n">arg</span><span class="p">:</span> <span class="n">Any</span>  <span class="c1"># Data payload for the node
</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">/</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">arg</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">arg</span> <span class="o">=</span> <span class="n">arg</span>
    <span class="c1"># ... repr, eq, hash ...
</span>
<span class="c1"># constants.py (Simplified view)
</span><span class="n">TASKS</span> <span class="o">=</span> <span class="n">sys</span><span class="p">.</span><span class="nb">intern</span><span class="p">(</span><span class="s">"__pregel_tasks"</span><span class="p">)</span> <span class="c1"># Internal key for Send objects
</span>
<span class="c1"># pregel/algo.py (Conceptual idea during task processing)
# if write is for TASKS channel:
#   packet = write_value # This is the Send object
#   # Schedule packet.node to run in the next step with packet.arg
#   schedule_task(node=packet.node, input=packet.arg, ...)
</span></code></pre></div></div>

<h2 id="3-interrupt---pausing-for-instructions">3. <code class="language-plaintext highlighter-rouge">Interrupt</code> - Pausing for Instructions</h2>

<p>Sometimes, your graph needs to stop and wait for external input before proceeding. A common case is Human-in-the-Loop (HITL), where an AI agent proposes a plan or an action, and a human needs to approve it.</p>

<p>The <code class="language-plaintext highlighter-rouge">Interrupt</code> primitive allows a node to pause the graph’s execution and wait. This requires a <a href="06_checkpointer___basecheckpointsaver__.md">Checkpointer</a> to be configured, as the graph needs to save its state to be resumable later.</p>

<p><strong>How it Works:</strong></p>

<ol>
  <li>You import <code class="language-plaintext highlighter-rouge">interrupt</code> from <code class="language-plaintext highlighter-rouge">langgraph.types</code>.</li>
  <li>Inside a node, you call <code class="language-plaintext highlighter-rouge">interrupt(value_to_send_to_client)</code>.</li>
  <li>This immediately raises a special <code class="language-plaintext highlighter-rouge">GraphInterrupt</code> exception.</li>
  <li>The LangGraph engine catches this, saves the current state using the checkpointer, and returns control to your calling code, often signaling that an interrupt occurred. The <code class="language-plaintext highlighter-rouge">value_to_send_to_client</code> is included in the information returned.</li>
  <li>Later, you can resume the graph execution by providing a value. This is typically done by invoking the compiled graph again with a special <code class="language-plaintext highlighter-rouge">Command(resume=value_for_interrupt)</code> object (from <code class="language-plaintext highlighter-rouge">langgraph.types</code>) and the same configuration (including the thread ID for the checkpointer).</li>
  <li>When resumed, the graph loads the saved state. The execution engine restarts the <em>interrupted node from the beginning</em>. When the code reaches the <code class="language-plaintext highlighter-rouge">interrupt()</code> call again, instead of raising an exception, it <em>returns</em> the <code class="language-plaintext highlighter-rouge">value_for_interrupt</code> that you provided when resuming. The node then continues executing from that point.</li>
</ol>

<p><strong>Example: Human Approval Step</strong></p>

<p>Let’s create a graph where a node plans an action, another node presents it for human approval (using <code class="language-plaintext highlighter-rouge">interrupt</code>), and a final node executes it if approved.</p>

<p><strong>Step 1: Define State</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Optional</span>

<span class="k">class</span> <span class="nc">ApprovalState</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">plan</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># We'll use the resume value to implicitly know if approved
</span>    <span class="n">feedback</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="c1"># Store feedback/approval status
</span></code></pre></div></div>

<p><strong>Step 2: Define Nodes (including interrupt)</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">langgraph.types</span> <span class="kn">import</span> <span class="n">interrupt</span><span class="p">,</span> <span class="n">Command</span> <span class="c1"># Import interrupt and Command
</span>
<span class="c1"># Node that creates a plan
</span><span class="k">def</span> <span class="nf">create_plan</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">ApprovalState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"--- Creating Plan ---"</span><span class="p">)</span>
    <span class="n">plan</span> <span class="o">=</span> <span class="s">"Plan: Execute risky action X."</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">"plan"</span><span class="p">:</span> <span class="n">plan</span><span class="p">}</span>

<span class="c1"># Node that requests human approval using interrupt
</span><span class="k">def</span> <span class="nf">request_approval</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">ApprovalState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"--- Requesting Human Approval ---"</span><span class="p">)</span>
    <span class="n">plan</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">'plan'</span><span class="p">]</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Proposed Plan: </span><span class="si">{</span><span class="n">plan</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="c1"># Call interrupt, passing the plan to the client
</span>    <span class="c1"># Execution STOPS here on the first run.
</span>    <span class="n">feedback_or_approval</span> <span class="o">=</span> <span class="n">interrupt</span><span class="p">(</span><span class="n">plan</span><span class="p">)</span>
    <span class="c1"># --- Execution RESUMES here on the second run ---
</span>    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"--- Resumed with feedback: </span><span class="si">{</span><span class="n">feedback_or_approval</span><span class="si">}</span><span class="s"> ---"</span><span class="p">)</span>
    <span class="c1"># Store the feedback received from the resume command
</span>    <span class="k">return</span> <span class="p">{</span><span class="s">"feedback"</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">feedback_or_approval</span><span class="p">)}</span> <span class="c1"># Ensure it's a string
</span>
<span class="c1"># Node that executes the plan (only if approved implicitly by resuming)
</span><span class="k">def</span> <span class="nf">execute_plan</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">ApprovalState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"--- Executing Plan ---"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">state</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"feedback"</span><span class="p">):</span> <span class="c1"># Check if we got feedback (meaning we resumed)
</span>        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Executing '</span><span class="si">{</span><span class="n">state</span><span class="p">[</span><span class="s">'plan'</span><span class="p">]</span><span class="si">}</span><span class="s">' based on feedback: </span><span class="si">{</span><span class="n">state</span><span class="p">[</span><span class="s">'feedback'</span><span class="p">]</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{}</span> <span class="c1"># No state change needed
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># This path shouldn't be hit if interrupt works correctly
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"Execution skipped (no feedback received)."</span><span class="p">)</span>
        <span class="k">return</span><span class="p">{}</span>

</code></pre></div></div>

<p><strong>Step 3: Build the Graph (with Checkpointer!)</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">langgraph.graph</span> <span class="kn">import</span> <span class="n">StateGraph</span><span class="p">,</span> <span class="n">END</span><span class="p">,</span> <span class="n">START</span>
<span class="c1"># Need a checkpointer for interrupts!
</span><span class="kn">from</span> <span class="nn">langgraph.checkpoint.memory</span> <span class="kn">import</span> <span class="n">MemorySaver</span>

<span class="n">workflow</span> <span class="o">=</span> <span class="n">StateGraph</span><span class="p">(</span><span class="n">ApprovalState</span><span class="p">)</span>

<span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"planner"</span><span class="p">,</span> <span class="n">create_plan</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"approval_gate"</span><span class="p">,</span> <span class="n">request_approval</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"executor"</span><span class="p">,</span> <span class="n">execute_plan</span><span class="p">)</span>

<span class="n">workflow</span><span class="p">.</span><span class="n">set_entry_point</span><span class="p">(</span><span class="s">"planner"</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">"planner"</span><span class="p">,</span> <span class="s">"approval_gate"</span><span class="p">)</span>
<span class="n">workflow</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">"approval_gate"</span><span class="p">,</span> <span class="s">"executor"</span><span class="p">)</span> <span class="c1"># Runs after interrupt is resolved
</span><span class="n">workflow</span><span class="p">.</span><span class="n">add_edge</span><span class="p">(</span><span class="s">"executor"</span><span class="p">,</span> <span class="n">END</span><span class="p">)</span>

<span class="c1"># Create checkpointer and compile
</span><span class="n">memory_saver</span> <span class="o">=</span> <span class="n">MemorySaver</span><span class="p">()</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">workflow</span><span class="p">.</span><span class="nb">compile</span><span class="p">(</span><span class="n">checkpointer</span><span class="o">=</span><span class="n">memory_saver</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Step 4: Run and Resume</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">uuid</span>

<span class="c1"># Unique ID for this conversation thread is needed for the checkpointer
</span><span class="n">config</span> <span class="o">=</span> <span class="p">{</span><span class="s">"configurable"</span><span class="p">:</span> <span class="p">{</span><span class="s">"thread_id"</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="p">.</span><span class="n">uuid4</span><span class="p">())}}</span>

<span class="k">print</span><span class="p">(</span><span class="s">"--- Initial Invocation ---"</span><span class="p">)</span>
<span class="c1"># Start the graph. It should interrupt at the approval node.
</span><span class="n">interrupt_info</span> <span class="o">=</span> <span class="bp">None</span>
<span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">app</span><span class="p">.</span><span class="n">stream</span><span class="p">({</span><span class="s">"plan"</span><span class="p">:</span> <span class="s">""</span><span class="p">},</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
    <span class="c1"># Check if the chunk contains interrupt information
</span>    <span class="k">if</span> <span class="s">"__interrupt__"</span> <span class="ow">in</span> <span class="n">chunk</span><span class="p">:</span>
        <span class="n">interrupt_info</span> <span class="o">=</span> <span class="n">chunk</span><span class="p">[</span><span class="s">"__interrupt__"</span><span class="p">]</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">!! Graph Interrupted !!"</span><span class="p">)</span>
        <span class="k">break</span> <span class="c1"># Stop processing stream after interrupt
</span>
<span class="c1"># The client code inspects the interrupt value (the plan)
</span><span class="k">if</span> <span class="n">interrupt_info</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Interrupt Value (Plan): </span><span class="si">{</span><span class="n">interrupt_info</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span><span class="si">}</span><span class="s">"</span><span class="p">)</span> <span class="c1"># interrupt_info is a tuple
</span>
    <span class="c1"># --- Simulate human interaction ---
</span>    <span class="n">human_decision</span> <span class="o">=</span> <span class="s">"Approved, proceed with caution."</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">--- Resuming with Decision: '</span><span class="si">{</span><span class="n">human_decision</span><span class="si">}</span><span class="s">' ---"</span><span class="p">)</span>

    <span class="c1"># Resume execution with the human's feedback/approval
</span>    <span class="c1"># We pass the decision using Command(resume=...)
</span>    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">app</span><span class="p">.</span><span class="n">stream</span><span class="p">(</span><span class="n">Command</span><span class="p">(</span><span class="n">resume</span><span class="o">=</span><span class="n">human_decision</span><span class="p">),</span> <span class="n">config</span><span class="o">=</span><span class="n">config</span><span class="p">):</span>
         <span class="k">print</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>

<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Graph finished without interruption."</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Expected Output:</strong></p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--- Initial Invocation ---
{'planner': {'plan': 'Plan: Execute risky action X.'}}
{'approval_gate': None} # Node starts execution
--- Requesting Human Approval ---
Proposed Plan: Plan: Execute risky action X.
{'__interrupt__': (Interrupt(value='Plan: Execute risky action X.', resumable=True, ns=..., when='during'),)} # Interrupt occurs

!! Graph Interrupted !!
Interrupt Value (Plan): Plan: Execute risky action X.

--- Resuming with Decision: 'Approved, proceed with caution.' ---
{'approval_gate': {'feedback': 'Approved, proceed with caution.'}} # Node resumes and finishes
--- Resumed with feedback: Approved, proceed with caution. ---
{'executor': {}} # Executor node runs
--- Executing Plan ---
Executing 'Plan: Execute risky action X.' based on feedback: Approved, proceed with caution.
{'__end__': {'plan': 'Plan: Execute risky action X.', 'feedback': 'Approved, proceed with caution.'}} # Graph finishes
</code></pre></div></div>

<p>The graph paused at <code class="language-plaintext highlighter-rouge">request_approval</code> after printing the plan. We then resumed it by sending <code class="language-plaintext highlighter-rouge">Command(resume="Approved, proceed with caution.")</code>. The <code class="language-plaintext highlighter-rouge">request_approval</code> node restarted, the <code class="language-plaintext highlighter-rouge">interrupt()</code> call returned our resume value, which was stored in the state, and finally, the <code class="language-plaintext highlighter-rouge">executor</code> node ran using that feedback.</p>

<p><strong>Internals (<code class="language-plaintext highlighter-rouge">types.py</code>, <code class="language-plaintext highlighter-rouge">errors.py</code>, Checkpointer)</strong></p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">interrupt(value)</code> function (in <code class="language-plaintext highlighter-rouge">langgraph/types.py</code>) checks if a resume value is available for the current step within the node.</li>
  <li>If no resume value exists (first run), it raises a <code class="language-plaintext highlighter-rouge">GraphInterrupt</code> exception (<code class="language-plaintext highlighter-rouge">langgraph/errors.py</code>) containing an <code class="language-plaintext highlighter-rouge">Interrupt</code> object (<code class="language-plaintext highlighter-rouge">langgraph/types.py</code>) which holds the <code class="language-plaintext highlighter-rouge">value</code>.</li>
  <li>The <a href="05_pregel_execution_engine.md">Pregel Execution Engine</a> catches <code class="language-plaintext highlighter-rouge">GraphInterrupt</code>.</li>
  <li>If a <a href="06_checkpointer___basecheckpointsaver__.md">Checkpointer</a> is present, the engine saves the current state (including which node was interrupted) and passes the <code class="language-plaintext highlighter-rouge">Interrupt</code> object back to the caller.</li>
  <li>When you resume with <code class="language-plaintext highlighter-rouge">Command(resume=resume_value)</code>, the engine loads the checkpoint.</li>
  <li>It knows which node was interrupted and provides the <code class="language-plaintext highlighter-rouge">resume_value</code> to it (often via a special <code class="language-plaintext highlighter-rouge">RESUME</code> entry written to the state channels, managed internally via <code class="language-plaintext highlighter-rouge">PregelScratchpad</code> in <code class="language-plaintext highlighter-rouge">pregel/algo.py</code>).</li>
  <li>The node restarts. When <code class="language-plaintext highlighter-rouge">interrupt()</code> is called again, it finds the <code class="language-plaintext highlighter-rouge">resume_value</code> (provided via the scratchpad or internal state) and returns it instead of raising an exception.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># types.py (Simplified view)
</span><span class="k">def</span> <span class="nf">interrupt</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="c1"># ... access internal config/scratchpad ...
</span>    <span class="n">scratchpad</span> <span class="o">=</span> <span class="n">conf</span><span class="p">[</span><span class="n">CONFIG_KEY_SCRATCHPAD</span><span class="p">]</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">scratchpad</span><span class="p">.</span><span class="n">interrupt_counter</span><span class="p">()</span>

    <span class="c1"># Check if resume value already exists for this interrupt index
</span>    <span class="k">if</span> <span class="n">scratchpad</span><span class="p">.</span><span class="n">resume</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">scratchpad</span><span class="p">.</span><span class="n">resume</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">scratchpad</span><span class="p">.</span><span class="n">resume</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="c1"># Return existing resume value
</span>
    <span class="c1"># Check if a new global resume value was provided
</span>    <span class="n">v</span> <span class="o">=</span> <span class="n">scratchpad</span><span class="p">.</span><span class="n">get_null_resume</span><span class="p">(</span><span class="n">consume</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Store and return the new resume value
</span>        <span class="n">scratchpad</span><span class="p">.</span><span class="n">resume</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">conf</span><span class="p">[</span><span class="n">CONFIG_KEY_SEND</span><span class="p">]([(</span><span class="n">RESUME</span><span class="p">,</span> <span class="n">scratchpad</span><span class="p">.</span><span class="n">resume</span><span class="p">)])</span> <span class="c1"># Update state internally
</span>        <span class="k">return</span> <span class="n">v</span>

    <span class="c1"># No resume value - raise the interrupt exception
</span>    <span class="k">raise</span> <span class="n">GraphInterrupt</span><span class="p">(</span>
        <span class="p">(</span><span class="n">Interrupt</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">resumable</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ns</span><span class="o">=</span><span class="p">...),)</span>
    <span class="p">)</span>

<span class="c1"># types.py (Simplified view)
</span><span class="o">@</span><span class="n">dataclasses</span><span class="p">.</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">Interrupt</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Any</span> <span class="c1"># The value passed to interrupt()
</span>    <span class="n">resumable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="c1"># ... other fields ...
</span>
<span class="c1"># types.py (Simplified view)
</span><span class="o">@</span><span class="n">dataclasses</span><span class="p">.</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">Command</span><span class="p">:</span>
    <span class="c1"># ... other fields like update, goto ...
</span>    <span class="n">resume</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># Value to provide to a pending interrupt
</span>
<span class="c1"># errors.py (Simplified view)
</span><span class="k">class</span> <span class="nc">GraphInterrupt</span><span class="p">(</span><span class="nb">Exception</span><span class="p">):</span> <span class="c1"># Base class for interrupts
</span>    <span class="k">pass</span>
</code></pre></div></div>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve learned about the essential tools for controlling the flow of execution in your LangGraph applications:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Branch</code></strong> (<code class="language-plaintext highlighter-rouge">add_conditional_edges</code>): Used to create conditional paths, like <code class="language-plaintext highlighter-rouge">if/else</code> statements, directing the flow based on the current state. Requires a routing function and often a path map.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Send</code></strong>: Used to directly trigger a specific node with specific data, bypassing normal edges. Essential for patterns like map-reduce where you want to invoke the same worker node multiple times with different inputs.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Interrupt</code></strong> (<code class="language-plaintext highlighter-rouge">langgraph.types.interrupt</code>): Used to pause graph execution, typically for human-in-the-loop scenarios. Requires a checkpointer and is resumed using <code class="language-plaintext highlighter-rouge">Command(resume=...)</code>.</li>
</ul>

<p>These primitives transform your graph from a simple linear sequence into a dynamic, decision-making process capable of handling complex, real-world workflows.</p>

<p>Now that we understand how nodes execute, how state is managed via channels, and how control flow directs traffic, let’s look at the engine that orchestrates all of this behind the scenes.</p>

<p>Next up: <a href="05_pregel_execution_engine.md">Chapter 5: Pregel Execution Engine</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
