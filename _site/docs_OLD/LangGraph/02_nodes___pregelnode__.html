<h1 id="chapter-2-nodes-pregelnode---the-workers-of-your-graph">Chapter 2: Nodes (<code class="language-plaintext highlighter-rouge">PregelNode</code>) - The Workers of Your Graph</h1>

<p>In <a href="01_graph___stategraph.md">Chapter 1: Graph / StateGraph</a>, we learned how <code class="language-plaintext highlighter-rouge">StateGraph</code> acts as a blueprint or a flowchart for our application. It defines the overall structure and the shared “whiteboard” (the State) that holds information.</p>

<p>But who actually does the work? If the <code class="language-plaintext highlighter-rouge">StateGraph</code> is the assembly line blueprint, who are the workers on the line?</p>

<p>That’s where <strong>Nodes</strong> come in!</p>

<h2 id="what-problem-do-nodes-solve">What Problem Do Nodes Solve?</h2>

<p>Think back to our cake baking analogy from Chapter 1. We had steps like “mix dry ingredients,” “mix wet ingredients,” “combine,” etc. Each of these distinct actions needs to be performed by someone or something.</p>

<p>In LangGraph, <strong>Nodes</strong> represent these individual units of work or computation steps within your graph.</p>

<ul>
  <li><strong>Analogy:</strong> Imagine chefs in a kitchen (the graph). Each chef (node) has a specific task: one chops vegetables, another mixes the sauce, another cooks the main course. They all work with shared ingredients (the state) from the pantry and fridge, and they put their finished components back for others to use.</li>
</ul>

<p>Nodes are the core building blocks that perform the actual logic of your application.</p>

<h2 id="key-concepts-what-makes-a-node">Key Concepts: What Makes a Node?</h2>

<ol>
  <li><strong>The Action:</strong> At its heart, a node is usually a Python function or a LangChain Runnable. This is the code that gets executed when the node runs.</li>
  <li><strong>Input:</strong> A node typically reads data it needs from the shared graph <strong>State</strong>. It receives the <em>current</em> state when it’s invoked. In our <code class="language-plaintext highlighter-rouge">StateGraph</code> example from Chapter 1, both <code class="language-plaintext highlighter-rouge">add_one</code> and <code class="language-plaintext highlighter-rouge">multiply_by_two</code> received the <code class="language-plaintext highlighter-rouge">state</code> dictionary containing the current <code class="language-plaintext highlighter-rouge">value</code>.</li>
  <li><strong>Execution:</strong> The node runs its defined logic (the function or Runnable).</li>
  <li><strong>Output:</strong> After executing, a node in a <code class="language-plaintext highlighter-rouge">StateGraph</code> returns a dictionary. This dictionary specifies <em>which parts</em> of the shared state the node wants to <em>update</em> and what the new values should be. LangGraph takes care of merging these updates back into the main state.</li>
</ol>

<h2 id="adding-nodes-to-your-graph-add_node">Adding Nodes to Your Graph (<code class="language-plaintext highlighter-rouge">add_node</code>)</h2>

<p>How do we tell our <code class="language-plaintext highlighter-rouge">StateGraph</code> about these workers? We use the <code class="language-plaintext highlighter-rouge">add_node</code> method.</p>

<p>Let’s revisit the code from Chapter 1:</p>

<p><strong>Step 1: Define the Node Functions</strong></p>

<p>These are our “workers”. They take the state and return updates.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span>

<span class="c1"># Define the state structure (the whiteboard)
</span><span class="k">class</span> <span class="nc">MyState</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">int</span>

<span class="c1"># Node 1: Adds 1 to the value
</span><span class="k">def</span> <span class="nf">add_one</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">MyState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"--- Running Adder Node ---"</span><span class="p">)</span>
    <span class="n">current_value</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">'value'</span><span class="p">]</span>
    <span class="n">new_value</span> <span class="o">=</span> <span class="n">current_value</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Input value: </span><span class="si">{</span><span class="n">current_value</span><span class="si">}</span><span class="s">, Output value: </span><span class="si">{</span><span class="n">new_value</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="c1"># Return *only* the key we want to update
</span>    <span class="k">return</span> <span class="p">{</span><span class="s">"value"</span><span class="p">:</span> <span class="n">new_value</span><span class="p">}</span>

<span class="c1"># Node 2: Multiplies the value by 2
</span><span class="k">def</span> <span class="nf">multiply_by_two</span><span class="p">(</span><span class="n">state</span><span class="p">:</span> <span class="n">MyState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"--- Running Multiplier Node ---"</span><span class="p">)</span>
    <span class="n">current_value</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s">'value'</span><span class="p">]</span>
    <span class="n">new_value</span> <span class="o">=</span> <span class="n">current_value</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Input value: </span><span class="si">{</span><span class="n">current_value</span><span class="si">}</span><span class="s">, Output value: </span><span class="si">{</span><span class="n">new_value</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="c1"># Return the update
</span>    <span class="k">return</span> <span class="p">{</span><span class="s">"value"</span><span class="p">:</span> <span class="n">new_value</span><span class="p">}</span>
</code></pre></div></div>

<p><strong>Step 2: Create the Graph and Add Nodes</strong></p>

<p>Here’s where we hire our workers and assign them names on the assembly line.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">langgraph.graph</span> <span class="kn">import</span> <span class="n">StateGraph</span>

<span class="c1"># Create the graph builder linked to our state
</span><span class="n">workflow</span> <span class="o">=</span> <span class="n">StateGraph</span><span class="p">(</span><span class="n">MyState</span><span class="p">)</span>

<span class="c1"># Add the first node:
# Give it the name "adder" and tell it to use the 'add_one' function
</span><span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"adder"</span><span class="p">,</span> <span class="n">add_one</span><span class="p">)</span>

<span class="c1"># Add the second node:
# Give it the name "multiplier" and tell it to use the 'multiply_by_two' function
</span><span class="n">workflow</span><span class="p">.</span><span class="n">add_node</span><span class="p">(</span><span class="s">"multiplier"</span><span class="p">,</span> <span class="n">multiply_by_two</span><span class="p">)</span>

<span class="c1"># (Edges like set_entry_point, add_edge, etc. define the flow *between* nodes)
# ... add edges and compile ...
</span></code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">workflow.add_node("adder", add_one)</code>: This line registers the <code class="language-plaintext highlighter-rouge">add_one</code> function as a node within the <code class="language-plaintext highlighter-rouge">workflow</code> graph. We give it the unique name <code class="language-plaintext highlighter-rouge">"adder"</code>. When the graph needs to execute the “adder” step, it will call our <code class="language-plaintext highlighter-rouge">add_one</code> function.</li>
  <li><code class="language-plaintext highlighter-rouge">workflow.add_node("multiplier", multiply_by_two)</code>: Similarly, this registers the <code class="language-plaintext highlighter-rouge">multiply_by_two</code> function under the name <code class="language-plaintext highlighter-rouge">"multiplier"</code>.</li>
</ul>

<p>It’s that simple! You define what a step does (the function) and then register it with <code class="language-plaintext highlighter-rouge">add_node</code>, giving it a name so you can connect it using edges later.</p>

<h2 id="how-do-nodes-actually-run-under-the-hood">How Do Nodes Actually Run? (Under the Hood)</h2>

<p>You’ve defined the functions and added them as nodes. What happens internally when the graph executes?</p>

<ol>
  <li><strong>Triggering:</strong> The <a href="05_pregel_execution_engine.md">Pregel Execution Engine</a> (LangGraph’s internal coordinator) determines which node should run next based on the graph’s structure (edges) and the current state. For example, after the <code class="language-plaintext highlighter-rouge">START</code> point, it knows to run the entry point node (“adder” in our example).</li>
  <li><strong>Reading State:</strong> Before running the node’s function (<code class="language-plaintext highlighter-rouge">add_one</code>), the engine reads the necessary information from the shared state. It knows what the function needs (the <code class="language-plaintext highlighter-rouge">MyState</code> dictionary). This reading happens via mechanisms called <a href="03_channels.md">Channels</a>, which manage the shared state.</li>
  <li><strong>Invoking the Function:</strong> The engine calls the node’s function (e.g., <code class="language-plaintext highlighter-rouge">add_one</code>), passing the state it just read (<code class="language-plaintext highlighter-rouge">{'value': 5}</code>).</li>
  <li><strong>Executing Logic:</strong> Your function’s code runs (e.g., <code class="language-plaintext highlighter-rouge">5 + 1</code>).</li>
  <li><strong>Receiving Updates:</strong> The engine receives the dictionary returned by the function (e.g., <code class="language-plaintext highlighter-rouge">{'value': 6}</code>).</li>
  <li><strong>Writing State:</strong> The engine uses <a href="03_channels.md">Channels</a> again to update the shared state with the information from the returned dictionary. The state on the “whiteboard” is now modified (e.g., becomes <code class="language-plaintext highlighter-rouge">{'value': 6}</code>).</li>
  <li><strong>Next Step:</strong> The engine then looks for the next edge originating from the completed node (“adder”) to determine what runs next (“multiplier”).</li>
</ol>

<p>Here’s a simplified view of the “adder” node executing:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Engine as Pregel Engine
    participant State (via Channels)
    participant AdderNode as adder (add_one func)

    Engine-&gt;&gt;State (via Channels): Read 'value' (current state is {'value': 5})
    State (via Channels)--&gt;&gt;Engine: Returns {'value': 5}
    Engine-&gt;&gt;AdderNode: Invoke add_one({'value': 5})
    Note over AdderNode: Function executes: 5 + 1 = 6
    AdderNode--&gt;&gt;Engine: Return {'value': 6}
    Engine-&gt;&gt;State (via Channels): Write update: 'value' = 6
    State (via Channels)--&gt;&gt;Engine: Acknowledge (state is now {'value': 6})
    Engine-&gt;&gt;Engine: Find next node based on edge from "adder"
</code></pre>

<h2 id="a-peek-at-the-code-graphstatepy-pregelreadpy">A Peek at the Code (<code class="language-plaintext highlighter-rouge">graph/state.py</code>, <code class="language-plaintext highlighter-rouge">pregel/read.py</code>)</h2>

<p>Let’s look at simplified snippets to see how this maps to the code:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">StateGraph.add_node</code> (<code class="language-plaintext highlighter-rouge">graph/state.py</code>)</strong>:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified view
</span><span class="k">class</span> <span class="nc">StateGraph</span><span class="p">(</span><span class="n">Graph</span><span class="p">):</span>
    <span class="c1"># ... (other methods) ...
</span>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">node</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>            <span class="c1"># The name you give the node (e.g., "adder")
</span>        <span class="n">action</span><span class="p">:</span> <span class="n">RunnableLike</span><span class="p">,</span> <span class="c1"># The function or Runnable (e.g., add_one)
</span>        <span class="o">*</span><span class="p">,</span>
        <span class="c1"># ... other optional parameters ...
</span>        <span class="nb">input</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="c1"># Optional: specific input type for this node
</span>    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="c1"># ... (checks for valid name, etc.) ...
</span>        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">channels</span><span class="p">:</span> <span class="c1"># Can't use a state key name as a node name
</span>            <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(...)</span>

        <span class="c1"># Converts your function into a standard LangChain Runnable if needed
</span>        <span class="n">runnable</span> <span class="o">=</span> <span class="n">coerce_to_runnable</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="p">...)</span>

        <span class="c1"># Stores the node's details, including the runnable and input schema
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">StateNodeSpec</span><span class="p">(</span>
            <span class="n">runnable</span><span class="o">=</span><span class="n">runnable</span><span class="p">,</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="c1"># Optional metadata
</span>            <span class="nb">input</span><span class="o">=</span><span class="nb">input</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">.</span><span class="n">schema</span><span class="p">,</span> <span class="c1"># Default to graph's main state schema
</span>            <span class="c1"># ... other details ...
</span>        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span>
</code></pre></div>    </div>
    <p>When you call <code class="language-plaintext highlighter-rouge">add_node</code>, LangGraph stores your function (<code class="language-plaintext highlighter-rouge">action</code>) under the given <code class="language-plaintext highlighter-rouge">node</code> name. It wraps your function into a standard <code class="language-plaintext highlighter-rouge">Runnable</code> object (<code class="language-plaintext highlighter-rouge">coerce_to_runnable</code>) and keeps track of what input schema it expects (usually the graph’s main state schema). This stored information is a <code class="language-plaintext highlighter-rouge">StateNodeSpec</code>.</p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">CompiledStateGraph.attach_node</code> (<code class="language-plaintext highlighter-rouge">graph/state.py</code>)</strong>:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified view (during graph.compile())
</span><span class="k">class</span> <span class="nc">CompiledStateGraph</span><span class="p">(</span><span class="n">CompiledGraph</span><span class="p">):</span>
    <span class="c1"># ... (other methods) ...
</span>    <span class="k">def</span> <span class="nf">attach_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">StateNodeSpec</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># ... (handles START node specially) ...
</span>        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># Determine what parts of the state this node needs to read
</span>            <span class="n">input_schema</span> <span class="o">=</span> <span class="n">node</span><span class="p">.</span><span class="nb">input</span>
            <span class="n">input_values</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">builder</span><span class="p">.</span><span class="n">schemas</span><span class="p">[</span><span class="n">input_schema</span><span class="p">])</span> <span class="c1"># Keys to read
</span>
            <span class="c1"># Create the internal representation: PregelNode
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">nodes</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">PregelNode</span><span class="p">(</span>
                <span class="n">triggers</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s">"branch:to:</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s">"</span><span class="p">],</span> <span class="c1"># When should this node run? (Connected via Channels)
</span>                <span class="n">channels</span><span class="o">=</span><span class="n">input_values</span><span class="p">,</span> <span class="c1"># What state keys does it read?
</span>                <span class="n">mapper</span><span class="o">=</span><span class="n">_pick_mapper</span><span class="p">(...),</span> <span class="c1"># How to format the input state for the function
</span>                <span class="n">writers</span><span class="o">=</span><span class="p">[</span><span class="n">ChannelWrite</span><span class="p">(...)],</span> <span class="c1"># How to write the output back to state (via Channels)
</span>                <span class="n">bound</span><span class="o">=</span><span class="n">node</span><span class="p">.</span><span class="n">runnable</span><span class="p">,</span> <span class="c1"># The actual function/Runnable to execute!
</span>                <span class="c1"># ... other internal details ...
</span>            <span class="p">)</span>
        <span class="c1"># ...
</span></code></pre></div>    </div>
    <p>During the <code class="language-plaintext highlighter-rouge">compile()</code> step, the information stored in <code class="language-plaintext highlighter-rouge">StateNodeSpec</code> is used to create the actual operational node object, which is internally called <code class="language-plaintext highlighter-rouge">PregelNode</code>. This <code class="language-plaintext highlighter-rouge">PregelNode</code> is the real “worker” managed by the execution engine.</p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">PregelNode</code> (<code class="language-plaintext highlighter-rouge">pregel/read.py</code>)</strong>:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified view
</span><span class="k">class</span> <span class="nc">PregelNode</span><span class="p">(</span><span class="n">Runnable</span><span class="p">):</span>
    <span class="n">channels</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="c1"># State keys to read as input
</span>    <span class="n">triggers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>                          <span class="c1"># Channel updates that activate this node
</span>    <span class="n">mapper</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Any</span><span class="p">]]</span>       <span class="c1"># Function to format input state
</span>    <span class="n">writers</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Runnable</span><span class="p">]</span>                      <span class="c1"># Runnables to write output back to Channels
</span>    <span class="n">bound</span><span class="p">:</span> <span class="n">Runnable</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>                    <span class="c1"># &lt;&lt; THE ACTUAL FUNCTION/RUNNABLE YOU PROVIDED &gt;&gt;
</span>    <span class="c1"># ... other attributes like retry policy, tags, etc. ...
</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">channels</span><span class="p">,</span> <span class="n">triggers</span><span class="p">,</span> <span class="n">writers</span><span class="p">,</span> <span class="n">bound</span><span class="p">,</span> <span class="p">...)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">channels</span> <span class="o">=</span> <span class="n">channels</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">triggers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">triggers</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">writers</span> <span class="o">=</span> <span class="n">writers</span> <span class="ow">or</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">bound</span> <span class="o">=</span> <span class="n">bound</span> <span class="c1"># Your code lives here!
</span>        <span class="c1"># ... initialize other attributes ...
</span>
    <span class="c1"># ... (methods for execution, handled by the Pregel engine) ...
</span></code></pre></div>    </div>
    <p>The <code class="language-plaintext highlighter-rouge">PregelNode</code> object encapsulates everything needed to run your node:</p>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">bound</code>: This holds the actual function or Runnable you passed to <code class="language-plaintext highlighter-rouge">add_node</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">channels</code>: Specifies which parts of the state (managed by <a href="03_channels.md">Channels</a>) to read as input.</li>
      <li><code class="language-plaintext highlighter-rouge">triggers</code>: Specifies which <a href="03_channels.md">Channels</a> must be updated to make this node eligible to run.</li>
      <li><code class="language-plaintext highlighter-rouge">writers</code>: Defines how the output of <code class="language-plaintext highlighter-rouge">bound</code> should be written back to the state using <a href="03_channels.md">Channels</a>.</li>
    </ul>
  </li>
</ul>

<p>Don’t worry too much about <code class="language-plaintext highlighter-rouge">PregelNode</code> details right now. The key idea is that <code class="language-plaintext highlighter-rouge">add_node</code> registers your function, and <code class="language-plaintext highlighter-rouge">compile</code> turns it into an executable component (<code class="language-plaintext highlighter-rouge">PregelNode</code>) that the graph engine can manage, telling it when to run, what state to read, and how to write results back.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve now learned about the “workers” in your LangGraph application: <strong>Nodes</strong>.</p>

<ul>
  <li>Nodes are the individual computational steps defined by Python functions or LangChain Runnables.</li>
  <li>They read from the shared <code class="language-plaintext highlighter-rouge">StateGraph</code> state.</li>
  <li>They execute their logic.</li>
  <li>They return dictionaries specifying updates to the state.</li>
  <li>You add them to your graph using <code class="language-plaintext highlighter-rouge">graph.add_node("node_name", your_function)</code>.</li>
  <li>Internally, they are represented as <code class="language-plaintext highlighter-rouge">PregelNode</code> objects, managed by the execution engine.</li>
</ul>

<p>We have the blueprint (<code class="language-plaintext highlighter-rouge">StateGraph</code>) and the workers (<code class="language-plaintext highlighter-rouge">Nodes</code>). But how exactly does information get passed around? How does the “adder” node’s output (<code class="language-plaintext highlighter-rouge">{'value': 6}</code>) reliably get to the “multiplier” node? How is the state managed efficiently?</p>

<p>That’s the role of <a href="03_channels.md">Chapter 3: Channels</a>, the communication system of the graph.</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
