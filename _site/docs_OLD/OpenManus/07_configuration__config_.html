<h1 id="chapter-7-configuration-config">Chapter 7: Configuration (Config)</h1>

<p>Welcome to Chapter 7! In <a href="06_schema.md">Chapter 6: Schema</a>, we learned how OpenManus uses schemas to define the structure of data passed between different components, like official forms ensuring everyone fills them out correctly.</p>

<p>Now, think about setting up a new application. You often need to tell it <em>how</em> to behave.</p>
<ul>
  <li>Which AI model should it use?</li>
  <li>What’s the secret key to access that AI?</li>
  <li>Should it run code in a restricted “sandbox” environment?</li>
  <li>Which search engine should it prefer?</li>
</ul>

<p>These are all <strong>settings</strong> or <strong>configurations</strong>. This chapter explores how OpenManus manages these settings using the <code class="language-plaintext highlighter-rouge">Config</code> system.</p>

<h2 id="what-problem-does-config-solve">What Problem Does Config Solve?</h2>

<p>Imagine you’re building a simple app that uses an AI service. You need an API key to access it. Where do you put this key?</p>

<ul>
  <li><strong>Option 1: Hardcode it directly in the code.</strong>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Bad idea! Don't do this!
</span><span class="n">api_key</span> <span class="o">=</span> <span class="s">"MY_SUPER_SECRET_API_KEY_12345"</span>
<span class="c1"># ... rest of the code uses api_key ...
</span></code></pre></div>    </div>
    <p>This is a terrible idea! Your secret key is exposed in the code. Sharing the code means sharing your secret. Changing the key means editing the code. What if multiple parts of the code need the key? You’d have it scattered everywhere!</p>
  </li>
  <li><strong>Option 2: Use a Configuration System.</strong>
Keep all settings in a separate, easy-to-read file. The application reads this file when it starts and makes the settings available wherever they’re needed.</li>
</ul>

<p>OpenManus uses Option 2. It keeps settings in a file named <code class="language-plaintext highlighter-rouge">config.toml</code> and uses a special <code class="language-plaintext highlighter-rouge">Config</code> object to manage them.</p>

<p><strong>Use Case:</strong> Let’s say we want our <a href="01_llm.md">LLM</a> component to use the “gpt-4o” model and a specific API key. Instead of writing “gpt-4o” and the key directly into the <code class="language-plaintext highlighter-rouge">LLM</code> class code, the <code class="language-plaintext highlighter-rouge">LLM</code> class will <em>ask</em> the <code class="language-plaintext highlighter-rouge">Config</code> system: “What model should I use?” and “What’s the API key?”. The <code class="language-plaintext highlighter-rouge">Config</code> system provides the answers it read from <code class="language-plaintext highlighter-rouge">config.toml</code>.</p>

<h2 id="key-concepts-the-settings-file-and-manager">Key Concepts: The Settings File and Manager</h2>

<h3 id="1-the-settings-file-configtoml">1. The Settings File (<code class="language-plaintext highlighter-rouge">config.toml</code>)</h3>

<p>This is a simple text file located in the <code class="language-plaintext highlighter-rouge">config/</code> directory of your OpenManus project. It uses the TOML format (Tom’s Obvious, Minimal Language), which is designed to be easy for humans to read.</p>

<p>It contains sections for different parts of the application. Here’s a highly simplified snippet:</p>

<div class="language-toml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># config/config.toml (Simplified Example)</span>

<span class="nn">[llm]</span> <span class="c"># Settings for the Large Language Model</span>
<span class="py">model</span> <span class="p">=</span> <span class="s">"gpt-4o"</span>
<span class="py">api_key</span> <span class="p">=</span> <span class="s">"YOUR_OPENAI_API_KEY_HERE"</span> <span class="c"># Replace with your actual key</span>
<span class="py">base_url</span> <span class="p">=</span> <span class="s">"https://api.openai.com/v1"</span>
<span class="py">api_type</span> <span class="p">=</span> <span class="s">"openai"</span>

<span class="nn">[sandbox]</span> <span class="c"># Settings for the code execution sandbox</span>
<span class="py">use_sandbox</span> <span class="p">=</span> <span class="kc">true</span>
<span class="py">image</span> <span class="p">=</span> <span class="s">"python:3.12-slim"</span>
<span class="py">memory_limit</span> <span class="p">=</span> <span class="s">"256m"</span>

<span class="nn">[search_config]</span> <span class="c"># Settings for web search</span>
<span class="py">engine</span> <span class="p">=</span> <span class="s">"DuckDuckGo"</span>

<span class="nn">[browser_config]</span> <span class="c"># Settings for the browser tool</span>
<span class="py">headless</span> <span class="p">=</span> <span class="kc">false</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">[llm]</code>, <code class="language-plaintext highlighter-rouge">[sandbox]</code>, etc., define sections.</li>
  <li><code class="language-plaintext highlighter-rouge">model = "gpt-4o"</code> assigns the value <code class="language-plaintext highlighter-rouge">"gpt-4o"</code> to the <code class="language-plaintext highlighter-rouge">model</code> setting within the <code class="language-plaintext highlighter-rouge">llm</code> section.</li>
  <li><code class="language-plaintext highlighter-rouge">api_key = "YOUR_..."</code> stores your secret key (you should put your real key here and <strong>never</strong> share this file publicly if it contains secrets!).</li>
  <li><code class="language-plaintext highlighter-rouge">use_sandbox = true</code> sets a boolean (true/false) value.</li>
</ul>

<p>This file acts as the central “control panel” list for the application’s behavior.</p>

<h3 id="2-the-settings-manager-config-class-in-appconfigpy">2. The Settings Manager (<code class="language-plaintext highlighter-rouge">Config</code> class in <code class="language-plaintext highlighter-rouge">app/config.py</code>)</h3>

<p>Okay, we have the settings file. How does the application <em>use</em> it?</p>

<p>OpenManus has a special Python class called <code class="language-plaintext highlighter-rouge">Config</code> (defined in <code class="language-plaintext highlighter-rouge">app/config.py</code>). Think of this class as the <strong>Settings Manager</strong>. Its job is:</p>

<ol>
  <li><strong>Read the File:</strong> When the application starts, the <code class="language-plaintext highlighter-rouge">Config</code> manager reads the <code class="language-plaintext highlighter-rouge">config.toml</code> file.</li>
  <li><strong>Parse and Store:</strong> It understands the TOML format and stores the settings internally, often using the Pydantic <a href="06_schema.md">Schemas</a> we learned about (like <code class="language-plaintext highlighter-rouge">LLMSettings</code>, <code class="language-plaintext highlighter-rouge">SandboxSettings</code>) to validate the data.</li>
  <li><strong>Provide Access:</strong> It offers a way for any other part of the application to easily ask for a specific setting (e.g., “Give me the LLM model name”).</li>
</ol>

<h3 id="3-the-singleton-pattern-one-manager-to-rule-them-all">3. The Singleton Pattern: One Manager to Rule Them All</h3>

<p>The <code class="language-plaintext highlighter-rouge">Config</code> class uses a special design pattern called a <strong>Singleton</strong>. This sounds fancy, but the idea is simple: <strong>There is only ever <em>one</em> instance (object) of the <code class="language-plaintext highlighter-rouge">Config</code> manager in the entire application.</strong></p>

<p><em>Analogy:</em> Think of the principal’s office in a school. There’s only one principal’s office. If any teacher or student needs official school-wide information (like the date of the next holiday), they go to that single, central office. They don’t each have their own separate, potentially conflicting, information source.</p>

<p>The <code class="language-plaintext highlighter-rouge">Config</code> object is like that principal’s office. When any part of OpenManus (like the <a href="01_llm.md">LLM</a> class or the <a href="08_dockersandbox.md">DockerSandbox</a> class) needs a setting, it asks the <em>same</em>, single <code class="language-plaintext highlighter-rouge">Config</code> instance. This ensures everyone is using the same configuration values that were loaded at the start.</p>

<h2 id="how-do-we-use-it-accessing-settings">How Do We Use It? (Accessing Settings)</h2>

<p>Because <code class="language-plaintext highlighter-rouge">Config</code> is a singleton, accessing settings is straightforward. You import the pre-created instance and ask for the setting you need.</p>

<p>The single instance is created automatically when <code class="language-plaintext highlighter-rouge">app/config.py</code> is first loaded and is made available as <code class="language-plaintext highlighter-rouge">config</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Example of how another part of the code might use the config
</span><span class="kn">from</span> <span class="nn">app.config</span> <span class="kn">import</span> <span class="n">config</span> <span class="c1"># Import the singleton instance
</span>
<span class="c1"># Access LLM settings
</span><span class="n">default_llm_settings</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">llm</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"default"</span><span class="p">)</span> <span class="c1"># Get the 'default' LLM config
</span><span class="k">if</span> <span class="n">default_llm_settings</span><span class="p">:</span>
    <span class="n">model_name</span> <span class="o">=</span> <span class="n">default_llm_settings</span><span class="p">.</span><span class="n">model</span>
    <span class="n">api_key</span> <span class="o">=</span> <span class="n">default_llm_settings</span><span class="p">.</span><span class="n">api_key</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"LLM Model: </span><span class="si">{</span><span class="n">model_name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="c1"># Don't print the API key in real code! This is just for illustration.
</span>    <span class="c1"># print(f"LLM API Key: {api_key[:4]}...{api_key[-4:]}")
</span>
<span class="c1"># Access Sandbox settings
</span><span class="n">use_sandbox_flag</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">sandbox</span><span class="p">.</span><span class="n">use_sandbox</span>
<span class="n">sandbox_image</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">sandbox</span><span class="p">.</span><span class="n">image</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Use Sandbox: </span><span class="si">{</span><span class="n">use_sandbox_flag</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Sandbox Image: </span><span class="si">{</span><span class="n">sandbox_image</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># Access Search settings (check if it exists)
</span><span class="k">if</span> <span class="n">config</span><span class="p">.</span><span class="n">search_config</span><span class="p">:</span>
    <span class="n">search_engine</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">search_config</span><span class="p">.</span><span class="n">engine</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Preferred Search Engine: </span><span class="si">{</span><span class="n">search_engine</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># Access Browser settings (check if it exists)
</span><span class="k">if</span> <span class="n">config</span><span class="p">.</span><span class="n">browser_config</span><span class="p">:</span>
    <span class="n">run_headless</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">browser_config</span><span class="p">.</span><span class="n">headless</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Run Browser Headless: </span><span class="si">{</span><span class="n">run_headless</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">from app.config import config</code>: We import the single, shared <code class="language-plaintext highlighter-rouge">config</code> object.</li>
  <li><code class="language-plaintext highlighter-rouge">config.llm</code>: Accesses the dictionary of all LLM configurations read from the <code class="language-plaintext highlighter-rouge">[llm]</code> sections in <code class="language-plaintext highlighter-rouge">config.toml</code>. We use <code class="language-plaintext highlighter-rouge">.get("default")</code> to get the settings specifically for the LLM named “default”.</li>
  <li><code class="language-plaintext highlighter-rouge">default_llm_settings.model</code>: Accesses the <code class="language-plaintext highlighter-rouge">model</code> attribute of the <code class="language-plaintext highlighter-rouge">LLMSettings</code> object. Pydantic ensures this attribute exists and is the correct type.</li>
  <li><code class="language-plaintext highlighter-rouge">config.sandbox.use_sandbox</code>: Directly accesses the <code class="language-plaintext highlighter-rouge">use_sandbox</code> attribute within the <code class="language-plaintext highlighter-rouge">sandbox</code> settings object (<code class="language-plaintext highlighter-rouge">SandboxSettings</code>).</li>
  <li>We check if <code class="language-plaintext highlighter-rouge">config.search_config</code> and <code class="language-plaintext highlighter-rouge">config.browser_config</code> exist before accessing them, as they might be optional sections in the <code class="language-plaintext highlighter-rouge">config.toml</code> file.</li>
</ol>

<p><strong>Use Case Example: How <code class="language-plaintext highlighter-rouge">LLM</code> Gets Its Settings</strong></p>

<p>Let’s revisit our use case. When an <code class="language-plaintext highlighter-rouge">LLM</code> object is created (often inside a <a href="03_baseagent.md">BaseAgent</a>), its initialization code (<code class="language-plaintext highlighter-rouge">__init__</code>) looks something like this (simplified):</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified snippet from app/llm.py __init__ method
</span>
<span class="kn">from</span> <span class="nn">app.config</span> <span class="kn">import</span> <span class="n">config</span><span class="p">,</span> <span class="n">LLMSettings</span> <span class="c1"># Import config and the schema
</span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>

<span class="k">class</span> <span class="nc">LLM</span><span class="p">:</span>
    <span class="c1"># ... other methods ...
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"default"</span><span class="p">,</span> <span class="n">llm_config</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">LLMSettings</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="c1"># If specific llm_config isn't provided, get it from the global config
</span>        <span class="k">if</span> <span class="n">llm_config</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># Ask the global 'config' object for the settings
</span>            <span class="c1"># corresponding to 'config_name' (e.g., "default")
</span>            <span class="n">llm_settings</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">llm</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">config_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">llm_settings</span><span class="p">:</span> <span class="c1"># Handle case where the name doesn't exist
</span>                 <span class="n">llm_settings</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">llm</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"default"</span><span class="p">)</span> <span class="c1"># Fallback to default
</span>
        <span class="k">else</span><span class="p">:</span> <span class="c1"># Use the provided config if given
</span>            <span class="n">llm_settings</span> <span class="o">=</span> <span class="n">llm_config</span>


        <span class="c1"># Store the settings read from the config object
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">model</span> <span class="o">=</span> <span class="n">llm_settings</span><span class="p">.</span><span class="n">model</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">api_key</span> <span class="o">=</span> <span class="n">llm_settings</span><span class="p">.</span><span class="n">api_key</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">base_url</span> <span class="o">=</span> <span class="n">llm_settings</span><span class="p">.</span><span class="n">base_url</span>
        <span class="c1"># ... store other settings like max_tokens, temperature ...
</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"LLM initialized with model: </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">model</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="c1"># Initialize the actual API client using these settings
</span>        <span class="c1"># self.client = AsyncOpenAI(api_key=self.api_key, base_url=self.base_url)
</span>        <span class="c1"># ... rest of initialization ...
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ul>
  <li>The <code class="language-plaintext highlighter-rouge">LLM</code> class imports the global <code class="language-plaintext highlighter-rouge">config</code> object.</li>
  <li>In its <code class="language-plaintext highlighter-rouge">__init__</code>, it uses <code class="language-plaintext highlighter-rouge">config.llm.get(config_name)</code> to retrieve the specific settings (like <code class="language-plaintext highlighter-rouge">model</code>, <code class="language-plaintext highlighter-rouge">api_key</code>) it needs.</li>
  <li>It then uses these retrieved values to configure itself and the underlying API client.</li>
</ul>

<p>This way, the <code class="language-plaintext highlighter-rouge">LLM</code> class doesn’t need the actual values hardcoded inside it. It just asks the central <code class="language-plaintext highlighter-rouge">Config</code> manager. If you want to change the model or API key, you only need to update <code class="language-plaintext highlighter-rouge">config.toml</code> and restart the application!</p>

<h2 id="under-the-hood-loading-and-providing-settings">Under the Hood: Loading and Providing Settings</h2>

<p>What happens when the application starts and the <code class="language-plaintext highlighter-rouge">config</code> object is first used?</p>

<ol>
  <li><strong>First Access:</strong> The first time code tries to <code class="language-plaintext highlighter-rouge">import config</code> from <code class="language-plaintext highlighter-rouge">app.config</code>, Python runs the code in <code class="language-plaintext highlighter-rouge">app.config.py</code>.</li>
  <li><strong>Singleton Check:</strong> The <code class="language-plaintext highlighter-rouge">Config</code> class’s special <code class="language-plaintext highlighter-rouge">__new__</code> method checks if an instance (<code class="language-plaintext highlighter-rouge">_instance</code>) already exists. If not, it creates a new one. If it <em>does</em> exist, it just returns the existing one. This ensures only one instance is ever made.</li>
  <li><strong>Initialization (<code class="language-plaintext highlighter-rouge">__init__</code>):</strong> The <code class="language-plaintext highlighter-rouge">__init__</code> method (run only once for the single instance) calls <code class="language-plaintext highlighter-rouge">_load_initial_config</code>.</li>
  <li><strong>Find File (<code class="language-plaintext highlighter-rouge">_get_config_path</code>):</strong> It looks for <code class="language-plaintext highlighter-rouge">config/config.toml</code>. If that doesn’t exist, it looks for <code class="language-plaintext highlighter-rouge">config/config.example.toml</code> as a fallback.</li>
  <li><strong>Read File (<code class="language-plaintext highlighter-rouge">_load_config</code>):</strong> It opens the found <code class="language-plaintext highlighter-rouge">.toml</code> file and uses the standard <code class="language-plaintext highlighter-rouge">tomllib</code> library to read its contents into a Python dictionary.</li>
  <li><strong>Parse &amp; Validate:</strong> <code class="language-plaintext highlighter-rouge">_load_initial_config</code> takes this raw dictionary and carefully organizes it, using Pydantic models (<code class="language-plaintext highlighter-rouge">LLMSettings</code>, <code class="language-plaintext highlighter-rouge">SandboxSettings</code>, <code class="language-plaintext highlighter-rouge">BrowserSettings</code>, <code class="language-plaintext highlighter-rouge">SearchSettings</code>, <code class="language-plaintext highlighter-rouge">MCPSettings</code>, all defined in <code class="language-plaintext highlighter-rouge">app/config.py</code>) to structure and <em>validate</em> the settings. For example, it creates <code class="language-plaintext highlighter-rouge">LLMSettings</code> objects for each entry under <code class="language-plaintext highlighter-rouge">[llm]</code>. If a required setting is missing or has the wrong type (e.g., <code class="language-plaintext highlighter-rouge">max_tokens</code> is text instead of a number), Pydantic will raise an error here, stopping the app from starting with bad configuration.</li>
  <li><strong>Store Internally:</strong> The validated settings (now nicely structured Pydantic objects) are stored within the <code class="language-plaintext highlighter-rouge">Config</code> instance (in <code class="language-plaintext highlighter-rouge">self._config</code>).</li>
  <li><strong>Ready for Use:</strong> The <code class="language-plaintext highlighter-rouge">config</code> instance is now ready. Subsequent accesses simply return the stored, validated settings via properties like <code class="language-plaintext highlighter-rouge">config.llm</code>, <code class="language-plaintext highlighter-rouge">config.sandbox</code>, etc.</li>
</ol>

<p><strong>Sequence Diagram:</strong></p>

<pre><code class="language-mermaid">sequenceDiagram
    participant App as Application Start
    participant CfgMod as app/config.py
    participant Config as Config Singleton Object
    participant TOML as config.toml File
    participant Parser as TOML Parser &amp; Pydantic
    participant OtherMod as e.g., app/llm.py

    App-&gt;&gt;+CfgMod: import config
    Note over CfgMod: First time loading module
    CfgMod-&gt;&gt;+Config: Config() called (implicitly via `config = Config()`)
    Config-&gt;&gt;Config: __new__ checks if _instance exists (it doesn't)
    Config-&gt;&gt;Config: Creates new Config instance (_instance)
    Config-&gt;&gt;Config: Calls __init__ (only runs once)
    Config-&gt;&gt;Config: _load_initial_config()
    Config-&gt;&gt;Config: _get_config_path() -&gt; finds path
    Config-&gt;&gt;+TOML: Opens file
    TOML--&gt;&gt;-Config: Returns file content
    Config-&gt;&gt;+Parser: Parses TOML content into dict
    Parser--&gt;&gt;-Config: Returns raw_config dict
    Config-&gt;&gt;+Parser: Validates dict using Pydantic models (LLMSettings etc.)
    Parser--&gt;&gt;-Config: Returns validated AppConfig object
    Config-&gt;&gt;Config: Stores validated config internally
    Config--&gt;&gt;-CfgMod: Returns the single instance
    CfgMod--&gt;&gt;-App: Provides `config` instance

    App-&gt;&gt;+OtherMod: Code runs (e.g., `LLM()`)
    OtherMod-&gt;&gt;+Config: Accesses property (e.g., `config.llm`)
    Config--&gt;&gt;-OtherMod: Returns stored settings (e.g., Dict[str, LLMSettings])
</code></pre>

<p><strong>Code Glimpse (<code class="language-plaintext highlighter-rouge">app/config.py</code>):</strong></p>

<p>Let’s look at the key parts:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified snippet from app/config.py
</span><span class="kn">import</span> <span class="nn">threading</span>
<span class="kn">import</span> <span class="nn">tomllib</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span>
<span class="c1"># ... other imports like typing ...
</span>
<span class="c1"># --- Pydantic Models for Settings ---
</span><span class="k">class</span> <span class="nc">LLMSettings</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span> <span class="c1"># Defines structure for [llm] section
</span>    <span class="n">model</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">api_key</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># ... other fields like base_url, max_tokens, api_type ...
</span>
<span class="k">class</span> <span class="nc">SandboxSettings</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span> <span class="c1"># Defines structure for [sandbox] section
</span>    <span class="n">use_sandbox</span><span class="p">:</span> <span class="nb">bool</span>
    <span class="n">image</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># ... other fields like memory_limit, timeout ...
</span>
<span class="c1"># ... Similar models for BrowserSettings, SearchSettings, MCPSettings ...
</span>
<span class="k">class</span> <span class="nc">AppConfig</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span> <span class="c1"># Holds all validated settings together
</span>    <span class="n">llm</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">LLMSettings</span><span class="p">]</span>
    <span class="n">sandbox</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SandboxSettings</span><span class="p">]</span>
    <span class="n">browser_config</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BrowserSettings</span><span class="p">]</span>
    <span class="n">search_config</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SearchSettings</span><span class="p">]</span>
    <span class="n">mcp_config</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">MCPSettings</span><span class="p">]</span>

<span class="c1"># --- The Singleton Config Class ---
</span><span class="k">class</span> <span class="nc">Config</span><span class="p">:</span>
    <span class="n">_instance</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">_lock</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="n">Lock</span><span class="p">()</span> <span class="c1"># Ensures thread-safety during creation
</span>    <span class="n">_initialized</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">):</span> <span class="c1"># Controls instance creation (Singleton part 1)
</span>        <span class="k">if</span> <span class="n">cls</span><span class="p">.</span><span class="n">_instance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">cls</span><span class="p">.</span><span class="n">_lock</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">cls</span><span class="p">.</span><span class="n">_instance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">cls</span><span class="p">.</span><span class="n">_instance</span> <span class="o">=</span> <span class="nb">super</span><span class="p">().</span><span class="n">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">.</span><span class="n">_instance</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># Initializes the instance (runs only once)
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">_initialized</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="p">.</span><span class="n">_lock</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">_initialized</span><span class="p">:</span>
                    <span class="bp">self</span><span class="p">.</span><span class="n">_config</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AppConfig</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># Where settings are stored
</span>                    <span class="bp">self</span><span class="p">.</span><span class="n">_load_initial_config</span><span class="p">()</span> <span class="c1"># Load from file
</span>                    <span class="bp">self</span><span class="p">.</span><span class="n">_initialized</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">_load_config</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span> <span class="c1"># Reads the TOML file
</span>        <span class="n">config_path</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_get_config_path</span><span class="p">()</span> <span class="c1"># Finds config.toml or example
</span>        <span class="k">with</span> <span class="n">config_path</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="s">"rb"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">tomllib</span><span class="p">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="c1"># Parses TOML into a dictionary
</span>
    <span class="k">def</span> <span class="nf">_load_initial_config</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="c1"># Parses dict and validates with Pydantic
</span>        <span class="n">raw_config</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_load_config</span><span class="p">()</span>
        <span class="c1"># ... (logic to handle defaults and structure the raw_config dict) ...
</span>        <span class="c1"># ... (creates LLMSettings, SandboxSettings etc. from raw_config) ...
</span>
        <span class="c1"># Validate the final structured dict using AppConfig
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_config</span> <span class="o">=</span> <span class="n">AppConfig</span><span class="p">(</span><span class="o">**</span><span class="n">structured_config_dict</span><span class="p">)</span>

    <span class="c1"># --- Properties to Access Settings ---
</span>    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">llm</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">LLMSettings</span><span class="p">]:</span>
        <span class="c1"># Provides easy access like 'config.llm'
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_config</span><span class="p">.</span><span class="n">llm</span>

    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">sandbox</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SandboxSettings</span><span class="p">:</span>
        <span class="c1"># Provides easy access like 'config.sandbox'
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_config</span><span class="p">.</span><span class="n">sandbox</span>

    <span class="c1"># ... Properties for browser_config, search_config, mcp_config ...
</span>
<span class="c1"># --- Create the Singleton Instance ---
# This line runs when the module is imported, creating the single instance.
</span><span class="n">config</span> <span class="o">=</span> <span class="n">Config</span><span class="p">()</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ul>
  <li>The Pydantic models (<code class="language-plaintext highlighter-rouge">LLMSettings</code>, <code class="language-plaintext highlighter-rouge">SandboxSettings</code>, <code class="language-plaintext highlighter-rouge">AppConfig</code>) define the expected structure and types for the settings read from <code class="language-plaintext highlighter-rouge">config.toml</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">Config</code> class uses <code class="language-plaintext highlighter-rouge">__new__</code> and <code class="language-plaintext highlighter-rouge">_lock</code> to implement the singleton pattern, ensuring only one instance.</li>
  <li><code class="language-plaintext highlighter-rouge">__init__</code> calls <code class="language-plaintext highlighter-rouge">_load_initial_config</code> only once.</li>
  <li><code class="language-plaintext highlighter-rouge">_load_initial_config</code> reads the TOML file and uses the Pydantic models (within <code class="language-plaintext highlighter-rouge">AppConfig</code>) to parse and validate the settings, storing the result in <code class="language-plaintext highlighter-rouge">self._config</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">@property</code> decorators provide clean access (e.g., <code class="language-plaintext highlighter-rouge">config.llm</code>) to the stored settings.</li>
  <li><code class="language-plaintext highlighter-rouge">config = Config()</code> at the end creates the actual singleton instance that gets imported elsewhere.</li>
</ul>

<h2 id="wrapping-up-chapter-7">Wrapping Up Chapter 7</h2>

<p>We’ve learned that the <code class="language-plaintext highlighter-rouge">Config</code> system is OpenManus’s way of managing application settings. It reads configurations from the <code class="language-plaintext highlighter-rouge">config.toml</code> file at startup, validates them using Pydantic <a href="06_schema.md">Schemas</a>, and makes them available throughout the application via a single, shared <code class="language-plaintext highlighter-rouge">config</code> object (using the singleton pattern). This keeps settings separate from code, making the application more flexible, secure, and easier to manage.</p>

<p>Many components rely on these configurations. For instance, when an agent needs to execute code safely, it might use a <code class="language-plaintext highlighter-rouge">DockerSandbox</code>. The settings for this sandbox – like which Docker image to use or how much memory to allow – are read directly from the configuration we just discussed.</p>

<p>Let’s move on to <a href="08_dockersandbox.md">Chapter 8: DockerSandbox</a> to see how OpenManus provides a secure environment for running code generated by agents, using settings managed by our <code class="language-plaintext highlighter-rouge">Config</code> system.</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
