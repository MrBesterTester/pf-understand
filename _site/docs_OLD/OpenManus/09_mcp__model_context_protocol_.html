<h1 id="chapter-9-mcp-model-context-protocol">Chapter 9: MCP (Model Context Protocol)</h1>

<p>Welcome to the final chapter of our core concepts tutorial! In <a href="08_dockersandbox.md">Chapter 8: DockerSandbox</a>, we saw how OpenManus can safely run code in an isolated environment. Now, let’s explore a powerful way to extend your agent’s capabilities <em>without</em> changing its internal code: the <strong>Model Context Protocol (MCP)</strong>.</p>

<h2 id="what-problem-does-mcp-solve">What Problem Does MCP Solve?</h2>

<p>Imagine you have an agent running smoothly. Suddenly, you realize you need it to perform a new, specialized task – maybe interacting with a custom company database or using a complex scientific calculation library.</p>

<p>Normally, you might have to:</p>
<ol>
  <li>Stop the agent.</li>
  <li>Write new code for the <a href="04_tool___toolcollection.md">Tool</a> that performs this task.</li>
  <li>Add this tool to the agent’s code or configuration.</li>
  <li>Restart the agent.</li>
</ol>

<p>This process can be cumbersome, especially if you want to add or update tools frequently, or if different people are managing different tools.</p>

<p>What if there was a way for the agent to <strong>dynamically discover and use tools</strong> provided by a completely separate service? Like plugging in a new USB device, and your computer automatically recognizes and uses it?</p>

<p><strong>This is what MCP enables!</strong> It defines a standard way for an OpenManus agent (<code class="language-plaintext highlighter-rouge">MCPAgent</code>) to connect to an external <strong>MCP Server</strong>. This server advertises the tools it offers, and the agent can call these tools remotely as if they were built-in.</p>

<p><strong>Use Case:</strong> Let’s say we want our agent to be able to run basic shell commands (like <code class="language-plaintext highlighter-rouge">ls</code> or <code class="language-plaintext highlighter-rouge">pwd</code>) using the <code class="language-plaintext highlighter-rouge">Bash</code> tool. Instead of building the <code class="language-plaintext highlighter-rouge">Bash</code> tool directly into the agent, we can run an <code class="language-plaintext highlighter-rouge">MCPServer</code> that <em>offers</em> the <code class="language-plaintext highlighter-rouge">Bash</code> tool. Our <code class="language-plaintext highlighter-rouge">MCPAgent</code> can connect to this server, discover the <code class="language-plaintext highlighter-rouge">Bash</code> tool, and use it when needed, all without having the <code class="language-plaintext highlighter-rouge">Bash</code> tool’s code inside the agent itself. If we later update the <code class="language-plaintext highlighter-rouge">Bash</code> tool on the server, the agent automatically gets the new version without needing changes.</p>

<h2 id="key-concepts-the-agent-the-server-and-the-rules">Key Concepts: The Agent, The Server, and The Rules</h2>

<p>MCP involves a few key players working together:</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">MCPServer</code> (The Tool Provider):</strong>
    <ul>
      <li>Think of this as a separate application, like a dedicated “Tool Shop” running independently from your agent.</li>
      <li>It holds one or more <a href="04_tool___toolcollection.md">Tools</a> (like <code class="language-plaintext highlighter-rouge">Bash</code>, <code class="language-plaintext highlighter-rouge">BrowserUseTool</code>, <code class="language-plaintext highlighter-rouge">StrReplaceEditor</code>, or custom ones).</li>
      <li>It “advertises” these tools, meaning it can tell connected clients (agents) which tools are available, what they do, and how to use them.</li>
      <li>When asked, it executes a tool and sends the result back.</li>
      <li>In OpenManus, <code class="language-plaintext highlighter-rouge">app/mcp/server.py</code> provides an implementation of this server.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">MCPAgent</code> (The Tool User):</strong>
    <ul>
      <li>This is a specialized type of <a href="03_baseagent.md">BaseAgent</a> designed specifically to talk to an <code class="language-plaintext highlighter-rouge">MCPServer</code>.</li>
      <li>When it starts, it connects to the specified <code class="language-plaintext highlighter-rouge">MCPServer</code>.</li>
      <li>It asks the server: “What tools do you have?”</li>
      <li>It treats the server’s tools as its own available <code class="language-plaintext highlighter-rouge">ToolCollection</code>.</li>
      <li>When its <a href="01_llm.md">LLM</a> decides to use one of these tools, the <code class="language-plaintext highlighter-rouge">MCPAgent</code> sends a request to the <code class="language-plaintext highlighter-rouge">MCPServer</code> to execute it.</li>
      <li>It can even periodically check if the server has added or removed tools and update its capabilities accordingly!</li>
    </ul>
  </li>
  <li><strong>The Protocol (The Rules of Communication):</strong>
    <ul>
      <li>MCP defines the exact format of messages exchanged between the <code class="language-plaintext highlighter-rouge">MCPAgent</code> and <code class="language-plaintext highlighter-rouge">MCPServer</code>. How does the agent ask for the tool list? How does it request a tool execution? How is the result formatted?</li>
      <li>OpenManus supports two main ways (transports) for this communication:
        <ul>
          <li><strong>stdio (Standard Input/Output):</strong> The agent starts the server process directly and communicates with it using standard text streams (like typing commands in a terminal). This is simpler for local setups.</li>
          <li><strong>SSE (Server-Sent Events):</strong> The agent connects to a running server over the network (using HTTP). This is more suitable if the server is running elsewhere.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p><em>Analogy:</em> Imagine the <code class="language-plaintext highlighter-rouge">MCPServer</code> is a smart TV’s App Store, offering apps (tools) like Netflix or YouTube. The <code class="language-plaintext highlighter-rouge">MCPAgent</code> is a universal remote control. MCP is the protocol that lets the remote connect to the TV, see the available apps, and tell the TV “Launch Netflix” or “Play this video on YouTube”. The actual app logic runs on the TV (the server), not the remote (the agent).</p>

<h2 id="how-do-we-use-it">How Do We Use It?</h2>

<p>Let’s see how to run the server and connect an agent using the simple <code class="language-plaintext highlighter-rouge">stdio</code> method.</p>

<p><strong>1. Run the MCPServer:</strong></p>

<p>The server needs to be running first. OpenManus provides a script to run a server that includes standard tools like <code class="language-plaintext highlighter-rouge">Bash</code>, <code class="language-plaintext highlighter-rouge">Browser</code>, and <code class="language-plaintext highlighter-rouge">Editor</code>.</p>

<p>Open a terminal and run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Make sure you are in the root directory of the OpenManus project</span>
<span class="c"># Use python to run the server module</span>
python <span class="nt">-m</span> app.mcp.server <span class="nt">--transport</span> stdio
</code></pre></div></div>

<p><strong>Expected Output (in the server terminal):</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INFO:root:Registered tool: bash
INFO:root:Registered tool: browser
INFO:root:Registered tool: editor
INFO:root:Registered tool: terminate
INFO:root:Starting OpenManus server (stdio mode)
# --- The server is now running and waiting for a connection ---
</code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">python -m app.mcp.server</code> tells Python to run the server code located in <code class="language-plaintext highlighter-rouge">app/mcp/server.py</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">--transport stdio</code> specifies that it should listen for connections via standard input/output.</li>
  <li>It registers the built-in tools and waits.</li>
</ul>

<p><strong>2. Run the MCPAgent (connecting to the server):</strong></p>

<p>Now, open a <em>separate</em> terminal. We’ll run a script that starts the <code class="language-plaintext highlighter-rouge">MCPAgent</code> and tells it how to connect to the server we just started.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># In a NEW terminal, in the root directory of OpenManus</span>
<span class="c"># Run the MCP agent runner script</span>
python run_mcp.py <span class="nt">--connection</span> stdio <span class="nt">--interactive</span>
</code></pre></div></div>

<p><strong>Expected Output (in the agent terminal):</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>INFO:app.config:Configuration loaded successfully from .../config/config.toml
INFO:app.agent.mcp:Initializing MCPAgent with stdio connection...
# ... (potential logs about connecting) ...
INFO:app.tool.mcp:Connected to server with tools: ['bash', 'browser', 'editor', 'terminate']
INFO:app.agent.mcp:Connected to MCP server via stdio

MCP Agent Interactive Mode (type 'exit' to quit)

Enter your request:
</code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">python run_mcp.py</code> runs the agent launcher script.</li>
  <li><code class="language-plaintext highlighter-rouge">--connection stdio</code> tells the agent to connect using standard input/output. The script (<code class="language-plaintext highlighter-rouge">run_mcp.py</code>) knows how to start the server process (<code class="language-plaintext highlighter-rouge">python -m app.mcp.server</code>) for this mode.</li>
  <li><code class="language-plaintext highlighter-rouge">--interactive</code> puts the agent in a mode where you can chat with it.</li>
  <li>The agent connects, asks the server for its tools (<code class="language-plaintext highlighter-rouge">list_tools</code>), and logs the tools it found (<code class="language-plaintext highlighter-rouge">bash</code>, <code class="language-plaintext highlighter-rouge">browser</code>, etc.). It’s now ready for your requests!</li>
</ul>

<p><strong>3. Interact with the Agent (Using a Server Tool):</strong></p>

<p>Now, in the agent’s interactive prompt, ask it to do something that requires a tool provided by the server, like listing files using <code class="language-plaintext highlighter-rouge">bash</code>:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code># In the agent's terminal
Enter your request: Use the bash tool to list the files in the current directory.
</code></pre></div></div>

<p><strong>What Happens:</strong></p>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">MCPAgent</code> receives your request.</li>
  <li>Its <a href="01_llm.md">LLM</a> analyzes the request and decides the <code class="language-plaintext highlighter-rouge">bash</code> tool is needed, with the command <code class="language-plaintext highlighter-rouge">ls</code>.</li>
  <li>The agent sees that <code class="language-plaintext highlighter-rouge">bash</code> is a tool provided by the connected <code class="language-plaintext highlighter-rouge">MCPServer</code>.</li>
  <li>The agent sends a <code class="language-plaintext highlighter-rouge">call_tool</code> request over <code class="language-plaintext highlighter-rouge">stdio</code> to the server: “Please run <code class="language-plaintext highlighter-rouge">bash</code> with <code class="language-plaintext highlighter-rouge">command='ls'</code>”.</li>
  <li>The <code class="language-plaintext highlighter-rouge">MCPServer</code> receives the request, finds its <code class="language-plaintext highlighter-rouge">Bash</code> tool, and executes <code class="language-plaintext highlighter-rouge">ls</code>.</li>
  <li>The server captures the output (the list of files).</li>
  <li>The server sends the result back to the agent.</li>
  <li>The agent receives the result, adds it to its <a href="02_message___memory.md">Memory</a>, and might use its LLM again to formulate a user-friendly response based on the tool’s output.</li>
</ol>

<p><strong>Expected Output (in the agent terminal, may vary):</strong></p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code># ... (Potential LLM thinking logs) ...
INFO:app.agent.mcp:Executing tool: bash with input {'command': 'ls'}
# ... (Server logs might show execution in its own terminal) ...

Agent: The bash tool executed the 'ls' command and returned the following output:
[List of files/directories in the project root, e.g.,]
README.md
app
config
run_mcp.py
... etc ...
</code></pre></div></div>

<p>Success! The agent used a tool (<code class="language-plaintext highlighter-rouge">bash</code>) that wasn’t part of its own code, but was provided dynamically by the external <code class="language-plaintext highlighter-rouge">MCPServer</code> via the Model Context Protocol. If you added a <em>new</em> tool to the <code class="language-plaintext highlighter-rouge">MCPServer</code> code and restarted the server, the agent could potentially discover and use it without needing any changes itself (it periodically refreshes the tool list).</p>

<p>Type <code class="language-plaintext highlighter-rouge">exit</code> in the agent’s terminal to stop it, then stop the server (usually Ctrl+C in its terminal).</p>

<h2 id="under-the-hood-how-mcp-communication-flows">Under the Hood: How MCP Communication Flows</h2>

<p>Let’s trace the simplified steps when the agent uses a server tool:</p>

<ol>
  <li><strong>Connect &amp; List:</strong> Agent starts, connects to Server (<code class="language-plaintext highlighter-rouge">stdio</code> or <code class="language-plaintext highlighter-rouge">SSE</code>). Agent sends <code class="language-plaintext highlighter-rouge">list_tools</code> request. Server replies with list of tools (<code class="language-plaintext highlighter-rouge">name</code>, <code class="language-plaintext highlighter-rouge">description</code>, <code class="language-plaintext highlighter-rouge">parameters</code>). Agent stores these.</li>
  <li><strong>User Request:</strong> User asks agent to do something (e.g., “list files”).</li>
  <li><strong>LLM Decides:</strong> Agent’s LLM decides to use <code class="language-plaintext highlighter-rouge">bash</code> tool with <code class="language-plaintext highlighter-rouge">command='ls'</code>.</li>
  <li><strong>Agent Request:</strong> Agent finds <code class="language-plaintext highlighter-rouge">bash</code> in its list of server tools. Sends <code class="language-plaintext highlighter-rouge">call_tool</code> request to Server (containing tool name <code class="language-plaintext highlighter-rouge">bash</code> and arguments <code class="language-plaintext highlighter-rouge">{'command': 'ls'}</code>).</li>
  <li><strong>Server Executes:</strong> Server receives request. Finds its internal <code class="language-plaintext highlighter-rouge">Bash</code> tool. Calls the tool’s <code class="language-plaintext highlighter-rouge">execute(command='ls')</code> method. The tool runs <code class="language-plaintext highlighter-rouge">ls</code>.</li>
  <li><strong>Server Response:</strong> Server gets the result from the tool (e.g., “README.md\napp\n…”). Sends this result back to the Agent.</li>
  <li><strong>Agent Processes:</strong> Agent receives the result. Updates its memory. Presents the answer to the user.</li>
</ol>

<p><strong>Sequence Diagram:</strong></p>

<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant Agent as MCPAgent
    participant LLM as Agent's LLM
    participant Server as MCPServer
    participant BashTool as Bash Tool (on Server)

    Note over Agent, Server: Initial Connection &amp; list_tools (omitted for brevity)

    User-&gt;&gt;+Agent: "List files using bash"
    Agent-&gt;&gt;+LLM: ask_tool("List files", tools=[...bash_schema...])
    LLM--&gt;&gt;-Agent: Decide: call tool 'bash', args={'command':'ls'}
    Agent-&gt;&gt;+Server: call_tool(name='bash', args={'command':'ls'})
    Server-&gt;&gt;+BashTool: execute(command='ls')
    BashTool-&gt;&gt;BashTool: Runs 'ls' command
    BashTool--&gt;&gt;-Server: Returns file list string
    Server--&gt;&gt;-Agent: Tool Result (output=file list)
    Agent-&gt;&gt;Agent: Process result, update memory
    Agent--&gt;&gt;-User: "OK, the files are: ..."

</code></pre>

<h2 id="code-glimpse-key-mcp-components">Code Glimpse: Key MCP Components</h2>

<p>Let’s look at simplified parts of the relevant files.</p>

<p><strong>1. <code class="language-plaintext highlighter-rouge">MCPServer</code> (<code class="language-plaintext highlighter-rouge">app/mcp/server.py</code>): Registering Tools</strong>
The server uses the <code class="language-plaintext highlighter-rouge">fastmcp</code> library to handle the protocol details. It needs to register the tools it wants to offer.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified snippet from app/mcp/server.py
</span><span class="kn">from</span> <span class="nn">mcp.server.fastmcp</span> <span class="kn">import</span> <span class="n">FastMCP</span>
<span class="kn">from</span> <span class="nn">app.tool.base</span> <span class="kn">import</span> <span class="n">BaseTool</span>
<span class="kn">from</span> <span class="nn">app.tool.bash</span> <span class="kn">import</span> <span class="n">Bash</span> <span class="c1"># Import the tool to offer
</span><span class="kn">from</span> <span class="nn">app.logger</span> <span class="kn">import</span> <span class="n">logger</span>
<span class="kn">import</span> <span class="nn">json</span>

<span class="k">class</span> <span class="nc">MCPServer</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"openmanus"</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">server</span> <span class="o">=</span> <span class="n">FastMCP</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="c1"># The underlying MCP server library
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">tools</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BaseTool</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Add tools to offer
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">tools</span><span class="p">[</span><span class="s">"bash"</span><span class="p">]</span> <span class="o">=</span> <span class="n">Bash</span><span class="p">()</span>
        <span class="c1"># ... add other tools like Browser, Editor ...
</span>
    <span class="k">def</span> <span class="nf">register_tool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tool</span><span class="p">:</span> <span class="n">BaseTool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""Registers a tool's execute method with the FastMCP server."""</span>
        <span class="n">tool_name</span> <span class="o">=</span> <span class="n">tool</span><span class="p">.</span><span class="n">name</span>
        <span class="n">tool_param</span> <span class="o">=</span> <span class="n">tool</span><span class="p">.</span><span class="n">to_param</span><span class="p">()</span> <span class="c1"># Get schema for the LLM
</span>        <span class="n">tool_function</span> <span class="o">=</span> <span class="n">tool_param</span><span class="p">[</span><span class="s">"function"</span><span class="p">]</span>

        <span class="c1"># Define the function that the MCP server will expose
</span>        <span class="k">async</span> <span class="k">def</span> <span class="nf">tool_method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s">"Executing </span><span class="si">{</span><span class="n">tool_name</span><span class="si">}</span><span class="s"> via MCP: </span><span class="si">{</span><span class="n">kwargs</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
            <span class="c1"># Call the actual tool's execute method
</span>            <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">tool</span><span class="p">.</span><span class="n">execute</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s">"Result of </span><span class="si">{</span><span class="n">tool_name</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
            <span class="c1"># Return result (often needs conversion, e.g., to JSON)
</span>            <span class="k">return</span> <span class="n">json</span><span class="p">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">model_dump</span><span class="p">())</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s">"model_dump"</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

        <span class="c1"># Attach metadata (name, description, parameters) for discovery
</span>        <span class="n">tool_method</span><span class="p">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">tool_name</span>
        <span class="n">tool_method</span><span class="p">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_build_docstring</span><span class="p">(</span><span class="n">tool_function</span><span class="p">)</span>
        <span class="n">tool_method</span><span class="p">.</span><span class="n">__signature__</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_build_signature</span><span class="p">(</span><span class="n">tool_function</span><span class="p">)</span>

        <span class="c1"># Register with the FastMCP library instance
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">server</span><span class="p">.</span><span class="n">tool</span><span class="p">()(</span><span class="n">tool_method</span><span class="p">)</span>
        <span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s">"Registered tool for MCP: </span><span class="si">{</span><span class="n">tool_name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">register_all_tools</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">tool</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">tools</span><span class="p">.</span><span class="n">values</span><span class="p">():</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">register_tool</span><span class="p">(</span><span class="n">tool</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transport</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"stdio"</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">register_all_tools</span><span class="p">()</span>
        <span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s">"Starting MCP server (</span><span class="si">{</span><span class="n">transport</span><span class="si">}</span><span class="s"> mode)"</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">server</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">transport</span><span class="o">=</span><span class="n">transport</span><span class="p">)</span> <span class="c1"># Start listening
</span>
<span class="c1"># Command-line execution part:
# if __name__ == "__main__":
#    server = MCPServer()
#    server.run(transport="stdio") # Or based on args
</span></code></pre></div></div>

<p><strong>Explanation:</strong> The <code class="language-plaintext highlighter-rouge">MCPServer</code> creates instances of tools (<code class="language-plaintext highlighter-rouge">Bash</code>, etc.) and then uses <code class="language-plaintext highlighter-rouge">register_tool</code> to wrap each tool’s <code class="language-plaintext highlighter-rouge">execute</code> method into a format the <code class="language-plaintext highlighter-rouge">fastmcp</code> library understands. This allows the server to advertise the tool (with its name, description, parameters) and call the correct function when the agent makes a <code class="language-plaintext highlighter-rouge">call_tool</code> request.</p>

<p><strong>2. <code class="language-plaintext highlighter-rouge">MCPClients</code> (<code class="language-plaintext highlighter-rouge">app/tool/mcp.py</code>): Client-Side Tool Representation</strong>
The <code class="language-plaintext highlighter-rouge">MCPAgent</code> uses this class, which acts like a <code class="language-plaintext highlighter-rouge">ToolCollection</code>, but its tools are proxies that make calls to the remote server.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified snippet from app/tool/mcp.py
</span><span class="kn">from</span> <span class="nn">mcp</span> <span class="kn">import</span> <span class="n">ClientSession</span> <span class="c1"># MCP library for client-side communication
</span><span class="kn">from</span> <span class="nn">mcp.client.stdio</span> <span class="kn">import</span> <span class="n">stdio_client</span> <span class="c1"># Specific transport handler
</span><span class="kn">from</span> <span class="nn">mcp.types</span> <span class="kn">import</span> <span class="n">TextContent</span>
<span class="kn">from</span> <span class="nn">app.tool.base</span> <span class="kn">import</span> <span class="n">BaseTool</span><span class="p">,</span> <span class="n">ToolResult</span>
<span class="kn">from</span> <span class="nn">app.tool.tool_collection</span> <span class="kn">import</span> <span class="n">ToolCollection</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">AsyncExitStack</span>

<span class="c1"># Represents a single tool on the server, callable from the client
</span><span class="k">class</span> <span class="nc">MCPClientTool</span><span class="p">(</span><span class="n">BaseTool</span><span class="p">):</span>
    <span class="n">session</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ClientSession</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># Holds the connection
</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ToolResult</span><span class="p">:</span>
        <span class="s">"""Execute by calling the remote tool via the MCP session."""</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">session</span><span class="p">:</span> <span class="k">return</span> <span class="n">ToolResult</span><span class="p">(</span><span class="n">error</span><span class="o">=</span><span class="s">"Not connected"</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Make the actual remote call
</span>            <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">session</span><span class="p">.</span><span class="n">call_tool</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Extract text output from the response
</span>            <span class="n">content</span> <span class="o">=</span> <span class="s">", "</span><span class="p">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">item</span><span class="p">.</span><span class="n">text</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">result</span><span class="p">.</span><span class="n">content</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">TextContent</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ToolResult</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="n">content</span> <span class="ow">or</span> <span class="s">"No output."</span><span class="p">)</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ToolResult</span><span class="p">(</span><span class="n">error</span><span class="o">=</span><span class="sa">f</span><span class="s">"MCP tool error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># The collection holding the proxy tools
</span><span class="k">class</span> <span class="nc">MCPClients</span><span class="p">(</span><span class="n">ToolCollection</span><span class="p">):</span>
    <span class="n">session</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ClientSession</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">exit_stack</span><span class="p">:</span> <span class="n">AsyncExitStack</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># Manages connection resources
</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">connect_stdio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="s">"""Connect using stdio."""</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">session</span><span class="p">:</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">disconnect</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">exit_stack</span> <span class="o">=</span> <span class="n">AsyncExitStack</span><span class="p">()</span>

        <span class="c1"># Set up stdio connection using MCP library helper
</span>        <span class="n">server_params</span> <span class="o">=</span> <span class="p">{</span><span class="s">"command"</span><span class="p">:</span> <span class="n">command</span><span class="p">,</span> <span class="s">"args"</span><span class="p">:</span> <span class="n">args</span><span class="p">}</span> <span class="c1"># Simplified
</span>        <span class="n">streams</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">exit_stack</span><span class="p">.</span><span class="n">enter_async_context</span><span class="p">(</span>
            <span class="n">stdio_client</span><span class="p">(</span><span class="n">server_params</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Establish the MCP session over the connection
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">session</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">exit_stack</span><span class="p">.</span><span class="n">enter_async_context</span><span class="p">(</span>
            <span class="n">ClientSession</span><span class="p">(</span><span class="o">*</span><span class="n">streams</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">_initialize_and_list_tools</span><span class="p">()</span> <span class="c1"># Get tool list from server
</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_initialize_and_list_tools</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Fetch tools from server and create proxy objects."""</span>
        <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">session</span><span class="p">.</span><span class="n">initialize</span><span class="p">()</span>
        <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">session</span><span class="p">.</span><span class="n">list_tools</span><span class="p">()</span> <span class="c1"># Ask server for tools
</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tool_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">tool_info</span> <span class="ow">in</span> <span class="n">response</span><span class="p">.</span><span class="n">tools</span><span class="p">:</span>
            <span class="c1"># Create an MCPClientTool instance for each server tool
</span>            <span class="n">proxy_tool</span> <span class="o">=</span> <span class="n">MCPClientTool</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">tool_info</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">description</span><span class="o">=</span><span class="n">tool_info</span><span class="p">.</span><span class="n">description</span><span class="p">,</span>
                <span class="n">parameters</span><span class="o">=</span><span class="n">tool_info</span><span class="p">.</span><span class="n">inputSchema</span><span class="p">,</span> <span class="c1"># Use schema from server
</span>                <span class="n">session</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">session</span><span class="p">,</span> <span class="c1"># Pass the active session
</span>            <span class="p">)</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">tool_map</span><span class="p">[</span><span class="n">tool_info</span><span class="p">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">proxy_tool</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tools</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">tool_map</span><span class="p">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s">"MCP Client found tools: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">tool_map</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">session</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">exit_stack</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">exit_stack</span><span class="p">.</span><span class="n">aclose</span><span class="p">()</span> <span class="c1"># Clean up connection
</span>            <span class="c1"># ... reset state ...
</span></code></pre></div></div>

<p><strong>Explanation:</strong> <code class="language-plaintext highlighter-rouge">MCPClients</code> handles the connection (<code class="language-plaintext highlighter-rouge">connect_stdio</code>). When connected, it calls <code class="language-plaintext highlighter-rouge">list_tools</code> on the server. For each tool reported by the server, it creates a local <code class="language-plaintext highlighter-rouge">MCPClientTool</code> proxy object. This proxy object looks like a normal <code class="language-plaintext highlighter-rouge">BaseTool</code> (with name, description, parameters), but its <code class="language-plaintext highlighter-rouge">execute</code> method doesn’t run code locally – instead, it uses the active <code class="language-plaintext highlighter-rouge">ClientSession</code> to send a <code class="language-plaintext highlighter-rouge">call_tool</code> request back to the server.</p>

<p><strong>3. <code class="language-plaintext highlighter-rouge">MCPAgent</code> (<code class="language-plaintext highlighter-rouge">app/agent/mcp.py</code>): Using MCPClients</strong>
The agent integrates the <code class="language-plaintext highlighter-rouge">MCPClients</code> collection.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified snippet from app/agent/mcp.py
</span><span class="kn">from</span> <span class="nn">app.agent.toolcall</span> <span class="kn">import</span> <span class="n">ToolCallAgent</span>
<span class="kn">from</span> <span class="nn">app.tool.mcp</span> <span class="kn">import</span> <span class="n">MCPClients</span>

<span class="k">class</span> <span class="nc">MCPAgent</span><span class="p">(</span><span class="n">ToolCallAgent</span><span class="p">):</span>
    <span class="c1"># Use MCPClients as the tool collection
</span>    <span class="n">mcp_clients</span><span class="p">:</span> <span class="n">MCPClients</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="n">MCPClients</span><span class="p">)</span>
    <span class="n">available_tools</span><span class="p">:</span> <span class="n">MCPClients</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># Will point to mcp_clients
</span>
    <span class="n">connection_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"stdio"</span>
    <span class="c1"># ... other fields ...
</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">command</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="p">...</span>
    <span class="p">):</span>
        <span class="s">"""Initialize by connecting the MCPClients instance."""</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">connection_type</span> <span class="o">==</span> <span class="s">"stdio"</span><span class="p">:</span>
            <span class="c1"># Tell mcp_clients to connect
</span>            <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">mcp_clients</span><span class="p">.</span><span class="n">connect_stdio</span><span class="p">(</span><span class="n">command</span><span class="o">=</span><span class="n">command</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="n">args</span> <span class="ow">or</span> <span class="p">[])</span>
        <span class="c1"># elif self.connection_type == "sse": ...
</span>
        <span class="c1"># The agent's tools are now the tools provided by the server
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">available_tools</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">mcp_clients</span>

        <span class="c1"># Store initial tool schemas for detecting changes later
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">tool_schemas</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">name</span><span class="p">:</span> <span class="n">t</span><span class="p">.</span><span class="n">parameters</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">available_tools</span><span class="p">}</span>

        <span class="c1"># Add system message about tools...
</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_refresh_tools</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Periodically check the server for tool updates."""</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">mcp_clients</span><span class="p">.</span><span class="n">session</span><span class="p">:</span> <span class="k">return</span>

        <span class="c1"># Ask the server for its current list of tools
</span>        <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">mcp_clients</span><span class="p">.</span><span class="n">session</span><span class="p">.</span><span class="n">list_tools</span><span class="p">()</span>
        <span class="n">current_tools</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">.</span><span class="n">name</span><span class="p">:</span> <span class="n">t</span><span class="p">.</span><span class="n">inputSchema</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">response</span><span class="p">.</span><span class="n">tools</span><span class="p">}</span>

        <span class="c1"># Compare with stored schemas (self.tool_schemas)
</span>        <span class="c1"># Detect added/removed tools and update self.tool_schemas
</span>        <span class="c1"># Add system messages to memory if tools change
</span>        <span class="c1"># ... logic to detect and log changes ...
</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">think</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="s">"""Agent's thinking step."""</span>
        <span class="c1"># Refresh tools periodically
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">current_step</span> <span class="o">%</span> <span class="bp">self</span><span class="p">.</span><span class="n">_refresh_tools_interval</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">_refresh_tools</span><span class="p">()</span>
            <span class="c1"># Stop if server seems gone (no tools left)
</span>            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">mcp_clients</span><span class="p">.</span><span class="n">tool_map</span><span class="p">:</span> <span class="k">return</span> <span class="bp">False</span>

        <span class="c1"># Use parent class's think method, which uses self.available_tools
</span>        <span class="c1"># (which points to self.mcp_clients) for tool decisions/calls
</span>        <span class="k">return</span> <span class="k">await</span> <span class="nb">super</span><span class="p">().</span><span class="n">think</span><span class="p">()</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">cleanup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Disconnect the MCP session when the agent finishes."""</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">mcp_clients</span><span class="p">.</span><span class="n">session</span><span class="p">:</span>
            <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">mcp_clients</span><span class="p">.</span><span class="n">disconnect</span><span class="p">()</span>
</code></pre></div></div>

<p><strong>Explanation:</strong> The <code class="language-plaintext highlighter-rouge">MCPAgent</code> holds an instance of <code class="language-plaintext highlighter-rouge">MCPClients</code>. In <code class="language-plaintext highlighter-rouge">initialize</code>, it tells <code class="language-plaintext highlighter-rouge">MCPClients</code> to connect to the server. It sets its own <code class="language-plaintext highlighter-rouge">available_tools</code> to point to the <code class="language-plaintext highlighter-rouge">MCPClients</code> instance. When the agent’s <code class="language-plaintext highlighter-rouge">think</code> method (inherited from <code class="language-plaintext highlighter-rouge">ToolCallAgent</code>) needs to consider or execute tools, it uses <code class="language-plaintext highlighter-rouge">self.available_tools</code>. Because this <em>is</em> the <code class="language-plaintext highlighter-rouge">MCPClients</code> object, any tool execution results in a remote call to the <code class="language-plaintext highlighter-rouge">MCPServer</code> via the proxy tools. The agent also adds logic to periodically <code class="language-plaintext highlighter-rouge">_refresh_tools</code> and <code class="language-plaintext highlighter-rouge">cleanup</code> the connection.</p>

<h2 id="wrapping-up-chapter-9">Wrapping Up Chapter 9</h2>

<p>Congratulations on completing the core concepts tutorial!</p>

<p>In this final chapter, we explored the <strong>Model Context Protocol (MCP)</strong>. You learned how MCP allows an <code class="language-plaintext highlighter-rouge">MCPAgent</code> to connect to an external <code class="language-plaintext highlighter-rouge">MCPServer</code> and dynamically discover and use tools hosted by that server. This provides a powerful way to extend agent capabilities with specialized tools without modifying the agent’s core code, enabling a flexible, plug-and-play architecture for agent skills.</p>

<p>You’ve journeyed through the essential building blocks of OpenManus:</p>
<ul>
  <li>The “brain” (<a href="01_llm.md">LLM</a>)</li>
  <li>Conversation history (<a href="02_message___memory.md">Message / Memory</a>)</li>
  <li>The agent structure (<a href="03_baseagent.md">BaseAgent</a>)</li>
  <li>Agent skills (<a href="04_tool___toolcollection.md">Tool / ToolCollection</a>)</li>
  <li>Multi-step task orchestration (<a href="05_baseflow.md">BaseFlow</a>)</li>
  <li>Data structure definitions (<a href="06_schema.md">Schema</a>)</li>
  <li>Settings management (<a href="07_configuration__config_.md">Configuration (Config)</a>)</li>
  <li>Secure code execution (<a href="08_dockersandbox.md">DockerSandbox</a>)</li>
  <li>And dynamic external tools (<a href="09_mcp__model_context_protocol_.md">MCP</a>)</li>
</ul>

<p>Armed with this knowledge, you’re now well-equipped to start exploring the OpenManus codebase, experimenting with different agents and tools, and building your own intelligent applications! Good luck!</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
