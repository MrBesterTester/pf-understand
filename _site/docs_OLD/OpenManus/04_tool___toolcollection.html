<h1 id="chapter-4-tool--toolcollection---giving-your-agent-skills">Chapter 4: Tool / ToolCollection - Giving Your Agent Skills</h1>

<p>In <a href="03_baseagent.md">Chapter 3: BaseAgent - The Agent Blueprint</a>, we learned how <code class="language-plaintext highlighter-rouge">BaseAgent</code> provides the standard structure for our agents, including a brain (<a href="01_llm.md">LLM</a>) and memory (<a href="02_message___memory.md">Message / Memory</a>). But what if we want our agent to do more than just <em>think</em> and <em>remember</em>? What if we want it to <em>act</em> in the world – like searching the web, running code, or editing files?</p>

<p>This is where <strong>Tools</strong> come in!</p>

<h2 id="what-problem-do-they-solve">What Problem Do They Solve?</h2>

<p>Imagine an agent trying to answer the question: “What’s the weather like in Tokyo <em>right now</em>?”</p>

<p>The agent’s LLM brain has a lot of general knowledge, but it doesn’t have <em>real-time</em> access to the internet. It can’t check the current weather. It needs a specific <strong>capability</strong> or <strong>skill</strong> to do that.</p>

<p>Similarly, if you ask an agent to “Write a python script that prints ‘hello world’ and save it to a file named <code class="language-plaintext highlighter-rouge">hello.py</code>,” the agent needs the ability to:</p>
<ol>
  <li>Understand the request (using its LLM).</li>
  <li>Write the code (using its LLM).</li>
  <li>Actually <em>execute</em> code to create and write to a file.</li>
</ol>

<p>Steps 1 and 2 are handled by the LLM, but step 3 requires interacting with the computer’s file system – something the LLM can’t do directly.</p>

<p><strong>Tools</strong> give agents these specific, actionable skills. A <code class="language-plaintext highlighter-rouge">ToolCollection</code> organizes these skills so the agent knows what it can do.</p>

<p><strong>Use Case:</strong> Let’s build towards an agent that can:</p>
<ol>
  <li>Search the web for today’s date.</li>
  <li>Tell the user the date.</li>
</ol>

<p>This agent needs a “Web Search” tool.</p>

<h2 id="key-concepts-tools-and-toolboxes">Key Concepts: Tools and Toolboxes</h2>

<p>Let’s break down the two main ideas:</p>

<h3 id="1-basetool-the-blueprint-for-a-skill">1. <code class="language-plaintext highlighter-rouge">BaseTool</code>: The Blueprint for a Skill</h3>

<p>Think of <code class="language-plaintext highlighter-rouge">BaseTool</code> (<code class="language-plaintext highlighter-rouge">app/tool/base.py</code>) as the <em>template</em> or <em>design specification</em> for any tool. It doesn’t <em>do</em> anything itself, but it defines what every tool needs to have:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">name</code> (str):</strong> A short, descriptive name for the tool (e.g., <code class="language-plaintext highlighter-rouge">web_search</code>, <code class="language-plaintext highlighter-rouge">file_writer</code>, <code class="language-plaintext highlighter-rouge">code_runner</code>). This is how the agent (or LLM) identifies the tool.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">description</code> (str):</strong> A clear explanation of what the tool does, what it’s good for, and when to use it. This is crucial for the LLM to decide <em>which</em> tool to use for a given task.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">parameters</code> (dict):</strong> A definition of the inputs the tool expects. For example, a <code class="language-plaintext highlighter-rouge">web_search</code> tool needs a <code class="language-plaintext highlighter-rouge">query</code> input, and a <code class="language-plaintext highlighter-rouge">file_writer</code> needs a <code class="language-plaintext highlighter-rouge">path</code> and <code class="language-plaintext highlighter-rouge">content</code>. This is defined using a standard format called JSON Schema.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">execute</code> method:</strong> An <strong>abstract</strong> method. This means <code class="language-plaintext highlighter-rouge">BaseTool</code> says “every tool <em>must</em> have an execute method”, but each specific tool needs to provide its <em>own</em> instructions for how to actually perform the action.</li>
</ul>

<p>You almost never use <code class="language-plaintext highlighter-rouge">BaseTool</code> directly. You use it as a starting point to create <em>actual</em>, usable tools.</p>

<h3 id="2-concrete-tools-the-actual-skills">2. Concrete Tools: The Actual Skills</h3>

<p>These are specific classes that <em>inherit</em> from <code class="language-plaintext highlighter-rouge">BaseTool</code> and provide the real implementation for the <code class="language-plaintext highlighter-rouge">execute</code> method. OpenManus comes with several pre-built tools:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">WebSearch</code> (<code class="language-plaintext highlighter-rouge">app/tool/web_search.py</code>):</strong> Searches the web using engines like Google, Bing, etc.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Bash</code> (<code class="language-plaintext highlighter-rouge">app/tool/bash.py</code>):</strong> Executes shell commands (like <code class="language-plaintext highlighter-rouge">ls</code>, <code class="language-plaintext highlighter-rouge">pwd</code>, <code class="language-plaintext highlighter-rouge">python script.py</code>).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">StrReplaceEditor</code> (<code class="language-plaintext highlighter-rouge">app/tool/str_replace_editor.py</code>):</strong> Views, creates, and edits files by replacing text.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">BrowserUseTool</code> (<code class="language-plaintext highlighter-rouge">app/tool/browser_use_tool.py</code>):</strong> Interacts with web pages like a user (clicking, filling forms, etc.).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Terminate</code> (<code class="language-plaintext highlighter-rouge">app/tool/terminate.py</code>):</strong> A special tool used by agents to signal they have finished their task.</li>
</ul>

<p>Each of these defines its specific <code class="language-plaintext highlighter-rouge">name</code>, <code class="language-plaintext highlighter-rouge">description</code>, <code class="language-plaintext highlighter-rouge">parameters</code>, and implements the <code class="language-plaintext highlighter-rouge">execute</code> method to perform its unique action.</p>

<h3 id="3-toolcollection-the-agents-toolbox">3. <code class="language-plaintext highlighter-rouge">ToolCollection</code>: The Agent’s Toolbox</h3>

<p>Think of a handyman. They don’t just carry one tool; they have a toolbox filled with hammers, screwdrivers, wrenches, etc.</p>

<p>A <code class="language-plaintext highlighter-rouge">ToolCollection</code> (<code class="language-plaintext highlighter-rouge">app/tool/tool_collection.py</code>) is like that toolbox for an agent.</p>

<ul>
  <li>It holds a list of specific tool instances (like <code class="language-plaintext highlighter-rouge">WebSearch</code>, <code class="language-plaintext highlighter-rouge">Bash</code>).</li>
  <li>It allows the agent (and its LLM) to see all the available tools and their descriptions.</li>
  <li>It provides a way to execute a specific tool by its name.</li>
</ul>

<p>When an agent needs to perform an action, its LLM can look at the <code class="language-plaintext highlighter-rouge">ToolCollection</code>, read the descriptions of the available tools, choose the best one for the job, figure out the necessary inputs based on the tool’s <code class="language-plaintext highlighter-rouge">parameters</code>, and then ask the <code class="language-plaintext highlighter-rouge">ToolCollection</code> to execute that tool with those inputs.</p>

<h2 id="how-do-we-use-them">How Do We Use Them?</h2>

<p>Let’s see how we can equip an agent with a simple tool. We’ll create a basic “EchoTool” first.</p>

<p><strong>1. Creating a Concrete Tool (Inheriting from <code class="language-plaintext highlighter-rouge">BaseTool</code>):</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Import the necessary base class
</span><span class="kn">from</span> <span class="nn">app.tool.base</span> <span class="kn">import</span> <span class="n">BaseTool</span><span class="p">,</span> <span class="n">ToolResult</span>

<span class="c1"># Define our simple tool
</span><span class="k">class</span> <span class="nc">EchoTool</span><span class="p">(</span><span class="n">BaseTool</span><span class="p">):</span>
    <span class="s">"""A simple tool that echoes the input text."""</span>

    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"echo_message"</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"Repeats back the text provided in the 'message' parameter."</span>
    <span class="n">parameters</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">"type"</span><span class="p">:</span> <span class="s">"object"</span><span class="p">,</span>
        <span class="s">"properties"</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">"message"</span><span class="p">:</span> <span class="p">{</span>
                <span class="s">"type"</span><span class="p">:</span> <span class="s">"string"</span><span class="p">,</span>
                <span class="s">"description"</span><span class="p">:</span> <span class="s">"The text to be echoed back."</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">},</span>
        <span class="s">"required"</span><span class="p">:</span> <span class="p">[</span><span class="s">"message"</span><span class="p">],</span> <span class="c1"># Tells the LLM 'message' must be provided
</span>    <span class="p">}</span>

    <span class="c1"># Implement the actual action
</span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ToolResult</span><span class="p">:</span>
        <span class="s">"""Takes a message and returns it."""</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"EchoTool executing with message: '</span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s">'"</span><span class="p">)</span>
        <span class="c1"># ToolResult is a standard way to return tool output
</span>        <span class="k">return</span> <span class="n">ToolResult</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="sa">f</span><span class="s">"You said: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># Create an instance of our tool
</span><span class="n">echo_tool_instance</span> <span class="o">=</span> <span class="n">EchoTool</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Tool Name: </span><span class="si">{</span><span class="n">echo_tool_instance</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Tool Description: </span><span class="si">{</span><span class="n">echo_tool_instance</span><span class="p">.</span><span class="n">description</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li>We import <code class="language-plaintext highlighter-rouge">BaseTool</code> and <code class="language-plaintext highlighter-rouge">ToolResult</code> (a standard object for wrapping tool outputs).</li>
  <li><code class="language-plaintext highlighter-rouge">class EchoTool(BaseTool):</code> declares that our <code class="language-plaintext highlighter-rouge">EchoTool</code> <em>is a type of</em> <code class="language-plaintext highlighter-rouge">BaseTool</code>.</li>
  <li>We define the <code class="language-plaintext highlighter-rouge">name</code>, <code class="language-plaintext highlighter-rouge">description</code>, and <code class="language-plaintext highlighter-rouge">parameters</code> according to the <code class="language-plaintext highlighter-rouge">BaseTool</code> template. The <code class="language-plaintext highlighter-rouge">parameters</code> structure tells the LLM what input is expected (<code class="language-plaintext highlighter-rouge">message</code> as a string) and that it’s required.</li>
  <li>We implement <code class="language-plaintext highlighter-rouge">async def execute(self, message: str) -&gt; ToolResult:</code>. This is the <em>specific</em> logic for our tool. It takes the <code class="language-plaintext highlighter-rouge">message</code> input and returns it wrapped in a <code class="language-plaintext highlighter-rouge">ToolResult</code>.</li>
</ul>

<p><strong>Example Output:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tool Name: echo_message
Tool Description: Repeats back the text provided in the 'message' parameter.
</code></pre></div></div>

<p><strong>2. Creating a ToolCollection:</strong></p>

<p>Now, let’s put our <code class="language-plaintext highlighter-rouge">EchoTool</code> and the built-in <code class="language-plaintext highlighter-rouge">WebSearch</code> tool into a toolbox.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Import ToolCollection and the tools we want
</span><span class="kn">from</span> <span class="nn">app.tool</span> <span class="kn">import</span> <span class="n">ToolCollection</span><span class="p">,</span> <span class="n">WebSearch</span>
<span class="c1"># Assume EchoTool class is defined as above
# from your_module import EchoTool # Or wherever EchoTool is defined
</span>
<span class="c1"># Create instances of the tools
</span><span class="n">echo_tool</span> <span class="o">=</span> <span class="n">EchoTool</span><span class="p">()</span>
<span class="n">web_search_tool</span> <span class="o">=</span> <span class="n">WebSearch</span><span class="p">()</span> <span class="c1"># Uses default settings
</span>
<span class="c1"># Create a ToolCollection containing these tools
</span><span class="n">my_toolbox</span> <span class="o">=</span> <span class="n">ToolCollection</span><span class="p">(</span><span class="n">echo_tool</span><span class="p">,</span> <span class="n">web_search_tool</span><span class="p">)</span>

<span class="c1"># See the names of the tools in the collection
</span><span class="n">tool_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">tool</span><span class="p">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">tool</span> <span class="ow">in</span> <span class="n">my_toolbox</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Tools in the toolbox: </span><span class="si">{</span><span class="n">tool_names</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># Get the parameters needed for the LLM
</span><span class="n">tool_params_for_llm</span> <span class="o">=</span> <span class="n">my_toolbox</span><span class="p">.</span><span class="n">to_params</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">Parameters for LLM (showing first tool):"</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="k">print</span><span class="p">(</span><span class="n">json</span><span class="p">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">tool_params_for_llm</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li>We import <code class="language-plaintext highlighter-rouge">ToolCollection</code> and the specific tools (<code class="language-plaintext highlighter-rouge">WebSearch</code>, <code class="language-plaintext highlighter-rouge">EchoTool</code>).</li>
  <li>We create instances of the tools we need.</li>
  <li><code class="language-plaintext highlighter-rouge">my_toolbox = ToolCollection(echo_tool, web_search_tool)</code> creates the collection, holding our tool instances.</li>
  <li>We can access the tools inside using <code class="language-plaintext highlighter-rouge">my_toolbox.tools</code> or iterate over <code class="language-plaintext highlighter-rouge">my_toolbox</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">my_toolbox.to_params()</code> is a crucial method. It formats the <code class="language-plaintext highlighter-rouge">name</code>, <code class="language-plaintext highlighter-rouge">description</code>, and <code class="language-plaintext highlighter-rouge">parameters</code> of <em>all</em> tools in the collection into a list of dictionaries. This specific format is exactly what the agent’s <a href="01_llm.md">LLM</a> needs (when using its <code class="language-plaintext highlighter-rouge">ask_tool</code> method) to understand which tools are available and how to use them.</li>
</ul>

<p><strong>Example Output:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Tools in the toolbox: ['echo_message', 'web_search']

Parameters for LLM (showing first tool):
{
  "type": "function",
  "function": {
    "name": "echo_message",
    "description": "Repeats back the text provided in the 'message' parameter.",
    "parameters": {
      "type": "object",
      "properties": {
        "message": {
          "type": "string",
          "description": "The text to be echoed back."
        }
      },
      "required": [
        "message"
      ]
    }
  }
}
</code></pre></div></div>

<p><strong>3. Agent Using the ToolCollection:</strong></p>

<p>Now, how does an agent like <code class="language-plaintext highlighter-rouge">ToolCallAgent</code> (a specific type of <a href="03_baseagent.md">BaseAgent</a>) use this?</p>

<p>Conceptually (the real agent code is more complex):</p>

<ol>
  <li>The agent is configured with a <code class="language-plaintext highlighter-rouge">ToolCollection</code> (like <code class="language-plaintext highlighter-rouge">my_toolbox</code>).</li>
  <li>When the agent needs to figure out the next step, it calls its LLM’s <code class="language-plaintext highlighter-rouge">ask_tool</code> method.</li>
  <li>It passes the conversation history (<a href="02_message___memory.md">Message / Memory</a>) AND the output of <code class="language-plaintext highlighter-rouge">my_toolbox.to_params()</code> to the LLM.</li>
  <li>The LLM looks at the conversation and the list of available tools (from <code class="language-plaintext highlighter-rouge">to_params()</code>). It reads the <code class="language-plaintext highlighter-rouge">description</code> of each tool to understand what it does.</li>
  <li>If the LLM decides a tool is needed (e.g., the user asked “What’s today’s date?”, the LLM sees the <code class="language-plaintext highlighter-rouge">web_search</code> tool is available and appropriate), it will generate a special response indicating:
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">name</code> of the tool to use (e.g., <code class="language-plaintext highlighter-rouge">"web_search"</code>).</li>
      <li>The <code class="language-plaintext highlighter-rouge">arguments</code> (inputs) for the tool, based on its <code class="language-plaintext highlighter-rouge">parameters</code> (e.g., <code class="language-plaintext highlighter-rouge">{"query": "today's date"}</code>).</li>
    </ul>
  </li>
  <li>The agent receives this response from the LLM.</li>
  <li>The agent then uses the <code class="language-plaintext highlighter-rouge">ToolCollection</code>’s <code class="language-plaintext highlighter-rouge">execute</code> method: <code class="language-plaintext highlighter-rouge">await my_toolbox.execute(name="web_search", tool_input={"query": "today's date"})</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">ToolCollection</code> finds the <code class="language-plaintext highlighter-rouge">WebSearch</code> tool instance in its internal <code class="language-plaintext highlighter-rouge">tool_map</code> and calls <em>its</em> <code class="language-plaintext highlighter-rouge">execute</code> method with the provided input.</li>
  <li>The <code class="language-plaintext highlighter-rouge">WebSearch</code> tool runs, performs the actual web search, and returns the results (as a <code class="language-plaintext highlighter-rouge">ToolResult</code> or similar).</li>
  <li>The agent takes this result, formats it as a <code class="language-plaintext highlighter-rouge">tool</code> message, adds it to its memory, and continues its thinking process (often asking the LLM again, now with the tool’s result as context).</li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">ToolCollection</code> acts as the crucial bridge between the LLM’s <em>decision</em> to use a tool and the <em>actual execution</em> of that tool’s code.</p>

<h2 id="under-the-hood-how-toolcollectionexecute-works">Under the Hood: How <code class="language-plaintext highlighter-rouge">ToolCollection.execute</code> Works</h2>

<p>Let’s trace the flow when an agent asks its <code class="language-plaintext highlighter-rouge">ToolCollection</code> to run a tool:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Agent as ToolCallAgent
    participant LLM as LLM (Deciding Step)
    participant Toolbox as ToolCollection
    participant SpecificTool as e.g., WebSearch Tool

    Agent-&gt;&gt;+LLM: ask_tool(messages, tools=Toolbox.to_params())
    LLM-&gt;&gt;LLM: Analyzes messages &amp; available tools
    LLM--&gt;&gt;-Agent: Response indicating tool call: name='web_search', arguments={'query': '...'}
    Agent-&gt;&gt;+Toolbox: execute(name='web_search', tool_input={'query': '...'})
    Toolbox-&gt;&gt;Toolbox: Look up 'web_search' in internal tool_map
    Note right of Toolbox: Finds the WebSearch instance
    Toolbox-&gt;&gt;+SpecificTool: Calls execute(**tool_input) on the found tool
    SpecificTool-&gt;&gt;SpecificTool: Performs actual web search action
    SpecificTool--&gt;&gt;-Toolbox: Returns ToolResult (output="...", error=None)
    Toolbox--&gt;&gt;-Agent: Returns the ToolResult
    Agent-&gt;&gt;Agent: Processes the result (adds to memory, etc.)
</code></pre>

<p><strong>Code Glimpse:</strong></p>

<p>Let’s look at the <code class="language-plaintext highlighter-rouge">ToolCollection</code> itself in <code class="language-plaintext highlighter-rouge">app/tool/tool_collection.py</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified snippet from app/tool/tool_collection.py
</span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">from</span> <span class="nn">app.tool.base</span> <span class="kn">import</span> <span class="n">BaseTool</span><span class="p">,</span> <span class="n">ToolResult</span><span class="p">,</span> <span class="n">ToolFailure</span>
<span class="kn">from</span> <span class="nn">app.exceptions</span> <span class="kn">import</span> <span class="n">ToolError</span>

<span class="k">class</span> <span class="nc">ToolCollection</span><span class="p">:</span>
    <span class="c1"># ... (Config class) ...
</span>
    <span class="n">tools</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">BaseTool</span><span class="p">,</span> <span class="p">...]</span> <span class="c1"># Holds the tool instances
</span>    <span class="n">tool_map</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">BaseTool</span><span class="p">]</span> <span class="c1"># Maps name to tool instance for quick lookup
</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">tools</span><span class="p">:</span> <span class="n">BaseTool</span><span class="p">):</span>
        <span class="s">"""Initializes with a sequence of tools."""</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">tools</span> <span class="o">=</span> <span class="n">tools</span>
        <span class="c1"># Create the map for easy lookup by name
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">tool_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">tool</span><span class="p">.</span><span class="n">name</span><span class="p">:</span> <span class="n">tool</span> <span class="k">for</span> <span class="n">tool</span> <span class="ow">in</span> <span class="n">tools</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">to_params</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="s">"""Formats tools for the LLM API."""</span>
        <span class="c1"># Calls the 'to_param()' method on each tool
</span>        <span class="k">return</span> <span class="p">[</span><span class="n">tool</span><span class="p">.</span><span class="n">to_param</span><span class="p">()</span> <span class="k">for</span> <span class="n">tool</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">tools</span><span class="p">]</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">execute</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">tool_input</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ToolResult</span><span class="p">:</span>
        <span class="s">"""Finds a tool by name and executes it."""</span>
        <span class="c1"># 1. Find the tool instance using the name
</span>        <span class="n">tool</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">tool_map</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">tool</span><span class="p">:</span>
            <span class="c1"># Return a standard failure result if tool not found
</span>            <span class="k">return</span> <span class="n">ToolFailure</span><span class="p">(</span><span class="n">error</span><span class="o">=</span><span class="sa">f</span><span class="s">"Tool </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s"> is invalid"</span><span class="p">)</span>

        <span class="c1"># 2. Execute the tool's specific method
</span>        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># The 'tool(**tool_input)' calls the tool instance's __call__ method,
</span>            <span class="c1"># which in BaseTool, calls the tool's 'execute' method.
</span>            <span class="c1"># The ** unpacks the dictionary into keyword arguments.
</span>            <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="n">tool</span><span class="p">(</span><span class="o">**</span><span class="p">(</span><span class="n">tool_input</span> <span class="ow">or</span> <span class="p">{}))</span>
            <span class="c1"># Ensure the result is a ToolResult (or subclass)
</span>            <span class="k">return</span> <span class="n">result</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">ToolResult</span><span class="p">)</span> <span class="k">else</span> <span class="n">ToolResult</span><span class="p">(</span><span class="n">output</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
        <span class="k">except</span> <span class="n">ToolError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
             <span class="c1"># Handle errors specific to tools
</span>            <span class="k">return</span> <span class="n">ToolFailure</span><span class="p">(</span><span class="n">error</span><span class="o">=</span><span class="n">e</span><span class="p">.</span><span class="n">message</span><span class="p">)</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
             <span class="c1"># Handle unexpected errors during execution
</span>            <span class="k">return</span> <span class="n">ToolFailure</span><span class="p">(</span><span class="n">error</span><span class="o">=</span><span class="sa">f</span><span class="s">"Unexpected error executing tool </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

    <span class="c1"># ... other methods like add_tool, __iter__ ...
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">__init__</code> method takes tool instances and stores them in <code class="language-plaintext highlighter-rouge">self.tools</code> (a tuple) and <code class="language-plaintext highlighter-rouge">self.tool_map</code> (a dictionary mapping name to instance).</li>
  <li><code class="language-plaintext highlighter-rouge">to_params</code> iterates through <code class="language-plaintext highlighter-rouge">self.tools</code> and calls each tool’s <code class="language-plaintext highlighter-rouge">to_param()</code> method (defined in <code class="language-plaintext highlighter-rouge">BaseTool</code>) to get the LLM-compatible format.</li>
  <li><code class="language-plaintext highlighter-rouge">execute</code> is the core method used by agents:
    <ul>
      <li>It uses <code class="language-plaintext highlighter-rouge">self.tool_map.get(name)</code> to quickly find the correct tool instance based on the requested name.</li>
      <li>If found, it calls <code class="language-plaintext highlighter-rouge">await tool(**(tool_input or {}))</code>. The <code class="language-plaintext highlighter-rouge">**</code> unpacks the <code class="language-plaintext highlighter-rouge">tool_input</code> dictionary into keyword arguments for the tool’s <code class="language-plaintext highlighter-rouge">execute</code> method (e.g., <code class="language-plaintext highlighter-rouge">message="hello"</code> for our <code class="language-plaintext highlighter-rouge">EchoTool</code>, or <code class="language-plaintext highlighter-rouge">query="today's date"</code> for <code class="language-plaintext highlighter-rouge">WebSearch</code>).</li>
      <li>It wraps the execution in <code class="language-plaintext highlighter-rouge">try...except</code> blocks to catch errors and return a standardized <code class="language-plaintext highlighter-rouge">ToolFailure</code> result if anything goes wrong.</li>
    </ul>
  </li>
</ul>

<h2 id="wrapping-up-chapter-4">Wrapping Up Chapter 4</h2>

<p>We’ve learned how <strong>Tools</strong> give agents specific skills beyond basic language understanding.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">BaseTool</code> is the abstract blueprint defining a tool’s <code class="language-plaintext highlighter-rouge">name</code>, <code class="language-plaintext highlighter-rouge">description</code>, and expected <code class="language-plaintext highlighter-rouge">parameters</code>.</li>
  <li>Concrete tools (like <code class="language-plaintext highlighter-rouge">WebSearch</code>, <code class="language-plaintext highlighter-rouge">Bash</code>, or our custom <code class="language-plaintext highlighter-rouge">EchoTool</code>) inherit from <code class="language-plaintext highlighter-rouge">BaseTool</code> and implement the actual <code class="language-plaintext highlighter-rouge">execute</code> logic.</li>
  <li><code class="language-plaintext highlighter-rouge">ToolCollection</code> acts as the agent’s toolbox, holding various tools and providing methods (<code class="language-plaintext highlighter-rouge">to_params</code>, <code class="language-plaintext highlighter-rouge">execute</code>) for the agent (often guided by its <a href="01_llm.md">LLM</a>) to discover and use these capabilities.</li>
</ul>

<p>With tools, agents can interact with external systems, run code, access real-time data, and perform complex actions, making them much more powerful.</p>

<p>But how do we coordinate multiple agents, potentially using different tools, to work together on a larger task? That’s where Flows come in.</p>

<p>Let’s move on to <a href="05_baseflow.md">Chapter 5: BaseFlow</a> to see how we orchestrate complex workflows involving multiple agents and steps.</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
