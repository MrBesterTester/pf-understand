<h1 id="chapter-6-schema---the-official-data-forms">Chapter 6: Schema - The Official Data Forms</h1>

<p>In <a href="05_baseflow.md">Chapter 5: BaseFlow</a>, we saw how Flows act like project managers, coordinating different <a href="03_baseagent.md">Agents</a> and <a href="04_tool___toolcollection.md">Tools</a> to complete complex tasks. But for all these different parts (Flows, Agents, LLMs, Tools) to work together smoothly, they need to speak the same language and use the same formats when exchanging information.</p>

<p>Imagine a busy office where everyone fills out forms for requests, reports, and messages. If everyone uses their <em>own</em> unique form layout, it quickly becomes chaotic! Someone might forget a required field, use the wrong data type (like writing “yesterday” instead of a specific date), or mislabel information. It would be incredibly hard to process anything efficiently.</p>

<p>This is where <strong>Schemas</strong> come into play in OpenManus.</p>

<h2 id="what-problem-does-schema-solve">What Problem Does Schema Solve?</h2>

<p>In our digital “office” (the OpenManus application), various components need to pass data back and forth:</p>
<ul>
  <li>The User sends a request (a message).</li>
  <li>The Agent stores this message in its <a href="02_message___memory.md">Memory</a>.</li>
  <li>The Agent might ask the <a href="01_llm.md">LLM</a> for help, sending the conversation history.</li>
  <li>The LLM might decide to use a <a href="04_tool___toolcollection.md">Tool</a>, sending back instructions on which tool and what inputs to use.</li>
  <li>The Tool executes and sends back its results.</li>
  <li>The Agent updates its status (e.g., from <code class="language-plaintext highlighter-rouge">RUNNING</code> to <code class="language-plaintext highlighter-rouge">FINISHED</code>).</li>
</ul>

<p>Without a standard way to structure all this information, we’d face problems:</p>
<ul>
  <li><strong>Inconsistency:</strong> One part might expect a user message to have a <code class="language-plaintext highlighter-rouge">sender</code> field, while another expects a <code class="language-plaintext highlighter-rouge">role</code> field.</li>
  <li><strong>Errors:</strong> A Tool might expect a number as input but receive text, causing it to crash.</li>
  <li><strong>Confusion:</strong> It would be hard for developers (and the system itself!) to know exactly what information is contained in a piece of data.</li>
  <li><strong>Maintenance Nightmares:</strong> Changing how data is structured in one place could break many other parts unexpectedly.</li>
</ul>

<p><strong>Schemas solve this by defining the official “forms” or “templates” for all the important data structures used in OpenManus.</strong> Think of them as the agreed-upon standard formats that everyone must use.</p>

<p><strong>Use Case:</strong> When the LLM decides the agent should use the <code class="language-plaintext highlighter-rouge">web_search</code> tool with the query “latest AI news”, it doesn’t just send back a vague text string. It needs to send structured data that clearly says:</p>
<ol>
  <li>“I want to call a tool.”</li>
  <li>“The tool’s name is <code class="language-plaintext highlighter-rouge">web_search</code>.”</li>
  <li>“The input parameter <code class="language-plaintext highlighter-rouge">query</code> should be set to <code class="language-plaintext highlighter-rouge">latest AI news</code>.”</li>
</ol>

<p>A schema defines exactly how this “tool call request” should look, ensuring the Agent understands it correctly.</p>

<h2 id="key-concepts-standard-templates-via-pydantic">Key Concepts: Standard Templates via Pydantic</h2>

<ol>
  <li><strong>Schema as Templates:</strong> At its core, a schema is a formal definition of a data structure. It specifies:
    <ul>
      <li>What pieces of information (fields) must be included (e.g., a <code class="language-plaintext highlighter-rouge">Message</code> must have a <code class="language-plaintext highlighter-rouge">role</code>).</li>
      <li>What type each piece of information should be (e.g., <code class="language-plaintext highlighter-rouge">role</code> must be text, <code class="language-plaintext highlighter-rouge">current_step</code> in an Agent must be a number).</li>
      <li>Which fields are optional and which are required.</li>
      <li>Sometimes, default values or specific allowed values (e.g., <code class="language-plaintext highlighter-rouge">role</code> must be one of “user”, “assistant”, “system”, or “tool”).</li>
    </ul>
  </li>
  <li><strong>Pydantic: The Schema Engine:</strong> OpenManus uses a popular Python library called <strong>Pydantic</strong> to define and enforce these schemas. You don’t need to be a Pydantic expert, but understanding its role is helpful. Pydantic lets us define these data structures using simple Python classes. When data is loaded into these classes, Pydantic automatically:
    <ul>
      <li><strong>Validates</strong> the data: Checks if all required fields are present and if the data types are correct. If not, it raises an error <em>before</em> the bad data can cause problems elsewhere.</li>
      <li><strong>Provides Auto-completion and Clarity:</strong> Because the structure is clearly defined in code, developers get better auto-completion hints in their editors, making the code easier to write and understand.</li>
    </ul>
  </li>
</ol>

<p>Think of Pydantic as the strict office manager who checks every form submitted, ensuring it’s filled out correctly according to the official template before passing it on.</p>

<h2 id="how-do-we-use-schemas-examples">How Do We Use Schemas? (Examples)</h2>

<p>Schemas are defined throughout the OpenManus codebase, primarily as Pydantic models. You’ve already encountered some! Let’s look at a few key examples found mostly in <code class="language-plaintext highlighter-rouge">app/schema.py</code> and <code class="language-plaintext highlighter-rouge">app/tool/base.py</code>.</p>

<p><strong>1. <code class="language-plaintext highlighter-rouge">Message</code> (from <code class="language-plaintext highlighter-rouge">app/schema.py</code>): The Chat Bubble</strong></p>

<p>We saw this in <a href="02_message___memory.md">Chapter 2: Message / Memory</a>. It defines the structure for a single turn in a conversation.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified Pydantic model from app/schema.py
</span><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Literal</span>

<span class="c1"># Define allowed roles
</span><span class="n">ROLE_TYPE</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s">"system"</span><span class="p">,</span> <span class="s">"user"</span><span class="p">,</span> <span class="s">"assistant"</span><span class="p">,</span> <span class="s">"tool"</span><span class="p">]</span>

<span class="k">class</span> <span class="nc">Message</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">role</span><span class="p">:</span> <span class="n">ROLE_TYPE</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(...)</span> <span class="c1"># '...' means this field is required
</span>    <span class="n">content</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span> <span class="c1"># Optional text content
</span>    <span class="c1"># ... other optional fields like tool_calls, name, tool_call_id ...
</span>
    <span class="c1"># Class methods like user_message, assistant_message are here...
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ul>
  <li>This Pydantic class <code class="language-plaintext highlighter-rouge">Message</code> defines the “form” for a message.</li>
  <li><code class="language-plaintext highlighter-rouge">role: ROLE_TYPE = Field(...)</code> means every message <em>must</em> have a <code class="language-plaintext highlighter-rouge">role</code>, and its value must be one of the strings defined in <code class="language-plaintext highlighter-rouge">ROLE_TYPE</code>. Pydantic enforces this.</li>
  <li><code class="language-plaintext highlighter-rouge">content: Optional[str] = Field(default=None)</code> means a message <em>can</em> have text <code class="language-plaintext highlighter-rouge">content</code>, but it’s optional. If not provided, it defaults to <code class="language-plaintext highlighter-rouge">None</code>.</li>
  <li>Pydantic ensures that if you try to create a <code class="language-plaintext highlighter-rouge">Message</code> object without a valid <code class="language-plaintext highlighter-rouge">role</code>, or with <code class="language-plaintext highlighter-rouge">content</code> that isn’t a string, you’ll get an error immediately.</li>
</ul>

<p><strong>2. <code class="language-plaintext highlighter-rouge">ToolCall</code> and <code class="language-plaintext highlighter-rouge">Function</code> (from <code class="language-plaintext highlighter-rouge">app/schema.py</code>): The Tool Request Form</strong></p>

<p>When the LLM tells the agent to use a tool, it sends back data structured according to the <code class="language-plaintext highlighter-rouge">ToolCall</code> schema.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified Pydantic models from app/schema.py
</span><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>

<span class="k">class</span> <span class="nc">Function</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>      <span class="c1"># The name of the tool/function to call
</span>    <span class="n">arguments</span><span class="p">:</span> <span class="nb">str</span> <span class="c1"># The input arguments as a JSON string
</span>
<span class="k">class</span> <span class="nc">ToolCall</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span>              <span class="c1"># A unique ID for this specific call
</span>    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"function"</span> <span class="c1"># Currently always "function"
</span>    <span class="n">function</span><span class="p">:</span> <span class="n">Function</span>   <span class="c1"># Embeds the Function details above
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ul>
  <li>The <code class="language-plaintext highlighter-rouge">Function</code> schema defines that we need the <code class="language-plaintext highlighter-rouge">name</code> of the tool (as text) and its <code class="language-plaintext highlighter-rouge">arguments</code> (also as text, expected to be formatted as JSON).</li>
  <li>The <code class="language-plaintext highlighter-rouge">ToolCall</code> schema includes a unique <code class="language-plaintext highlighter-rouge">id</code>, the <code class="language-plaintext highlighter-rouge">type</code> (always “function” for now), and embeds the <code class="language-plaintext highlighter-rouge">Function</code> data.</li>
  <li>This ensures that whenever the agent receives a tool call instruction from the LLM, it knows exactly where to find the tool’s name and arguments, preventing guesswork and errors.</li>
</ul>

<p><strong>3. <code class="language-plaintext highlighter-rouge">AgentState</code> (from <code class="language-plaintext highlighter-rouge">app/schema.py</code>): The Agent Status Report</strong></p>

<p>We saw this in <a href="03_baseagent.md">Chapter 3: BaseAgent</a>. It standardizes how we represent the agent’s current status.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified definition from app/schema.py
</span><span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>

<span class="k">class</span> <span class="nc">AgentState</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
    <span class="s">"""Agent execution states"""</span>
    <span class="n">IDLE</span> <span class="o">=</span> <span class="s">"IDLE"</span>
    <span class="n">RUNNING</span> <span class="o">=</span> <span class="s">"RUNNING"</span>
    <span class="n">FINISHED</span> <span class="o">=</span> <span class="s">"FINISHED"</span>
    <span class="n">ERROR</span> <span class="o">=</span> <span class="s">"ERROR"</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ul>
  <li>This uses Python’s <code class="language-plaintext highlighter-rouge">Enum</code> (Enumeration) type, which is automatically compatible with Pydantic.</li>
  <li>It defines a fixed set of allowed values for the agent’s state. An agent’s state <em>must</em> be one of these four strings.</li>
  <li>This prevents typos (like “Runing” or “Idle”) and makes it easy to check the agent’s status reliably.</li>
</ul>

<p><strong>4. <code class="language-plaintext highlighter-rouge">ToolResult</code> (from <code class="language-plaintext highlighter-rouge">app/tool/base.py</code>): The Tool Output Form</strong></p>

<p>When a <a href="04_tool___toolcollection.md">Tool</a> finishes its job, it needs to report back its findings in a standard way.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified Pydantic model from app/tool/base.py
</span><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">Field</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span>

<span class="k">class</span> <span class="nc">ToolResult</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="s">"""Represents the result of a tool execution."""</span>
    <span class="n">output</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>          <span class="c1"># The main result data
</span>    <span class="n">error</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span> <span class="c1"># Error message, if any
</span>    <span class="c1"># ... other optional fields like base64_image, system message ...
</span>
    <span class="k">class</span> <span class="nc">Config</span><span class="p">:</span>
        <span class="n">arbitrary_types_allowed</span> <span class="o">=</span> <span class="bp">True</span> <span class="c1"># Allows 'Any' type for output
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ul>
  <li>Defines a standard structure for <em>any</em> tool’s output.</li>
  <li>It includes an <code class="language-plaintext highlighter-rouge">output</code> field for the successful result (which can be of <code class="language-plaintext highlighter-rouge">Any</code> type, allowing flexibility for different tools) and an optional <code class="language-plaintext highlighter-rouge">error</code> field to report problems.</li>
  <li>Specific tools might <em>inherit</em> from <code class="language-plaintext highlighter-rouge">ToolResult</code> to add more specific fields, like <code class="language-plaintext highlighter-rouge">SearchResult</code> adding <code class="language-plaintext highlighter-rouge">url</code>, <code class="language-plaintext highlighter-rouge">title</code>, etc. (see <code class="language-plaintext highlighter-rouge">app/tool/web_search.py</code>). Using <code class="language-plaintext highlighter-rouge">ToolResult</code> as a base ensures all tool outputs have a consistent minimum structure.</li>
</ul>

<h2 id="under-the-hood-pydantic-validation">Under the Hood: Pydantic Validation</h2>

<p>The real power of using Pydantic for schemas comes from its automatic data validation. Let’s illustrate with a simplified <code class="language-plaintext highlighter-rouge">Message</code> example.</p>

<p>Imagine you have this Pydantic model:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Standalone Example (Illustrative)
</span><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="n">ValidationError</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span>

<span class="n">ROLE_TYPE</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s">"user"</span><span class="p">,</span> <span class="s">"assistant"</span><span class="p">]</span> <span class="c1"># Only allow these roles
</span>
<span class="k">class</span> <span class="nc">SimpleMessage</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">role</span><span class="p">:</span> <span class="n">ROLE_TYPE</span>
    <span class="n">content</span><span class="p">:</span> <span class="nb">str</span>
</code></pre></div></div>

<p>Now, let’s see what happens when we try to create instances:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- Valid Data ---
</span><span class="k">try</span><span class="p">:</span>
    <span class="n">msg1</span> <span class="o">=</span> <span class="n">SimpleMessage</span><span class="p">(</span><span class="n">role</span><span class="o">=</span><span class="s">"user"</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="s">"Hello there!"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"msg1 created successfully:"</span><span class="p">,</span> <span class="n">msg1</span><span class="p">.</span><span class="n">model_dump</span><span class="p">())</span> <span class="c1"># .model_dump() shows dict
</span><span class="k">except</span> <span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Error creating msg1:"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>

<span class="c1"># --- Missing Required Field ('content') ---
</span><span class="k">try</span><span class="p">:</span>
    <span class="n">msg2</span> <span class="o">=</span> <span class="n">SimpleMessage</span><span class="p">(</span><span class="n">role</span><span class="o">=</span><span class="s">"assistant"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"msg2 created successfully:"</span><span class="p">,</span> <span class="n">msg2</span><span class="p">.</span><span class="n">model_dump</span><span class="p">())</span>
<span class="k">except</span> <span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Error creating msg2:"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="c1"># Pydantic gives a detailed error
</span>
<span class="c1"># --- Invalid Role ---
</span><span class="k">try</span><span class="p">:</span>
    <span class="n">msg3</span> <span class="o">=</span> <span class="n">SimpleMessage</span><span class="p">(</span><span class="n">role</span><span class="o">=</span><span class="s">"system"</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="s">"System message"</span><span class="p">)</span> <span class="c1"># 'system' is not allowed
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"msg3 created successfully:"</span><span class="p">,</span> <span class="n">msg3</span><span class="p">.</span><span class="n">model_dump</span><span class="p">())</span>
<span class="k">except</span> <span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Error creating msg3:"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="c1"># Pydantic catches the wrong role
</span>
<span class="c1"># --- Wrong Data Type for 'content' ---
</span><span class="k">try</span><span class="p">:</span>
    <span class="n">msg4</span> <span class="o">=</span> <span class="n">SimpleMessage</span><span class="p">(</span><span class="n">role</span><span class="o">=</span><span class="s">"user"</span><span class="p">,</span> <span class="n">content</span><span class="o">=</span><span class="mi">123</span><span class="p">)</span> <span class="c1"># content should be string
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"msg4 created successfully:"</span><span class="p">,</span> <span class="n">msg4</span><span class="p">.</span><span class="n">model_dump</span><span class="p">())</span>
<span class="k">except</span> <span class="n">ValidationError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Error creating msg4:"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="c1"># Pydantic catches the type error
</span></code></pre></div></div>

<p><strong>Example Output:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msg1 created successfully: {'role': 'user', 'content': 'Hello there!'}

Error creating msg2:
1 validation error for SimpleMessage
content
  Field required [type=missing, input_value={'role': 'assistant'}, input_type=dict]
    For further information visit https://errors.pydantic.dev/2.7/v/missing

Error creating msg3:
1 validation error for SimpleMessage
role
  Input should be 'user' or 'assistant' [type=literal_error, input_value='system', input_type=str]
    For further information visit https://errors.pydantic.dev/2.7/v/literal_error

Error creating msg4:
1 validation error for SimpleMessage
content
  Input should be a valid string [type=string_type, input_value=123, input_type=int]
    For further information visit https://errors.pydantic.dev/2.7/v/string_type
</code></pre></div></div>

<p><strong>Explanation:</strong></p>
<ul>
  <li>When the data matches the schema (<code class="language-plaintext highlighter-rouge">msg1</code>), the object is created successfully.</li>
  <li>When data is missing (<code class="language-plaintext highlighter-rouge">msg2</code>), has an invalid value (<code class="language-plaintext highlighter-rouge">msg3</code>), or the wrong type (<code class="language-plaintext highlighter-rouge">msg4</code>), Pydantic automatically raises a <code class="language-plaintext highlighter-rouge">ValidationError</code>.</li>
  <li>The error message clearly explains <em>what</em> is wrong and <em>where</em>.</li>
</ul>

<p>This validation happens automatically whenever data is loaded into these Pydantic models within OpenManus, catching errors early and ensuring data consistency across the entire application. You mostly find these schema definitions in <code class="language-plaintext highlighter-rouge">app/schema.py</code>, but also within specific tool files (like <code class="language-plaintext highlighter-rouge">app/tool/base.py</code>, <code class="language-plaintext highlighter-rouge">app/tool/web_search.py</code>) for their specific results.</p>

<h2 id="wrapping-up-chapter-6">Wrapping Up Chapter 6</h2>

<p>You’ve learned that <strong>Schemas</strong> are like official data templates or forms used throughout OpenManus. They define the expected structure for important data like messages, tool calls, agent states, and tool results. By using the <strong>Pydantic</strong> library, OpenManus automatically <strong>validates</strong> data against these schemas, ensuring consistency, preventing errors, and making the whole system more reliable and easier to understand. They are the backbone of structured communication between different components.</p>

<p>We’ve now covered most of the core functional building blocks of OpenManus. But how do we configure things like which LLM model to use, API keys, or which tools an agent should have? That’s handled by the Configuration system.</p>

<p>Let’s move on to <a href="07_configuration__config_.md">Chapter 7: Configuration (Config)</a> to see how we manage settings and secrets for our agents and flows.</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
