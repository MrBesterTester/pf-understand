<h1 id="chapter-4-flow-flow-asyncflow">Chapter 4: Flow (<code class="language-plaintext highlighter-rouge">Flow</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</h1>

<p>In <a href="03_actions___transitions__.md">Chapter 3: Actions / Transitions</a>, we saw how individual <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> can decide what should happen next by returning “action” strings, and how these actions lead to “transitions” between Nodes. But what actually manages this sequence? What’s the conductor of this orchestra of Nodes? That’s where <strong>Flows</strong> come in!</p>

<h2 id="what-problem-do-flows-solve-meet-the-orchestrator">What Problem Do Flows Solve? Meet the Orchestrator!</h2>

<p>Imagine you’re building a simple AI application that interacts with a user:</p>
<ol>
  <li><strong>Greet User Node</strong>: Displays a welcome message.</li>
  <li><strong>Get Name Node</strong>: Asks the user for their name and stores it.</li>
  <li><strong>Personalized Message Node</strong>: Uses the name to give a personalized response.</li>
</ol>

<p>Each step is a <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a>. But how do you ensure they run in the correct order? How does the “Get Name Node” know to run after “Greet User Node”, and how is the name passed along? This is the job of a <strong>Flow</strong>.</p>

<p>A <strong>Flow</strong> is like the <strong>blueprint</strong> or the <strong>manager</strong> of an assembly line. It defines the sequence of operations by connecting multiple <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> into a complete workflow. It dictates:</p>
<ul>
  <li>Which <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> starts the process.</li>
  <li>How to move from one <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> to another based on the <a href="03_actions___transitions__.md">Actions / Transitions</a> we learned about.</li>
  <li>It ensures the <a href="01_shared_state___shared__dictionary__.md">shared dictionary</a> is passed along, so all <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> have access to the data they need.</li>
</ul>

<p>PocketFlow offers two main types of Flows:</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Flow</code></strong>: For workflows that consist primarily of synchronous <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> (tasks that run one after another, blocking until complete).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">AsyncFlow</code></strong>: For workflows that include asynchronous <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> (tasks that can “pause” and let other operations run, like waiting for user input or a network request).</li>
</ul>

<p>Let’s see how to build and use them!</p>

<h2 id="building-your-first-flow">Building Your First <code class="language-plaintext highlighter-rouge">Flow</code></h2>

<p>Let’s create a simple text transformation workflow using <code class="language-plaintext highlighter-rouge">Flow</code>. It will:</p>
<ol>
  <li>Get text input from the user.</li>
  <li>Offer transformation choices (uppercase, lowercase, etc.).</li>
  <li>Transform the text.</li>
  <li>Ask if the user wants to do another transformation or exit.</li>
</ol>

<p>This example is inspired by <code class="language-plaintext highlighter-rouge">cookbook/pocketflow-flow/flow.py</code>.</p>

<p><strong>Step 1: Define Your Nodes</strong></p>

<p>First, we need our worker <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a>. (We’ll use conceptual Node definitions here for brevity; refer to <a href="02_node___basenode____node____asyncnode__.md">Chapter 2</a> for Node details).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Assume these Nodes are defined (simplified from cookbook/pocketflow-flow/flow.py)
# from pocketflow import Node
</span>
<span class="k">class</span> <span class="nc">TextInput</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span> <span class="c1"># Gets input and choice
</span>    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span> <span class="n">prep_res</span><span class="p">,</span> <span class="n">exec_res</span><span class="p">):</span>
        <span class="c1"># ... (gets user input for text and choice) ...
</span>        <span class="c1"># shared["text"] = user_text
</span>        <span class="c1"># shared["choice"] = user_choice
</span>        <span class="k">if</span> <span class="n">shared</span><span class="p">[</span><span class="s">"choice"</span><span class="p">]</span> <span class="o">==</span> <span class="s">"5"</span><span class="p">:</span> <span class="c1"># Exit choice
</span>            <span class="k">return</span> <span class="s">"exit"</span>
        <span class="k">return</span> <span class="s">"transform"</span> <span class="c1"># Action to proceed to transformation
</span>
<span class="k">class</span> <span class="nc">TextTransform</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span> <span class="c1"># Transforms text based on choice
</span>    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span> <span class="n">prep_res</span><span class="p">,</span> <span class="n">exec_res</span><span class="p">):</span>
        <span class="c1"># ... (transforms text, prints result) ...
</span>        <span class="c1"># shared["transformed_text"] = result
</span>        <span class="k">if</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Convert another? (y/n): "</span><span class="p">)</span> <span class="o">==</span> <span class="s">'y'</span><span class="p">:</span>
            <span class="n">shared</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="s">"text"</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="c1"># Clear for next input
</span>            <span class="k">return</span> <span class="s">"input"</span> <span class="c1"># Action to go back to TextInput
</span>        <span class="k">return</span> <span class="s">"exit"</span> <span class="c1"># Action to end
</span>
<span class="k">class</span> <span class="nc">EndNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span> <span class="c1"># A simple Node to mark the end
</span>    <span class="k">pass</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">TextInput</code>: Its <code class="language-plaintext highlighter-rouge">post</code> method will return <code class="language-plaintext highlighter-rouge">"transform"</code> to move to the <code class="language-plaintext highlighter-rouge">TextTransform</code> Node, or <code class="language-plaintext highlighter-rouge">"exit"</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">TextTransform</code>: Its <code class="language-plaintext highlighter-rouge">post</code> method will return <code class="language-plaintext highlighter-rouge">"input"</code> to loop back to <code class="language-plaintext highlighter-rouge">TextInput</code>, or <code class="language-plaintext highlighter-rouge">"exit"</code>.</li>
</ul>

<p><strong>Step 2: Instantiate Your Nodes</strong></p>

<p>Create an instance of each Node class:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">text_input</span> <span class="o">=</span> <span class="n">TextInput</span><span class="p">()</span>
<span class="n">text_transform</span> <span class="o">=</span> <span class="n">TextTransform</span><span class="p">()</span>
<span class="n">end_node</span> <span class="o">=</span> <span class="n">EndNode</span><span class="p">()</span>
</code></pre></div></div>

<p><strong>Step 3: Connect Nodes Using Transitions</strong></p>

<p>Now, tell PocketFlow how these <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> connect based on the actions they return. We learned this in <a href="03_actions___transitions__.md">Chapter 3: Actions / Transitions</a>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># If text_input returns "transform", go to text_transform
</span><span class="n">text_input</span> <span class="o">-</span> <span class="s">"transform"</span> <span class="o">&gt;&gt;</span> <span class="n">text_transform</span>
<span class="c1"># If text_input returns "exit" (or any other unhandled action by default for this setup)
# we'll eventually want it to go to end_node or the flow just ends.
# For simplicity here, let's make "exit" explicit if we want a dedicated end.
</span><span class="n">text_input</span> <span class="o">-</span> <span class="s">"exit"</span> <span class="o">&gt;&gt;</span> <span class="n">end_node</span> <span class="c1"># Or simply let it end if no "exit" transition
</span>
<span class="c1"># If text_transform returns "input", go back to text_input
</span><span class="n">text_transform</span> <span class="o">-</span> <span class="s">"input"</span> <span class="o">&gt;&gt;</span> <span class="n">text_input</span>
<span class="c1"># If text_transform returns "exit", go to end_node
</span><span class="n">text_transform</span> <span class="o">-</span> <span class="s">"exit"</span> <span class="o">&gt;&gt;</span> <span class="n">end_node</span>
</code></pre></div></div>

<p><strong>Step 4: Create the <code class="language-plaintext highlighter-rouge">Flow</code></strong></p>

<p>Now, create an instance of the <code class="language-plaintext highlighter-rouge">Flow</code> class, telling it which <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> to start with.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pocketflow</span> <span class="kn">import</span> <span class="n">Flow</span>

<span class="c1"># Create the flow, starting with the text_input node
</span><span class="n">app_flow</span> <span class="o">=</span> <span class="n">Flow</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">text_input</span><span class="p">)</span>
</code></pre></div></div>
<p>And that’s it! <code class="language-plaintext highlighter-rouge">app_flow</code> is now a complete, runnable workflow.</p>

<p><strong>Step 5: Run the <code class="language-plaintext highlighter-rouge">Flow</code></strong></p>

<p>To execute your workflow, you call its <code class="language-plaintext highlighter-rouge">run</code> method, usually with an initial <a href="01_shared_state___shared__dictionary__.md">shared dictionary</a>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">initial_shared_data</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># Start with an empty shared dictionary
</span><span class="n">app_flow</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">initial_shared_data</span><span class="p">)</span>

<span class="c1"># After the flow finishes, initial_shared_data might contain final results
# if your nodes were designed to store them there.
</span><span class="k">print</span><span class="p">(</span><span class="s">"Flow finished!"</span><span class="p">)</span>
</code></pre></div></div>
<p>When you run this:</p>
<ol>
  <li><code class="language-plaintext highlighter-rouge">app_flow</code> will start with <code class="language-plaintext highlighter-rouge">text_input</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">text_input</code> will execute (prompting you for text and choice).</li>
  <li>Based on the action returned by <code class="language-plaintext highlighter-rouge">text_input</code> (e.g., <code class="language-plaintext highlighter-rouge">"transform"</code>), the <code class="language-plaintext highlighter-rouge">Flow</code> will look at the transitions you defined and execute the next <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> (e.g., <code class="language-plaintext highlighter-rouge">text_transform</code>).</li>
  <li>This continues until a <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> returns an action for which no transition is defined, or it transitions to a <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> like <code class="language-plaintext highlighter-rouge">end_node</code> that doesn’t lead anywhere else.</li>
</ol>

<h2 id="orchestrating-asynchronous-tasks-with-asyncflow">Orchestrating Asynchronous Tasks with <code class="language-plaintext highlighter-rouge">AsyncFlow</code></h2>

<p>What if your workflow involves tasks that wait for external operations, like fetching data from a website or waiting for a user to type something slowly? If you use a regular <code class="language-plaintext highlighter-rouge">Flow</code> and synchronous <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> for these, your whole application would freeze during these waits.</p>

<p>This is where <code class="language-plaintext highlighter-rouge">AsyncFlow</code> and <a href="05_asynchronous_processing___asyncnode____asyncflow___.md">Asynchronous Processing (<code class="language-plaintext highlighter-rouge">AsyncNode</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a> come in. <code class="language-plaintext highlighter-rouge">AsyncFlow</code> is designed to work with <code class="language-plaintext highlighter-rouge">AsyncNode</code>s, which can perform tasks asynchronously.</p>

<p>Let’s look at a conceptual recipe finder flow (inspired by <code class="language-plaintext highlighter-rouge">cookbook/pocketflow-async-basic/flow.py</code>).</p>

<p><strong>Step 1: Define Your AsyncNodes</strong>
You’d define <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> using <code class="language-plaintext highlighter-rouge">AsyncNode</code> and <code class="language-plaintext highlighter-rouge">async def</code> methods.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># from pocketflow import AsyncNode, Node
</span>
<span class="k">class</span> <span class="nc">FetchRecipes</span><span class="p">(</span><span class="n">AsyncNode</span><span class="p">):</span> <span class="c1"># Gets ingredient &amp; fetches recipes (async)
</span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">post_async</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span> <span class="n">prep_res</span><span class="p">,</span> <span class="n">exec_res</span><span class="p">):</span>
        <span class="c1"># ... (stores recipes in shared) ...
</span>        <span class="k">return</span> <span class="s">"suggest"</span> <span class="c1"># Action to suggest a recipe
</span>
<span class="k">class</span> <span class="nc">SuggestRecipe</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span> <span class="c1"># Suggests a recipe (can be sync)
</span>    <span class="k">def</span> <span class="nf">post</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span> <span class="n">prep_res</span><span class="p">,</span> <span class="n">exec_res</span><span class="p">):</span>
        <span class="c1"># ... (prints suggestion) ...
</span>        <span class="k">return</span> <span class="s">"approve"</span> <span class="c1"># Action to get approval
</span>
<span class="k">class</span> <span class="nc">GetApproval</span><span class="p">(</span><span class="n">AsyncNode</span><span class="p">):</span> <span class="c1"># Gets user approval (async)
</span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">post_async</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span> <span class="n">prep_res</span><span class="p">,</span> <span class="n">exec_res</span><span class="p">):</span>
        <span class="c1"># ... (gets approval) ...
</span>        <span class="k">if</span> <span class="n">approved</span><span class="p">:</span> <span class="k">return</span> <span class="s">"accept"</span>
        <span class="k">return</span> <span class="s">"retry"</span> <span class="c1"># Action to suggest another
</span>
<span class="k">class</span> <span class="nc">EndFlowNode</span><span class="p">(</span><span class="n">Node</span><span class="p">):</span> <span class="k">pass</span> <span class="c1"># Simple synchronous end node
</span></code></pre></div></div>

<p><strong>Step 2 &amp; 3: Instantiate and Connect</strong>
This is very similar to <code class="language-plaintext highlighter-rouge">Flow</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">fetch_recipes</span> <span class="o">=</span> <span class="n">FetchRecipes</span><span class="p">()</span>
<span class="n">suggest_recipe</span> <span class="o">=</span> <span class="n">SuggestRecipe</span><span class="p">()</span>
<span class="n">get_approval</span> <span class="o">=</span> <span class="n">GetApproval</span><span class="p">()</span>
<span class="n">end_node</span> <span class="o">=</span> <span class="n">EndFlowNode</span><span class="p">()</span>

<span class="n">fetch_recipes</span> <span class="o">-</span> <span class="s">"suggest"</span> <span class="o">&gt;&gt;</span> <span class="n">suggest_recipe</span>
<span class="n">suggest_recipe</span> <span class="o">-</span> <span class="s">"approve"</span> <span class="o">&gt;&gt;</span> <span class="n">get_approval</span>
<span class="n">get_approval</span> <span class="o">-</span> <span class="s">"retry"</span> <span class="o">&gt;&gt;</span> <span class="n">suggest_recipe</span> <span class="c1"># Loop back
</span><span class="n">get_approval</span> <span class="o">-</span> <span class="s">"accept"</span> <span class="o">&gt;&gt;</span> <span class="n">end_node</span>
</code></pre></div></div>

<p><strong>Step 4: Create the <code class="language-plaintext highlighter-rouge">AsyncFlow</code></strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pocketflow</span> <span class="kn">import</span> <span class="n">AsyncFlow</span>

<span class="n">recipe_flow</span> <span class="o">=</span> <span class="n">AsyncFlow</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">fetch_recipes</span><span class="p">)</span>
</code></pre></div></div>
<p>Notice we use <code class="language-plaintext highlighter-rouge">AsyncFlow</code> here.</p>

<p><strong>Step 5: Run the <code class="language-plaintext highlighter-rouge">AsyncFlow</code></strong></p>

<p>Running an <code class="language-plaintext highlighter-rouge">AsyncFlow</code> involves <code class="language-plaintext highlighter-rouge">async</code> and <code class="language-plaintext highlighter-rouge">await</code> because the flow itself is asynchronous.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">initial_shared</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">await</span> <span class="n">recipe_flow</span><span class="p">.</span><span class="n">run_async</span><span class="p">(</span><span class="n">initial_shared</span><span class="p">)</span> <span class="c1"># Use run_async()
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"Recipe flow finished!"</span><span class="p">)</span>

<span class="c1"># To run the main async function
# asyncio.run(main())
</span></code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">AsyncFlow</code> will manage the <code class="language-plaintext highlighter-rouge">AsyncNode</code>s, allowing them to <code class="language-plaintext highlighter-rouge">await</code> their operations without blocking the entire event loop (if you’re running other async tasks). We’ll explore this more in <a href="05_asynchronous_processing___asyncnode____asyncflow___.md">Chapter 5: Asynchronous Processing (<code class="language-plaintext highlighter-rouge">AsyncNode</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a>.</p>

<h2 id="nesting-flows-managing-complexity">Nesting Flows: Managing Complexity</h2>

<p>What if your workflow becomes very large and complex? You can break it down! A <strong>Flow can itself be treated as a Node and nested within another Flow.</strong> This is like having a project manager who oversees several team leads, and each team lead manages their own team’s tasks.</p>

<p>Consider the <code class="language-plaintext highlighter-rouge">cookbook/pocketflow-supervisor/flow.py</code> example. It has an <code class="language-plaintext highlighter-rouge">agent_inner_flow</code> which handles research, and then an outer <code class="language-plaintext highlighter-rouge">Flow</code> that uses this <code class="language-plaintext highlighter-rouge">agent_inner_flow</code> as a step, followed by a <code class="language-plaintext highlighter-rouge">SupervisorNode</code> to check the agent’s work.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Conceptual: from cookbook/pocketflow-supervisor/flow.py
# agent_inner_flow is a complete Flow instance itself
</span><span class="n">agent_inner_flow</span> <span class="o">=</span> <span class="n">create_agent_inner_flow</span><span class="p">()</span> 
<span class="n">supervisor</span> <span class="o">=</span> <span class="n">SupervisorNode</span><span class="p">()</span>

<span class="c1"># The inner flow is treated like a node in the outer flow's transitions
</span><span class="n">agent_inner_flow</span> <span class="o">&gt;&gt;</span> <span class="n">supervisor</span> <span class="c1"># Default transition
</span><span class="n">supervisor</span> <span class="o">-</span> <span class="s">"retry"</span> <span class="o">&gt;&gt;</span> <span class="n">agent_inner_flow</span>

<span class="n">supervised_flow</span> <span class="o">=</span> <span class="n">Flow</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">agent_inner_flow</span><span class="p">)</span>
</code></pre></div></div>
<p>Here, <code class="language-plaintext highlighter-rouge">agent_inner_flow</code> runs completely. When it finishes, the <code class="language-plaintext highlighter-rouge">supervised_flow</code> transitions to the <code class="language-plaintext highlighter-rouge">supervisor</code> Node. This is a powerful way to create hierarchical and modular workflows.</p>

<h2 id="under-the-hood-how-do-flows-orchestrate">Under the Hood: How Do Flows Orchestrate?</h2>

<p>At its core, a <code class="language-plaintext highlighter-rouge">Flow</code> (or <code class="language-plaintext highlighter-rouge">AsyncFlow</code>) runs a loop that:</p>
<ol>
  <li>Identifies the current <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> to run (starting with its <code class="language-plaintext highlighter-rouge">start_node</code>).</li>
  <li>Executes this <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> (which involves its <code class="language-plaintext highlighter-rouge">prep</code>, <code class="language-plaintext highlighter-rouge">exec</code>, and <code class="language-plaintext highlighter-rouge">post</code> methods).</li>
  <li>Gets the “action” string returned by the Node’s <code class="language-plaintext highlighter-rouge">post</code> method.</li>
  <li>Uses this action string to look up the <em>next</em> <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> based on the transitions you defined (e.g., <code class="language-plaintext highlighter-rouge">current_node - "action" &gt;&gt; next_node</code>).</li>
  <li>If a next <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> is found, it becomes the current <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a>, and the loop continues.</li>
  <li>If no next <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> is found (no matching transition), the flow (or that branch of it) ends.</li>
</ol>

<p>Here’s a simplified sequence diagram:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant You
    participant MyFlow as Flow Object
    participant NodeA as Start Node
    participant NodeB as Next Node
    participant SharedDict as Shared Dictionary

    You-&gt;&gt;MyFlow: flow.run(initial_shared)
    MyFlow-&gt;&gt;SharedDict: Initialize with initial_shared
    MyFlow-&gt;&gt;NodeA: _run(SharedDict)
    NodeA--&gt;&gt;MyFlow: returns action_A (from NodeA's post method)
    MyFlow-&gt;&gt;MyFlow: get_next_node(NodeA, action_A)
    Note right of MyFlow: Finds NodeB based on NodeA's transitions
    MyFlow-&gt;&gt;NodeB: _run(SharedDict)
    NodeB--&gt;&gt;MyFlow: returns action_B (from NodeB's post method)
    MyFlow-&gt;&gt;MyFlow: get_next_node(NodeB, action_B)
    Note right of MyFlow: No more nodes or no transition found. Flow ends.
    MyFlow--&gt;&gt;You: Flow execution complete
</code></pre>

<p><strong>A Glimpse into the Code (<code class="language-plaintext highlighter-rouge">pocketflow/__init__.py</code>):</strong></p>

<p>The <code class="language-plaintext highlighter-rouge">Flow</code> class inherits from <code class="language-plaintext highlighter-rouge">BaseNode</code>, so it also has <code class="language-plaintext highlighter-rouge">prep</code>, <code class="language-plaintext highlighter-rouge">exec</code>, <code class="language-plaintext highlighter-rouge">post</code> methods. Its main job is done in its orchestration logic.</p>

<ol>
  <li><strong>Initialization:</strong> When you create a <code class="language-plaintext highlighter-rouge">Flow</code>, you give it a starting <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a>.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Inside Flow class
</span><span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span> <span class="c1"># Initialize BaseNode parts
</span>    <span class="bp">self</span><span class="p">.</span><span class="n">start_node</span> <span class="o">=</span> <span class="n">start</span> <span class="c1"># Store the starting node
</span></code></pre></div>    </div>
  </li>
  <li><strong>Getting the Next Node:</strong> The <code class="language-plaintext highlighter-rouge">get_next_node</code> method is crucial. It checks the current node’s <code class="language-plaintext highlighter-rouge">successors</code> dictionary (which was populated by your transition definitions like <code class="language-plaintext highlighter-rouge">nodeA - "action" &gt;&gt; nodeB</code>).
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Inside Flow class
</span><span class="k">def</span> <span class="nf">get_next_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current_node</span><span class="p">,</span> <span class="n">action_str</span><span class="p">):</span>
    <span class="c1"># Try specific action, then "default"
</span>    <span class="n">next_node</span> <span class="o">=</span> <span class="n">current_node</span><span class="p">.</span><span class="n">successors</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">action_str</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">next_node</span><span class="p">:</span> <span class="c1"># If specific action's successor not found
</span>        <span class="n">next_node</span> <span class="o">=</span> <span class="n">current_node</span><span class="p">.</span><span class="n">successors</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"default"</span><span class="p">)</span>
    <span class="c1"># ... (warnings if no successor found but some exist) ...
</span>    <span class="k">return</span> <span class="n">next_node</span>
</code></pre></div>    </div>
  </li>
  <li><strong>The Orchestration Loop (<code class="language-plaintext highlighter-rouge">_orch</code>):</strong> This is the heart of the <code class="language-plaintext highlighter-rouge">Flow</code>.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Inside Flow class (simplified)
</span><span class="k">def</span> <span class="nf">_orch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">current_node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">start_node</span> 
    <span class="n">last_action</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">while</span> <span class="n">current_node</span><span class="p">:</span>
        <span class="c1"># ... (set parameters for current_node if any) ...
</span>        <span class="n">last_action</span> <span class="o">=</span> <span class="n">current_node</span><span class="p">.</span><span class="n">_run</span><span class="p">(</span><span class="n">shared</span><span class="p">)</span> <span class="c1"># Run the node
</span>        <span class="c1"># Get the next node based on the action from the current one
</span>        <span class="n">current_node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_next_node</span><span class="p">(</span><span class="n">current_node</span><span class="p">,</span> <span class="n">last_action</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">last_action</span> <span class="c1"># Returns the very last action from the flow
</span></code></pre></div>    </div>
    <p>The <code class="language-plaintext highlighter-rouge">current_node._run(shared)</code> call is what executes the <code class="language-plaintext highlighter-rouge">prep -&gt; exec -&gt; post</code> cycle of that <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a>.</p>
  </li>
</ol>

<p>For <code class="language-plaintext highlighter-rouge">AsyncFlow</code>, the structure is very similar. It has an <code class="language-plaintext highlighter-rouge">_orch_async</code> method:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Inside AsyncFlow class (conceptual)
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">_orch_async</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">current_node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">start_node</span>
    <span class="n">last_action</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">while</span> <span class="n">current_node</span><span class="p">:</span>
        <span class="c1"># ...
</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">current_node</span><span class="p">,</span> <span class="n">AsyncNode</span><span class="p">):</span>
            <span class="n">last_action</span> <span class="o">=</span> <span class="k">await</span> <span class="n">current_node</span><span class="p">.</span><span class="n">_run_async</span><span class="p">(</span><span class="n">shared</span><span class="p">)</span> <span class="c1"># Await async nodes
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">last_action</span> <span class="o">=</span> <span class="n">current_node</span><span class="p">.</span><span class="n">_run</span><span class="p">(</span><span class="n">shared</span><span class="p">)</span> <span class="c1"># Run sync nodes normally
</span>        <span class="n">current_node</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_next_node</span><span class="p">(</span><span class="n">current_node</span><span class="p">,</span> <span class="n">last_action</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">last_action</span>
</code></pre></div></div>
<p>The key difference is that it <code class="language-plaintext highlighter-rouge">await</code>s the <code class="language-plaintext highlighter-rouge">_run_async</code> method of <code class="language-plaintext highlighter-rouge">AsyncNode</code>s, allowing for non-blocking execution.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve now learned about <strong><code class="language-plaintext highlighter-rouge">Flow</code></strong> and <strong><code class="language-plaintext highlighter-rouge">AsyncFlow</code></strong>, the orchestrators that bring your <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> together to form complete, dynamic workflows!</p>
<ul>
  <li>Flows define the sequence and logic of how <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> are executed.</li>
  <li>They use the “action” strings returned by <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> and the transition rules you define (e.g., <code class="language-plaintext highlighter-rouge">nodeA - "action" &gt;&gt; nodeB</code>) to decide the path of execution.</li>
  <li><code class="language-plaintext highlighter-rouge">Flow</code> is for synchronous workflows, while <code class="language-plaintext highlighter-rouge">AsyncFlow</code> handles workflows with asynchronous tasks using <code class="language-plaintext highlighter-rouge">AsyncNode</code>s.</li>
  <li>Flows can be nested to manage complexity.</li>
</ul>

<p>With Flows, you can build anything from simple linear sequences to complex, branching, and looping AI applications.</p>

<p>In the next chapter, we’ll take a much deeper dive into the world of asynchronous operations specifically, exploring how <code class="language-plaintext highlighter-rouge">AsyncNode</code> and <code class="language-plaintext highlighter-rouge">AsyncFlow</code> enable you to build responsive, I/O-bound applications efficiently.</p>

<p>Next up: <a href="05_asynchronous_processing___asyncnode____asyncflow___.md">Chapter 5: Asynchronous Processing (<code class="language-plaintext highlighter-rouge">AsyncNode</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
