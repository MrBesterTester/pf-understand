<h1 id="chapter-7-a2a-agent-to-agent-communication-framework">Chapter 7: A2A (Agent-to-Agent) Communication Framework</h1>

<p>Welcome to the final chapter of our PocketFlow journey! In <a href="06_batch_processing___batchnode____batchflow____asyncparallelbatchnode___.md">Chapter 6: Batch Processing (<code class="language-plaintext highlighter-rouge">BatchNode</code>, <code class="language-plaintext highlighter-rouge">BatchFlow</code>, <code class="language-plaintext highlighter-rouge">AsyncParallelBatchNode</code>)</a>, we saw how to process multiple items or run workflows repeatedly. Now, we’ll explore how to make your PocketFlow agents available to the wider world, allowing them to communicate with other systems or agents using a standard “language.”</p>

<h2 id="the-challenge-making-your-agent-a-team-player">The Challenge: Making Your Agent a Team Player</h2>

<p>Imagine you’ve built a fantastic PocketFlow agent that can research topics and answer questions. It’s great for your own use, but what if:</p>
<ul>
  <li>Another team in your company wants their AI system to ask questions of your agent?</li>
  <li>You want to offer your agent’s capabilities as a service that other applications can call?</li>
  <li>You want to build a larger system composed of multiple specialized agents that need to collaborate?</li>
</ul>

<p>These scenarios require a <strong>standardized way for agents to talk to each other</strong>. Simply sharing Python code or relying on custom integrations isn’t scalable or interoperable. This is where the <strong>A2A (Agent-to-Agent) Communication Framework</strong> comes in.</p>

<p><strong>Our Use Case:</strong> We want to take the PocketFlow-based research agent we’ve been conceptualizing (which uses <a href="02_node___basenode____node____asyncnode___.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> and a <a href="04_flow___flow____asyncflow___.md">Flow (<code class="language-plaintext highlighter-rouge">Flow</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a>) and make it accessible via a standard A2A interface. Another program (a client) should be able to send it a question (e.g., “What is PocketFlow?”) and receive an answer, all using this A2A standard.</p>

<p>The A2A framework in PocketFlow provides components that wrap your agent, allowing it to understand and speak the A2A JSON-RPC specification. Think of it like giving your agent a universal translator and a public phone line.</p>

<h2 id="key-components-of-the-a2a-framework">Key Components of the A2A Framework</h2>

<p>The A2A framework in <code class="language-plaintext highlighter-rouge">PocketFlow</code> consists of a few main parts that work together:</p>

<ol>
  <li><strong>A2A JSON-RPC Specification (The “Language”)</strong>: This isn’t code, but a standard agreement on how agents communicate. It uses JSON-RPC, a lightweight remote procedure call protocol using JSON. It defines methods like <code class="language-plaintext highlighter-rouge">tasks/send</code> (to give an agent a job) and <code class="language-plaintext highlighter-rouge">tasks/get</code> (to check on a job), and the structure of messages. PocketFlow’s A2A components adhere to this spec.
    <ul>
      <li><strong>Analogy</strong>: If agents are from different countries, JSON-RPC is the agreed-upon common language (like Esperanto or English as a lingua franca) they’ll use to talk.</li>
    </ul>
  </li>
  <li><strong>Common <code class="language-plaintext highlighter-rouge">types</code> (The “Vocabulary and Grammar”)</strong>: These are pre-defined Python Pydantic models (found in <code class="language-plaintext highlighter-rouge">cookbook/pocketflow-a2a/common/types.py</code>) that represent the structure of all A2A messages. This includes <code class="language-plaintext highlighter-rouge">Task</code>, <code class="language-plaintext highlighter-rouge">Message</code>, <code class="language-plaintext highlighter-rouge">Artifact</code>, <code class="language-plaintext highlighter-rouge">TextPart</code>, <code class="language-plaintext highlighter-rouge">JSONRPCRequest</code>, <code class="language-plaintext highlighter-rouge">JSONRPCResponse</code>, etc. Using these types ensures that both the client and server understand the format of the data being exchanged.
    <ul>
      <li><strong>Analogy</strong>: These are the specific words and sentence structures within the agreed-upon language.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">A2AServer</code> (The “Receptionist”)</strong>: This component hosts your PocketFlow agent. It listens for incoming A2A requests over HTTP, understands the A2A JSON-RPC protocol, and passes the work to your agent (via the <code class="language-plaintext highlighter-rouge">TaskManager</code>).
    <ul>
      <li><strong>Analogy</strong>: The <code class="language-plaintext highlighter-rouge">A2AServer</code> is like the public-facing receptionist for your PocketFlow agent. It answers the “phone” (HTTP requests) and speaks the standard A2A language.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">TaskManager</code> (The “Internal Translator”)</strong>: This is the crucial bridge. It receives instructions from the <code class="language-plaintext highlighter-rouge">A2AServer</code> (which are in the A2A format), translates them into something your PocketFlow <a href="04_flow___flow____asyncflow__.md">Flow (<code class="language-plaintext highlighter-rouge">Flow</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a> can understand (typically by preparing the <a href="01_shared_state___shared__dictionary__.md">shared dictionary</a>), runs your PocketFlow <a href="04_flow___flow____asyncflow__.md">Flow (<code class="language-plaintext highlighter-rouge">Flow</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a>, and then takes the results from the <a href="01_shared_state___shared__dictionary__.md">shared dictionary</a> and packages them back into the A2A format for the <code class="language-plaintext highlighter-rouge">A2AServer</code> to send out.
    <ul>
      <li><strong>Analogy</strong>: If your PocketFlow agent only speaks “PocketFlow-ese,” the <code class="language-plaintext highlighter-rouge">TaskManager</code> is the internal assistant who translates A2A language from the receptionist into PocketFlow-ese and vice-versa.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">A2AClient</code> (The “Caller”)</strong>: This component allows you (or another system) to interact with an agent hosted by an <code class="language-plaintext highlighter-rouge">A2AServer</code>. It knows how to formulate A2A JSON-RPC requests and understand the responses.
    <ul>
      <li><strong>Analogy</strong>: The <code class="language-plaintext highlighter-rouge">A2AClient</code> is someone using the public phone line to call your agent’s receptionist.</li>
    </ul>
  </li>
</ol>

<p>Let’s see how to use these to make our PocketFlow research agent accessible.</p>

<h2 id="making-your-pocketflow-agent-a2a-compatible">Making Your PocketFlow Agent A2A-Compatible</h2>

<p>Let’s assume you’ve already built your core PocketFlow agent using <a href="02_node___basenode____node____asyncnode___.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> and a <a href="04_flow___flow____asyncflow___.md">Flow (<code class="language-plaintext highlighter-rouge">Flow</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a>, perhaps similar to the one in <code class="language-plaintext highlighter-rouge">cookbook/pocketflow-a2a/flow.py</code> that can take a question and produce an answer. The main function in <code class="language-plaintext highlighter-rouge">flow.py</code> to get this flow is <code class="language-plaintext highlighter-rouge">create_agent_flow()</code>.</p>

<p><strong>Step 1: Create Your <code class="language-plaintext highlighter-rouge">TaskManager</code></strong></p>

<p>The <code class="language-plaintext highlighter-rouge">TaskManager</code> connects the A2A world to your PocketFlow <a href="04_flow___flow____asyncflow___.md">Flow (<code class="language-plaintext highlighter-rouge">Flow</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a>. We’ll create a <code class="language-plaintext highlighter-rouge">PocketFlowTaskManager</code> that inherits from a base <code class="language-plaintext highlighter-rouge">InMemoryTaskManager</code> (which handles storing task states).</p>

<p>Here’s a simplified look at <code class="language-plaintext highlighter-rouge">PocketFlowTaskManager</code> from <code class="language-plaintext highlighter-rouge">cookbook/pocketflow-a2a/task_manager.py</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In task_manager.py
</span><span class="kn">from</span> <span class="nn">common.server.task_manager</span> <span class="kn">import</span> <span class="n">InMemoryTaskManager</span>
<span class="kn">from</span> <span class="nn">common.types</span> <span class="kn">import</span> <span class="p">(</span> <span class="c1"># A2A standard message types
</span>    <span class="n">SendTaskRequest</span><span class="p">,</span> <span class="n">SendTaskResponse</span><span class="p">,</span> <span class="n">TaskState</span><span class="p">,</span> <span class="n">TaskStatus</span><span class="p">,</span>
    <span class="n">TextPart</span><span class="p">,</span> <span class="n">Artifact</span><span class="p">,</span> <span class="n">Message</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">flow</span> <span class="kn">import</span> <span class="n">create_agent_flow</span> <span class="c1"># Your PocketFlow agent logic
</span>
<span class="k">class</span> <span class="nc">PocketFlowTaskManager</span><span class="p">(</span><span class="n">InMemoryTaskManager</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_send_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">:</span> <span class="n">SendTaskRequest</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SendTaskResponse</span><span class="p">:</span>
        <span class="c1"># 1. Get the question from the A2A request
</span>        <span class="n">query</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_get_user_query</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="n">params</span><span class="p">)</span> <span class="c1"># Helper to extract text
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="n">query</span><span class="p">:</span>
            <span class="c1"># ... handle error: no query found ...
</span>
        <span class="c1"># 2. Prepare shared data for your PocketFlow agent
</span>        <span class="n">shared_data</span> <span class="o">=</span> <span class="p">{</span><span class="s">"question"</span><span class="p">:</span> <span class="n">query</span><span class="p">}</span>
        <span class="n">agent_flow</span> <span class="o">=</span> <span class="n">create_agent_flow</span><span class="p">()</span> <span class="c1"># Get your PocketFlow flow
</span>
        <span class="c1"># 3. Run your PocketFlow agent
</span>        <span class="k">try</span><span class="p">:</span>
            <span class="n">agent_flow</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">shared_data</span><span class="p">)</span> <span class="c1"># This modifies shared_data
</span>            <span class="c1"># 'shared_data' now contains the answer, e.g., shared_data["answer"]
</span>        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># ... handle agent execution error ...
</span>
        <span class="c1"># 4. Package the result into A2A format
</span>        <span class="n">answer_text</span> <span class="o">=</span> <span class="n">shared_data</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"answer"</span><span class="p">,</span> <span class="s">"No answer."</span><span class="p">)</span>
        <span class="n">final_status</span> <span class="o">=</span> <span class="n">TaskStatus</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="n">TaskState</span><span class="p">.</span><span class="n">COMPLETED</span><span class="p">)</span>
        <span class="n">final_artifact</span> <span class="o">=</span> <span class="n">Artifact</span><span class="p">(</span><span class="n">parts</span><span class="o">=</span><span class="p">[</span><span class="n">TextPart</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">answer_text</span><span class="p">)])</span>
        
        <span class="c1"># Store final task details (InMemoryTaskManager helps here)
</span>        <span class="n">final_task</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">update_store</span><span class="p">(</span>
            <span class="n">request</span><span class="p">.</span><span class="n">params</span><span class="p">.</span><span class="nb">id</span><span class="p">,</span> <span class="n">final_status</span><span class="p">,</span> <span class="p">[</span><span class="n">final_artifact</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">SendTaskResponse</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="nb">id</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="n">final_task</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_user_query</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task_params</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Simplified: Extracts text from the A2A message parts
</span>        <span class="c1"># (Actual code in common/types.py &amp; task_manager.py is more robust)
</span>        <span class="k">if</span> <span class="n">task_params</span><span class="p">.</span><span class="n">message</span> <span class="ow">and</span> <span class="n">task_params</span><span class="p">.</span><span class="n">message</span><span class="p">.</span><span class="n">parts</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">task_params</span><span class="p">.</span><span class="n">message</span><span class="p">.</span><span class="n">parts</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">part</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="s">"text"</span><span class="p">:</span> <span class="c1"># Assuming part is a Pydantic model
</span>                    <span class="k">return</span> <span class="n">part</span><span class="p">.</span><span class="n">text</span>
        <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>
<p><strong>Explanation:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">on_send_task</code>: This method is called when the <code class="language-plaintext highlighter-rouge">A2AServer</code> receives a <code class="language-plaintext highlighter-rouge">tasks/send</code> request.</li>
  <li>It extracts the user’s question from the A2A request’s <code class="language-plaintext highlighter-rouge">message.parts</code> (using <code class="language-plaintext highlighter-rouge">_get_user_query</code>).</li>
  <li>It prepares the <a href="01_shared_state___shared__dictionary__.md">shared dictionary</a> (<code class="language-plaintext highlighter-rouge">shared_data</code>) for your PocketFlow <a href="04_flow___flow____asyncflow___.md">Flow (<code class="language-plaintext highlighter-rouge">Flow</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a>.</li>
  <li>It runs your <code class="language-plaintext highlighter-rouge">agent_flow</code> with this <code class="language-plaintext highlighter-rouge">shared_data</code>. The <code class="language-plaintext highlighter-rouge">agent_flow</code> does its work and puts the answer back into <code class="language-plaintext highlighter-rouge">shared_data["answer"]</code>.</li>
  <li>It retrieves the answer from <code class="language-plaintext highlighter-rouge">shared_data</code> and packages it into an A2A <code class="language-plaintext highlighter-rouge">Artifact</code> with a <code class="language-plaintext highlighter-rouge">TextPart</code>.</li>
  <li>It updates the task’s status to <code class="language-plaintext highlighter-rouge">COMPLETED</code> and returns an A2A <code class="language-plaintext highlighter-rouge">SendTaskResponse</code> containing the final <code class="language-plaintext highlighter-rouge">Task</code> object (which includes the answer artifact).</li>
</ul>

<p><strong>Step 2: Set Up the <code class="language-plaintext highlighter-rouge">A2AServer</code></strong></p>

<p>Now, we need to host our <code class="language-plaintext highlighter-rouge">PocketFlowTaskManager</code> using <code class="language-plaintext highlighter-rouge">A2AServer</code>. This involves defining an <code class="language-plaintext highlighter-rouge">AgentCard</code> (metadata about your agent) and starting the server.</p>

<p>A simplified <code class="language-plaintext highlighter-rouge">main</code> function from <code class="language-plaintext highlighter-rouge">cookbook/pocketflow-a2a/a2a_server.py</code>:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In a2a_server.py
</span><span class="kn">from</span> <span class="nn">common.server</span> <span class="kn">import</span> <span class="n">A2AServer</span>
<span class="kn">from</span> <span class="nn">common.types</span> <span class="kn">import</span> <span class="n">AgentCard</span><span class="p">,</span> <span class="n">AgentCapabilities</span><span class="p">,</span> <span class="n">AgentSkill</span> <span class="c1"># For metadata
</span><span class="kn">from</span> <span class="nn">task_manager</span> <span class="kn">import</span> <span class="n">PocketFlowTaskManager</span> <span class="c1"># Your task manager
</span><span class="kn">import</span> <span class="nn">os</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s">"localhost"</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="mi">10003</span><span class="p">):</span>
    <span class="c1"># (Error checking for API keys like OPENAI_API_KEY happens here)
</span>    
    <span class="c1"># 1. Define Agent's "Business Card" (AgentCard)
</span>    <span class="n">capabilities</span> <span class="o">=</span> <span class="n">AgentCapabilities</span><span class="p">(</span><span class="n">streaming</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># Our agent isn't streaming
</span>    <span class="n">skill</span> <span class="o">=</span> <span class="n">AgentSkill</span><span class="p">(</span>
        <span class="nb">id</span><span class="o">=</span><span class="s">"web_research_qa"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">"Web Research and Answering"</span><span class="p">,</span>
        <span class="c1"># ... (more skill details: description, examples) ...
</span>        <span class="n">inputModes</span><span class="o">=</span><span class="p">[</span><span class="s">"text"</span><span class="p">],</span> <span class="n">outputModes</span><span class="o">=</span><span class="p">[</span><span class="s">"text"</span><span class="p">]</span>
    <span class="p">)</span>
    <span class="n">agent_card</span> <span class="o">=</span> <span class="n">AgentCard</span><span class="p">(</span>
        <span class="n">name</span><span class="o">=</span><span class="s">"PocketFlow Research Agent (A2A)"</span><span class="p">,</span>
        <span class="n">url</span><span class="o">=</span><span class="sa">f</span><span class="s">"http://</span><span class="si">{</span><span class="n">host</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">port</span><span class="si">}</span><span class="s">/"</span><span class="p">,</span> <span class="c1"># Where clients connect
</span>        <span class="c1"># ... (more card details: description, version, skills) ...
</span>        <span class="n">capabilities</span><span class="o">=</span><span class="n">capabilities</span><span class="p">,</span> <span class="n">skills</span><span class="o">=</span><span class="p">[</span><span class="n">skill</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># 2. Initialize TaskManager and Server
</span>    <span class="n">task_manager</span> <span class="o">=</span> <span class="n">PocketFlowTaskManager</span><span class="p">()</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">A2AServer</span><span class="p">(</span>
        <span class="n">agent_card</span><span class="o">=</span><span class="n">agent_card</span><span class="p">,</span>
        <span class="n">task_manager</span><span class="o">=</span><span class="n">task_manager</span><span class="p">,</span>
        <span class="n">host</span><span class="o">=</span><span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="n">port</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Starting PocketFlow A2A server on http://</span><span class="si">{</span><span class="n">host</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">port</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="n">server</span><span class="p">.</span><span class="n">start</span><span class="p">()</span> <span class="c1"># This starts the HTTP server (e.g., Uvicorn)
</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="c1"># This would typically call main()
</span>    <span class="c1"># For example: main()
</span>    <span class="k">pass</span>
</code></pre></div></div>
<p><strong>Explanation:</strong></p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">AgentCard</code>: This provides metadata about your agent (name, URL, capabilities, skills offered). Other A2A systems can fetch this card (from <code class="language-plaintext highlighter-rouge">/.well-known/agent.json</code>) to learn about your agent.</li>
  <li>We instantiate our <code class="language-plaintext highlighter-rouge">PocketFlowTaskManager</code>.</li>
  <li>We create an <code class="language-plaintext highlighter-rouge">A2AServer</code>, giving it the <code class="language-plaintext highlighter-rouge">agent_card</code>, our <code class="language-plaintext highlighter-rouge">task_manager</code>, and the <code class="language-plaintext highlighter-rouge">host</code>/<code class="language-plaintext highlighter-rouge">port</code> to listen on.</li>
  <li><code class="language-plaintext highlighter-rouge">server.start()</code> launches the web server. Now your PocketFlow agent is listening for A2A requests!</li>
</ul>

<p><strong>Step 3: Interact Using an <code class="language-plaintext highlighter-rouge">A2AClient</code></strong></p>

<p>With the server running, other programs can now “call” your agent. The <code class="language-plaintext highlighter-rouge">A2AClient</code> helps with this.</p>

<p>A simplified CLI client from <code class="language-plaintext highlighter-rouge">cookbook/pocketflow-a2a/a2a_client.py</code>:</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In a2a_client.py
</span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">common.client</span> <span class="kn">import</span> <span class="n">A2AClient</span> <span class="c1"># The A2A client utility
</span><span class="kn">from</span> <span class="nn">common.types</span> <span class="kn">import</span> <span class="n">TextPart</span> <span class="c1"># To structure our question
</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">run_client</span><span class="p">(</span><span class="n">agent_url</span><span class="o">=</span><span class="s">"http://localhost:10003"</span><span class="p">):</span>
    <span class="n">client</span> <span class="o">=</span> <span class="n">A2AClient</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">agent_url</span><span class="p">)</span>
    
    <span class="c1"># Get question from user
</span>    <span class="n">question_text</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">"Enter your question: "</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">question_text</span><span class="p">:</span> <span class="k">return</span>

    <span class="c1"># 1. Prepare the A2A request payload (matches TaskSendParams)
</span>    <span class="c1"># This is a simplified representation of the common.types.TaskSendParams
</span>    <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">"id"</span><span class="p">:</span> <span class="s">"some_unique_task_id"</span><span class="p">,</span> <span class="c1"># Each task needs an ID
</span>        <span class="s">"message"</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">"role"</span><span class="p">:</span> <span class="s">"user"</span><span class="p">,</span>
            <span class="s">"parts"</span><span class="p">:</span> <span class="p">[{</span><span class="s">"type"</span><span class="p">:</span> <span class="s">"text"</span><span class="p">,</span> <span class="s">"text"</span><span class="p">:</span> <span class="n">question_text</span><span class="p">}],</span> <span class="c1"># Our question
</span>        <span class="p">},</span>
        <span class="s">"acceptedOutputModes"</span><span class="p">:</span> <span class="p">[</span><span class="s">"text"</span><span class="p">],</span> <span class="c1"># We want text back
</span>    <span class="p">}</span>

    <span class="k">print</span><span class="p">(</span><span class="s">"Sending task to agent..."</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># 2. Send the task to the server
</span>        <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="n">send_task</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="c1"># This makes the HTTP call
</span>
        <span class="c1"># 3. Process the response
</span>        <span class="k">if</span> <span class="n">response</span><span class="p">.</span><span class="n">error</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Error from agent: </span><span class="si">{</span><span class="n">response</span><span class="p">.</span><span class="n">error</span><span class="p">.</span><span class="n">message</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">response</span><span class="p">.</span><span class="n">result</span> <span class="ow">and</span> <span class="n">response</span><span class="p">.</span><span class="n">result</span><span class="p">.</span><span class="n">artifacts</span><span class="p">:</span>
            <span class="c1"># Extract answer from the first text part of the first artifact
</span>            <span class="n">answer_part</span> <span class="o">=</span> <span class="n">response</span><span class="p">.</span><span class="n">result</span><span class="p">.</span><span class="n">artifacts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">answer_part</span><span class="p">,</span> <span class="n">TextPart</span><span class="p">)</span> <span class="ow">or</span> <span class="n">answer_part</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="s">"text"</span><span class="p">:</span>
                <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Agent Answer: </span><span class="si">{</span><span class="n">answer_part</span><span class="p">.</span><span class="n">text</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="s">"Agent did not return a clear answer."</span><span class="p">)</span>
            
    <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Client error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># To run this:
# if __name__ == "__main__":
# asyncio.run(run_client())
</span></code></pre></div></div>
<p><strong>Explanation:</strong></p>
<ul>
  <li>An <code class="language-plaintext highlighter-rouge">A2AClient</code> is initialized with the server’s URL.</li>
  <li>A <code class="language-plaintext highlighter-rouge">payload</code> dictionary is created. This structure matches the A2A specification for sending a task (specifically, <code class="language-plaintext highlighter-rouge">TaskSendParams</code> from <code class="language-plaintext highlighter-rouge">common.types</code>). Our question is placed in <code class="language-plaintext highlighter-rouge">message.parts</code> as a <code class="language-plaintext highlighter-rouge">TextPart</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">client.send_task(payload)</code> sends the JSON-RPC request to the <code class="language-plaintext highlighter-rouge">A2AServer</code>.</li>
  <li>The response (an A2A <code class="language-plaintext highlighter-rouge">Task</code> object) is processed. The answer is typically found in the <code class="language-plaintext highlighter-rouge">artifacts</code> of the <code class="language-plaintext highlighter-rouge">Task</code>.</li>
</ul>

<p><strong>Example Interaction:</strong></p>
<ol>
  <li>You run <code class="language-plaintext highlighter-rouge">a2a_server.py</code>. It starts listening on <code class="language-plaintext highlighter-rouge">http://localhost:10003</code>.</li>
  <li>You run <code class="language-plaintext highlighter-rouge">a2a_client.py</code>.</li>
  <li>Client prompts: <code class="language-plaintext highlighter-rouge">Enter your question:</code></li>
  <li>You type: <code class="language-plaintext highlighter-rouge">What is PocketFlow?</code></li>
  <li>Client sends this to the server.</li>
  <li>Server (via <code class="language-plaintext highlighter-rouge">PocketFlowTaskManager</code> and your <code class="language-plaintext highlighter-rouge">agent_flow</code>) processes it.</li>
  <li>Client receives the response and might print: <code class="language-plaintext highlighter-rouge">Agent Answer: PocketFlow is a minimalist LLM framework...</code></li>
</ol>

<p>Your PocketFlow agent is now communicating via a standard A2A interface!</p>

<h2 id="under-the-hood-the-a2a-conversation-flow">Under the Hood: The A2A Conversation Flow</h2>

<p>Let’s trace a request from client to server and back:</p>

<ol>
  <li><strong>Client Prepares</strong>: The <code class="language-plaintext highlighter-rouge">A2AClient</code> takes your input (e.g., a question) and constructs a JSON object according to the A2A spec. This is a JSON-RPC request, often for the method <code class="language-plaintext highlighter-rouge">tasks/send</code>.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">A2AClient._send_request</code> (from <code class="language-plaintext highlighter-rouge">common/client/client.py</code>) assembles this. It uses <code class="language-plaintext highlighter-rouge">httpx</code> to make an HTTP POST request to the server’s URL, with the JSON-RPC payload.</li>
    </ul>
  </li>
  <li><strong>Server Receives</strong>: The <code class="language-plaintext highlighter-rouge">A2AServer</code> (built with Starlette) receives the HTTP POST request.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">A2AServer._process_request</code> (from <code class="language-plaintext highlighter-rouge">common/server/server.py</code>) handles this. It parses the JSON body into an <code class="language-plaintext highlighter-rouge">A2ARequest</code> Pydantic model (e.g., <code class="language-plaintext highlighter-rouge">SendTaskRequest</code>).</li>
    </ul>
  </li>
  <li><strong>Server Routes to TaskManager</strong>: Based on the JSON-RPC method in the request (e.g., <code class="language-plaintext highlighter-rouge">tasks/send</code>), the <code class="language-plaintext highlighter-rouge">A2AServer</code> calls the corresponding method on your <code class="language-plaintext highlighter-rouge">TaskManager</code>.
    <ul>
      <li>E.g., for <code class="language-plaintext highlighter-rouge">tasks/send</code>, it calls <code class="language-plaintext highlighter-rouge">task_manager.on_send_task(request_model)</code>.</li>
    </ul>
  </li>
  <li><strong>TaskManager -&gt; PocketFlow</strong>: Your <code class="language-plaintext highlighter-rouge">PocketFlowTaskManager</code>’s <code class="language-plaintext highlighter-rouge">on_send_task</code> method:
    <ul>
      <li>Extracts relevant data (like the question) from the <code class="language-plaintext highlighter-rouge">request_model</code>.</li>
      <li>Prepares the <a href="01_shared_state___shared__dictionary__.md">shared dictionary</a> for your PocketFlow <a href="04_flow___flow____asyncflow__.md">Flow (<code class="language-plaintext highlighter-rouge">Flow</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a>.</li>
      <li>Calls <code class="language-plaintext highlighter-rouge">your_pocketflow_flow.run(shared)</code>.</li>
    </ul>
  </li>
  <li>
    <p><strong>PocketFlow Executes</strong>: Your PocketFlow <a href="04_flow___flow____asyncflow__.md">Flow (<code class="language-plaintext highlighter-rouge">Flow</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a> runs its <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a>, using and updating the <a href="01_shared_state___shared__dictionary__.md">shared dictionary</a>. The final answer is placed in <code class="language-plaintext highlighter-rouge">shared</code> (e.g., <code class="language-plaintext highlighter-rouge">shared["answer"]</code>).</p>
  </li>
  <li><strong>PocketFlow -&gt; TaskManager</strong>: Control returns to <code class="language-plaintext highlighter-rouge">PocketFlowTaskManager</code>. It:
    <ul>
      <li>Retrieves the result (e.g., <code class="language-plaintext highlighter-rouge">shared["answer"]</code>).</li>
      <li>Constructs an A2A <code class="language-plaintext highlighter-rouge">Task</code> object (from <code class="language-plaintext highlighter-rouge">common.types</code>), including <code class="language-plaintext highlighter-rouge">Artifacts</code> containing the answer.</li>
    </ul>
  </li>
  <li>
    <p><strong>TaskManager -&gt; Server</strong>: The <code class="language-plaintext highlighter-rouge">TaskManager</code> returns the populated <code class="language-plaintext highlighter-rouge">Task</code> object (wrapped in a <code class="language-plaintext highlighter-rouge">JSONRPCResponse</code> model) to the <code class="language-plaintext highlighter-rouge">A2AServer</code>.</p>
  </li>
  <li><strong>Server Responds</strong>: The <code class="language-plaintext highlighter-rouge">A2AServer</code> serializes the <code class="language-plaintext highlighter-rouge">JSONRPCResponse</code> (which contains the <code class="language-plaintext highlighter-rouge">Task</code> with the answer) back into a JSON string.
    <ul>
      <li>It sends this JSON as the body of an HTTP 200 OK response back to the client.</li>
    </ul>
  </li>
  <li><strong>Client Processes</strong>: The <code class="language-plaintext highlighter-rouge">A2AClient</code> receives the HTTP response.
    <ul>
      <li>It parses the JSON body into its own Pydantic models (e.g., <code class="language-plaintext highlighter-rouge">SendTaskResponse</code> containing the <code class="language-plaintext highlighter-rouge">Task</code>).</li>
      <li>It extracts the answer from the <code class="language-plaintext highlighter-rouge">Task</code>’s artifacts for you to see.</li>
    </ul>
  </li>
</ol>

<p>Here’s a simplified sequence diagram of this interaction:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant UserApp as User App (e.g., CLI)
    participant Client as A2AClient
    participant Server as A2AServer
    participant TaskMgr as PocketFlowTaskManager
    participant PF_Flow as Your PocketFlow Flow

    UserApp-&gt;&gt;Client: User provides question
    Client-&gt;&gt;Server: HTTP POST / (JSON-RPC: tasks/send {question})
    Server-&gt;&gt;TaskMgr: on_send_task(a2a_request_with_question)
    TaskMgr-&gt;&gt;PF_Flow: flow.run(shared={"question": ...})
    Note over PF_Flow: Flow processes, puts answer in shared
    PF_Flow--&gt;&gt;TaskMgr: Returns (shared modified with answer)
    TaskMgr-&gt;&gt;TaskMgr: Creates A2A Task object with answer
    TaskMgr--&gt;&gt;Server: Returns A2A Task object
    Server--&gt;&gt;Client: HTTP 200 OK (JSON-RPC response {A2A Task with answer})
    Client-&gt;&gt;UserApp: Displays answer from A2A Task
</code></pre>

<p><strong>Key Code Snippets (Highly Simplified):</strong></p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">A2AClient</code> sending request (from <code class="language-plaintext highlighter-rouge">common/client/client.py</code>):</strong>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Inside A2AClient
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">_send_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request_model</span><span class="p">:</span> <span class="n">JSONRPCRequest</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
    <span class="c1"># request_model is e.g., SendTaskRequest
</span>    <span class="n">payload</span> <span class="o">=</span> <span class="n">request_model</span><span class="p">.</span><span class="n">model_dump</span><span class="p">(</span><span class="n">exclude_none</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c1"># self.fetchImpl is an httpx.AsyncClient
</span>    <span class="n">http_response</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">fetchImpl</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">url</span><span class="p">,</span> <span class="n">json</span><span class="o">=</span><span class="n">payload</span><span class="p">)</span>
    <span class="n">http_response</span><span class="p">.</span><span class="n">raise_for_status</span><span class="p">()</span> <span class="c1"># Check for HTTP errors
</span>    <span class="k">return</span> <span class="n">http_response</span><span class="p">.</span><span class="n">json</span><span class="p">()</span> <span class="c1"># Return parsed JSON response
</span></code></pre></div>    </div>
    <p>This shows the client converting a Pydantic model to a dictionary (<code class="language-plaintext highlighter-rouge">payload</code>) and sending it via HTTP.</p>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">A2AServer</code> processing request (from <code class="language-plaintext highlighter-rouge">common/server/server.py</code>):</strong>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Inside A2AServer
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">_process_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">http_request</span><span class="p">:</span> <span class="n">Request</span><span class="p">):</span>
    <span class="n">raw_body</span> <span class="o">=</span> <span class="k">await</span> <span class="n">http_request</span><span class="p">.</span><span class="n">body</span><span class="p">()</span>
    <span class="n">parsed_body</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="n">loads</span><span class="p">(</span><span class="n">raw_body</span><span class="p">)</span>
    <span class="c1"># A2ARequest.validate_python converts dict to Pydantic model
</span>    <span class="n">a2a_request_model</span> <span class="o">=</span> <span class="n">A2ARequest</span><span class="p">.</span><span class="n">validate_python</span><span class="p">(</span><span class="n">parsed_body</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a2a_request_model</span><span class="p">,</span> <span class="n">SendTaskRequest</span><span class="p">):</span>
        <span class="c1"># self.task_manager is your PocketFlowTaskManager
</span>        <span class="n">result_model</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">task_manager</span><span class="p">.</span><span class="n">on_send_task</span><span class="p">(</span><span class="n">a2a_request_model</span><span class="p">)</span>
    <span class="c1"># ... (other request types like GetTaskRequest) ...
</span>        
    <span class="c1"># result_model is e.g., SendTaskResponse
</span>    <span class="k">return</span> <span class="n">JSONResponse</span><span class="p">(</span><span class="n">result_model</span><span class="p">.</span><span class="n">model_dump</span><span class="p">(</span><span class="n">exclude_none</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
</code></pre></div>    </div>
    <p>This shows the server parsing the incoming JSON, converting it to a Pydantic model, and calling the appropriate <code class="language-plaintext highlighter-rouge">TaskManager</code> method.</p>
  </li>
</ul>

<h2 id="conclusion-your-agent-is-now-a-global-citizen">Conclusion: Your Agent is Now a Global Citizen!</h2>

<p>You’ve reached the end of our PocketFlow tutorial series! With the <strong>A2A (Agent-to-Agent) Communication Framework</strong>, you’ve learned how to:</p>
<ul>
  <li>Understand the roles of <code class="language-plaintext highlighter-rouge">A2AServer</code>, <code class="language-plaintext highlighter-rouge">A2AClient</code>, and <code class="language-plaintext highlighter-rouge">TaskManager</code>.</li>
  <li>Wrap your existing PocketFlow <a href="04_flow___flow____asyncflow__.md">Flows (<code class="language-plaintext highlighter-rouge">Flow</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a> with a <code class="language-plaintext highlighter-rouge">TaskManager</code> to handle A2A requests and responses.</li>
  <li>Host your agent using <code class="language-plaintext highlighter-rouge">A2AServer</code>, making it accessible via a standard JSON-RPC interface.</li>
  <li>Use <code class="language-plaintext highlighter-rouge">A2AClient</code> to interact with A2A-compatible agents.</li>
</ul>

<p>This framework transforms your PocketFlow agent from a standalone application into a component that can integrate with larger systems and collaborate with other agents, regardless of how they are built internally, as long as they speak the A2A language.</p>

<p><strong>Reflecting on Your PocketFlow Journey:</strong></p>

<p>Throughout this tutorial, you’ve explored the core concepts of PocketFlow:</p>
<ul>
  <li>Managing data with the <a href="01_shared_state___shared__dictionary__.md">Shared State (<code class="language-plaintext highlighter-rouge">shared</code> dictionary)</a>.</li>
  <li>Building modular tasks with <a href="02_node___basenode____node____asyncnode___.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a>.</li>
  <li>Creating dynamic workflows with <a href="03_actions___transitions_.md">Actions / Transitions</a>.</li>
  <li>Orchestrating nodes into powerful <a href="04_flow___flow____asyncflow__.md">Flows (<code class="language-plaintext highlighter-rouge">Flow</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a>.</li>
  <li>Handling I/O-bound tasks efficiently with <a href="05_asynchronous_processing___asyncnode____asyncflow___.md">Asynchronous Processing (<code class="language-plaintext highlighter-rouge">AsyncNode</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a>.</li>
  <li>Processing collections of data using <a href="06_batch_processing___batchnode____batchflow____asyncparallelbatchnode___.md">Batch Processing (<code class="language-plaintext highlighter-rouge">BatchNode</code>, <code class="language-plaintext highlighter-rouge">BatchFlow</code>, <code class="language-plaintext highlighter-rouge">AsyncParallelBatchNode</code>)</a>.</li>
  <li>And finally, enabling standardized inter-agent communication with the A2A framework.</li>
</ul>

<p>You now have a solid foundation to build sophisticated, modular, and interoperable AI applications with PocketFlow. The world of intelligent agents awaits your creativity! Happy building!</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
