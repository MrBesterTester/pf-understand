<h1 id="chapter-5-asynchronous-processing-asyncnode-asyncflow">Chapter 5: Asynchronous Processing (<code class="language-plaintext highlighter-rouge">AsyncNode</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</h1>

<p>In <a href="04_flow___flow____asyncflow__.md">Chapter 4: Flow (<code class="language-plaintext highlighter-rouge">Flow</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a>, we learned how <code class="language-plaintext highlighter-rouge">Flow</code> and <code class="language-plaintext highlighter-rouge">AsyncFlow</code> orchestrate sequences of <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> to create complete applications. Now, we’re going to zoom in on a powerful feature that <code class="language-plaintext highlighter-rouge">AsyncFlow</code> enables: <strong>Asynchronous Processing</strong>. This is key to building AI applications that feel responsive and can handle tasks that involve waiting, like calling web APIs or interacting with users.</p>

<h2 id="the-problem-waiting-can-be-wasteful">The Problem: Waiting Can Be Wasteful!</h2>

<p>Imagine you’re building an AI assistant that needs to:</p>
<ol>
  <li>Ask the user for a city name.</li>
  <li>Fetch the current weather for that city from an online weather service (this involves a network request, which can take a few seconds).</li>
  <li>Tell the user the weather.</li>
</ol>

<p>If we build this “synchronously” (one step strictly after the other, waiting for each to finish), your application would <em>freeze</em> while it’s waiting for the weather service. The user can’t do anything else; the app just hangs. This isn’t a great experience!</p>

<p>This is where asynchronous processing helps. It’s like a skilled chef in a busy kitchen.</p>
<ul>
  <li>A <strong>synchronous chef</strong> would prepare one dish from start to finish: chop vegetables, put it on the stove, wait for it to simmer, then plate it. Only <em>after</em> that one dish is completely done would they start the next. If simmering takes 20 minutes, they’re just standing there waiting!</li>
  <li>An <strong>asynchronous chef</strong> is much more efficient! They can start chopping vegetables for dish A, put it on the stove to simmer, and <em>while it’s simmering</em> (a waiting period), they can start preparing dish B, or perhaps clean up. They don’t idly wait; they switch to other tasks that can be done.</li>
</ul>

<p>PocketFlow’s <code class="language-plaintext highlighter-rouge">AsyncNode</code> and <code class="language-plaintext highlighter-rouge">AsyncFlow</code> let your AI application be like that efficient, asynchronous chef.</p>

<h2 id="what-is-asynchronous-processing">What is Asynchronous Processing?</h2>

<p>Asynchronous processing allows your program to start a potentially long-running task (like an API call or waiting for user input) and then, instead of freezing and waiting for it to complete, it can switch to doing other work. When the long-running task eventually finishes, the program can pick up where it left off with that task.</p>

<p>This is especially crucial for <strong>I/O-bound tasks</strong>. “I/O” stands for Input/Output, like:</p>
<ul>
  <li>Reading/writing files from a disk.</li>
  <li>Making requests over a network (e.g., to an LLM API, a database, or a web service).</li>
  <li>Waiting for user input.</li>
</ul>

<p>These tasks often involve waiting for something external to the program itself. Asynchronous processing ensures your application remains responsive and can handle multiple things (seemingly) at once, improving overall throughput and user experience.</p>

<p>In Python, this is often achieved using the <code class="language-plaintext highlighter-rouge">async</code> and <code class="language-plaintext highlighter-rouge">await</code> keywords.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">async def</code> is used to define an asynchronous function (also called a “coroutine”).</li>
  <li><code class="language-plaintext highlighter-rouge">await</code> is used inside an <code class="language-plaintext highlighter-rouge">async</code> function to pause its execution until an awaited task (another coroutine or an I/O operation) completes. While paused, other asynchronous tasks can run.</li>
</ul>

<h2 id="meet-asyncnode-the-asynchronous-worker">Meet <code class="language-plaintext highlighter-rouge">AsyncNode</code>: The Asynchronous Worker</h2>

<p>In PocketFlow, an <code class="language-plaintext highlighter-rouge">AsyncNode</code> is a special type of <a href="02_node___basenode____node____asyncnode__.md">Node (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a> designed for asynchronous operations. It looks very similar to a regular <code class="language-plaintext highlighter-rouge">Node</code>, but its core methods (<code class="language-plaintext highlighter-rouge">prep</code>, <code class="language-plaintext highlighter-rouge">exec</code>, <code class="language-plaintext highlighter-rouge">post</code>) are defined as <code class="language-plaintext highlighter-rouge">async</code> functions:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">async def prep_async(self, shared)</code></li>
  <li><code class="language-plaintext highlighter-rouge">async def exec_async(self, prep_res)</code></li>
  <li><code class="language-plaintext highlighter-rouge">async def post_async(self, shared, prep_res, exec_res)</code></li>
</ul>

<p>Inside these methods, you can use <code class="language-plaintext highlighter-rouge">await</code> to call other asynchronous functions or perform non-blocking I/O operations.</p>

<p>Let’s create a simple <code class="language-plaintext highlighter-rouge">AsyncNode</code> that simulates fetching data from a website. We’ll use <code class="language-plaintext highlighter-rouge">asyncio.sleep()</code> to mimic the delay of a network request.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">pocketflow</span> <span class="kn">import</span> <span class="n">AsyncNode</span>

<span class="k">class</span> <span class="nc">WeatherFetcherNode</span><span class="p">(</span><span class="n">AsyncNode</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">prep_async</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shared</span><span class="p">):</span>
        <span class="n">city</span> <span class="o">=</span> <span class="n">shared</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"city_name"</span><span class="p">,</span> <span class="s">"Unknown city"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"WeatherFetcherNode: Preparing to fetch weather for </span><span class="si">{</span><span class="n">city</span><span class="si">}</span><span class="s">."</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">city</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">exec_async</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">city</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"WeatherFetcherNode: Calling weather API for </span><span class="si">{</span><span class="n">city</span><span class="si">}</span><span class="s">..."</span><span class="p">)</span>
        <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># Simulate a 2-second API call
</span>        <span class="n">weather_data</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"Sunny in </span><span class="si">{</span><span class="n">city</span><span class="si">}</span><span class="s">"</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"WeatherFetcherNode: Got weather: </span><span class="si">{</span><span class="n">weather_data</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weather_data</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">post_async</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span> <span class="n">prep_res</span><span class="p">,</span> <span class="n">exec_res</span><span class="p">):</span>
        <span class="n">shared</span><span class="p">[</span><span class="s">"weather_report"</span><span class="p">]</span> <span class="o">=</span> <span class="n">exec_res</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"WeatherFetcherNode: Weather report stored in shared."</span><span class="p">)</span>
        <span class="k">return</span> <span class="s">"done"</span> <span class="c1"># Action to signify completion
</span></code></pre></div></div>
<p>In this <code class="language-plaintext highlighter-rouge">WeatherFetcherNode</code>:</p>
<ul>
  <li>All methods are <code class="language-plaintext highlighter-rouge">async def</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">exec_async</code> uses <code class="language-plaintext highlighter-rouge">await asyncio.sleep(2)</code> to pause for 2 seconds. If this were a real application, it might be <code class="language-plaintext highlighter-rouge">await http_client.get(...)</code>. While this <code class="language-plaintext highlighter-rouge">await</code> is active, other asynchronous tasks in your program could run.</li>
</ul>

<h2 id="orchestrating-with-asyncflow">Orchestrating with <code class="language-plaintext highlighter-rouge">AsyncFlow</code></h2>

<p>To run <code class="language-plaintext highlighter-rouge">AsyncNode</code>s, you need an <code class="language-plaintext highlighter-rouge">AsyncFlow</code>. As we saw in <a href="04_flow___flow____asyncflow__.md">Chapter 4: Flow (<code class="language-plaintext highlighter-rouge">Flow</code>, <code class="language-plaintext highlighter-rouge">AsyncFlow</code>)</a>, an <code class="language-plaintext highlighter-rouge">AsyncFlow</code> can manage both <code class="language-plaintext highlighter-rouge">AsyncNode</code>s and regular <code class="language-plaintext highlighter-rouge">Node</code>s. When it encounters an <code class="language-plaintext highlighter-rouge">AsyncNode</code>, it will correctly <code class="language-plaintext highlighter-rouge">await</code> its asynchronous methods.</p>

<p>Let’s set up an <code class="language-plaintext highlighter-rouge">AsyncFlow</code> to use our <code class="language-plaintext highlighter-rouge">WeatherFetcherNode</code>.</p>

<p><strong>1. Instantiate your Node(s):</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">weather_node</span> <span class="o">=</span> <span class="n">WeatherFetcherNode</span><span class="p">()</span>
<span class="c1"># You could have other nodes here, sync or async
</span></code></pre></div></div>

<p><strong>2. (Optional) Define Transitions:</strong>
If you have multiple nodes, you define transitions as usual. Since we only have one node, its returned action <code class="language-plaintext highlighter-rouge">"done"</code> will simply end this branch of the flow.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Example: weather_node - "done" &gt;&gt; some_other_node
# For this example, we'll let it end.
</span></code></pre></div></div>

<p><strong>3. Create the <code class="language-plaintext highlighter-rouge">AsyncFlow</code>:</strong></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pocketflow</span> <span class="kn">import</span> <span class="n">AsyncFlow</span>

<span class="n">weather_flow</span> <span class="o">=</span> <span class="n">AsyncFlow</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="n">weather_node</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>4. Run the <code class="language-plaintext highlighter-rouge">AsyncFlow</code>:</strong>
Running an <code class="language-plaintext highlighter-rouge">AsyncFlow</code> requires <code class="language-plaintext highlighter-rouge">await</code> because the flow itself is an asynchronous operation. You’ll typically do this inside an <code class="language-plaintext highlighter-rouge">async</code> function.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># main.py
</span><span class="kn">import</span> <span class="nn">asyncio</span>

<span class="c1"># Assume WeatherFetcherNode is defined as above
# Assume weather_flow is created as above
</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">shared_data</span> <span class="o">=</span> <span class="p">{</span><span class="s">"city_name"</span><span class="p">:</span> <span class="s">"London"</span><span class="p">}</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Starting weather flow..."</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">weather_flow</span><span class="p">.</span><span class="n">run_async</span><span class="p">(</span><span class="n">shared_data</span><span class="p">)</span> <span class="c1"># Use run_async()
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"Weather flow finished."</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Final shared data: </span><span class="si">{</span><span class="n">shared_data</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span> <span class="c1"># Standard way to run an async main function
</span></code></pre></div></div>

<p><strong>Expected Output/Behavior:</strong></p>

<p>When you run <code class="language-plaintext highlighter-rouge">main.py</code>:</p>
<ol>
  <li>“Starting weather flow…” is printed.</li>
  <li><code class="language-plaintext highlighter-rouge">WeatherFetcherNode: Preparing to fetch weather for London.</code> is printed.</li>
  <li><code class="language-plaintext highlighter-rouge">WeatherFetcherNode: Calling weather API for London...</code> is printed.</li>
  <li>The program will <em>pause</em> here for about 2 seconds (due to <code class="language-plaintext highlighter-rouge">await asyncio.sleep(2)</code>). If other <code class="language-plaintext highlighter-rouge">async</code> tasks were scheduled, Python’s event loop could run them during this time.</li>
  <li>After 2 seconds:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">WeatherFetcherNode: Got weather: Sunny in London</code> is printed.</li>
      <li><code class="language-plaintext highlighter-rouge">WeatherFetcherNode: Weather report stored in shared.</code> is printed.</li>
    </ul>
  </li>
  <li>“Weather flow finished.” is printed.</li>
  <li><code class="language-plaintext highlighter-rouge">Final shared data: {'city_name': 'London', 'weather_report': 'Sunny in London'}</code> is printed.</li>
</ol>

<p>The key is that during the 2-second “API call,” a well-structured asynchronous application wouldn’t be frozen. It could be handling other user requests, updating a UI, or performing other background tasks.</p>

<h2 id="what-happens-under-the-hood">What Happens Under the Hood?</h2>

<p>When an <code class="language-plaintext highlighter-rouge">AsyncFlow</code> runs an <code class="language-plaintext highlighter-rouge">AsyncNode</code>, it leverages Python’s <code class="language-plaintext highlighter-rouge">asyncio</code> event loop.</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">AsyncFlow</code> starts:</strong> You call <code class="language-plaintext highlighter-rouge">await my_async_flow.run_async(shared)</code>.</li>
  <li><strong>Node Execution:</strong> The <code class="language-plaintext highlighter-rouge">AsyncFlow</code>’s orchestrator (<code class="language-plaintext highlighter-rouge">_orch_async</code>) identifies the current node.</li>
  <li><strong>Calling <code class="language-plaintext highlighter-rouge">_run_async</code>:</strong> If the current node is an <code class="language-plaintext highlighter-rouge">AsyncNode</code> (like our <code class="language-plaintext highlighter-rouge">WeatherFetcherNode</code>), the <code class="language-plaintext highlighter-rouge">AsyncFlow</code> calls <code class="language-plaintext highlighter-rouge">await current_node._run_async(shared)</code>.</li>
  <li><strong>Inside <code class="language-plaintext highlighter-rouge">AsyncNode</code>:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">_run_async</code> calls <code class="language-plaintext highlighter-rouge">await self.prep_async(shared)</code>.</li>
      <li>Then, <code class="language-plaintext highlighter-rouge">await self._exec(prep_result)</code> (which internally calls <code class="language-plaintext highlighter-rouge">await self.exec_async(prep_result)</code>).</li>
      <li>Finally, <code class="language-plaintext highlighter-rouge">await self.post_async(shared, prep_result, exec_result)</code>.</li>
    </ul>
  </li>
  <li><strong>The <code class="language-plaintext highlighter-rouge">await</code> Keyword:</strong> When an <code class="language-plaintext highlighter-rouge">AsyncNode</code>’s method encounters an <code class="language-plaintext highlighter-rouge">await</code> statement (e.g., <code class="language-plaintext highlighter-rouge">await asyncio.sleep(2)</code> or <code class="language-plaintext highlighter-rouge">await some_api_call()</code>), execution of <em>that specific node’s task</em> pauses. Control is yielded back to the <code class="language-plaintext highlighter-rouge">asyncio</code> event loop.</li>
  <li><strong>Event Loop Magic:</strong> The event loop can then run other pending asynchronous tasks. It keeps track of the paused task.</li>
  <li><strong>Task Resumes:</strong> When the awaited operation completes (e.g., <code class="language-plaintext highlighter-rouge">asyncio.sleep(2)</code> finishes, or the API responds), the event loop resumes the paused <code class="language-plaintext highlighter-rouge">AsyncNode</code> task from where it left off.</li>
  <li><strong>Action and Next Node:</strong> The <code class="language-plaintext highlighter-rouge">AsyncNode</code>’s <code class="language-plaintext highlighter-rouge">post_async</code> eventually returns an action, and the <code class="language-plaintext highlighter-rouge">AsyncFlow</code> determines the next node, continuing the process.</li>
</ol>

<p>Here’s a sequence diagram to visualize it:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant UserApp as Your main()
    participant AFlow as AsyncFlow
    participant ANode as AsyncNode (e.g., WeatherFetcherNode)
    participant IOSim as Simulated I/O (e.g., asyncio.sleep)
    participant EventLoop as Python Event Loop

    UserApp-&gt;&gt;AFlow: await flow.run_async(shared)
    AFlow-&gt;&gt;ANode: await node._run_async(shared)
    ANode-&gt;&gt;ANode: await self.prep_async(shared)
    ANode-&gt;&gt;ANode: await self.exec_async(prep_res)
    Note over ANode,IOSim: e.g., await asyncio.sleep(2)
    ANode-&gt;&gt;IOSim: Start sleep operation
    Note over ANode, EventLoop: Task yields control to Event Loop
    EventLoop-&gt;&gt;EventLoop: (Runs other tasks, if any)
    IOSim--&gt;&gt;ANode: Sleep operation complete
    Note over ANode, EventLoop: Task resumes
    ANode-&gt;&gt;ANode: await self.post_async(shared, exec_res)
    ANode--&gt;&gt;AFlow: Returns action (e.g., "done")
    AFlow--&gt;&gt;UserApp: Flow complete (shared is updated)
</code></pre>

<p><strong>Diving into PocketFlow’s Code (Simplified):</strong></p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">AsyncNode</code>’s Execution (<code class="language-plaintext highlighter-rouge">pocketflow/__init__.py</code>):</strong>
The <code class="language-plaintext highlighter-rouge">AsyncNode</code> has an <code class="language-plaintext highlighter-rouge">_run_async</code> method:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Inside AsyncNode class
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">_run_async</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shared</span><span class="p">):</span>
    <span class="n">p</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">prep_async</span><span class="p">(</span><span class="n">shared</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">_exec</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="c1"># _exec calls exec_async with retries
</span>    <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">post_async</span><span class="p">(</span><span class="n">shared</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</code></pre></div>    </div>
    <p>And its <code class="language-plaintext highlighter-rouge">_exec</code> method handles calling <code class="language-plaintext highlighter-rouge">exec_async</code> (and retries, similar to <code class="language-plaintext highlighter-rouge">Node</code> but <code class="language-plaintext highlighter-rouge">async</code>):</p>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Inside AsyncNode class (simplified _exec)
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">_exec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prep_res</span><span class="p">):</span> 
    <span class="c1"># ... (retry loop) ...
</span>    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">exec_async</span><span class="p">(</span><span class="n">prep_res</span><span class="p">)</span> <span class="c1"># Key: await exec_async
</span>    <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="c1"># ... (fallback logic) ...
</span></code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">AsyncFlow</code>’s Orchestration (<code class="language-plaintext highlighter-rouge">pocketflow/__init__.py</code>):</strong>
The <code class="language-plaintext highlighter-rouge">AsyncFlow</code> has an <code class="language-plaintext highlighter-rouge">_orch_async</code> method that handles running nodes:
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Inside AsyncFlow class
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">_orch_async</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shared</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="n">curr</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">last_action</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">start_node</span><span class="p">,</span> <span class="p">(</span><span class="n">params</span> <span class="ow">or</span> <span class="p">{}),</span> <span class="bp">None</span>
    <span class="k">while</span> <span class="n">curr</span><span class="p">:</span>
        <span class="c1"># ... (set params for current node) ...
</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">AsyncNode</span><span class="p">):</span>
            <span class="n">last_action</span> <span class="o">=</span> <span class="k">await</span> <span class="n">curr</span><span class="p">.</span><span class="n">_run_async</span><span class="p">(</span><span class="n">shared</span><span class="p">)</span> <span class="c1"># AWAIT AsyncNode
</span>        <span class="k">else</span><span class="p">:</span>
            <span class="n">last_action</span> <span class="o">=</span> <span class="n">curr</span><span class="p">.</span><span class="n">_run</span><span class="p">(</span><span class="n">shared</span><span class="p">)</span> <span class="c1"># Run sync Node normally
</span>        <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_next_node</span><span class="p">(</span><span class="n">curr</span><span class="p">,</span> <span class="n">last_action</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">last_action</span>
</code></pre></div>    </div>
    <p>Notice how it checks if <code class="language-plaintext highlighter-rouge">curr</code> is an <code class="language-plaintext highlighter-rouge">AsyncNode</code> and uses <code class="language-plaintext highlighter-rouge">await curr._run_async(shared)</code> if it is. Otherwise, for regular synchronous <a href="02_node___basenode____node____asyncnode__.md">Nodes (<code class="language-plaintext highlighter-rouge">BaseNode</code>, <code class="language-plaintext highlighter-rouge">Node</code>, <code class="language-plaintext highlighter-rouge">AsyncNode</code>)</a>, it calls <code class="language-plaintext highlighter-rouge">curr._run(shared)</code> directly.</p>
  </li>
</ul>

<h2 id="benefits-of-asynchronous-processing">Benefits of Asynchronous Processing</h2>

<ol>
  <li><strong>Responsiveness:</strong> Your application doesn’t freeze while waiting for I/O tasks. This is vital for user interfaces or servers handling multiple requests.</li>
  <li><strong>Improved Throughput:</strong> For applications with many I/O-bound tasks (e.g., making multiple API calls), asynchronous processing allows these tasks to overlap their waiting periods, leading to faster overall completion. Imagine our chef preparing multiple simmering dishes at once!</li>
  <li><strong>Efficient Resource Usage:</strong> Threads can be resource-intensive. <code class="language-plaintext highlighter-rouge">asyncio</code> often uses a single thread more efficiently by switching between tasks during their I/O wait times.</li>
</ol>

<p>Use <code class="language-plaintext highlighter-rouge">AsyncNode</code> and <code class="language-plaintext highlighter-rouge">AsyncFlow</code> when your workflow involves tasks that spend significant time waiting for external operations.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve now unlocked the power of asynchronous processing in PocketFlow with <code class="language-plaintext highlighter-rouge">AsyncNode</code> and <code class="language-plaintext highlighter-rouge">AsyncFlow</code>!</p>
<ul>
  <li>Asynchronous operations prevent your application from freezing during I/O-bound tasks like API calls.</li>
  <li><code class="language-plaintext highlighter-rouge">AsyncNode</code> defines its logic with <code class="language-plaintext highlighter-rouge">async def</code> methods (<code class="language-plaintext highlighter-rouge">prep_async</code>, <code class="language-plaintext highlighter-rouge">exec_async</code>, <code class="language-plaintext highlighter-rouge">post_async</code>) and uses <code class="language-plaintext highlighter-rouge">await</code> for non-blocking waits.</li>
  <li><code class="language-plaintext highlighter-rouge">AsyncFlow</code> orchestrates these <code class="language-plaintext highlighter-rouge">AsyncNode</code>s (and regular <code class="language-plaintext highlighter-rouge">Node</code>s) using <code class="language-plaintext highlighter-rouge">await flow.run_async()</code>.</li>
  <li>This approach leads to more responsive and efficient applications, especially when dealing with network requests or user interactions.</li>
</ul>

<p>This “asynchronous chef” model is incredibly useful. What if you have many similar items to process, perhaps even asynchronously and in parallel? That’s where batch processing comes in.</p>

<p>Next up: <a href="06_batch_processing___batchnode____batchflow____asyncparallelbatchnode___.md">Chapter 6: Batch Processing (<code class="language-plaintext highlighter-rouge">BatchNode</code>, <code class="language-plaintext highlighter-rouge">BatchFlow</code>, <code class="language-plaintext highlighter-rouge">AsyncParallelBatchNode</code>)</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
