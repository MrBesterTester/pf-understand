<h1 id="chapter-1-commands-and-groups-the-building-blocks">Chapter 1: Commands and Groups: The Building Blocks</h1>

<p>Welcome to your first step in learning Click! Imagine you want to create your own command-line tool, maybe something like <code class="language-plaintext highlighter-rouge">git</code> or <code class="language-plaintext highlighter-rouge">docker</code>. How do you tell your program what to do when someone types <code class="language-plaintext highlighter-rouge">git commit</code> or <code class="language-plaintext highlighter-rouge">docker build</code>? That’s where <strong>Commands</strong> and <strong>Groups</strong> come in. They are the fundamental building blocks for any Click application.</p>

<p>Think about a simple tool. Maybe you want a program that can greet someone. You’d type <code class="language-plaintext highlighter-rouge">greet Alice</code> in your terminal, and it would print “Hello Alice!”. In Click, this single action, “greet”, would be represented by a <code class="language-plaintext highlighter-rouge">Command</code>.</p>

<p>Now, what if your tool needed to do <em>more</em> than one thing? Maybe besides greeting, it could also say goodbye. You might want to type <code class="language-plaintext highlighter-rouge">mytool greet Alice</code> or <code class="language-plaintext highlighter-rouge">mytool goodbye Bob</code>. The main <code class="language-plaintext highlighter-rouge">mytool</code> part acts like a container or a menu, holding the different actions (<code class="language-plaintext highlighter-rouge">greet</code>, <code class="language-plaintext highlighter-rouge">goodbye</code>). This container is what Click calls a <code class="language-plaintext highlighter-rouge">Group</code>.</p>

<p>So:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Command</code>: Represents a single action your tool can perform.</li>
  <li><code class="language-plaintext highlighter-rouge">Group</code>: Represents a collection of related actions (Commands or other Groups).</li>
</ul>

<p>Let’s dive in and see how to create them!</p>

<h2 id="your-first-command">Your First Command</h2>

<p>Creating a command in Click is surprisingly simple. You basically write a normal Python function and then “decorate” it to tell Click it’s a command-line command.</p>

<p>Let’s make a command that just prints “Hello World!”.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># hello_app.py
</span><span class="kn">import</span> <span class="nn">click</span>

<span class="o">@</span><span class="n">click</span><span class="p">.</span><span class="n">command</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
  <span class="s">"""A simple command that says Hello World"""</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
  <span class="n">hello</span><span class="p">()</span>
</code></pre></div></div>

<p>Let’s break this down:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">import click</code>: We need to import the Click library first.</li>
  <li><code class="language-plaintext highlighter-rouge">@click.command()</code>: This is the magic part! It’s called a decorator. It transforms the Python function <code class="language-plaintext highlighter-rouge">hello()</code> right below it into a Click <code class="language-plaintext highlighter-rouge">Command</code> object. We’ll learn more about <a href="02_decorators.md">Decorators</a> in the next chapter, but for now, just know this line turns <code class="language-plaintext highlighter-rouge">hello</code> into something Click understands as a command.</li>
  <li><code class="language-plaintext highlighter-rouge">def hello(): ...</code>: This is a standard Python function. The code inside this function is what will run when you execute the command from your terminal.</li>
  <li><code class="language-plaintext highlighter-rouge">"""A simple command that says Hello World"""</code>: This is a docstring. Click cleverly uses the function’s docstring as the help text for the command!</li>
  <li><code class="language-plaintext highlighter-rouge">if __name__ == '__main__': hello()</code>: This standard Python construct checks if the script is being run directly. If it is, it calls our <code class="language-plaintext highlighter-rouge">hello</code> command function (which is now actually a Click <code class="language-plaintext highlighter-rouge">Command</code> object).</li>
</ol>

<p><strong>Try running it!</strong> Save the code above as <code class="language-plaintext highlighter-rouge">hello_app.py</code>. Open your terminal in the same directory and run:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python hello_app.py
Hello World!
</code></pre></div></div>

<p>It works! You just created your first command-line command with Click.</p>

<p><strong>Bonus: Automatic Help!</strong></p>

<p>Click automatically generates help screens for you. Try running your command with <code class="language-plaintext highlighter-rouge">--help</code>:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python hello_app.py <span class="nt">--help</span>
Usage: hello_app.py <span class="o">[</span>OPTIONS]

  A simple <span class="nb">command </span>that says Hello World

Options:
  <span class="nt">--help</span>  Show this message and exit.
</code></pre></div></div>

<p>See? Click used the docstring we wrote (<code class="language-plaintext highlighter-rouge">A simple command that says Hello World</code>) and added a standard <code class="language-plaintext highlighter-rouge">--help</code> option for free!</p>

<h2 id="grouping-commands">Grouping Commands</h2>

<p>Okay, one command is nice, but real tools often have multiple commands. Like <code class="language-plaintext highlighter-rouge">git</code> has <code class="language-plaintext highlighter-rouge">commit</code>, <code class="language-plaintext highlighter-rouge">pull</code>, <code class="language-plaintext highlighter-rouge">push</code>, etc. Let’s say we want our tool to have two commands: <code class="language-plaintext highlighter-rouge">hello</code> and <code class="language-plaintext highlighter-rouge">goodbye</code>.</p>

<p>We need a way to group these commands together. That’s what <code class="language-plaintext highlighter-rouge">click.group()</code> is for. A <code class="language-plaintext highlighter-rouge">Group</code> acts as the main entry point and can have other commands attached to it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># multi_app.py
</span><span class="kn">import</span> <span class="nn">click</span>

<span class="c1"># 1. Create the main group
</span><span class="o">@</span><span class="n">click</span><span class="p">.</span><span class="n">group</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">cli</span><span class="p">():</span>
  <span class="s">"""A simple tool with multiple commands."""</span>
  <span class="k">pass</span> <span class="c1"># The group function itself doesn't need to do anything
</span>
<span class="c1"># 2. Define the 'hello' command
</span><span class="o">@</span><span class="n">click</span><span class="p">.</span><span class="n">command</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">hello</span><span class="p">():</span>
  <span class="s">"""Says Hello World"""</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"Hello World!"</span><span class="p">)</span>

<span class="c1"># 3. Define the 'goodbye' command
</span><span class="o">@</span><span class="n">click</span><span class="p">.</span><span class="n">command</span><span class="p">()</span>
<span class="k">def</span> <span class="nf">goodbye</span><span class="p">():</span>
  <span class="s">"""Says Goodbye World"""</span>
  <span class="k">print</span><span class="p">(</span><span class="s">"Goodbye World!"</span><span class="p">)</span>

<span class="c1"># 4. Attach the commands to the group
</span><span class="n">cli</span><span class="p">.</span><span class="n">add_command</span><span class="p">(</span><span class="n">hello</span><span class="p">)</span>
<span class="n">cli</span><span class="p">.</span><span class="n">add_command</span><span class="p">(</span><span class="n">goodbye</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
  <span class="n">cli</span><span class="p">()</span> <span class="c1"># Run the main group
</span></code></pre></div></div>

<p>What’s changed?</p>

<ol>
  <li>We created a function <code class="language-plaintext highlighter-rouge">cli</code> and decorated it with <code class="language-plaintext highlighter-rouge">@click.group()</code>. This makes <code class="language-plaintext highlighter-rouge">cli</code> our main entry point, a container for other commands. Notice the function body is just <code class="language-plaintext highlighter-rouge">pass</code> – often, the group function itself doesn’t need logic; its job is to hold other commands.</li>
  <li>We defined <code class="language-plaintext highlighter-rouge">hello</code> and <code class="language-plaintext highlighter-rouge">goodbye</code> just like before, using <code class="language-plaintext highlighter-rouge">@click.command()</code>.</li>
  <li>Crucially, we <em>attached</em> our commands to the group: <code class="language-plaintext highlighter-rouge">cli.add_command(hello)</code> and <code class="language-plaintext highlighter-rouge">cli.add_command(goodbye)</code>. This tells Click that <code class="language-plaintext highlighter-rouge">hello</code> and <code class="language-plaintext highlighter-rouge">goodbye</code> are subcommands of <code class="language-plaintext highlighter-rouge">cli</code>.</li>
  <li>Finally, in the <code class="language-plaintext highlighter-rouge">if __name__ == '__main__':</code> block, we run <code class="language-plaintext highlighter-rouge">cli()</code>, our main group.</li>
</ol>

<p><strong>Let’s run this!</strong> Save it as <code class="language-plaintext highlighter-rouge">multi_app.py</code>.</p>

<p>First, check the main help screen:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python multi_app.py <span class="nt">--help</span>
Usage: multi_app.py <span class="o">[</span>OPTIONS] COMMAND <span class="o">[</span>ARGS]...

  A simple tool with multiple commands.

Options:
  <span class="nt">--help</span>  Show this message and exit.

Commands:
  goodbye  Says Goodbye World
  hello    Says Hello World
</code></pre></div></div>

<p>Look! Click now lists <code class="language-plaintext highlighter-rouge">goodbye</code> and <code class="language-plaintext highlighter-rouge">hello</code> under “Commands”. It automatically figured out their names from the function names (<code class="language-plaintext highlighter-rouge">goodbye</code>, <code class="language-plaintext highlighter-rouge">hello</code>) and their help text from their docstrings.</p>

<p>Now, run the specific commands:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>python multi_app.py hello
Hello World!

<span class="nv">$ </span>python multi_app.py goodbye
Goodbye World!
</code></pre></div></div>

<p>You’ve successfully created a multi-command CLI tool!</p>

<p><em>(Self-promotion: There’s an even shorter way to attach commands using decorators directly on the group, which we’ll see in <a href="02_decorators.md">Decorators</a>!)</em></p>

<h2 id="how-it-works-under-the-hood">How It Works Under the Hood</h2>

<p>What’s really happening when you use <code class="language-plaintext highlighter-rouge">@click.command()</code> or <code class="language-plaintext highlighter-rouge">@click.group()</code>?</p>

<ol>
  <li>
    <p><strong>Decoration:</strong> The decorator (<code class="language-plaintext highlighter-rouge">@click.command</code> or <code class="language-plaintext highlighter-rouge">@click.group</code>) takes your Python function (<code class="language-plaintext highlighter-rouge">hello</code>, <code class="language-plaintext highlighter-rouge">goodbye</code>, <code class="language-plaintext highlighter-rouge">cli</code>). It wraps this function inside a Click object – either a <code class="language-plaintext highlighter-rouge">Command</code> instance or a <code class="language-plaintext highlighter-rouge">Group</code> instance (which is actually a special type of <code class="language-plaintext highlighter-rouge">Command</code>). These objects store your original function as the <code class="language-plaintext highlighter-rouge">callback</code> to be executed later. They also store metadata like the command name (derived from the function name) and the help text (from the docstring). You can find the code for these decorators in <code class="language-plaintext highlighter-rouge">decorators.py</code> and the <code class="language-plaintext highlighter-rouge">Command</code>/<code class="language-plaintext highlighter-rouge">Group</code> classes in <code class="language-plaintext highlighter-rouge">core.py</code>.</p>
  </li>
  <li>
    <p><strong>Execution:</strong> When you run <code class="language-plaintext highlighter-rouge">python multi_app.py hello</code>, Python executes the <code class="language-plaintext highlighter-rouge">cli()</code> call at the bottom. Since <code class="language-plaintext highlighter-rouge">cli</code> is a <code class="language-plaintext highlighter-rouge">Group</code> object created by Click, it knows how to parse the command-line arguments (<code class="language-plaintext highlighter-rouge">hello</code> in this case).</p>
  </li>
  <li>
    <p><strong>Parsing &amp; Dispatch:</strong> The <code class="language-plaintext highlighter-rouge">cli</code> group looks at the first argument (<code class="language-plaintext highlighter-rouge">hello</code>). It checks its list of registered subcommands (which we added using <code class="language-plaintext highlighter-rouge">cli.add_command</code>). It finds a match with the <code class="language-plaintext highlighter-rouge">hello</code> command object.</p>
  </li>
  <li>
    <p><strong>Callback:</strong> The <code class="language-plaintext highlighter-rouge">cli</code> group then invokes the <code class="language-plaintext highlighter-rouge">hello</code> command object. The <code class="language-plaintext highlighter-rouge">hello</code> command object, in turn, calls the original Python function (<code class="language-plaintext highlighter-rouge">hello()</code>) that it stored earlier as its <code class="language-plaintext highlighter-rouge">callback</code>.</p>
  </li>
</ol>

<p>Here’s a simplified view of what happens when you run <code class="language-plaintext highlighter-rouge">python multi_app.py hello</code>:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant Terminal
    participant PythonScript (multi_app.py)
    participant ClickRuntime
    participant cli_Group as cli (Group Object)
    participant hello_Command as hello (Command Object)

    User-&gt;&gt;Terminal: python multi_app.py hello
    Terminal-&gt;&gt;PythonScript: Executes script with args ["hello"]
    PythonScript-&gt;&gt;ClickRuntime: Calls cli() entry point
    ClickRuntime-&gt;&gt;cli_Group: Asks to handle args ["hello"]
    cli_Group-&gt;&gt;cli_Group: Parses args, identifies "hello" as subcommand
    cli_Group-&gt;&gt;hello_Command: Invokes the 'hello' command
    hello_Command-&gt;&gt;hello_Command: Executes its callback (the original hello() function)
    hello_Command--&gt;&gt;PythonScript: Prints "Hello World!"
    PythonScript--&gt;&gt;Terminal: Shows output
    Terminal--&gt;&gt;User: Displays "Hello World!"
</code></pre>

<p>This process of parsing arguments and calling the right function based on the command structure is the core job of Click, making it easy for <em>you</em> to just focus on writing the functions for each command.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve learned about the two most fundamental concepts in Click:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Command</code>: Represents a single action, created by decorating a function with <code class="language-plaintext highlighter-rouge">@click.command()</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Group</code>: Acts as a container for multiple commands (or other groups), created with <code class="language-plaintext highlighter-rouge">@click.group()</code>. Groups allow you to structure your CLI application logically.</li>
</ul>

<p>We saw how Click uses decorators to transform simple Python functions into powerful command-line interface components, automatically handling things like help text generation and command dispatching.</p>

<p>Commands and Groups form the basic structure, but how do we pass information <em>into</em> our commands (like <code class="language-plaintext highlighter-rouge">git commit -m "My message"</code>)? And what other cool things can decorators do? We’ll explore that starting with a deeper look at decorators in the next chapter!</p>

<p>Next up: <a href="02_decorators.md">Chapter 2: Decorators</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
