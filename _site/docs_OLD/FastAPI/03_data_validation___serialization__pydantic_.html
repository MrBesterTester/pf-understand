<h1 id="chapter-3-data-validation--serialization-pydantic">Chapter 3: Data Validation &amp; Serialization (Pydantic)</h1>

<p>Welcome back! In <a href="02_path_operations___parameter_declaration.md">Chapter 2: Path Operations &amp; Parameter Declaration</a>, we learned how FastAPI uses type hints to understand path parameters (like <code class="language-plaintext highlighter-rouge">/items/{item_id}</code>) and query parameters (like <code class="language-plaintext highlighter-rouge">/?skip=0&amp;limit=10</code>). We even saw a sneak peek of how Pydantic models can define the structure of a JSON request body.</p>

<p>Now, let’s dive deep into that magic! How does FastAPI <em>really</em> handle complex data coming into your API and the data you send back?</p>

<p><strong>Our Goal Today:</strong> Understand how FastAPI uses the powerful <strong>Pydantic</strong> library to automatically validate incoming data (making sure it’s correct) and serialize outgoing data (converting it to JSON).</p>

<h2 id="what-problem-does-this-solve">What Problem Does This Solve?</h2>

<p>Imagine you’re building the API for an online store, specifically the part where a user can add a new product. They need to send you information like the product’s name, price, and maybe an optional description. This information usually comes as JSON in the request body.</p>

<p>You need to make sure:</p>

<ol>
  <li><strong>The data arrived:</strong> Did the user actually send the product details?</li>
  <li><strong>It has the right shape:</strong> Does the JSON contain a <code class="language-plaintext highlighter-rouge">name</code> and a <code class="language-plaintext highlighter-rouge">price</code>? Is the <code class="language-plaintext highlighter-rouge">description</code> there, or is it okay if it’s missing?</li>
  <li><strong>It has the right types:</strong> Is the <code class="language-plaintext highlighter-rouge">name</code> a string? Is the <code class="language-plaintext highlighter-rouge">price</code> a number (like a float or decimal)?</li>
  <li><strong>It meets certain rules (optional):</strong> Maybe the price must be positive? Maybe the name can’t be empty?</li>
</ol>

<p>Doing these checks manually for every API endpoint would be tedious and error-prone.</p>

<p>Similarly, when you send data <em>back</em> (like the details of the newly created product), you need to convert your internal Python objects (like dictionaries or custom class instances) into standard JSON that the user’s browser or application can understand. You might also want to control <em>which</em> information gets sent back (e.g., maybe hide internal cost fields).</p>

<p><strong>FastAPI solves both problems using Pydantic:</strong></p>

<ul>
  <li><strong>Validation (Gatekeeper):</strong> Pydantic models act like strict blueprints or forms. You define the expected structure and types of incoming data using a Pydantic model. FastAPI uses this model to automatically parse the incoming JSON, check if it matches the blueprint (validate it), and provide you with a clean Python object. If the data doesn’t match, FastAPI automatically sends back a clear error message saying exactly what’s wrong. Think of it as a meticulous gatekeeper checking IDs and forms at the entrance.</li>
  <li><strong>Serialization (Translator):</strong> When you return data from your API function, FastAPI can use a Pydantic model (specified as a <code class="language-plaintext highlighter-rouge">response_model</code>) or its built-in <code class="language-plaintext highlighter-rouge">jsonable_encoder</code> to convert your Python objects (Pydantic models, database objects, dictionaries, etc.) into JSON format. Think of it as a helpful translator converting your application’s internal language into the common language of JSON for the outside world.</li>
</ul>

<h2 id="your-first-pydantic-model">Your First Pydantic Model</h2>

<p>Pydantic models are simply Python classes that inherit from <code class="language-plaintext highlighter-rouge">pydantic.BaseModel</code>. You define the “fields” of your data as class attributes with type hints.</p>

<p>Let’s define a model for our product item:</p>

<ol>
  <li><strong>Create a file (optional but good practice):</strong> You could put this in a file like <code class="language-plaintext highlighter-rouge">models.py</code>.</li>
  <li><strong>Write the model:</strong></li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># models.py (or within your main.py/routers/items.py)
</span><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>

<span class="k">class</span> <span class="nc">Item</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># Optional field with a default of None
</span>    <span class="n">price</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">tax</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>        <span class="c1"># Optional field with a default of None
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">from pydantic import BaseModel</code>: We import the necessary <code class="language-plaintext highlighter-rouge">BaseModel</code> from Pydantic.</li>
  <li><code class="language-plaintext highlighter-rouge">class Item(BaseModel):</code>: We define our model class <code class="language-plaintext highlighter-rouge">Item</code>, inheriting from <code class="language-plaintext highlighter-rouge">BaseModel</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">name: str</code>: We declare a field named <code class="language-plaintext highlighter-rouge">name</code>. The type hint <code class="language-plaintext highlighter-rouge">: str</code> tells Pydantic that this field is <strong>required</strong> and must be a string.</li>
  <li><code class="language-plaintext highlighter-rouge">description: str | None = None</code>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">str | None</code>: This type hint (using the pipe <code class="language-plaintext highlighter-rouge">|</code> operator for Union) means <code class="language-plaintext highlighter-rouge">description</code> can be either a string OR <code class="language-plaintext highlighter-rouge">None</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">= None</code>: This sets the <strong>default value</strong> to <code class="language-plaintext highlighter-rouge">None</code>. Because it has a default value, this field is <strong>optional</strong>. If the incoming data doesn’t include <code class="language-plaintext highlighter-rouge">description</code>, Pydantic will automatically set it to <code class="language-plaintext highlighter-rouge">None</code>.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">price: float</code>: A required field that must be a floating-point number.</li>
  <li><code class="language-plaintext highlighter-rouge">tax: float | None = None</code>: An optional field that can be a float or <code class="language-plaintext highlighter-rouge">None</code>, defaulting to <code class="language-plaintext highlighter-rouge">None</code>.</li>
</ul>

<p>This simple class definition now acts as our data blueprint!</p>

<h2 id="using-pydantic-for-request-body-validation">Using Pydantic for Request Body Validation</h2>

<p>Now, let’s use this <code class="language-plaintext highlighter-rouge">Item</code> model in a <code class="language-plaintext highlighter-rouge">POST</code> request to create a new item. We saw this briefly in Chapter 2.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># main.py (or routers/items.py)
</span><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>
<span class="c1"># Assume 'Item' model is defined above or imported: from models import Item
</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span> <span class="c1"># Or use your APIRouter
</span>
<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="s">"/items/"</span><span class="p">)</span>
<span class="c1"># Declare 'item' parameter with type hint 'Item'
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">create_item</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Item</span><span class="p">):</span>
    <span class="c1"># If the code reaches here, FastAPI + Pydantic already did:
</span>    <span class="c1"># 1. Read the request body (as JSON bytes).
</span>    <span class="c1"># 2. Parsed the JSON into a Python dict.
</span>    <span class="c1"># 3. Validated the dict against the 'Item' model.
</span>    <span class="c1">#    - Checked required fields ('name', 'price').
</span>    <span class="c1">#    - Checked types (name is str, price is float, etc.).
</span>    <span class="c1">#    - Assigned default values for optional fields if missing.
</span>    <span class="c1"># 4. Created an 'Item' instance from the valid data.
</span>
    <span class="c1"># 'item' is now a Pydantic 'Item' object with validated data!
</span>    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Received item name: </span><span class="si">{</span><span class="n">item</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Received item price: </span><span class="si">{</span><span class="n">item</span><span class="p">.</span><span class="n">price</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">item</span><span class="p">.</span><span class="n">description</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Received item description: </span><span class="si">{</span><span class="n">item</span><span class="p">.</span><span class="n">description</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">item</span><span class="p">.</span><span class="n">tax</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Received item tax: </span><span class="si">{</span><span class="n">item</span><span class="p">.</span><span class="n">tax</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

    <span class="c1"># You can easily convert the Pydantic model back to a dict if needed
</span>    <span class="n">item_dict</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">model_dump</span><span class="p">()</span> <span class="c1"># Pydantic v2 method
</span>
    <span class="c1"># ... here you would typically save the item to a database ...
</span>
    <span class="c1"># Return the created item's data
</span>    <span class="k">return</span> <span class="n">item_dict</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">async def create_item(item: Item)</code>: By declaring the function parameter <code class="language-plaintext highlighter-rouge">item</code> with the type hint <code class="language-plaintext highlighter-rouge">Item</code> (our Pydantic model), FastAPI automatically knows it should:
    <ul>
      <li>Expect JSON in the request body.</li>
      <li>Validate that JSON against the <code class="language-plaintext highlighter-rouge">Item</code> model.</li>
    </ul>
  </li>
  <li><strong>Automatic Validation:</strong> If the client sends JSON like <code class="language-plaintext highlighter-rouge">{"name": "Thingamajig", "price": 49.99}</code>, FastAPI/Pydantic validates it, creates an <code class="language-plaintext highlighter-rouge">Item</code> object (<code class="language-plaintext highlighter-rouge">item</code>), and passes it to your function. Inside your function, <code class="language-plaintext highlighter-rouge">item.name</code> will be <code class="language-plaintext highlighter-rouge">"Thingamajig"</code>, <code class="language-plaintext highlighter-rouge">item.price</code> will be <code class="language-plaintext highlighter-rouge">49.99</code>, and <code class="language-plaintext highlighter-rouge">item.description</code> and <code class="language-plaintext highlighter-rouge">item.tax</code> will be <code class="language-plaintext highlighter-rouge">None</code> (their defaults).</li>
  <li><strong>Automatic Errors:</strong> If the client sends invalid JSON, like <code class="language-plaintext highlighter-rouge">{"name": "Gadget"}</code> (missing <code class="language-plaintext highlighter-rouge">price</code>) or <code class="language-plaintext highlighter-rouge">{"name": "Gizmo", "price": "expensive"}</code> (<code class="language-plaintext highlighter-rouge">price</code> is not a float), FastAPI will <strong>not</strong> call your <code class="language-plaintext highlighter-rouge">create_item</code> function. Instead, it will automatically send back a <code class="language-plaintext highlighter-rouge">422 Unprocessable Entity</code> HTTP error response with a detailed JSON body explaining the validation errors.</li>
</ul>

<p><strong>Example 422 Error Response (if <code class="language-plaintext highlighter-rouge">price</code> was missing):</strong></p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"missing"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"loc"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"body"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"price"</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"msg"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Field required"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"input"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">The</span><span class="w"> </span><span class="err">invalid</span><span class="w"> </span><span class="err">data</span><span class="w"> </span><span class="err">received</span><span class="w">
        </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Gadget"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">Pydantic</span><span class="w"> </span><span class="err">v</span><span class="mi">2</span><span class="w"> </span><span class="err">URL</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">error</span><span class="w"> </span><span class="err">details</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>This automatic validation saves you a <em>ton</em> of boilerplate code and provides clear feedback to API consumers.</p>

<h2 id="using-pydantic-for-response-serialization-response_model">Using Pydantic for Response Serialization (<code class="language-plaintext highlighter-rouge">response_model</code>)</h2>

<p>We just saw how Pydantic validates <em>incoming</em> data. It’s also incredibly useful for shaping <em>outgoing</em> data.</p>

<p>Let’s say when we create an item, we want to return the item’s data, but maybe we have some internal fields in our Pydantic model that we <em>don’t</em> want to expose in the API response. Or, we just want to be absolutely sure the response <em>always</em> conforms to the <code class="language-plaintext highlighter-rouge">Item</code> structure.</p>

<p>We can use the <code class="language-plaintext highlighter-rouge">response_model</code> parameter in the path operation decorator:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># main.py (or routers/items.py, modified version)
</span><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>
<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span> <span class="c1"># Assuming Item is defined here or imported
</span>
<span class="c1"># Let's add an internal field to our model for demonstration
</span><span class="k">class</span> <span class="nc">Item</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">price</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">tax</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">internal_cost</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span> <span class="c1"># Field we DON'T want in the response
</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span> <span class="c1"># Or use your APIRouter
</span>
<span class="c1"># Add response_model=Item to the decorator
</span><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="s">"/items/"</span><span class="p">,</span> <span class="n">response_model</span><span class="o">=</span><span class="n">Item</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">create_item</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Item</span><span class="p">):</span>
    <span class="c1"># item is the validated input Item object
</span>    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Processing item: </span><span class="si">{</span><span class="n">item</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s"> with internal cost </span><span class="si">{</span><span class="n">item</span><span class="p">.</span><span class="n">internal_cost</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

    <span class="c1"># ... save item to database ...
</span>
    <span class="c1"># Let's imagine we return the same item object we received
</span>    <span class="c1"># (in reality, you might return an object fetched from the DB)
</span>    <span class="k">return</span> <span class="n">item</span> <span class="c1"># FastAPI will handle serialization based on response_model
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@app.post("/items/", response_model=Item)</code>: By adding <code class="language-plaintext highlighter-rouge">response_model=Item</code>, we tell FastAPI:
    <ol>
      <li><strong>Filter:</strong> Whatever data is returned by the <code class="language-plaintext highlighter-rouge">create_item</code> function, filter it so that only the fields defined in the <code class="language-plaintext highlighter-rouge">Item</code> model (<code class="language-plaintext highlighter-rouge">name</code>, <code class="language-plaintext highlighter-rouge">description</code>, <code class="language-plaintext highlighter-rouge">price</code>, <code class="language-plaintext highlighter-rouge">tax</code>, <code class="language-plaintext highlighter-rouge">internal_cost</code>) are included in the final JSON response. <strong>Wait!</strong> Actually, Pydantic V2 by default includes all fields from the returned object <em>that are also in the response model</em>. In this case, since we return <code class="language-plaintext highlighter-rouge">item</code> which <em>is</em> an <code class="language-plaintext highlighter-rouge">Item</code> instance, all fields (<code class="language-plaintext highlighter-rouge">name</code>, <code class="language-plaintext highlighter-rouge">description</code>, <code class="language-plaintext highlighter-rouge">price</code>, <code class="language-plaintext highlighter-rouge">tax</code>, <code class="language-plaintext highlighter-rouge">internal_cost</code>) would be included <em>if</em> the returned object <em>was</em> an <code class="language-plaintext highlighter-rouge">Item</code> instance. <em>Correction:</em> Let’s refine the example to show filtering. Let’s define a <em>different</em> response model.</li>
    </ol>
  </li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># models.py
</span><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>

<span class="c1"># Input model (can include internal fields)
</span><span class="k">class</span> <span class="nc">ItemCreate</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">price</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">tax</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">internal_cost</span><span class="p">:</span> <span class="nb">float</span> <span class="c1"># Required input, but we won't return it
</span>
<span class="c1"># Output model (defines what the client sees)
</span><span class="k">class</span> <span class="nc">ItemPublic</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">price</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">tax</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="c1"># Note: internal_cost is NOT defined here
</span>
<span class="c1"># ---- In main.py or routers/items.py ----
</span><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>
<span class="kn">from</span> <span class="nn">models</span> <span class="kn">import</span> <span class="n">ItemCreate</span><span class="p">,</span> <span class="n">ItemPublic</span> <span class="c1"># Import both models
</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span>

<span class="n">items_db</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># Simple in-memory "database"
</span>
<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="s">"/items/"</span><span class="p">,</span> <span class="n">response_model</span><span class="o">=</span><span class="n">ItemPublic</span><span class="p">)</span> <span class="c1"># Use ItemPublic for response
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">create_item</span><span class="p">(</span><span class="n">item_input</span><span class="p">:</span> <span class="n">ItemCreate</span><span class="p">):</span> <span class="c1"># Use ItemCreate for input
</span>    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Received internal cost: </span><span class="si">{</span><span class="n">item_input</span><span class="p">.</span><span class="n">internal_cost</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

    <span class="c1"># Convert input model to a dict (or create DB model instance)
</span>    <span class="n">item_data</span> <span class="o">=</span> <span class="n">item_input</span><span class="p">.</span><span class="n">model_dump</span><span class="p">()</span>

    <span class="c1"># Simulate saving to DB and getting back the saved data
</span>    <span class="c1"># In a real app, the DB might assign an ID, etc.
</span>    <span class="n">saved_item_data</span> <span class="o">=</span> <span class="n">item_data</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">saved_item_data</span><span class="p">[</span><span class="s">"id"</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">items_db</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># Add a simulated ID
</span>    <span class="n">items_db</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">saved_item_data</span><span class="p">)</span>

    <span class="c1"># Return the *dictionary* of saved data. FastAPI will use response_model
</span>    <span class="c1"># ItemPublic to filter and serialize this dictionary.
</span>    <span class="k">return</span> <span class="n">saved_item_data</span>
</code></pre></div></div>

<p><strong>Explanation (Revised):</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ItemCreate</code>: Defines the structure we expect for <em>creating</em> an item, including <code class="language-plaintext highlighter-rouge">internal_cost</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">ItemPublic</code>: Defines the structure we want to <em>return</em> to the client, notably <em>excluding</em> <code class="language-plaintext highlighter-rouge">internal_cost</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">create_item(item_input: ItemCreate)</code>: We accept the full <code class="language-plaintext highlighter-rouge">ItemCreate</code> model as input.</li>
  <li><code class="language-plaintext highlighter-rouge">@app.post("/items/", response_model=ItemPublic)</code>: We declare that the response should conform to the <code class="language-plaintext highlighter-rouge">ItemPublic</code> model.</li>
  <li><code class="language-plaintext highlighter-rouge">return saved_item_data</code>: We return a Python dictionary containing all fields (including <code class="language-plaintext highlighter-rouge">internal_cost</code> and the simulated <code class="language-plaintext highlighter-rouge">id</code>).</li>
  <li><strong>Automatic Filtering &amp; Serialization:</strong> FastAPI takes the returned dictionary (<code class="language-plaintext highlighter-rouge">saved_item_data</code>). Because <code class="language-plaintext highlighter-rouge">response_model=ItemPublic</code> is set, it does the following <em>before</em> sending the response:
    <ol>
      <li>It looks at the fields defined in <code class="language-plaintext highlighter-rouge">ItemPublic</code> (<code class="language-plaintext highlighter-rouge">name</code>, <code class="language-plaintext highlighter-rouge">description</code>, <code class="language-plaintext highlighter-rouge">price</code>, <code class="language-plaintext highlighter-rouge">tax</code>).</li>
      <li>It takes only those fields from the <code class="language-plaintext highlighter-rouge">saved_item_data</code> dictionary. The <code class="language-plaintext highlighter-rouge">internal_cost</code> and <code class="language-plaintext highlighter-rouge">id</code> fields are automatically dropped because they are not in <code class="language-plaintext highlighter-rouge">ItemPublic</code>.</li>
      <li>It ensures the values for the included fields match the types expected by <code class="language-plaintext highlighter-rouge">ItemPublic</code> (this also provides some output validation).</li>
      <li>It converts the resulting filtered data into a JSON string using <code class="language-plaintext highlighter-rouge">jsonable_encoder</code> internally.</li>
    </ol>
  </li>
</ul>

<p><strong>Example Interaction:</strong></p>

<ol>
  <li><strong>Client sends <code class="language-plaintext highlighter-rouge">POST /items/</code> with body:</strong>
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Super Gadget"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"price"</span><span class="p">:</span><span class="w"> </span><span class="mf">120.50</span><span class="p">,</span><span class="w">
  </span><span class="nl">"internal_cost"</span><span class="p">:</span><span class="w"> </span><span class="mf">55.25</span><span class="p">,</span><span class="w">
  </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"The best gadget ever!"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li><strong>FastAPI:</strong> Validates this against <code class="language-plaintext highlighter-rouge">ItemCreate</code> (Success).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">create_item</code> function:</strong> Runs, prints <code class="language-plaintext highlighter-rouge">internal_cost</code>, prepares <code class="language-plaintext highlighter-rouge">saved_item_data</code> dictionary.</li>
  <li><strong>FastAPI (Response processing):</strong> Takes the returned dictionary, filters it using <code class="language-plaintext highlighter-rouge">ItemPublic</code>.</li>
  <li><strong>Client receives <code class="language-plaintext highlighter-rouge">200 OK</code> with body:</strong>
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Super Gadget"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="s2">"The best gadget ever!"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"price"</span><span class="p">:</span><span class="w"> </span><span class="mf">120.50</span><span class="p">,</span><span class="w">
  </span><span class="nl">"tax"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
    <p>Notice <code class="language-plaintext highlighter-rouge">internal_cost</code> and <code class="language-plaintext highlighter-rouge">id</code> are gone!</p>
  </li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">response_model</code> gives you precise control over your API’s output contract, enhancing security and clarity.</p>

<h2 id="how-it-works-under-the-hood-simplified">How it Works Under the Hood (Simplified)</h2>

<p>Let’s trace the journey of a <code class="language-plaintext highlighter-rouge">POST /items/</code> request using our <code class="language-plaintext highlighter-rouge">ItemCreate</code> input model and <code class="language-plaintext highlighter-rouge">ItemPublic</code> response model.</p>

<ol>
  <li><strong>Request In:</strong> Client sends <code class="language-plaintext highlighter-rouge">POST /items/</code> with JSON body to the Uvicorn server.</li>
  <li><strong>FastAPI Routing:</strong> Uvicorn passes the request to FastAPI. FastAPI matches the path and method to our <code class="language-plaintext highlighter-rouge">create_item</code> function.</li>
  <li><strong>Parameter Analysis:</strong> FastAPI inspects <code class="language-plaintext highlighter-rouge">create_item(item_input: ItemCreate)</code>. It sees <code class="language-plaintext highlighter-rouge">item_input</code> is type-hinted with a Pydantic model (<code class="language-plaintext highlighter-rouge">ItemCreate</code>), so it knows to look for the data in the request body.</li>
  <li><strong>Body Reading &amp; Parsing:</strong> FastAPI reads the raw bytes from the request body and attempts to parse them as JSON into a Python dictionary. If JSON parsing fails, an error is returned.</li>
  <li><strong>Pydantic Validation:</strong> FastAPI passes the parsed dictionary to Pydantic, essentially calling <code class="language-plaintext highlighter-rouge">ItemCreate.model_validate(parsed_dict)</code>.
    <ul>
      <li><strong>Success:</strong> Pydantic checks types, required fields, etc. If valid, it returns a populated <code class="language-plaintext highlighter-rouge">ItemCreate</code> instance.</li>
      <li><strong>Failure:</strong> Pydantic raises a <code class="language-plaintext highlighter-rouge">ValidationError</code>. FastAPI catches this.</li>
    </ul>
  </li>
  <li><strong>Error Handling (if validation failed):</strong> FastAPI converts the Pydantic <code class="language-plaintext highlighter-rouge">ValidationError</code> into a user-friendly JSON response (status code 422) and sends it back immediately. The <code class="language-plaintext highlighter-rouge">create_item</code> function is <em>never called</em>.</li>
  <li><strong>Function Execution (if validation succeeded):</strong> FastAPI calls <code class="language-plaintext highlighter-rouge">create_item(item_input=&lt;ItemCreate instance&gt;)</code>. Your function logic runs.</li>
  <li><strong>Return Value:</strong> Your function returns a value (e.g., the <code class="language-plaintext highlighter-rouge">saved_item_data</code> dictionary).</li>
  <li><strong>Response Model Processing:</strong> FastAPI sees <code class="language-plaintext highlighter-rouge">response_model=ItemPublic</code> in the decorator.</li>
  <li><strong>Filtering/Validation:</strong> FastAPI uses the <code class="language-plaintext highlighter-rouge">ItemPublic</code> model to filter the returned dictionary (<code class="language-plaintext highlighter-rouge">saved_item_data</code>), keeping only fields defined in <code class="language-plaintext highlighter-rouge">ItemPublic</code>. It may also perform type coercion/validation based on <code class="language-plaintext highlighter-rouge">ItemPublic</code>.</li>
  <li><strong>Serialization (<code class="language-plaintext highlighter-rouge">jsonable_encoder</code>):</strong> FastAPI passes the filtered data to <code class="language-plaintext highlighter-rouge">jsonable_encoder</code>. This function recursively walks through the data, converting Pydantic models, <code class="language-plaintext highlighter-rouge">datetime</code> objects, <code class="language-plaintext highlighter-rouge">UUID</code>s, Decimals, etc., into basic JSON-compatible types (strings, numbers, booleans, lists, dicts, null).</li>
  <li><strong>Response Out:</strong> FastAPI creates the final HTTP response with the correct status code, headers (<code class="language-plaintext highlighter-rouge">Content-Type: application/json</code>), and the JSON string body. Uvicorn sends this back to the client.</li>
</ol>

<p>Here’s a diagram summarizing the flow:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Client
    participant ASGI Server (Uvicorn)
    participant FastAPI App
    participant Pydantic Validator
    participant Route Handler (create_item)
    participant Pydantic Serializer (via response_model)
    participant JsonableEncoder

    Client-&gt;&gt;ASGI Server (Uvicorn): POST /items/ (with JSON body)
    ASGI Server (Uvicorn)-&gt;&gt;FastAPI App: Pass Request
    FastAPI App-&gt;&gt;FastAPI App: Find route, see param `item_input: ItemCreate`
    FastAPI App-&gt;&gt;FastAPI App: Read &amp; Parse JSON body
    FastAPI App-&gt;&gt;Pydantic Validator: Validate data with ItemCreate model
    alt Validation Fails
        Pydantic Validator--&gt;&gt;FastAPI App: Raise ValidationError
        FastAPI App-&gt;&gt;FastAPI App: Format 422 Error Response
        FastAPI App--&gt;&gt;ASGI Server (Uvicorn): Send 422 Response
        ASGI Server (Uvicorn)--&gt;&gt;Client: HTTP 422 Response
    else Validation Succeeds
        Pydantic Validator--&gt;&gt;FastAPI App: Return ItemCreate instance
        FastAPI App-&gt;&gt;Route Handler (create_item): Call create_item(item_input=...)
        Route Handler (create_item)--&gt;&gt;FastAPI App: Return result (e.g., dict)
        FastAPI App-&gt;&gt;FastAPI App: Check response_model=ItemPublic
        FastAPI App-&gt;&gt;Pydantic Serializer (via response_model): Filter/Validate result using ItemPublic
        Pydantic Serializer (via response_model)--&gt;&gt;FastAPI App: Return filtered data
        FastAPI App-&gt;&gt;JsonableEncoder: Convert filtered data to JSON types
        JsonableEncoder--&gt;&gt;FastAPI App: Return JSON-compatible data
        FastAPI App-&gt;&gt;FastAPI App: Create 200 OK JSON Response
        FastAPI App--&gt;&gt;ASGI Server (Uvicorn): Send 200 Response
        ASGI Server (Uvicorn)--&gt;&gt;Client: HTTP 200 OK Response
    end
</code></pre>

<h2 id="internal-code-connections">Internal Code Connections</h2>

<p>While FastAPI hides the complexity, here’s roughly where things happen:</p>

<ul>
  <li><strong>Model Definition:</strong> You use <code class="language-plaintext highlighter-rouge">pydantic.BaseModel</code>.</li>
  <li><strong>Parameter Analysis:</strong> FastAPI’s <code class="language-plaintext highlighter-rouge">fastapi.dependencies.utils.analyze_param</code> identifies parameters type-hinted with Pydantic models as potential body parameters.</li>
  <li><strong>Request Body Handling:</strong> <code class="language-plaintext highlighter-rouge">fastapi.dependencies.utils.request_body_to_args</code> coordinates reading, parsing, and validation (using Pydantic’s validation methods internally, like <code class="language-plaintext highlighter-rouge">model_validate</code> in v2).</li>
  <li><strong>Validation Errors:</strong> Pydantic raises <code class="language-plaintext highlighter-rouge">pydantic.ValidationError</code>, which FastAPI catches and handles using default exception handlers (see <code class="language-plaintext highlighter-rouge">fastapi.exception_handlers</code>) to create the 422 response.</li>
  <li><strong>Response Serialization:</strong> The <code class="language-plaintext highlighter-rouge">fastapi.routing.APIRoute</code> class handles the <code class="language-plaintext highlighter-rouge">response_model</code>. If present, it uses it to process the return value before passing it to <code class="language-plaintext highlighter-rouge">fastapi.encoders.jsonable_encoder</code>.</li>
  <li><strong>JSON Conversion:</strong> <code class="language-plaintext highlighter-rouge">fastapi.encoders.jsonable_encoder</code> is the workhorse that converts various Python types into JSON-compatible formats. It knows how to handle Pydantic models (calling their <code class="language-plaintext highlighter-rouge">.model_dump(mode='json')</code> method in v2), datetimes, UUIDs, etc.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve unlocked one of FastAPI’s superpowers: seamless data validation and serialization powered by Pydantic!</p>

<ul>
  <li>You learned to define data shapes using <strong>Pydantic models</strong> (<code class="language-plaintext highlighter-rouge">BaseModel</code>).</li>
  <li>You saw how FastAPI <strong>automatically validates</strong> incoming request bodies against these models using simple type hints in your function parameters (<code class="language-plaintext highlighter-rouge">item: Item</code>).</li>
  <li>You learned how to use the <code class="language-plaintext highlighter-rouge">response_model</code> parameter in path operation decorators to <strong>filter and serialize</strong> outgoing data, ensuring your API responses have a consistent and predictable structure.</li>
  <li>You understood the basic flow: FastAPI acts as the orchestrator, using Pydantic as the expert validator and <code class="language-plaintext highlighter-rouge">jsonable_encoder</code> as the expert translator.</li>
</ul>

<p>This automatic handling drastically reduces boilerplate code, prevents common errors, and makes your API development faster and more robust.</p>

<p>But there’s another huge benefit to defining your data with Pydantic models: FastAPI uses them to generate interactive API documentation automatically! Let’s see how that works in the next chapter.</p>

<p>Ready to see your API document itself? Let’s move on to <a href="04_openapi___automatic_docs.md">Chapter 4: OpenAPI &amp; Automatic Docs</a>!</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
