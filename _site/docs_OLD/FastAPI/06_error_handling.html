<h1 id="chapter-6-error-handling">Chapter 6: Error Handling</h1>

<p>Welcome back! In <a href="05_dependency_injection.md">Chapter 5: Dependency Injection</a>, we learned how to structure our code using dependencies to manage common tasks like pagination or database sessions. This helps keep our code clean and reusable.</p>

<p>But what happens when things don’t go as planned? A user might request data that doesn’t exist, or they might send invalid input. Our API needs a way to gracefully handle these situations and inform the client about what went wrong.</p>

<p><strong>Our Goal Today:</strong> Learn how FastAPI helps us manage errors effectively, both for problems we expect (like “item not found”) and for unexpected issues like invalid input data.</p>

<h2 id="what-problem-does-this-solve">What Problem Does This Solve?</h2>

<p>Imagine our online store API. We have an endpoint like <code class="language-plaintext highlighter-rouge">/items/{item_id}</code> to fetch details about a specific item. What should happen if a user tries to access <code class="language-plaintext highlighter-rouge">/items/9999</code> but there’s no item with ID 9999 in our database?</p>

<p>If we don’t handle this, our application might crash or return a confusing, generic server error (like <code class="language-plaintext highlighter-rouge">500 Internal Server Error</code>). This isn’t helpful for the person using our API. They need clear feedback: “The item you asked for doesn’t exist.”</p>

<p>Similarly, if a user tries to <em>create</em> an item (<code class="language-plaintext highlighter-rouge">POST /items/</code>) but forgets to include the required <code class="language-plaintext highlighter-rouge">price</code> field in the JSON body, we shouldn’t just crash. We need to tell them, “You forgot the price field!”</p>

<p>FastAPI provides a structured way to handle these different types of errors, ensuring clear communication with the client. Think of it as setting up clear emergency procedures for your API.</p>

<h2 id="key-concepts">Key Concepts</h2>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">HTTPException</code> for Expected Errors:</strong>
    <ul>
      <li>These are errors you anticipate might occur based on the client’s request, like requesting a non-existent resource or lacking permissions.</li>
      <li>You can <strong>raise</strong> <code class="language-plaintext highlighter-rouge">HTTPException</code> directly in your code.</li>
      <li>You specify an appropriate HTTP <strong>status code</strong> (like <code class="language-plaintext highlighter-rouge">404 Not Found</code>, <code class="language-plaintext highlighter-rouge">403 Forbidden</code>) and a helpful <strong>detail message</strong> (like <code class="language-plaintext highlighter-rouge">"Item not found"</code>).</li>
      <li>FastAPI catches this exception and automatically sends a properly formatted JSON error response to the client.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">RequestValidationError</code> for Invalid Input:</strong>
    <ul>
      <li>This error occurs when the data sent by the client in the request (path parameters, query parameters, or request body) fails the validation rules defined by your type hints and Pydantic models (as seen in <a href="02_path_operations___parameter_declaration.md">Chapter 2: Path Operations &amp; Parameter Declaration</a> and <a href="03_data_validation___serialization__pydantic_.md">Chapter 3: Data Validation &amp; Serialization (Pydantic)</a>).</li>
      <li>FastAPI <strong>automatically</strong> catches these validation errors.</li>
      <li>It sends back a <code class="language-plaintext highlighter-rouge">422 Unprocessable Entity</code> response containing detailed information about <em>which</em> fields were invalid and <em>why</em>. You usually don’t need to write extra code for this!</li>
    </ul>
  </li>
  <li><strong>Custom Exception Handlers:</strong>
    <ul>
      <li>For more advanced scenarios, you can define your <em>own</em> functions to handle specific types of exceptions (either built-in Python exceptions or custom ones you create).</li>
      <li>This gives you full control over how errors are logged and what response is sent back to the client.</li>
    </ul>
  </li>
</ol>

<h2 id="using-httpexception-for-expected-errors">Using <code class="language-plaintext highlighter-rouge">HTTPException</code> for Expected Errors</h2>

<p>Let’s solve our “item not found” problem using <code class="language-plaintext highlighter-rouge">HTTPException</code>.</p>

<ol>
  <li>
    <p><strong>Import <code class="language-plaintext highlighter-rouge">HTTPException</code>:</strong></p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># main.py or your router file
</span><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span><span class="p">,</span> <span class="n">HTTPException</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span> <span class="c1"># Or use your APIRouter
</span>
<span class="c1"># Simple in-memory storage (like from Chapter 4)
</span><span class="n">fake_items_db</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="p">{</span><span class="s">"name"</span><span class="p">:</span> <span class="s">"Foo"</span><span class="p">},</span> <span class="mi">2</span><span class="p">:</span> <span class="p">{</span><span class="s">"name"</span><span class="p">:</span> <span class="s">"Bar"</span><span class="p">}}</span>
</code></pre></div>    </div>

    <p><strong>Explanation:</strong> We import <code class="language-plaintext highlighter-rouge">HTTPException</code> directly from <code class="language-plaintext highlighter-rouge">fastapi</code>.</p>
  </li>
  <li>
    <p><strong>Check and Raise in Your Path Operation:</strong></p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"/items/{item_id}"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">read_item</span><span class="p">(</span><span class="n">item_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
    <span class="c1"># Check if the requested item_id exists in our "database"
</span>    <span class="k">if</span> <span class="n">item_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">fake_items_db</span><span class="p">:</span>
        <span class="c1"># If not found, raise HTTPException!
</span>        <span class="k">raise</span> <span class="n">HTTPException</span><span class="p">(</span><span class="n">status_code</span><span class="o">=</span><span class="mi">404</span><span class="p">,</span> <span class="n">detail</span><span class="o">=</span><span class="s">"Item not found"</span><span class="p">)</span>

    <span class="c1"># If found, proceed normally
</span>    <span class="k">return</span> <span class="p">{</span><span class="s">"item"</span><span class="p">:</span> <span class="n">fake_items_db</span><span class="p">[</span><span class="n">item_id</span><span class="p">]}</span>
</code></pre></div>    </div>

    <p><strong>Explanation:</strong></p>
    <ul>
      <li>Inside <code class="language-plaintext highlighter-rouge">read_item</code>, we check if the <code class="language-plaintext highlighter-rouge">item_id</code> exists as a key in our <code class="language-plaintext highlighter-rouge">fake_items_db</code> dictionary.</li>
      <li>If <code class="language-plaintext highlighter-rouge">item_id</code> is <em>not</em> found, we <code class="language-plaintext highlighter-rouge">raise HTTPException(...)</code>.
        <ul>
          <li><code class="language-plaintext highlighter-rouge">status_code=404</code>: We use the standard HTTP status code <code class="language-plaintext highlighter-rouge">404 Not Found</code>. FastAPI knows many common status codes (you can also use <code class="language-plaintext highlighter-rouge">from starlette import status; raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, ...)</code> for more readability).</li>
          <li><code class="language-plaintext highlighter-rouge">detail="Item not found"</code>: We provide a human-readable message explaining the error. This will be sent back to the client in the JSON response body.</li>
        </ul>
      </li>
      <li>If the item <em>is</em> found, the <code class="language-plaintext highlighter-rouge">raise</code> statement is skipped, and the function returns the item details as usual.</li>
    </ul>
  </li>
</ol>

<p><strong>How it Behaves:</strong></p>

<ul>
  <li><strong>Request:</strong> Client sends <code class="language-plaintext highlighter-rouge">GET /items/1</code>
    <ul>
      <li><strong>Response (Status Code 200):</strong>
        <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"item"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Foo"</span><span class="p">}}</span><span class="w">
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>Request:</strong> Client sends <code class="language-plaintext highlighter-rouge">GET /items/99</code>
    <ul>
      <li><strong>Response (Status Code 404):</strong>
        <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Item not found"</span><span class="p">}</span><span class="w">
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<p>FastAPI automatically catches the <code class="language-plaintext highlighter-rouge">HTTPException</code> you raised and sends the correct HTTP status code along with the <code class="language-plaintext highlighter-rouge">detail</code> message formatted as JSON.</p>

<h2 id="automatic-handling-of-requestvalidationerror">Automatic Handling of <code class="language-plaintext highlighter-rouge">RequestValidationError</code></h2>

<p>You’ve already seen this in action without realizing it! When you define Pydantic models for your request bodies or use type hints for path/query parameters, FastAPI automatically validates incoming data.</p>

<p>Let’s revisit the <code class="language-plaintext highlighter-rouge">create_item</code> example from <a href="03_data_validation___serialization__pydantic_.md">Chapter 3: Data Validation &amp; Serialization (Pydantic)</a>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># main.py or your router file
</span><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>
<span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span>

<span class="c1"># Pydantic model requiring name and price
</span><span class="k">class</span> <span class="nc">Item</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">price</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>

<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="s">"/items/"</span><span class="p">)</span>
<span class="c1"># Expects request body matching the Item model
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">create_item</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Item</span><span class="p">):</span>
    <span class="c1"># If execution reaches here, validation PASSED automatically.
</span>    <span class="k">return</span> <span class="p">{</span><span class="s">"message"</span><span class="p">:</span> <span class="s">"Item received!"</span><span class="p">,</span> <span class="s">"item_data"</span><span class="p">:</span> <span class="n">item</span><span class="p">.</span><span class="n">model_dump</span><span class="p">()}</span>
</code></pre></div></div>

<p><strong>How it Behaves (Automatically):</strong></p>

<ul>
  <li><strong>Request:</strong> Client sends <code class="language-plaintext highlighter-rouge">POST /items/</code> with a <em>valid</em> JSON body:
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Gadget"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"price"</span><span class="p">:</span><span class="w"> </span><span class="mf">19.95</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
    <ul>
      <li><strong>Response (Status Code 200):</strong>
        <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Item received!"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"item_data"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Gadget"</span><span class="p">,</span><span class="w">
    </span><span class="nl">"price"</span><span class="p">:</span><span class="w"> </span><span class="mf">19.95</span><span class="p">,</span><span class="w">
    </span><span class="nl">"description"</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>Request:</strong> Client sends <code class="language-plaintext highlighter-rouge">POST /items/</code> with an <em>invalid</em> JSON body (missing <code class="language-plaintext highlighter-rouge">price</code>):
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Widget"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
    <ul>
      <li><strong>Response (Status Code 422):</strong> FastAPI <em>automatically</em> intercepts this before <code class="language-plaintext highlighter-rouge">create_item</code> runs and sends:
        <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"missing"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"loc"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"body"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"price"</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"msg"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Field required"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"input"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
        </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Widget"</span><span class="w">
      </span><span class="p">},</span><span class="w">
      </span><span class="nl">"url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">Link</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">Pydantic</span><span class="w"> </span><span class="err">error</span><span class="w"> </span><span class="err">docs</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>Request:</strong> Client sends <code class="language-plaintext highlighter-rouge">POST /items/</code> with an <em>invalid</em> JSON body (wrong type for <code class="language-plaintext highlighter-rouge">price</code>):
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Doohickey"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"price"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cheap"</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
    <ul>
      <li><strong>Response (Status Code 422):</strong> FastAPI automatically sends:
        <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"float_parsing"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"loc"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"body"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"price"</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"msg"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Input should be a valid number, unable to parse string as a number"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"input"</span><span class="p">:</span><span class="w"> </span><span class="s2">"cheap"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<p>Notice that we didn’t write any <code class="language-plaintext highlighter-rouge">try...except</code> blocks or <code class="language-plaintext highlighter-rouge">if</code> statements in <code class="language-plaintext highlighter-rouge">create_item</code> to handle these validation issues. FastAPI and Pydantic take care of it, providing detailed error messages that tell the client exactly what went wrong and where (<code class="language-plaintext highlighter-rouge">loc</code>). This is a huge time saver!</p>

<h2 id="custom-exception-handlers-a-quick-look">Custom Exception Handlers (A Quick Look)</h2>

<p>Sometimes, you might want to handle specific errors in a unique way. Maybe you want to log a particular error to a monitoring service, or perhaps you need to return error responses in a completely custom format different from FastAPI’s default.</p>

<p>FastAPI allows you to register <strong>exception handlers</strong> using the <code class="language-plaintext highlighter-rouge">@app.exception_handler()</code> decorator.</p>

<p><strong>Example:</strong> Imagine you have a custom error <code class="language-plaintext highlighter-rouge">UnicornNotFound</code> and want to return a <code class="language-plaintext highlighter-rouge">418 I'm a teapot</code> status code when it occurs.</p>

<ol>
  <li>
    <p><strong>Define the Custom Exception:</strong></p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Can be in your main file or a separate exceptions.py
</span><span class="k">class</span> <span class="nc">UnicornNotFound</span><span class="p">(</span><span class="nb">Exception</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Define the Handler Function:</strong></p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># main.py
</span><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span><span class="p">,</span> <span class="n">Request</span>
<span class="kn">from</span> <span class="nn">fastapi.responses</span> <span class="kn">import</span> <span class="n">JSONResponse</span>
<span class="c1"># Assuming UnicornNotFound is defined above or imported
</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span>

<span class="c1"># Decorator registers this function to handle UnicornNotFound errors
</span><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">exception_handler</span><span class="p">(</span><span class="n">UnicornNotFound</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">unicorn_exception_handler</span><span class="p">(</span><span class="n">request</span><span class="p">:</span> <span class="n">Request</span><span class="p">,</span> <span class="n">exc</span><span class="p">:</span> <span class="n">UnicornNotFound</span><span class="p">):</span>
    <span class="c1"># This function runs whenever UnicornNotFound is raised
</span>    <span class="k">return</span> <span class="n">JSONResponse</span><span class="p">(</span>
        <span class="n">status_code</span><span class="o">=</span><span class="mi">418</span><span class="p">,</span> <span class="c1"># I'm a teapot!
</span>        <span class="n">content</span><span class="o">=</span><span class="p">{</span><span class="s">"message"</span><span class="p">:</span> <span class="sa">f</span><span class="s">"Oops! Can't find unicorn named: </span><span class="si">{</span><span class="n">exc</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">."</span><span class="p">},</span>
    <span class="p">)</span>
</code></pre></div>    </div>

    <p><strong>Explanation:</strong></p>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">@app.exception_handler(UnicornNotFound)</code>: This tells FastAPI that the <code class="language-plaintext highlighter-rouge">unicorn_exception_handler</code> function should be called whenever an error of type <code class="language-plaintext highlighter-rouge">UnicornNotFound</code> is raised <em>and not caught</em> elsewhere.</li>
      <li>The handler function receives the <code class="language-plaintext highlighter-rouge">request</code> object and the exception instance (<code class="language-plaintext highlighter-rouge">exc</code>).</li>
      <li>It returns a <code class="language-plaintext highlighter-rouge">JSONResponse</code> with the desired status code (418) and a custom content dictionary.</li>
    </ul>
  </li>
  <li>
    <p><strong>Raise the Custom Exception in a Path Operation:</strong></p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"/unicorns/{name}"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">read_unicorn</span><span class="p">(</span><span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s">"yolo"</span><span class="p">:</span>
        <span class="c1"># Raise our custom exception
</span>        <span class="k">raise</span> <span class="n">UnicornNotFound</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">"unicorn_name"</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s">"message"</span><span class="p">:</span> <span class="s">"Unicorn exists!"</span><span class="p">}</span>
</code></pre></div>    </div>
  </li>
</ol>

<p><strong>How it Behaves:</strong></p>

<ul>
  <li><strong>Request:</strong> <code class="language-plaintext highlighter-rouge">GET /unicorns/sparklehoof</code>
    <ul>
      <li><strong>Response (Status Code 200):</strong>
        <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"unicorn_name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"sparklehoof"</span><span class="p">,</span><span class="w"> </span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Unicorn exists!"</span><span class="p">}</span><span class="w">
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li><strong>Request:</strong> <code class="language-plaintext highlighter-rouge">GET /unicorns/yolo</code>
    <ul>
      <li><strong>Response (Status Code 418):</strong> (Handled by <code class="language-plaintext highlighter-rouge">unicorn_exception_handler</code>)
        <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"message"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Oops! Can't find unicorn named: yolo."</span><span class="p">}</span><span class="w">
</span></code></pre></div>        </div>
      </li>
    </ul>
  </li>
</ul>

<p>Custom handlers provide flexibility, but for most common API errors, <code class="language-plaintext highlighter-rouge">HTTPException</code> and the automatic <code class="language-plaintext highlighter-rouge">RequestValidationError</code> handling are sufficient.</p>

<h2 id="how-it-works-under-the-hood-simplified">How it Works Under the Hood (Simplified)</h2>

<p>When an error occurs during a request, FastAPI follows a process to decide how to respond:</p>

<p><strong>Scenario 1: Raising <code class="language-plaintext highlighter-rouge">HTTPException</code></strong></p>

<ol>
  <li><strong>Raise:</strong> Your path operation code (e.g., <code class="language-plaintext highlighter-rouge">read_item</code>) executes <code class="language-plaintext highlighter-rouge">raise HTTPException(status_code=404, detail="Item not found")</code>.</li>
  <li><strong>Catch:</strong> FastAPI’s internal request/response cycle catches this specific <code class="language-plaintext highlighter-rouge">HTTPException</code>.</li>
  <li><strong>Find Handler:</strong> FastAPI checks if there’s a custom handler registered for <code class="language-plaintext highlighter-rouge">HTTPException</code>. If not (which is usually the case unless you override it), it uses its <strong>default handler</strong> for <code class="language-plaintext highlighter-rouge">HTTPException</code>.</li>
  <li><strong>Default Handler Executes:</strong> The default handler (<code class="language-plaintext highlighter-rouge">fastapi.exception_handlers.http_exception_handler</code>) takes the <code class="language-plaintext highlighter-rouge">status_code</code> and <code class="language-plaintext highlighter-rouge">detail</code> from the exception you raised.</li>
  <li><strong>Create Response:</strong> It creates a <code class="language-plaintext highlighter-rouge">starlette.responses.JSONResponse</code> containing <code class="language-plaintext highlighter-rouge">{"detail": exc.detail}</code> and sets the status code to <code class="language-plaintext highlighter-rouge">exc.status_code</code>.</li>
  <li><strong>Send Response:</strong> This JSON response is sent back to the client.</li>
</ol>

<pre><code class="language-mermaid">sequenceDiagram
    participant Client
    participant FastAPIApp as FastAPI App
    participant RouteHandler as Route Handler (read_item)
    participant DefaultHTTPExceptionHandler as Default HTTPException Handler

    Client-&gt;&gt;+FastAPIApp: GET /items/99
    FastAPIApp-&gt;&gt;+RouteHandler: Call read_item(item_id=99)
    RouteHandler-&gt;&gt;RouteHandler: Check DB: item 99 not found
    RouteHandler--&gt;&gt;-FastAPIApp: raise HTTPException(404, "Item not found")
    Note over FastAPIApp: Catches HTTPException
    FastAPIApp-&gt;&gt;+DefaultHTTPExceptionHandler: Handle the exception instance
    DefaultHTTPExceptionHandler-&gt;&gt;DefaultHTTPExceptionHandler: Extract status_code=404, detail="Item not found"
    DefaultHTTPExceptionHandler--&gt;&gt;-FastAPIApp: Return JSONResponse(status=404, content={"detail": "..."})
    FastAPIApp--&gt;&gt;-Client: Send 404 JSON Response
</code></pre>

<p><strong>Scenario 2: Automatic <code class="language-plaintext highlighter-rouge">RequestValidationError</code></strong></p>

<ol>
  <li><strong>Request:</strong> Client sends <code class="language-plaintext highlighter-rouge">POST /items/</code> with invalid data (e.g., missing <code class="language-plaintext highlighter-rouge">price</code>).</li>
  <li><strong>Parameter/Body Parsing:</strong> FastAPI tries to parse the request body and validate it against the <code class="language-plaintext highlighter-rouge">Item</code> Pydantic model before calling <code class="language-plaintext highlighter-rouge">create_item</code>.</li>
  <li><strong>Pydantic Raises:</strong> Pydantic’s validation fails and raises a <code class="language-plaintext highlighter-rouge">pydantic.ValidationError</code>.</li>
  <li><strong>FastAPI Wraps:</strong> FastAPI catches the <code class="language-plaintext highlighter-rouge">pydantic.ValidationError</code> and wraps it inside its own <code class="language-plaintext highlighter-rouge">fastapi.exceptions.RequestValidationError</code> to add context.</li>
  <li><strong>Catch:</strong> FastAPI’s internal request/response cycle catches the <code class="language-plaintext highlighter-rouge">RequestValidationError</code>.</li>
  <li><strong>Find Handler:</strong> FastAPI looks for a handler for <code class="language-plaintext highlighter-rouge">RequestValidationError</code> and finds its default one.</li>
  <li><strong>Default Handler Executes:</strong> The default handler (<code class="language-plaintext highlighter-rouge">fastapi.exception_handlers.request_validation_exception_handler</code>) takes the <code class="language-plaintext highlighter-rouge">RequestValidationError</code>.</li>
  <li><strong>Extract &amp; Format Errors:</strong> It calls the <code class="language-plaintext highlighter-rouge">.errors()</code> method on the exception to get the list of validation errors provided by Pydantic. It then formats this list into the standard structure (with <code class="language-plaintext highlighter-rouge">loc</code>, <code class="language-plaintext highlighter-rouge">msg</code>, <code class="language-plaintext highlighter-rouge">type</code>).</li>
  <li><strong>Create Response:</strong> It creates a <code class="language-plaintext highlighter-rouge">JSONResponse</code> with status code <code class="language-plaintext highlighter-rouge">422</code> and the formatted error details as the content.</li>
  <li><strong>Send Response:</strong> This 422 JSON response is sent back to the client. Your <code class="language-plaintext highlighter-rouge">create_item</code> function was never even called.</li>
</ol>

<h3 id="code-connections">Code Connections</h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">fastapi.exceptions.HTTPException</code></strong>: The class you import and raise for expected client errors. Defined in <code class="language-plaintext highlighter-rouge">fastapi/exceptions.py</code>. It inherits from <code class="language-plaintext highlighter-rouge">starlette.exceptions.HTTPException</code>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">fastapi.exception_handlers.http_exception_handler</code></strong>: The default function that handles <code class="language-plaintext highlighter-rouge">HTTPException</code>. Defined in <code class="language-plaintext highlighter-rouge">fastapi/exception_handlers.py</code>. It creates a <code class="language-plaintext highlighter-rouge">JSONResponse</code>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">fastapi.exceptions.RequestValidationError</code></strong>: The exception FastAPI raises internally when Pydantic validation fails for request data. Defined in <code class="language-plaintext highlighter-rouge">fastapi/exceptions.py</code>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">fastapi.exception_handlers.request_validation_exception_handler</code></strong>: The default function that handles <code class="language-plaintext highlighter-rouge">RequestValidationError</code>. Defined in <code class="language-plaintext highlighter-rouge">fastapi/exception_handlers.py</code>. It calls <code class="language-plaintext highlighter-rouge">jsonable_encoder(exc.errors())</code> and creates a 422 <code class="language-plaintext highlighter-rouge">JSONResponse</code>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">@app.exception_handler(ExceptionType)</code></strong>: The decorator used on the <code class="language-plaintext highlighter-rouge">FastAPI</code> app instance to register your own custom handler functions. The <code class="language-plaintext highlighter-rouge">exception_handler</code> method is part of the <code class="language-plaintext highlighter-rouge">FastAPI</code> class in <code class="language-plaintext highlighter-rouge">fastapi/applications.py</code>.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve learned how FastAPI helps you manage errors gracefully!</p>

<ul>
  <li>You can handle <strong>expected client errors</strong> (like “not found”) by raising <strong><code class="language-plaintext highlighter-rouge">HTTPException</code></strong> with a specific <code class="language-plaintext highlighter-rouge">status_code</code> and <code class="language-plaintext highlighter-rouge">detail</code> message.</li>
  <li>FastAPI <strong>automatically handles validation errors</strong> (<code class="language-plaintext highlighter-rouge">RequestValidationError</code>) when incoming data doesn’t match your Pydantic models or type hints, returning detailed <code class="language-plaintext highlighter-rouge">422</code> responses.</li>
  <li>You can define <strong>custom exception handlers</strong> for fine-grained control over error responses and logging using <code class="language-plaintext highlighter-rouge">@app.exception_handler()</code>.</li>
</ul>

<p>Using these tools makes your API more robust, predictable, and easier for clients to interact with, even when things go wrong. Clear error messages are a crucial part of a good API design.</p>

<p>Now that we know how to handle errors, let’s think about another critical aspect: security. How do we protect our endpoints, ensuring only authorized users can access certain data or perform specific actions?</p>

<p>Ready to secure your API? Let’s move on to <a href="07_security_utilities.md">Chapter 7: Security Utilities</a>!</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
