<h1 id="chapter-2-path-operations--parameter-declaration">Chapter 2: Path Operations &amp; Parameter Declaration</h1>

<p>Welcome back! In <a href="01_fastapi_application___routing.md">Chapter 1: FastAPI Application &amp; Routing</a>, we learned how to set up a basic FastAPI application and organize our code using <code class="language-plaintext highlighter-rouge">APIRouter</code>. We saw how to connect a URL like <code class="language-plaintext highlighter-rouge">/</code> to a Python function using <code class="language-plaintext highlighter-rouge">@app.get("/")</code>.</p>

<p>But what if we need more information from the user? Imagine you’re building an API for an online store. You don’t just want a single “hello” page; you want users to be able to:</p>

<ol>
  <li>Get information about a <em>specific</em> item, like <code class="language-plaintext highlighter-rouge">/items/5</code> (where 5 is the item ID).</li>
  <li>Search or filter items, like <code class="language-plaintext highlighter-rouge">/items/?query=socks</code> (search for “socks”).</li>
  <li>Add a <em>new</em> item by sending its details (name, price, etc.).</li>
</ol>

<p>How do we tell FastAPI to expect this extra information (like the item ID <code class="language-plaintext highlighter-rouge">5</code>, the search query <code class="language-plaintext highlighter-rouge">"socks"</code>, or the new item’s details) and make it available inside our Python function?</p>

<p>That’s exactly what <strong>Path Operations</strong> and <strong>Parameter Declaration</strong> are for!</p>

<p><strong>Our Goal Today:</strong> Learn how FastAPI uses function parameters and type hints to automatically handle data coming from different parts of the web request (URL path, query string, request body) and even validate it!</p>

<h2 id="what-problem-does-this-solve">What Problem Does This Solve?</h2>

<p>Think of your API endpoint (like <code class="language-plaintext highlighter-rouge">/items/</code>) as a specific room in a building. To get into the room or ask for something specific within it, you often need to provide information:</p>

<ul>
  <li>Maybe the room number is part of the address (<code class="language-plaintext highlighter-rouge">/items/10</code> - room number 10). This is like a <strong>Path Parameter</strong>.</li>
  <li>Maybe you need to fill out a small form asking optional questions (“Any specific colour?”, “Sort by price?”). This is like <strong>Query Parameters</strong>.</li>
  <li>Maybe you need to hand over a detailed document with instructions or data (like the specs for a new item). This is like the <strong>Request Body</strong>.</li>
</ul>

<p>FastAPI needs a way to understand these different types of information, extract them from the incoming request, check if they are the correct type (e.g., is the item ID <em>really</em> a number?), and give them to your Python function in a clean, easy-to-use way. It does this magic using standard Python type hints and special functions we’ll learn about.</p>

<h2 id="path-operations-more-than-just-get">Path Operations: More Than Just GET</h2>

<p>In Chapter 1, we used <code class="language-plaintext highlighter-rouge">@app.get("/")</code>. The <code class="language-plaintext highlighter-rouge">get</code> part refers to the HTTP <strong>method</strong>. Browsers use <code class="language-plaintext highlighter-rouge">GET</code> when you simply visit a URL. But there are other common methods for different actions:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">GET</code>: Retrieve data.</li>
  <li><code class="language-plaintext highlighter-rouge">POST</code>: Create new data.</li>
  <li><code class="language-plaintext highlighter-rouge">PUT</code>: Update existing data completely.</li>
  <li><code class="language-plaintext highlighter-rouge">PATCH</code>: Partially update existing data.</li>
  <li><code class="language-plaintext highlighter-rouge">DELETE</code>: Remove data.</li>
</ul>

<p>FastAPI provides decorators for all these: <code class="language-plaintext highlighter-rouge">@app.post()</code>, <code class="language-plaintext highlighter-rouge">@app.put()</code>, <code class="language-plaintext highlighter-rouge">@app.patch()</code>, <code class="language-plaintext highlighter-rouge">@app.delete()</code>. You use them just like <code class="language-plaintext highlighter-rouge">@app.get()</code> to link a path and an HTTP method to your function.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># main.py (continuing from Chapter 1, maybe add this to routers/items.py)
</span><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span>

<span class="c1"># A GET operation (read)
</span><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"/items/"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">read_items</span><span class="p">():</span>
    <span class="k">return</span> <span class="p">[{</span><span class="s">"item_id"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s">"name"</span><span class="p">:</span> <span class="s">"Thingamajig"</span><span class="p">}]</span>

<span class="c1"># A POST operation (create)
</span><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="s">"/items/"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">create_item</span><span class="p">():</span>
    <span class="c1"># We'll see how to get data *into* here later
</span>    <span class="k">return</span> <span class="p">{</span><span class="s">"message"</span><span class="p">:</span> <span class="s">"Item received!"</span><span class="p">}</span> <span class="c1"># Placeholder
</span>
<span class="c1"># We'll focus on GET for now, but others work similarly!
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li>We define different functions for different <em>actions</em> on the same path (<code class="language-plaintext highlighter-rouge">/items/</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">@app.get("/items/")</code> handles requests to <em>get</em> the list of items.</li>
  <li><code class="language-plaintext highlighter-rouge">@app.post("/items/")</code> handles requests to <em>create</em> a new item. FastAPI knows which function to call based on the HTTP method used in the request.</li>
</ul>

<h2 id="path-parameters-getting-data-from-the-url-path">Path Parameters: Getting Data from the URL Path</h2>

<p>Let’s say you want an endpoint to get a <em>single</em> item by its ID. The URL might look like <code class="language-plaintext highlighter-rouge">http://127.0.0.1:8000/items/5</code>. Here, <code class="language-plaintext highlighter-rouge">5</code> is the ID we want to capture.</p>

<p>You define this in FastAPI by putting the variable name in curly braces <code class="language-plaintext highlighter-rouge">{}</code> within the path string:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># main.py or routers/items.py
</span><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span> <span class="c1"># Or use your APIRouter
</span>
<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"/items/{item_id}"</span><span class="p">)</span>  <span class="c1"># Path parameter defined here
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">read_item</span><span class="p">(</span><span class="n">item_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span> <span class="c1"># Parameter name MUST match! Type hint is key!
</span>    <span class="c1"># FastAPI automatically converts the 'item_id' from the path (which is a string)
</span>    <span class="c1"># into an integer because of the 'int' type hint.
</span>    <span class="c1"># It also validates if it *can* be converted to an int.
</span>    <span class="k">return</span> <span class="p">{</span><span class="s">"item_id"</span><span class="p">:</span> <span class="n">item_id</span><span class="p">,</span> <span class="s">"name"</span><span class="p">:</span> <span class="sa">f</span><span class="s">"Item </span><span class="si">{</span><span class="n">item_id</span><span class="si">}</span><span class="s"> Name"</span><span class="p">}</span>

</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">@app.get("/items/{item_id}")</code>: The <code class="language-plaintext highlighter-rouge">{item_id}</code> part tells FastAPI: “Expect some value here in the URL path, and call it <code class="language-plaintext highlighter-rouge">item_id</code>.”</li>
  <li><code class="language-plaintext highlighter-rouge">async def read_item(item_id: int)</code>:
    <ul>
      <li>We declare a function parameter named <strong>exactly</strong> <code class="language-plaintext highlighter-rouge">item_id</code>. FastAPI connects the path variable to this function argument.</li>
      <li>We use the Python type hint <code class="language-plaintext highlighter-rouge">: int</code>. This is crucial! FastAPI uses this to:
        <ol>
          <li><strong>Convert:</strong> The value from the URL (<code class="language-plaintext highlighter-rouge">"5"</code>) is automatically converted to an integer (<code class="language-plaintext highlighter-rouge">5</code>).</li>
          <li><strong>Validate:</strong> If you visit <code class="language-plaintext highlighter-rouge">/items/foo</code>, FastAPI knows <code class="language-plaintext highlighter-rouge">"foo"</code> cannot be converted to an <code class="language-plaintext highlighter-rouge">int</code>, and it automatically returns a helpful error response <em>before</em> your function even runs!</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<p><strong>Try it:</strong></p>

<ol>
  <li>Run <code class="language-plaintext highlighter-rouge">uvicorn main:app --reload</code>.</li>
  <li>Visit <code class="language-plaintext highlighter-rouge">http://127.0.0.1:8000/items/5</code>. You should see:
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="nl">"item_id"</span><span class="p">:</span><span class="mi">5</span><span class="p">,</span><span class="nl">"name"</span><span class="p">:</span><span class="s2">"Item 5 Name"</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>Visit <code class="language-plaintext highlighter-rouge">http://127.0.0.1:8000/items/abc</code>. You should see an error like:
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"detail"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"int_parsing"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"loc"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
        </span><span class="s2">"path"</span><span class="p">,</span><span class="w">
        </span><span class="s2">"item_id"</span><span class="w">
      </span><span class="p">],</span><span class="w">
      </span><span class="nl">"msg"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Input should be a valid integer, unable to parse string as an integer"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"input"</span><span class="p">:</span><span class="w"> </span><span class="s2">"abc"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"url"</span><span class="p">:</span><span class="w"> </span><span class="s2">"..."</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
    <p>See? Automatic validation!</p>
  </li>
</ol>

<p>Path parameters are <em>required</em> parts of the path. The URL simply won’t match the route if that part is missing.</p>

<h2 id="query-parameters-optional-info-after-">Query Parameters: Optional Info After “?”</h2>

<p>What if you want to provide optional filtering or configuration in the URL? Like getting items, but maybe skipping the first 10 and limiting the results to 5: <code class="language-plaintext highlighter-rouge">http://127.0.0.1:8000/items/?skip=10&amp;limit=5</code>.</p>

<p>These <code class="language-plaintext highlighter-rouge">key=value</code> pairs after the <code class="language-plaintext highlighter-rouge">?</code> are called <strong>Query Parameters</strong>.</p>

<p>In FastAPI, you declare them as function parameters that are <em>not</em> part of the path string. You can provide default values to make them optional.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># main.py or routers/items.py
</span><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span> <span class="c1"># Or use your APIRouter
</span>
<span class="c1"># A simple fake database of items
</span><span class="n">fake_items_db</span> <span class="o">=</span> <span class="p">[{</span><span class="s">"item_name"</span><span class="p">:</span> <span class="s">"Foo"</span><span class="p">},</span> <span class="p">{</span><span class="s">"item_name"</span><span class="p">:</span> <span class="s">"Bar"</span><span class="p">},</span> <span class="p">{</span><span class="s">"item_name"</span><span class="p">:</span> <span class="s">"Baz"</span><span class="p">}]</span>

<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"/items/"</span><span class="p">)</span>
<span class="c1"># 'skip' and 'limit' are NOT in the path "/items/"
# They have default values, making them optional query parameters
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">read_items</span><span class="p">(</span><span class="n">skip</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">):</span>
    <span class="c1"># FastAPI automatically gets 'skip' and 'limit' from the query string.
</span>    <span class="c1"># If they are not provided in the URL, it uses the defaults (0 and 10).
</span>    <span class="c1"># It also converts them to integers and validates them!
</span>    <span class="k">return</span> <span class="n">fake_items_db</span><span class="p">[</span><span class="n">skip</span> <span class="p">:</span> <span class="n">skip</span> <span class="o">+</span> <span class="n">limit</span><span class="p">]</span>

</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">async def read_items(skip: int = 0, limit: int = 10)</code>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">skip</code> and <code class="language-plaintext highlighter-rouge">limit</code> are <em>not</em> mentioned in <code class="language-plaintext highlighter-rouge">@app.get("/items/")</code>. FastAPI knows they must be query parameters.</li>
      <li>They have default values (<code class="language-plaintext highlighter-rouge">= 0</code>, <code class="language-plaintext highlighter-rouge">= 10</code>). This makes them optional. If the user doesn’t provide them in the URL, these defaults are used.</li>
      <li>The type hints <code class="language-plaintext highlighter-rouge">: int</code> ensure automatic conversion and validation, just like with path parameters.</li>
    </ul>
  </li>
</ul>

<p><strong>Try it:</strong></p>

<ol>
  <li>Make sure <code class="language-plaintext highlighter-rouge">uvicorn</code> is running.</li>
  <li>Visit <code class="language-plaintext highlighter-rouge">http://127.0.0.1:8000/items/</code>. Result (uses defaults <code class="language-plaintext highlighter-rouge">skip=0</code>, <code class="language-plaintext highlighter-rouge">limit=10</code>):
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="nl">"item_name"</span><span class="p">:</span><span class="s2">"Foo"</span><span class="p">},{</span><span class="nl">"item_name"</span><span class="p">:</span><span class="s2">"Bar"</span><span class="p">},{</span><span class="nl">"item_name"</span><span class="p">:</span><span class="s2">"Baz"</span><span class="p">}]</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>Visit <code class="language-plaintext highlighter-rouge">http://127.0.0.1:8000/items/?skip=1&amp;limit=1</code>. Result:
    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[{</span><span class="nl">"item_name"</span><span class="p">:</span><span class="s2">"Bar"</span><span class="p">}]</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>Visit <code class="language-plaintext highlighter-rouge">http://127.0.0.1:8000/items/?limit=abc</code>. Result: Automatic validation error because <code class="language-plaintext highlighter-rouge">abc</code> is not an integer.</li>
</ol>

<p>You can also declare query parameters without default values. In that case, they become <em>required</em> query parameters.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Example: Required query parameter 'query_str'
</span><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"/search/"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">search_items</span><span class="p">(</span><span class="n">query_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span> <span class="c1"># No default value means it's required
</span>    <span class="k">return</span> <span class="p">{</span><span class="s">"search_query"</span><span class="p">:</span> <span class="n">query_str</span><span class="p">}</span>

<span class="c1"># Visiting /search/ will cause an error
# Visiting /search/?query_str=hello will work
</span></code></pre></div></div>

<p>You can also use other types like <code class="language-plaintext highlighter-rouge">bool</code> or <code class="language-plaintext highlighter-rouge">float</code>, and even optional types like <code class="language-plaintext highlighter-rouge">str | None = None</code> (or <code class="language-plaintext highlighter-rouge">Optional[str] = None</code> in older Python).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"/users/{user_id}/items"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">read_user_items</span><span class="p">(</span>
    <span class="n">user_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>                 <span class="c1"># Path parameter
</span>    <span class="n">show_details</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>   <span class="c1"># Optional query parameter (e.g., ?show_details=true)
</span>    <span class="n">category</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># Optional query parameter (e.g., ?category=books)
</span><span class="p">):</span>
    <span class="c1"># ... function logic ...
</span>    <span class="k">return</span> <span class="p">{</span><span class="s">"user_id"</span><span class="p">:</span> <span class="n">user_id</span><span class="p">,</span> <span class="s">"show_details"</span><span class="p">:</span> <span class="n">show_details</span><span class="p">,</span> <span class="s">"category"</span><span class="p">:</span> <span class="n">category</span><span class="p">}</span>
</code></pre></div></div>

<h2 id="request-body-sending-complex-data">Request Body: Sending Complex Data</h2>

<p>Sometimes, the data you need to send is too complex for the URL path or query string (like the name, description, price, tax, and tags for a new item). For <code class="language-plaintext highlighter-rouge">POST</code>, <code class="language-plaintext highlighter-rouge">PUT</code>, and <code class="language-plaintext highlighter-rouge">PATCH</code> requests, data is usually sent in the <strong>Request Body</strong>, often as JSON.</p>

<p>FastAPI uses <strong>Pydantic models</strong> to define the structure of the data you expect in the request body. We’ll dive deep into Pydantic in <a href="03_data_validation___serialization__pydantic_.md">Chapter 3: Data Validation &amp; Serialization (Pydantic)</a>, but here’s a sneak peek:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># main.py or a new models.py file
</span><span class="kn">from</span> <span class="nn">pydantic</span> <span class="kn">import</span> <span class="n">BaseModel</span>

<span class="c1"># Define the structure of an Item using Pydantic
</span><span class="k">class</span> <span class="nc">Item</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># Optional field
</span>    <span class="n">price</span><span class="p">:</span> <span class="nb">float</span>
    <span class="n">tax</span><span class="p">:</span> <span class="nb">float</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>       <span class="c1"># Optional field
</span>
<span class="c1"># Now use it in a path operation
# main.py or routers/items.py
</span><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span>
<span class="c1"># Assume Item is defined as above (maybe import it)
</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span> <span class="c1"># Or use your APIRouter
</span>
<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="s">"/items/"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">create_item</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Item</span><span class="p">):</span> <span class="c1"># Declare the body parameter using the Pydantic model
</span>    <span class="c1"># FastAPI automatically:
</span>    <span class="c1"># 1. Reads the request body.
</span>    <span class="c1"># 2. Parses the JSON data.
</span>    <span class="c1"># 3. Validates the data against the 'Item' model (Are 'name' and 'price' present? Are types correct?).
</span>    <span class="c1"># 4. If valid, provides the data as the 'item' argument (an instance of the Item class).
</span>    <span class="c1"># 5. If invalid, returns an automatic validation error.
</span>    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Received item: </span><span class="si">{</span><span class="n">item</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">, Price: </span><span class="si">{</span><span class="n">item</span><span class="p">.</span><span class="n">price</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="n">item_dict</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">model_dump</span><span class="p">()</span> <span class="c1"># Convert Pydantic model back to dict if needed
</span>    <span class="k">if</span> <span class="n">item</span><span class="p">.</span><span class="n">tax</span><span class="p">:</span>
        <span class="n">price_with_tax</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">price</span> <span class="o">+</span> <span class="n">item</span><span class="p">.</span><span class="n">tax</span>
        <span class="n">item_dict</span><span class="p">[</span><span class="s">"price_with_tax"</span><span class="p">]</span> <span class="o">=</span> <span class="n">price_with_tax</span>
    <span class="k">return</span> <span class="n">item_dict</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">class Item(BaseModel): ...</code>: We define a class <code class="language-plaintext highlighter-rouge">Item</code> that inherits from Pydantic’s <code class="language-plaintext highlighter-rouge">BaseModel</code>. We declare the expected fields (<code class="language-plaintext highlighter-rouge">name</code>, <code class="language-plaintext highlighter-rouge">description</code>, <code class="language-plaintext highlighter-rouge">price</code>, <code class="language-plaintext highlighter-rouge">tax</code>) and their types.</li>
  <li><code class="language-plaintext highlighter-rouge">async def create_item(item: Item)</code>: We declare a <em>single</em> parameter <code class="language-plaintext highlighter-rouge">item</code> with the type hint <code class="language-plaintext highlighter-rouge">Item</code>. Because <code class="language-plaintext highlighter-rouge">Item</code> is a Pydantic model, FastAPI knows it should expect this data in the <strong>request body</strong> as JSON.</li>
  <li>FastAPI handles all the parsing and validation. If the incoming JSON doesn’t match the <code class="language-plaintext highlighter-rouge">Item</code> structure, the client gets an error. If it matches, your function receives a ready-to-use <code class="language-plaintext highlighter-rouge">item</code> object.</li>
</ul>

<p>You typically use request bodies for <code class="language-plaintext highlighter-rouge">POST</code>, <code class="language-plaintext highlighter-rouge">PUT</code>, and <code class="language-plaintext highlighter-rouge">PATCH</code> requests. You can only declare <em>one</em> body parameter per function (though that body can contain nested structures, as defined by your Pydantic model).</p>

<h2 id="fine-tuning-parameters-with-path-query-body-etc">Fine-tuning Parameters with <code class="language-plaintext highlighter-rouge">Path</code>, <code class="language-plaintext highlighter-rouge">Query</code>, <code class="language-plaintext highlighter-rouge">Body</code>, etc.</h2>

<p>Type hints are great for basic validation (like <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">str</code>, <code class="language-plaintext highlighter-rouge">bool</code>). But what if you need more specific rules?</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">item_id</code> must be greater than 0.</li>
  <li>A query parameter <code class="language-plaintext highlighter-rouge">q</code> should have a maximum length of 50 characters.</li>
  <li>A <code class="language-plaintext highlighter-rouge">description</code> in the request body should have a minimum length.</li>
</ul>

<p>FastAPI provides functions like <code class="language-plaintext highlighter-rouge">Path</code>, <code class="language-plaintext highlighter-rouge">Query</code>, <code class="language-plaintext highlighter-rouge">Body</code>, <code class="language-plaintext highlighter-rouge">Header</code>, <code class="language-plaintext highlighter-rouge">Cookie</code>, and <code class="language-plaintext highlighter-rouge">File</code> (imported directly from <code class="language-plaintext highlighter-rouge">fastapi</code>) that you can use alongside type hints (using <code class="language-plaintext highlighter-rouge">typing.Annotated</code>) to add these extra validation rules and metadata.</p>

<p>Let’s enhance our previous examples:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># main.py or routers/items.py
</span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Annotated</span> <span class="c1"># Use Annotated for extra metadata
</span><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">FastAPI</span><span class="p">,</span> <span class="n">Path</span><span class="p">,</span> <span class="n">Query</span>
<span class="c1"># Assume Item Pydantic model is defined/imported
</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">FastAPI</span><span class="p">()</span> <span class="c1"># Or use your APIRouter
</span>
<span class="c1"># Fake DB
</span><span class="n">fake_items_db</span> <span class="o">=</span> <span class="p">[{</span><span class="s">"item_name"</span><span class="p">:</span> <span class="s">"Foo"</span><span class="p">},</span> <span class="p">{</span><span class="s">"item_name"</span><span class="p">:</span> <span class="s">"Bar"</span><span class="p">},</span> <span class="p">{</span><span class="s">"item_name"</span><span class="p">:</span> <span class="s">"Baz"</span><span class="p">}]</span>

<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"/items/{item_id}"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">read_item</span><span class="p">(</span>
    <span class="c1"># Use Annotated[type, Path(...)] for path parameters
</span>    <span class="n">item_id</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Path</span><span class="p">(</span>
        <span class="n">title</span><span class="o">=</span><span class="s">"The ID of the item to get"</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s">"The item ID must be a positive integer."</span><span class="p">,</span>
        <span class="n">gt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="c1"># gt = Greater Than 0
</span>        <span class="n">le</span><span class="o">=</span><span class="mi">1000</span> <span class="c1"># le = Less Than or Equal to 1000
</span>    <span class="p">)]</span>
<span class="p">):</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">"item_id"</span><span class="p">:</span> <span class="n">item_id</span><span class="p">,</span> <span class="s">"name"</span><span class="p">:</span> <span class="sa">f</span><span class="s">"Item </span><span class="si">{</span><span class="n">item_id</span><span class="si">}</span><span class="s"> Name"</span><span class="p">}</span>


<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"/items/"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">read_items</span><span class="p">(</span>
    <span class="c1"># Use Annotated[type | None, Query(...)] for optional query parameters
</span>    <span class="n">q</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span><span class="p">,</span> <span class="n">Query</span><span class="p">(</span>
        <span class="n">title</span><span class="o">=</span><span class="s">"Query string"</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="s">"Optional query string to search items."</span><span class="p">,</span>
        <span class="n">min_length</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
        <span class="n">max_length</span><span class="o">=</span><span class="mi">50</span>
    <span class="p">)]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="c1"># Default value still makes it optional
</span>    <span class="n">skip</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Query</span><span class="p">(</span><span class="n">ge</span><span class="o">=</span><span class="mi">0</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="c1"># ge = Greater Than or Equal to 0
</span>    <span class="n">limit</span><span class="p">:</span> <span class="n">Annotated</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Query</span><span class="p">(</span><span class="n">gt</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">le</span><span class="o">=</span><span class="mi">100</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">10</span>
<span class="p">):</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">fake_items_db</span><span class="p">[</span><span class="n">skip</span> <span class="p">:</span> <span class="n">skip</span> <span class="o">+</span> <span class="n">limit</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">q</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">results</span> <span class="k">if</span> <span class="n">q</span><span class="p">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="n">item</span><span class="p">[</span><span class="s">"item_name"</span><span class="p">].</span><span class="n">lower</span><span class="p">()]</span>
    <span class="k">return</span> <span class="n">results</span>

<span class="c1"># Using Body works similarly, often used inside Pydantic models (Chapter 3)
# or if you need to embed a single body parameter
</span><span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="s">"/items/"</span><span class="p">)</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">create_item</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="n">Item</span><span class="p">):</span> <span class="c1"># Pydantic model handles body structure
</span>    <span class="c1"># Validation for item fields is defined within the Item model itself (See Chapter 3)
</span>    <span class="c1"># For simple body params without Pydantic, you might use:
</span>    <span class="c1"># importance: Annotated[int, Body(gt=0)]
</span>    <span class="k">return</span> <span class="n">item</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Annotated</code></strong>: This is the standard Python way (Python 3.9+) to add extra context to type hints. FastAPI uses this to associate <code class="language-plaintext highlighter-rouge">Path</code>, <code class="language-plaintext highlighter-rouge">Query</code>, etc., with your parameters.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Path(...)</code></strong>: Used for path parameters.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">title</code>, <code class="language-plaintext highlighter-rouge">description</code>: Add metadata that will appear in the automatic documentation (see <a href="04_openapi___automatic_docs.md">Chapter 4</a>).</li>
      <li><code class="language-plaintext highlighter-rouge">gt</code>, <code class="language-plaintext highlighter-rouge">ge</code>, <code class="language-plaintext highlighter-rouge">lt</code>, <code class="language-plaintext highlighter-rouge">le</code>: Numeric validation (greater than, greater than or equal, less than, less than or equal).</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">Query(...)</code></strong>: Used for query parameters.
    <ul>
      <li>Takes similar arguments to <code class="language-plaintext highlighter-rouge">Path</code> for metadata and numeric validation.</li>
      <li><code class="language-plaintext highlighter-rouge">min_length</code>, <code class="language-plaintext highlighter-rouge">max_length</code>: String length validation.</li>
      <li>The default value (<code class="language-plaintext highlighter-rouge">= None</code>, <code class="language-plaintext highlighter-rouge">= 0</code>, <code class="language-plaintext highlighter-rouge">= 10</code>) still determines if the parameter is optional or required.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">Body(...)</code></strong>: Used for request body parameters (often implicitly handled by Pydantic models). Can add metadata or validation similar to <code class="language-plaintext highlighter-rouge">Query</code>.</li>
  <li><strong>Others</strong>: <code class="language-plaintext highlighter-rouge">Header()</code>, <code class="language-plaintext highlighter-rouge">Cookie()</code>, <code class="language-plaintext highlighter-rouge">File()</code> work similarly for data from request headers, cookies, or uploaded files.</li>
</ul>

<p>Using <code class="language-plaintext highlighter-rouge">Path</code>, <code class="language-plaintext highlighter-rouge">Query</code>, etc., gives you fine-grained control over data validation and adds useful information to your API documentation automatically.</p>

<h2 id="how-it-works-under-the-hood-simplified">How it Works Under the Hood (Simplified)</h2>

<p>How does FastAPI magically connect URL parts and request data to your function arguments and validate them?</p>

<ol>
  <li><strong>App Startup:</strong> When you run your app, FastAPI (using Starlette’s routing) inspects all the functions decorated with <code class="language-plaintext highlighter-rouge">@app.get</code>, <code class="language-plaintext highlighter-rouge">@app.post</code>, etc.</li>
  <li><strong>Function Signature Inspection:</strong> For each function, FastAPI looks at its parameters (<code class="language-plaintext highlighter-rouge">item_id</code>, <code class="language-plaintext highlighter-rouge">skip</code>, <code class="language-plaintext highlighter-rouge">limit</code>, <code class="language-plaintext highlighter-rouge">item</code>, <code class="language-plaintext highlighter-rouge">q</code>).</li>
  <li><strong>Parameter Type Analysis:</strong> It checks the type hints (<code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">str</code>, <code class="language-plaintext highlighter-rouge">bool</code>, <code class="language-plaintext highlighter-rouge">Item</code>, <code class="language-plaintext highlighter-rouge">Annotated[...]</code>).</li>
  <li><strong>Location Determination:</strong>
    <ul>
      <li>If a parameter name matches a variable in the path string (<code class="language-plaintext highlighter-rouge">{item_id}</code>), it’s a <strong>Path Parameter</strong>.</li>
      <li>If a parameter has a type hint that’s a Pydantic model (<code class="language-plaintext highlighter-rouge">item: Item</code>), it’s a <strong>Body Parameter</strong>.</li>
      <li>Otherwise, it’s a <strong>Query Parameter</strong> (<code class="language-plaintext highlighter-rouge">skip</code>, <code class="language-plaintext highlighter-rouge">limit</code>, <code class="language-plaintext highlighter-rouge">q</code>).</li>
      <li>If <code class="language-plaintext highlighter-rouge">Annotated</code> is used with <code class="language-plaintext highlighter-rouge">Path</code>, <code class="language-plaintext highlighter-rouge">Query</code>, <code class="language-plaintext highlighter-rouge">Body</code>, <code class="language-plaintext highlighter-rouge">Header</code>, <code class="language-plaintext highlighter-rouge">Cookie</code>, or <code class="language-plaintext highlighter-rouge">File</code>, that explicitly defines the location and adds extra validation rules.</li>
    </ul>
  </li>
  <li><strong>Request Arrives:</strong> A request comes in (e.g., <code class="language-plaintext highlighter-rouge">GET /items/5?q=search</code>).</li>
  <li><strong>Routing:</strong> Uvicorn passes the request to FastAPI. FastAPI/Starlette matches the path (<code class="language-plaintext highlighter-rouge">/items/5</code>) and method (<code class="language-plaintext highlighter-rouge">GET</code>) to the <code class="language-plaintext highlighter-rouge">read_item</code> function (or <code class="language-plaintext highlighter-rouge">read_items</code> if the path was <code class="language-plaintext highlighter-rouge">/items/</code>). Let’s assume it matches <code class="language-plaintext highlighter-rouge">read_item</code> for <code class="language-plaintext highlighter-rouge">/items/{item_id}</code>.</li>
  <li><strong>Data Extraction:</strong> FastAPI extracts data from the request based on the parameter definitions found in step 4:
    <ul>
      <li>Path: Extracts <code class="language-plaintext highlighter-rouge">"5"</code> for <code class="language-plaintext highlighter-rouge">item_id</code>.</li>
      <li>Query: Extracts <code class="language-plaintext highlighter-rouge">"search"</code> for <code class="language-plaintext highlighter-rouge">q</code> (if the route was <code class="language-plaintext highlighter-rouge">/items/</code> and the function <code class="language-plaintext highlighter-rouge">read_items</code>).</li>
      <li>Body: Reads and parses JSON (if it was a POST/PUT request with a body parameter).</li>
    </ul>
  </li>
  <li><strong>Validation &amp; Conversion:</strong> FastAPI uses the type hints and any extra rules from <code class="language-plaintext highlighter-rouge">Path</code>, <code class="language-plaintext highlighter-rouge">Query</code>, <code class="language-plaintext highlighter-rouge">Body</code> (often leveraging Pydantic internally):
    <ul>
      <li>Converts <code class="language-plaintext highlighter-rouge">"5"</code> to the integer <code class="language-plaintext highlighter-rouge">5</code> for <code class="language-plaintext highlighter-rouge">item_id</code>. Checks <code class="language-plaintext highlighter-rouge">gt=0</code>.</li>
      <li>Converts <code class="language-plaintext highlighter-rouge">"search"</code> to a string for <code class="language-plaintext highlighter-rouge">q</code>. Checks <code class="language-plaintext highlighter-rouge">max_length</code>.</li>
      <li>Validates the JSON body against the <code class="language-plaintext highlighter-rouge">Item</code> model.</li>
    </ul>
  </li>
  <li><strong>Error Handling:</strong> If any validation or conversion fails, FastAPI <em>immediately</em> stops and sends back a 422 “Unprocessable Entity” error response with details about what went wrong. Your function is <em>not</em> called.</li>
  <li><strong>Function Call:</strong> If everything is valid, FastAPI calls your function (<code class="language-plaintext highlighter-rouge">read_item</code> or <code class="language-plaintext highlighter-rouge">read_items</code>) with the extracted, converted, and validated data as arguments (<code class="language-plaintext highlighter-rouge">read_item(item_id=5)</code> or <code class="language-plaintext highlighter-rouge">read_items(q="search", skip=0, limit=10)</code>).</li>
  <li><strong>Response:</strong> Your function runs and returns a result. FastAPI processes the result into an HTTP response.</li>
</ol>

<p>Here’s a simplified diagram for a <code class="language-plaintext highlighter-rouge">GET /items/5?limit=10</code> request:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Client
    participant ASGI Server (Uvicorn)
    participant FastAPI App
    participant Param Processor
    participant Route Handler (read_item)

    Client-&gt;&gt;+ASGI Server (Uvicorn): GET /items/5?limit=10
    ASGI Server (Uvicorn)-&gt;&gt;+FastAPI App: Pass Request (method='GET', path='/items/5', query='limit=10')
    FastAPI App-&gt;&gt;FastAPI App: Match route for GET /items/{item_id}
    FastAPI App-&gt;&gt;+Param Processor: Process params for read_item(item_id: Annotated[int, Path(gt=0)], limit: Annotated[int, Query(gt=0)]=10)
    Param Processor-&gt;&gt;Param Processor: Extract '5' from path for item_id
    Param Processor-&gt;&gt;Param Processor: Extract '10' from query for limit
    Param Processor-&gt;&gt;Param Processor: Validate/Convert: item_id = 5 (int, &gt;0) -&gt; OK
    Param Processor-&gt;&gt;Param Processor: Validate/Convert: limit = 10 (int, &gt;0) -&gt; OK
    Param Processor--&gt;&gt;-FastAPI App: Validated Params: {item_id: 5, limit: 10}
    FastAPI App-&gt;&gt;+Route Handler (read_item): Call read_item(item_id=5, limit=10)
    Route Handler (read_item)--&gt;&gt;-FastAPI App: Return {"item_id": 5, ...}
    FastAPI App-&gt;&gt;FastAPI App: Convert result to JSON Response
    FastAPI App--&gt;&gt;-ASGI Server (Uvicorn): Send HTTP Response
    ASGI Server (Uvicorn)--&gt;&gt;-Client: HTTP 200 OK Response
</code></pre>

<p>FastAPI cleverly uses Python’s type hinting system, Pydantic, and Starlette’s request handling to automate the tedious tasks of parsing, validation, and documentation.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve now learned the core mechanics of defining API endpoints (Path Operations) and extracting data from requests in FastAPI!</p>

<ul>
  <li>You know how to use decorators like <code class="language-plaintext highlighter-rouge">@app.get</code>, <code class="language-plaintext highlighter-rouge">@app.post</code> for different HTTP methods.</li>
  <li>You can define <strong>Path Parameters</strong> using <code class="language-plaintext highlighter-rouge">{}</code> in the path string and matching function arguments with type hints (<code class="language-plaintext highlighter-rouge">item_id: int</code>).</li>
  <li>You can define <strong>Query Parameters</strong> using function arguments <em>not</em> in the path, making them optional with default values (<code class="language-plaintext highlighter-rouge">skip: int = 0</code>).</li>
  <li>You understand the basics of receiving JSON <strong>Request Bodies</strong> using Pydantic models (<code class="language-plaintext highlighter-rouge">item: Item</code>).</li>
  <li>You saw how to add extra validation and metadata using <code class="language-plaintext highlighter-rouge">Annotated</code> with <code class="language-plaintext highlighter-rouge">Path()</code>, <code class="language-plaintext highlighter-rouge">Query()</code>, and <code class="language-plaintext highlighter-rouge">Body()</code>.</li>
  <li>You got a glimpse of how FastAPI uses type hints and these tools to automatically parse, validate, and document your API parameters.</li>
</ul>

<p>This powerful parameter declaration system is a cornerstone of FastAPI’s ease of use and robustness. In the next chapter, we’ll explore Pydantic models in much more detail, unlocking even more powerful data validation and serialization capabilities for your request bodies and responses.</p>

<p>Ready to master data shapes? Let’s move on to <a href="03_data_validation___serialization__pydantic_.md">Chapter 3: Data Validation &amp; Serialization (Pydantic)</a>!</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
