<h1 id="chapter-9-demo-ui-application--service">Chapter 9: Demo UI Application &amp; Service</h1>

<p>In the <a href="08_multi_agent_orchestration__host_agent_.md">previous chapter</a>, we explored how a <strong>Host Agent</strong> can act like a project manager, coordinating multiple specialized agents using the A2A protocol to achieve complex goals. We’ve learned about Agent Cards, Tasks, the protocol itself, servers, clients, task logic, streaming, and orchestration. That’s a lot of building blocks!</p>

<p>But how do we see all these pieces working together in a real, interactive way? Just reading about protocols and servers is like reading the blueprints for a car. Wouldn’t it be more helpful to actually <em>see</em> the car drive?</p>

<p>That’s where the <strong>Demo UI Application &amp; Service</strong> comes in. It solves the problem: <strong>How can we visualize and interact with the A2A protocol and multi-agent systems in action?</strong></p>

<h2 id="what-is-the-demo-ui-application--service-the-control-room">What is the Demo UI Application &amp; Service? The Control Room</h2>

<p>Imagine a space mission control room. You have:</p>

<ul>
  <li><strong>Big Screens (UI):</strong> Showing the rocket’s status, communication logs, astronaut locations, etc.</li>
  <li><strong>Flight Controllers (Backend Service):</strong> People at consoles managing specific parts of the mission, talking to different teams, and updating the screens.</li>
  <li><strong>Astronauts &amp; Ground Crew (A2A Agents):</strong> The actual experts doing the work (flying, repairing, analyzing), communicating back via radio (A2A protocol).</li>
</ul>

<p>The <strong>Demo UI Application &amp; Service</strong> is like that control room for our A2A agents:</p>

<ol>
  <li><strong>Demo UI Application:</strong> This is the web-based frontend, built using a Python framework called <a href="https://github.com/mesop-dev/mesop">Mesop</a>. It provides the “big screens” – a chat interface where you can talk to agents, see their responses (including special content like forms or images), view lists of available agents, and inspect the communication flow.</li>
  <li><strong>Backend Service (<code class="language-plaintext highlighter-rouge">ConversationServer</code>):</strong> This is the “flight controller” software running behind the scenes. It’s a backend web service (built using FastAPI in Python) that the UI application talks to. It’s <em>not</em> the main <a href="08_multi_agent_orchestration__host_agent_.md">Host Agent</a> itself, but rather an <strong>intermediary</strong>. It manages the user’s conversations, receives events from the UI (like sending a message), communicates with the actual agent logic (like the Host Agent), and sends state updates back to the UI so the screens stay current.</li>
</ol>

<p>Think of it as a user-friendly window into the world of A2A, letting you watch and participate as agents collaborate.</p>

<h2 id="key-components">Key Components</h2>

<p>Let’s break down the two main parts:</p>

<h3 id="1-frontend-mesop-ui-application">1. Frontend (Mesop UI Application)</h3>

<p>This is what you see and interact with in your web browser. Mesop allows building UIs purely in Python. Key features include:</p>

<ul>
  <li><strong>Chat Interface:</strong> Displays the conversation history between you and the agent system. (<code class="language-plaintext highlighter-rouge">demo/ui/components/conversation.py</code>)</li>
  <li><strong>Input Box:</strong> Where you type your messages to the agent. (<code class="language-plaintext highlighter-rouge">demo/ui/components/conversation.py</code>)</li>
  <li><strong>Agent Management:</strong> Allows adding new agents by providing their <a href="01_agent_card.md">Agent Card</a> URL. (<code class="language-plaintext highlighter-rouge">demo/ui/pages/agent_list.py</code>)</li>
  <li><strong>Rich Content Rendering:</strong> Can display not just text, but also interactive forms sent by agents (<code class="language-plaintext highlighter-rouge">demo/ui/components/form_render.py</code>), images, etc.</li>
  <li><strong>Task/Event Views:</strong> Provides ways to inspect the underlying <a href="02_task.md">Tasks</a> and communication events happening via A2A. (<code class="language-plaintext highlighter-rouge">demo/ui/pages/task_list.py</code>, <code class="language-plaintext highlighter-rouge">demo/ui/pages/event_list.py</code>)</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File: demo/ui/components/conversation.py (Simplified Snippet)
# ... imports ...
</span>
<span class="o">@</span><span class="n">me</span><span class="p">.</span><span class="n">component</span>
<span class="k">def</span> <span class="nf">conversation</span><span class="p">():</span>
    <span class="s">"""Conversation component"""</span>
    <span class="n">page_state</span> <span class="o">=</span> <span class="n">me</span><span class="p">.</span><span class="n">state</span><span class="p">(</span><span class="n">PageState</span><span class="p">)</span> <span class="c1"># Local page state
</span>    <span class="n">app_state</span> <span class="o">=</span> <span class="n">me</span><span class="p">.</span><span class="n">state</span><span class="p">(</span><span class="n">AppState</span><span class="p">)</span>   <span class="c1"># Global application state
</span>
    <span class="c1"># ... loop to display existing messages using chat_bubble component ...
</span>    <span class="k">for</span> <span class="n">message</span> <span class="ow">in</span> <span class="n">app_state</span><span class="p">.</span><span class="n">messages</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">is_form</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
          <span class="n">render_form</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">app_state</span><span class="p">)</span> <span class="c1"># Special handling for forms
</span>        <span class="c1"># ... other message types ...
</span>        <span class="k">else</span><span class="p">:</span>
          <span class="n">chat_bubble</span><span class="p">(</span><span class="n">message</span><span class="p">,</span> <span class="n">message</span><span class="p">.</span><span class="n">message_id</span><span class="p">)</span> <span class="c1"># Display regular chat message
</span>
    <span class="c1"># --- Input area ---
</span>    <span class="k">with</span> <span class="n">me</span><span class="p">.</span><span class="n">box</span><span class="p">(</span><span class="n">style</span><span class="o">=</span><span class="n">me</span><span class="p">.</span><span class="n">Style</span><span class="p">(</span><span class="n">display</span><span class="o">=</span><span class="s">"flex"</span><span class="p">,</span> <span class="n">flex_direction</span><span class="o">=</span><span class="s">"row"</span><span class="p">,</span> <span class="p">...)):</span>
        <span class="n">me</span><span class="p">.</span><span class="nb">input</span><span class="p">(</span>
            <span class="n">label</span><span class="o">=</span><span class="s">"How can I help you?"</span><span class="p">,</span>
            <span class="n">on_enter</span><span class="o">=</span><span class="n">send_message_enter</span><span class="p">,</span> <span class="c1"># Function to call when user presses Enter
</span>            <span class="c1"># ... other attributes ...
</span>        <span class="p">)</span>
        <span class="k">with</span> <span class="n">me</span><span class="p">.</span><span class="n">content_button</span><span class="p">(</span><span class="n">on_click</span><span class="o">=</span><span class="n">send_message_button</span><span class="p">):</span> <span class="c1"># Button handler
</span>            <span class="n">me</span><span class="p">.</span><span class="n">icon</span><span class="p">(</span><span class="n">icon</span><span class="o">=</span><span class="s">"send"</span><span class="p">)</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">send_message_enter</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">me</span><span class="p">.</span><span class="n">InputEnterEvent</span><span class="p">):</span>
    <span class="c1"># ... (get state) ...
</span>    <span class="n">message_content</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">value</span>
    <span class="n">message_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="p">.</span><span class="n">uuid4</span><span class="p">())</span>
    <span class="c1"># Store something to indicate a background task is running
</span>    <span class="n">app_state</span> <span class="o">=</span> <span class="n">me</span><span class="p">.</span><span class="n">state</span><span class="p">(</span><span class="n">AppState</span><span class="p">)</span>
    <span class="n">app_state</span><span class="p">.</span><span class="n">background_tasks</span><span class="p">[</span><span class="n">message_id</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Processing..."</span>
    <span class="k">yield</span> <span class="c1"># Update UI to show indicator
</span>    <span class="c1"># Call the backend service to actually send the message
</span>    <span class="k">await</span> <span class="n">send_message</span><span class="p">(</span><span class="n">message_content</span><span class="p">,</span> <span class="n">message_id</span><span class="p">)</span>
    <span class="k">yield</span> <span class="c1"># Allow UI to potentially update again
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li>This Mesop component defines the chat interface.</li>
  <li>It uses <code class="language-plaintext highlighter-rouge">app_state</code> (defined in <code class="language-plaintext highlighter-rouge">demo/ui/state/state.py</code>) to access the current list of messages and display them.</li>
  <li>It renders an <code class="language-plaintext highlighter-rouge">me.input</code> field. When the user presses Enter (<code class="language-plaintext highlighter-rouge">on_enter</code>), the <code class="language-plaintext highlighter-rouge">send_message_enter</code> function is called.</li>
  <li><code class="language-plaintext highlighter-rouge">send_message_enter</code> gets the user’s text, updates the state to show a “Processing…” indicator, and then calls <code class="language-plaintext highlighter-rouge">send_message</code> (defined in <code class="language-plaintext highlighter-rouge">demo/ui/state/host_agent_service.py</code>) which actually communicates with the backend <code class="language-plaintext highlighter-rouge">ConversationServer</code>.</li>
</ul>

<h3 id="2-backend-conversationserver">2. Backend (<code class="language-plaintext highlighter-rouge">ConversationServer</code>)</h3>

<p>This FastAPI server acts as the bridge between the simple HTTP/JSON communication from the UI and the potentially more complex agent interactions (which might involve A2A or frameworks like Google ADK).</p>

<ul>
  <li><strong>API Endpoints:</strong> Exposes simple HTTP endpoints (e.g., <code class="language-plaintext highlighter-rouge">/message/send</code>, <code class="language-plaintext highlighter-rouge">/conversation/list</code>) that the UI’s client can call. (<code class="language-plaintext highlighter-rouge">demo/ui/service/server/server.py</code>)</li>
  <li><strong>Conversation Management:</strong> Keeps track of different chat sessions.</li>
  <li><strong>State Management:</strong> Holds the application state (messages, tasks, agents) that the UI needs to display.</li>
  <li><strong>Agent Interaction Logic:</strong> Contains the logic to forward requests from the UI to the actual agent system (e.g., the ADK <a href="08_multi_agent_orchestration__host_agent_.md">Host Agent</a>). (<code class="language-plaintext highlighter-rouge">demo/ui/service/server/adk_host_manager.py</code>)</li>
  <li><strong>Callback Handling:</strong> Receives updates (like task status changes or new artifacts) from the agent system and updates its internal state.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File: demo/ui/service/server/server.py (Simplified Snippet)
</span><span class="kn">from</span> <span class="nn">fastapi</span> <span class="kn">import</span> <span class="n">APIRouter</span><span class="p">,</span> <span class="n">Request</span>
<span class="kn">from</span> <span class="nn">common.types</span> <span class="kn">import</span> <span class="n">Message</span>
<span class="kn">from</span> <span class="nn">.adk_host_manager</span> <span class="kn">import</span> <span class="n">ADKHostManager</span> <span class="c1"># Implements agent interaction logic
# ... other imports ...
</span>
<span class="k">class</span> <span class="nc">ConversationServer</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">router</span><span class="p">:</span> <span class="n">APIRouter</span><span class="p">):</span>
        <span class="c1"># Choose the manager (e.g., ADKHostManager uses the Host Agent)
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">manager</span> <span class="o">=</span> <span class="n">ADKHostManager</span><span class="p">()</span>

        <span class="c1"># Define API route for sending messages
</span>        <span class="n">router</span><span class="p">.</span><span class="n">add_api_route</span><span class="p">(</span>
            <span class="s">"/message/send"</span><span class="p">,</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_send_message</span><span class="p">,</span> <span class="c1"># Maps URL to the _send_message method
</span>            <span class="n">methods</span><span class="o">=</span><span class="p">[</span><span class="s">"POST"</span><span class="p">])</span>
        <span class="c1"># ... other routes (/conversation/list, /task/list, etc.) ...
</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">_send_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">:</span> <span class="n">Request</span><span class="p">):</span>
        <span class="n">message_data</span> <span class="o">=</span> <span class="k">await</span> <span class="n">request</span><span class="p">.</span><span class="n">json</span><span class="p">()</span>
        <span class="c1"># Parse the message data sent by the UI client
</span>        <span class="n">message</span> <span class="o">=</span> <span class="n">Message</span><span class="p">(</span><span class="o">**</span><span class="n">message_data</span><span class="p">[</span><span class="s">'params'</span><span class="p">])</span>
        <span class="c1"># Add necessary metadata (IDs, etc.)
</span>        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">manager</span><span class="p">.</span><span class="n">sanitize_message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="c1"># --- Crucial Part: Pass message to the agent logic ---
</span>        <span class="c1"># Run the actual agent processing in a background thread
</span>        <span class="c1"># so the API call returns quickly to the UI.
</span>        <span class="n">thread</span> <span class="o">=</span> <span class="n">threading</span><span class="p">.</span><span class="n">Thread</span><span class="p">(</span>
           <span class="n">target</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">manager</span><span class="p">.</span><span class="n">process_message</span><span class="p">(</span><span class="n">message</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">thread</span><span class="p">.</span><span class="n">start</span><span class="p">()</span>
        <span class="c1"># Return an immediate confirmation to the UI
</span>        <span class="k">return</span> <span class="n">SendMessageResponse</span><span class="p">(</span><span class="n">result</span><span class="o">=</span><span class="n">MessageInfo</span><span class="p">(</span>
            <span class="n">message_id</span><span class="o">=</span><span class="n">message</span><span class="p">.</span><span class="n">metadata</span><span class="p">[</span><span class="s">'message_id'</span><span class="p">],</span>
            <span class="c1"># ... other info ...
</span>        <span class="p">))</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">ConversationServer</code> sets up API routes using FastAPI.</li>
  <li>The <code class="language-plaintext highlighter-rouge">_send_message</code> method handles requests to the <code class="language-plaintext highlighter-rouge">/message/send</code> endpoint.</li>
  <li>It parses the <code class="language-plaintext highlighter-rouge">Message</code> sent from the UI client.</li>
  <li>It calls <code class="language-plaintext highlighter-rouge">self.manager.process_message(message)</code>. The <code class="language-plaintext highlighter-rouge">manager</code> (here, <code class="language-plaintext highlighter-rouge">ADKHostManager</code>) is responsible for actually interacting with the underlying agent system (<a href="08_multi_agent_orchestration__host_agent_.md">Host Agent</a>).</li>
  <li>Crucially, <code class="language-plaintext highlighter-rouge">process_message</code> is run in a separate thread so the API can respond quickly, acknowledging receipt, while the potentially long-running agent work happens in the background.</li>
</ul>

<h2 id="how-it-works-the-flow-of-a-message">How It Works: The Flow of a Message</h2>

<p>Let’s trace what happens when you type “Hello” and press Enter in the Demo UI:</p>

<ol>
  <li><strong>UI (Mesop):</strong> The <code class="language-plaintext highlighter-rouge">on_enter</code> event triggers <code class="language-plaintext highlighter-rouge">send_message_enter</code> in <code class="language-plaintext highlighter-rouge">conversation.py</code>.</li>
  <li><strong>UI State:</strong> <code class="language-plaintext highlighter-rouge">send_message_enter</code> updates the <code class="language-plaintext highlighter-rouge">AppState</code> to show a “Processing” indicator.</li>
  <li><strong>UI Client (<code class="language-plaintext highlighter-rouge">host_agent_service.py</code>):</strong> <code class="language-plaintext highlighter-rouge">send_message_enter</code> calls <code class="language-plaintext highlighter-rouge">SendMessage(message)</code>. This function uses the <code class="language-plaintext highlighter-rouge">ConversationClient</code> to make an HTTP POST request to the <code class="language-plaintext highlighter-rouge">ConversationServer</code>’s <code class="language-plaintext highlighter-rouge">/message/send</code> endpoint, sending the user’s message as JSON.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File: demo/ui/state/host_agent_service.py (Simplified Snippet)
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">SendMessage</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="n">Message</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span><span class="p">:</span>
  <span class="n">client</span> <span class="o">=</span> <span class="n">ConversationClient</span><span class="p">(</span><span class="n">server_url</span><span class="p">)</span> <span class="c1"># Backend server URL
</span>  <span class="k">try</span><span class="p">:</span>
    <span class="c1"># Make HTTP POST request to backend API
</span>    <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="n">client</span><span class="p">.</span><span class="n">send_message</span><span class="p">(</span><span class="n">SendMessageRequest</span><span class="p">(</span><span class="n">params</span><span class="o">=</span><span class="n">message</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">response</span><span class="p">.</span><span class="n">result</span> <span class="c1"># Contains confirmation IDs
</span>  <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Failed to send message: "</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Backend Service (<code class="language-plaintext highlighter-rouge">server.py</code>):</strong> The <code class="language-plaintext highlighter-rouge">_send_message</code> method on the <code class="language-plaintext highlighter-rouge">ConversationServer</code> receives the POST request.</li>
  <li><strong>Backend Service Logic (<code class="language-plaintext highlighter-rouge">adk_host_manager.py</code>):</strong> <code class="language-plaintext highlighter-rouge">_send_message</code> calls <code class="language-plaintext highlighter-rouge">self.manager.process_message(message)</code> (running in a background thread).
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File: demo/ui/service/server/adk_host_manager.py (Simplified Snippet)
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">process_message</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">Message</span><span class="p">):</span>
    <span class="c1"># ... (Store message, add event) ...
</span>    <span class="c1"># Get conversation context
</span>    <span class="n">conversation_id</span> <span class="o">=</span> <span class="n">message</span><span class="p">.</span><span class="n">metadata</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'conversation_id'</span><span class="p">)</span>
    <span class="c1"># --- Interact with the actual agent (e.g., Google ADK Runner) ---
</span>    <span class="k">async</span> <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">_host_runner</span><span class="p">.</span><span class="n">run_async</span><span class="p">(</span>
        <span class="n">user_id</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">user_id</span><span class="p">,</span>
        <span class="n">session_id</span><span class="o">=</span><span class="n">conversation_id</span><span class="p">,</span>
        <span class="n">new_message</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">adk_content_from_message</span><span class="p">(</span><span class="n">message</span><span class="p">)</span> <span class="c1"># Convert to agent format
</span>    <span class="p">):</span>
        <span class="c1"># Process events coming *back* from the agent
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">add_event</span><span class="p">(...)</span> <span class="c1"># Store for UI event log
</span>        <span class="c1"># ... potentially update task status via task_callback ...
</span>    <span class="c1"># ... (Store final response message) ...
</span>    <span class="c1"># Remove pending indicator
</span>    <span class="bp">self</span><span class="p">.</span><span class="n">_pending_message_ids</span><span class="p">.</span><span class="n">remove</span><span class="p">(</span><span class="n">get_message_id</span><span class="p">(</span><span class="n">message</span><span class="p">))</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Agent Processing:</strong> <code class="language-plaintext highlighter-rouge">process_message</code> uses the ADK <code class="language-plaintext highlighter-rouge">Runner</code> (<code class="language-plaintext highlighter-rouge">self._host_runner</code>) to send the message to the configured agent (our <a href="08_multi_agent_orchestration__host_agent_.md">Host Agent</a>). The Host Agent might then use its own <a href="05_a2a_client_implementation.md">A2A Client</a> logic to talk to downstream agents via A2A.</li>
  <li><strong>Agent Response/Updates:</strong> As the agent system works, it sends back events (potentially via <a href="07_streaming_communication__sse_.md">Streaming Communication (SSE)</a> if using A2A, or via ADK callbacks). The <code class="language-plaintext highlighter-rouge">ADKHostManager</code>’s <code class="language-plaintext highlighter-rouge">task_callback</code> or the <code class="language-plaintext highlighter-rouge">run_async</code> loop processes these updates, storing new messages, updating task statuses, and storing artifacts.</li>
  <li><strong>UI Polling (<code class="language-plaintext highlighter-rouge">page_scaffold.py</code>):</strong> Meanwhile, the Mesop UI periodically polls the <code class="language-plaintext highlighter-rouge">ConversationServer</code> for state updates using an <code class="language-plaintext highlighter-rouge">async_poller</code> component. This poller triggers <code class="language-plaintext highlighter-rouge">UpdateAppState</code> in <code class="language-plaintext highlighter-rouge">host_agent_service.py</code>.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File: demo/ui/components/page_scaffold.py (Simplified Snippet)
</span><span class="k">async</span> <span class="k">def</span> <span class="nf">refresh_app_state</span><span class="p">(</span><span class="n">e</span><span class="p">:</span> <span class="n">mel</span><span class="p">.</span><span class="n">WebEvent</span><span class="p">):</span> <span class="c1"># Triggered by poller
</span>    <span class="k">yield</span>
    <span class="n">app_state</span> <span class="o">=</span> <span class="n">me</span><span class="p">.</span><span class="n">state</span><span class="p">(</span><span class="n">AppState</span><span class="p">)</span>
    <span class="c1"># Call backend service to get the latest state
</span>    <span class="k">await</span> <span class="n">UpdateAppState</span><span class="p">(</span><span class="n">app_state</span><span class="p">,</span> <span class="n">app_state</span><span class="p">.</span><span class="n">current_conversation_id</span><span class="p">)</span>
    <span class="k">yield</span>
<span class="c1"># ... in page_scaffold component setup ...
</span><span class="n">async_poller</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="p">...,</span> <span class="n">trigger_event</span><span class="o">=</span><span class="n">refresh_app_state</span><span class="p">)</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Backend State Request (<code class="language-plaintext highlighter-rouge">host_agent_service.py</code>):</strong> <code class="language-plaintext highlighter-rouge">UpdateAppState</code> calls various <code class="language-plaintext highlighter-rouge">ConversationServer</code> endpoints (like <code class="language-plaintext highlighter-rouge">/conversation/list</code>, <code class="language-plaintext highlighter-rouge">/message/list</code>, <code class="language-plaintext highlighter-rouge">/task/list</code>) to get the latest messages, tasks, etc.</li>
  <li><strong>Backend Response:</strong> The <code class="language-plaintext highlighter-rouge">ConversationServer</code> returns the current state data from its <code class="language-plaintext highlighter-rouge">manager</code>.</li>
  <li><strong>UI Update:</strong> <code class="language-plaintext highlighter-rouge">UpdateAppState</code> updates the global <code class="language-plaintext highlighter-rouge">AppState</code> in Mesop with the fresh data. Because Mesop automatically re-renders when state changes, the UI updates to show the agent’s response, remove the “Processing” indicator, and update task lists.</li>
</ol>

<h2 id="under-the-hood-sequence-diagram">Under the Hood: Sequence Diagram</h2>

<p>This diagram shows the high-level flow for sending a message and getting a response, involving the UI, the Backend Service, and the Agent Logic (like the Host Agent).</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant UI as Mesop Frontend
    participant BClient as Backend Client (host_agent_service)
    participant BServer as Backend Service (ConversationServer)
    participant Manager as Backend Manager (ADKHostManager)
    participant Agent as Agent Logic (Host Agent / ADK)

    User-&gt;&gt;UI: Type message, press Enter
    UI-&gt;&gt;BClient: Call SendMessage(msg)
    BClient-&gt;&gt;BServer: POST /message/send (JSON: msg)
    BServer-&gt;&gt;Manager: Call process_message(msg) [async]
    BServer--&gt;&gt;BClient: 200 OK (Ack)
    BClient--&gt;&gt;UI: Return (UI shows processing)

    Note over Manager, Agent: Agent processing happens...
    Manager-&gt;&gt;Agent: Run agent with message
    Agent--&gt;&gt;Manager: Agent produces results/updates
    Manager-&gt;&gt;Manager: Store results/state updates

    loop UI Polling for Updates
        UI-&gt;&gt;BClient: Call UpdateAppState()
        BClient-&gt;&gt;BServer: POST /message/list, /task/list, etc.
        BServer-&gt;&gt;Manager: Get current state data
        Manager--&gt;&gt;BServer: Return state data
        BServer--&gt;&gt;BClient: 200 OK (JSON: state)
        BClient-&gt;&gt;UI: Update Mesop AppState
        Note over UI: Mesop re-renders with new data (agent response)
    end
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>The Demo UI Application and its associated <code class="language-plaintext highlighter-rouge">ConversationServer</code> backend provide a crucial, practical tool for the Google A2A project. They act as an interactive “control room” allowing you to:</p>

<ul>
  <li><strong>Visualize</strong> conversations involving one or more A2A agents.</li>
  <li><strong>Interact</strong> with the system by sending messages.</li>
  <li><strong>Observe</strong> how components like the <a href="08_multi_agent_orchestration__host_agent_.md">Host Agent</a> delegate tasks using the A2A protocol.</li>
  <li><strong>Inspect</strong> the state of <a href="02_task.md">Tasks</a> and communication events.</li>
  <li><strong>Experiment</strong> by adding new agents via their <a href="01_agent_card.md">Agent Cards</a>.</li>
</ul>

<p>It brings together all the concepts we’ve discussed – servers, clients, tasks, streaming, orchestration – into a tangible demonstration, making the abstract protocol concrete and easier to understand. This completes our journey through the core concepts of the Google A2A protocol and its demonstration application!</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
