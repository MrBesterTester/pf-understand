<h1 id="chapter-4-a2a-server-implementation">Chapter 4: A2A Server Implementation</h1>

<p>In the <a href="03_a2a_protocol___core_types.md">previous chapter</a>, we learned the “language” and “grammar” that AI agents use to talk to each other – the <strong>A2A Protocol</strong> based on JSON-RPC and its <strong>Core Types</strong> like <code class="language-plaintext highlighter-rouge">Task</code> and <code class="language-plaintext highlighter-rouge">Message</code>. Think of it like learning the rules of diplomacy and the standard format for official documents.</p>

<p>But just knowing the rules isn’t enough. If one country (an AI agent) wants to send a diplomatic message (a <a href="02_task.md">Task</a>) to another, it needs an official reception point – an embassy. How does an AI agent set up its “embassy” to receive and handle these official A2A communications?</p>

<p>That’s the role of the <strong>A2A Server Implementation</strong>. It solves the problem of <strong>hosting an agent</strong> and making it <strong>accessible</strong> according to the A2A protocol rules.</p>

<h2 id="what-is-an-a2a-server-the-agents-embassy">What is an A2A Server? The Agent’s Embassy</h2>

<p>Imagine our AI agent is like a skilled expert (a translator, a coder, an image generator) working inside a building. How do people from the outside world reach this expert and give them work? They can’t just barge into the building!</p>

<p>They need to go through the official <strong>reception desk</strong> or <strong>front office</strong>. This office:</p>

<ol>
  <li>Listens for visitors (incoming requests).</li>
  <li>Understands the standard procedures for submitting work (the A2A protocol).</li>
  <li>Takes the request (the <code class="language-plaintext highlighter-rouge">Task</code>), logs it, and passes it to the right expert inside.</li>
  <li>Keeps track of the work’s progress.</li>
  <li>Delivers the results back to the visitor when ready.</li>
  <li>Provides basic information about the building and its services (the <a href="01_agent_card.md">Agent Card</a>).</li>
</ol>

<p>An <strong>A2A Server</strong> is exactly like that front office or embassy for your AI agent. It’s the software component that runs on a server, listens for incoming network requests, and acts as the official gateway for all A2A communication.</p>

<h2 id="why-do-we-need-it">Why Do We Need It?</h2>

<p>Without a server, our AI agent is isolated. It might be brilliant at its job, but no other agent or application can interact with it using the standard A2A protocol. The A2A Server provides the necessary “infrastructure” to:</p>

<ul>
  <li><strong>Listen:</strong> Be constantly available on the network (at a specific URL) for incoming requests.</li>
  <li><strong>Understand:</strong> Decode the JSON-RPC messages and figure out what the client wants (e.g., <code class="language-plaintext highlighter-rouge">tasks/send</code>, <code class="language-plaintext highlighter-rouge">tasks/get</code>).</li>
  <li><strong>Delegate:</strong> Pass the work request (the <code class="language-plaintext highlighter-rouge">Task</code> details) to the actual AI logic (which might be implemented using tools like LangGraph, CrewAI, Genkit, or custom code).</li>
  <li><strong>Manage:</strong> Keep track of ongoing <code class="language-plaintext highlighter-rouge">Tasks</code>, their current <code class="language-plaintext highlighter-rouge">status</code> (e.g., <code class="language-plaintext highlighter-rouge">submitted</code>, <code class="language-plaintext highlighter-rouge">working</code>, <code class="language-plaintext highlighter-rouge">completed</code>), and store their results (<code class="language-plaintext highlighter-rouge">Artifacts</code>).</li>
  <li><strong>Respond:</strong> Send back properly formatted JSON-RPC responses (confirming task creation, providing results, or reporting errors).</li>
  <li><strong>Advertise:</strong> Serve the agent’s <code class="language-plaintext highlighter-rouge">agent.json</code> (<a href="01_agent_card.md">Agent Card</a>) so others can discover it.</li>
</ul>

<p>Think of it as the bridge connecting your agent’s internal world to the external world of A2A communication.</p>

<h2 id="setting-up-a-basic-server">Setting Up a Basic Server</h2>

<p>Luckily, the <code class="language-plaintext highlighter-rouge">Google A2A</code> project provides helper libraries to make setting up a server much easier! You don’t need to build the entire “embassy” from scratch. You mainly need to provide:</p>

<ol>
  <li>Your agent’s specific logic (the “expert” who does the actual work).</li>
  <li>The agent’s <a href="01_agent_card.md">Agent Card</a> details.</li>
</ol>

<p>Let’s look at simplified examples in JavaScript (Node.js) and Python.</p>

<h3 id="javascript-example-using-a2aserver-from-the-library">JavaScript Example (using <code class="language-plaintext highlighter-rouge">A2AServer</code> from the library)</h3>

<p>Imagine we have a very simple “Echo Agent” that just sends back whatever text it receives.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: simple-agent/index.ts (Conceptual Example)</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">A2AServer</span><span class="p">,</span> <span class="nx">TaskContext</span><span class="p">,</span> <span class="nx">TaskYieldUpdate</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">google-a2a/server</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// Simplified import</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">schema</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">google-a2a/schema</span><span class="dl">"</span><span class="p">;</span>

<span class="c1">// 1. Define the Agent's Logic (The "Expert")</span>
<span class="c1">// This function handles a single task.</span>
<span class="k">async</span> <span class="kd">function</span><span class="o">*</span> <span class="nx">echoAgentLogic</span><span class="p">(</span>
  <span class="nx">context</span><span class="p">:</span> <span class="nx">TaskContext</span>
<span class="p">):</span> <span class="nx">AsyncGenerator</span><span class="o">&lt;</span><span class="nx">TaskYieldUpdate</span><span class="p">,</span> <span class="nx">schema</span><span class="p">.</span><span class="nx">Task</span> <span class="o">|</span> <span class="k">void</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">inputText</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">userMessage</span><span class="p">.</span><span class="nx">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">text</span> <span class="o">??</span> <span class="dl">"</span><span class="s2">No text found</span><span class="dl">"</span><span class="p">;</span>

  <span class="c1">// Yield a status update: "working"</span>
  <span class="k">yield</span> <span class="p">{</span> <span class="na">state</span><span class="p">:</span> <span class="dl">"</span><span class="s2">working</span><span class="dl">"</span><span class="p">,</span> <span class="na">message</span><span class="p">:</span> <span class="p">{</span> <span class="na">role</span><span class="p">:</span> <span class="dl">"</span><span class="s2">agent</span><span class="dl">"</span><span class="p">,</span> <span class="na">parts</span><span class="p">:</span> <span class="p">[{</span> <span class="na">text</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Echoing...</span><span class="dl">"</span> <span class="p">}]</span> <span class="p">}</span> <span class="p">};</span>

  <span class="c1">// Yield the final result: "completed"</span>
  <span class="k">yield</span> <span class="p">{</span>
    <span class="na">state</span><span class="p">:</span> <span class="dl">"</span><span class="s2">completed</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">message</span><span class="p">:</span> <span class="p">{</span> <span class="na">role</span><span class="p">:</span> <span class="dl">"</span><span class="s2">agent</span><span class="dl">"</span><span class="p">,</span> <span class="na">parts</span><span class="p">:</span> <span class="p">[{</span> <span class="na">text</span><span class="p">:</span> <span class="s2">`You said: </span><span class="p">${</span><span class="nx">inputText</span><span class="p">}</span><span class="s2">`</span> <span class="p">}]</span> <span class="p">}</span>
  <span class="p">};</span>
  <span class="c1">// (Artifacts could also be yielded here if needed)</span>
<span class="p">}</span>

<span class="c1">// 2. Define the Agent Card</span>
<span class="kd">const</span> <span class="nx">echoAgentCard</span><span class="p">:</span> <span class="nx">schema</span><span class="p">.</span><span class="nx">AgentCard</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Echo Agent</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">description</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Replies with the text it receives.</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">url</span><span class="p">:</span> <span class="dl">"</span><span class="s2">http://localhost:4000</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// Where this server will run</span>
  <span class="na">version</span><span class="p">:</span> <span class="dl">"</span><span class="s2">1.0</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">capabilities</span><span class="p">:</span> <span class="p">{</span> <span class="na">streaming</span><span class="p">:</span> <span class="kc">true</span> <span class="p">},</span> <span class="c1">// It yields updates</span>
  <span class="na">skills</span><span class="p">:</span> <span class="p">[{</span> <span class="na">id</span><span class="p">:</span> <span class="dl">"</span><span class="s2">echo</span><span class="dl">"</span><span class="p">,</span> <span class="na">name</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Echo Text</span><span class="dl">"</span> <span class="p">}],</span>
  <span class="c1">// ... other card details</span>
<span class="p">};</span>

<span class="c1">// 3. Create and Start the Server</span>
<span class="kd">const</span> <span class="nx">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">A2AServer</span><span class="p">(</span><span class="nx">echoAgentLogic</span><span class="p">,</span> <span class="p">{</span> <span class="na">card</span><span class="p">:</span> <span class="nx">echoAgentCard</span> <span class="p">});</span>
<span class="nx">server</span><span class="p">.</span><span class="nx">start</span><span class="p">(</span><span class="mi">4000</span><span class="p">);</span> <span class="c1">// Start listening on port 4000</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="dl">"</span><span class="s2">Echo Agent server running on http://localhost:4000</span><span class="dl">"</span><span class="p">);</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><strong>Agent Logic (<code class="language-plaintext highlighter-rouge">echoAgentLogic</code>):</strong> This is the core function defining <em>what</em> the agent does. It receives the <code class="language-plaintext highlighter-rouge">TaskContext</code> (containing the user’s message) and uses <code class="language-plaintext highlighter-rouge">yield</code> to send back status updates (<code class="language-plaintext highlighter-rouge">working</code>) and the final result (<code class="language-plaintext highlighter-rouge">completed</code>). We’ll dive deeper into this logic in <a href="06_task_handling_logic__server_side_.md">Chapter 6: Task Handling Logic (Server-side)</a>. For now, just see it as the agent’s brain.</li>
  <li><strong>Agent Card (<code class="language-plaintext highlighter-rouge">echoAgentCard</code>):</strong> We define the agent’s public profile, including its name, description, and importantly, the <code class="language-plaintext highlighter-rouge">url</code> where the server will be listening.</li>
  <li><strong>Server Setup:</strong> We create an instance of <code class="language-plaintext highlighter-rouge">A2AServer</code>, passing our agent’s logic function and its card. Then, we call <code class="language-plaintext highlighter-rouge">server.start()</code> to make it listen for requests on the specified port (4000).</li>
</ol>

<p>That’s it! With this code, we have a running A2A server ready to accept <code class="language-plaintext highlighter-rouge">tasks/send</code> requests for our Echo Agent.</p>

<h3 id="python-example-using-a2aserver-from-the-library">Python Example (using <code class="language-plaintext highlighter-rouge">A2AServer</code> from the library)</h3>

<p>Let’s do the same for Python.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File: simple_agent/main.py (Conceptual Example)
</span><span class="kn">from</span> <span class="nn">common.server</span> <span class="kn">import</span> <span class="n">A2AServer</span><span class="p">,</span> <span class="n">TaskManager</span>  <span class="c1"># Simplified import
</span><span class="kn">from</span> <span class="nn">common.types</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AgentCard</span><span class="p">,</span> <span class="n">AgentCapabilities</span><span class="p">,</span> <span class="n">AgentSkill</span><span class="p">,</span>
    <span class="n">Task</span><span class="p">,</span> <span class="n">TaskSendParams</span><span class="p">,</span> <span class="n">TaskStatus</span><span class="p">,</span> <span class="n">TaskState</span><span class="p">,</span> <span class="n">Message</span><span class="p">,</span> <span class="n">TextPart</span><span class="p">,</span> <span class="n">SendTaskResponse</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logging</span><span class="p">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="p">.</span><span class="n">INFO</span><span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="c1"># 1. Define the Agent's Logic Handler (Task Manager)
# This class bridges the server and the agent's actual logic.
</span><span class="k">class</span> <span class="nc">EchoTaskManager</span><span class="p">(</span><span class="n">TaskManager</span><span class="p">):</span> <span class="c1"># Inherit from the base TaskManager
</span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_send_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">TaskSendParams</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SendTaskResponse</span><span class="p">:</span>
        <span class="c1"># Simulate processing the task
</span>        <span class="n">input_text</span> <span class="o">=</span> <span class="n">params</span><span class="p">.</span><span class="n">message</span><span class="p">.</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">text</span> <span class="k">if</span> <span class="n">params</span><span class="p">.</span><span class="n">message</span><span class="p">.</span><span class="n">parts</span> <span class="k">else</span> <span class="s">"No text"</span>
        <span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s">"Echo Agent received: </span><span class="si">{</span><span class="n">input_text</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

        <span class="c1"># Create the final Task object (simplified for non-streaming)
</span>        <span class="n">final_task</span> <span class="o">=</span> <span class="n">Task</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">params</span><span class="p">.</span><span class="nb">id</span><span class="p">,</span>
            <span class="n">status</span><span class="o">=</span><span class="n">TaskStatus</span><span class="p">(</span>
                <span class="n">state</span><span class="o">=</span><span class="n">TaskState</span><span class="p">.</span><span class="n">COMPLETED</span><span class="p">,</span>
                <span class="n">message</span><span class="o">=</span><span class="n">Message</span><span class="p">(</span><span class="n">role</span><span class="o">=</span><span class="s">"agent"</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="p">[</span><span class="n">TextPart</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="sa">f</span><span class="s">"You said: </span><span class="si">{</span><span class="n">input_text</span><span class="si">}</span><span class="s">"</span><span class="p">)])</span>
            <span class="p">),</span>
            <span class="c1"># ... other Task fields ...
</span>        <span class="p">)</span>
        <span class="c1"># In a real scenario, you'd store/update the task state
</span>        <span class="c1"># self.tasks[params.id] = final_task # Example storage
</span>        <span class="k">return</span> <span class="n">SendTaskResponse</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">params</span><span class="p">.</span><span class="nb">id</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="n">final_task</span><span class="p">)</span>

    <span class="c1"># Implement other abstract methods from TaskManager (get, cancel, etc.)
</span>    <span class="c1"># (Skipped for brevity in this example)
</span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_get_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span> <span class="k">raise</span> <span class="nb">NotImplementedError</span><span class="p">()</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_cancel_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span> <span class="k">raise</span> <span class="nb">NotImplementedError</span><span class="p">()</span>
    <span class="c1"># ... and so on for streaming, push notifications etc.
</span>
<span class="c1"># 2. Define the Agent Card
</span><span class="n">echo_agent_card</span> <span class="o">=</span> <span class="n">AgentCard</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">"Echo Agent"</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s">"Replies with the text it receives."</span><span class="p">,</span>
    <span class="n">url</span><span class="o">=</span><span class="s">"http://localhost:5000/"</span><span class="p">,</span> <span class="c1"># Where this server will run
</span>    <span class="n">version</span><span class="o">=</span><span class="s">"1.0"</span><span class="p">,</span>
    <span class="n">capabilities</span><span class="o">=</span><span class="n">AgentCapabilities</span><span class="p">(</span><span class="n">streaming</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="c1"># Simplified non-streaming Python example
</span>    <span class="n">skills</span><span class="o">=</span><span class="p">[</span><span class="n">AgentSkill</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="s">"echo"</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s">"Echo Text"</span><span class="p">)],</span>
    <span class="c1"># ... other card details
</span><span class="p">)</span>

<span class="c1"># 3. Create and Start the Server
</span><span class="n">server</span> <span class="o">=</span> <span class="n">A2AServer</span><span class="p">(</span>
    <span class="n">agent_card</span><span class="o">=</span><span class="n">echo_agent_card</span><span class="p">,</span>
    <span class="n">task_manager</span><span class="o">=</span><span class="n">EchoTaskManager</span><span class="p">(),</span> <span class="c1"># Pass our task handler
</span>    <span class="n">host</span><span class="o">=</span><span class="s">"localhost"</span><span class="p">,</span>
    <span class="n">port</span><span class="o">=</span><span class="mi">5000</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="s">"Starting Echo Agent server on http://localhost:5000"</span><span class="p">)</span>
<span class="n">server</span><span class="p">.</span><span class="n">start</span><span class="p">()</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><strong>Agent Logic Handler (<code class="language-plaintext highlighter-rouge">EchoTaskManager</code>):</strong> In the Python library structure, we often create a class that inherits from <code class="language-plaintext highlighter-rouge">TaskManager</code>. This class implements methods like <code class="language-plaintext highlighter-rouge">on_send_task</code> to handle specific A2A commands. Here, <code class="language-plaintext highlighter-rouge">on_send_task</code> simulates processing and returns the final <code class="language-plaintext highlighter-rouge">Task</code> object wrapped in a <code class="language-plaintext highlighter-rouge">SendTaskResponse</code>. <a href="06_task_handling_logic__server_side_.md">Chapter 6</a> will cover this in detail.</li>
  <li><strong>Agent Card (<code class="language-plaintext highlighter-rouge">echo_agent_card</code>):</strong> Similar to the JS example, we define the agent’s profile.</li>
  <li><strong>Server Setup:</strong> We create an <code class="language-plaintext highlighter-rouge">A2AServer</code> instance, providing the card and our custom <code class="language-plaintext highlighter-rouge">EchoTaskManager</code>. We then call <code class="language-plaintext highlighter-rouge">server.start()</code>.</li>
</ol>

<p>Both examples achieve the same goal: they use the library’s <code class="language-plaintext highlighter-rouge">A2AServer</code> class to quickly stand up a web server that listens for A2A requests, delegates the work to the provided agent logic, and handles the communication details.</p>

<h2 id="under-the-hood-how-a-request-is-processed">Under the Hood: How a Request is Processed</h2>

<p>What happens when a client sends a <code class="language-plaintext highlighter-rouge">tasks/send</code> request to our running A2A server?</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant C as Client App
    participant S as A2A Server (e.g., Express/Starlette)
    participant TM as Task Manager/Handler (Your Logic Bridge)
    participant AL as Agent Logic (e.g., echoAgentLogic, CrewAI)
    participant TS as Task Store (Memory/DB)

    C-&gt;&gt;S: POST / (JSON-RPC: method="tasks/send", params={...})
    Note right of S: Receives HTTP POST, parses JSON-RPC

    S-&gt;&gt;TM: Call on_send_task / Invoke Handler(params)
    Note right of TM: Validates parameters

    TM-&gt;&gt;TS: Load/Create Task Record (ID: task-123)
    Note right of TS: Creates Task in 'submitted' state

    TM-&gt;&gt;AL: Execute Agent Logic (Input: user message)
    Note right of AL: Performs the core work (e.g., echo)

    AL--&gt;&gt;TM: Returns result/Yields updates (e.g., "working", "completed")

    loop For each update/result
        TM-&gt;&gt;TS: Update Task Record (ID: task-123, state: working/completed, artifacts: [...])
        Note right of TS: Saves the latest task state
        alt Streaming Response (SSE)
           S--&gt;&gt;C: SSE Event (data: {TaskStatusUpdateEvent/Artifact})
        end
    end

    alt Non-Streaming Response
        TM--&gt;&gt;S: Final Task object
        S--&gt;&gt;C: 200 OK (JSON-RPC: result={Final Task Object})
    else Streaming Response (SSE)
        Note over S,C: Stream ends after final event
    end
</code></pre>

<p><strong>Steps:</strong></p>

<ol>
  <li><strong>Receive Request:</strong> The client sends an HTTP POST request containing the JSON-RPC payload to the server’s URL (e.g., <code class="language-plaintext highlighter-rouge">http://localhost:4000</code>). The web server part of the <code class="language-plaintext highlighter-rouge">A2AServer</code> (like Express in JS or Starlette in Python) receives this.</li>
  <li><strong>Parse &amp; Route:</strong> The <code class="language-plaintext highlighter-rouge">A2AServer</code> parses the JSON body, validates it’s a valid JSON-RPC request, and looks at the <code class="language-plaintext highlighter-rouge">method</code> field (e.g., <code class="language-plaintext highlighter-rouge">tasks/send</code>). Based on the method, it calls the appropriate handler function (like <code class="language-plaintext highlighter-rouge">handleTaskSend</code> in the JS server or delegates to the <code class="language-plaintext highlighter-rouge">on_send_task</code> method of the <code class="language-plaintext highlighter-rouge">TaskManager</code> in Python).</li>
  <li><strong>Task Management:</strong> The task handler (your <code class="language-plaintext highlighter-rouge">echoAgentLogic</code> or <code class="language-plaintext highlighter-rouge">EchoTaskManager</code>) takes over. It typically interacts with a <code class="language-plaintext highlighter-rouge">TaskStore</code> (like <code class="language-plaintext highlighter-rouge">InMemoryTaskStore</code>) to create or retrieve the <a href="02_task.md">Task</a> record associated with the request’s <code class="language-plaintext highlighter-rouge">taskId</code>. It updates the task’s status to <code class="language-plaintext highlighter-rouge">submitted</code> or <code class="language-plaintext highlighter-rouge">working</code>.</li>
  <li><strong>Execute Agent Logic:</strong> The handler calls the actual underlying AI agent code, passing the necessary input (like the user’s message).</li>
  <li><strong>Process Results/Updates:</strong> As the agent logic runs, it might produce results or status updates. The handler receives these.</li>
  <li><strong>Update Store &amp; Respond:</strong> The handler updates the <code class="language-plaintext highlighter-rouge">Task</code> record in the <code class="language-plaintext highlighter-rouge">TaskStore</code> with the new status or results (<code class="language-plaintext highlighter-rouge">Artifacts</code>).
    <ul>
      <li>For a simple request/response like <code class="language-plaintext highlighter-rouge">tasks/send</code> (non-streaming), it waits for the final result and sends back a single JSON-RPC response containing the completed <code class="language-plaintext highlighter-rouge">Task</code>.</li>
      <li>For a streaming request like <code class="language-plaintext highlighter-rouge">tasks/sendSubscribe</code>, it sends back Server-Sent Events (SSE) for each update as they happen. (<a href="07_streaming_communication__sse_.md">Chapter 7: Streaming Communication (SSE)</a> covers this).</li>
    </ul>
  </li>
  <li><strong>Serve Agent Card:</strong> Separately, if a client sends a GET request to <code class="language-plaintext highlighter-rouge">/.well-known/agent.json</code>, the <code class="language-plaintext highlighter-rouge">A2AServer</code> simply responds with the content of the <code class="language-plaintext highlighter-rouge">AgentCard</code> you provided during setup.</li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">A2AServer</code> libraries (<code class="language-plaintext highlighter-rouge">samples/js/src/server/server.ts</code>, <code class="language-plaintext highlighter-rouge">samples/python/common/server/server.py</code>) handle the complexities of HTTP, JSON-RPC parsing, routing, and response formatting, letting you focus on implementing your agent’s specific capabilities within the task handler (<a href="06_task_handling_logic__server_side_.md">Chapter 6</a>).</p>

<h2 id="conclusion">Conclusion</h2>

<p>The <strong>A2A Server Implementation</strong> is the crucial component that brings your AI agent to life on the network, acting as its official “embassy” for A2A communication. It listens for requests, understands the A2A protocol, manages tasks, interacts with your agent’s core logic, and sends back responses.</p>

<p>By using the provided <code class="language-plaintext highlighter-rouge">A2AServer</code> libraries, you can quickly set up a compliant server without worrying about the low-level details of web servers and JSON-RPC, allowing you to concentrate on building your agent’s unique skills.</p>

<p>Now that we know how to build the <em>server</em> side (the agent’s embassy), how does another application or agent <em>talk</em> to it? We need to build an <strong>A2A Client</strong>.</p>

<p><strong>Next:</strong> <a href="05_a2a_client_implementation.md">Chapter 5: A2A Client Implementation</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
