<h1 id="chapter-8-multi-agent-orchestration-host-agent">Chapter 8: Multi-Agent Orchestration (Host Agent)</h1>

<p>In the <a href="07_streaming_communication__sse_.md">previous chapter</a>, we saw how an agent server can stream updates back to a client using Server-Sent Events (SSE). This is great for keeping users informed during long tasks.</p>

<p>But what if a task is <em>so</em> complex that no single AI agent can handle it alone? Imagine asking an assistant: “Plan a weekend trip to London for me, including flights from New York, a hotel near the British Museum, and suggest two vegetarian restaurants.”</p>

<p>One agent might be amazing at finding flights, another specialized in hotel bookings, and a third brilliant at restaurant recommendations. How can we get these specialist agents to work together to fulfill your complex request?</p>

<p>This chapter introduces the concept of <strong>Multi-Agent Orchestration</strong> using a <strong>Host Agent</strong>. It solves the problem: <strong>How can we coordinate multiple, specialized AI agents to achieve a larger goal?</strong></p>

<h2 id="what-is-a-host-agent-the-project-manager-ai">What is a Host Agent? The Project Manager AI</h2>

<p>Think of a big project, like building a house. You don’t just talk to one person. You have a <strong>project manager</strong> (or general contractor). They:</p>

<ol>
  <li>Receive the high-level goal (build a house).</li>
  <li>Understand the different skills needed (plumbing, electrical, framing, etc.).</li>
  <li>Find and hire specialists (plumbers, electricians, carpenters).</li>
  <li>Assign specific tasks to each specialist.</li>
  <li>Coordinate their work and deadlines.</li>
  <li>Combine their contributions into the final house.</li>
</ol>

<p>A <strong>Host Agent</strong> in the A2A world acts exactly like that project manager. It’s an AI agent whose main job is <em>not</em> to perform tasks itself, but to <strong>coordinate other agents</strong>. Specifically, it acts as an <strong><a href="05_a2a_client_implementation.md">A2A Client</a></strong> to <em>other</em> downstream A2A agents.</p>

<p>Here’s the flow:</p>

<ol>
  <li><strong>Receives Request:</strong> The Host Agent gets a request from a user or application (e.g., “Plan my London trip”).</li>
  <li><strong>Finds Specialists:</strong> It looks at its list of known downstream agents and their <a href="01_agent_card.md">Agent Cards</a> to see who has the needed skills (e.g., “Flight Booker Agent”, “Hotel Finder Agent”).</li>
  <li><strong>Delegates Tasks:</strong> It breaks down the request and sends specific <a href="02_task.md">Tasks</a> to the chosen downstream agents using the standard <a href="03_a2a_protocol___core_types.md">A2A Protocol &amp; Core Types</a>. For example:
    <ul>
      <li>Sends a task “Find NYC-London flights for next weekend” to the Flight Booker Agent.</li>
      <li>Sends a task “Find hotels near British Museum” to the Hotel Finder Agent.</li>
    </ul>
  </li>
  <li><strong>Gathers Results:</strong> It receives the results (potentially via <a href="07_streaming_communication__sse_.md">Streaming Communication (SSE)</a>) from the downstream agents.</li>
  <li><strong>Combines &amp; Responds:</strong> It might combine the flight info and hotel options into a single, coherent response for the original user.</li>
</ol>

<p>The Host Agent is the central coordinator, making multiple agents appear as one unified, more capable agent.</p>

<h2 id="how-a-host-agent-works-conceptual">How a Host Agent Works (Conceptual)</h2>

<p>Let’s imagine we’re building a simple Host Agent. It knows about two other agents:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Joke Teller Agent</code> (at <code class="language-plaintext highlighter-rouge">http://joke-agent.com</code>) - Skill: <code class="language-plaintext highlighter-rouge">tell_joke</code></li>
  <li><code class="language-plaintext highlighter-rouge">Summarizer Agent</code> (at <code class="language-plaintext highlighter-rouge">http://summary-agent.com</code>) - Skill: <code class="language-plaintext highlighter-rouge">summarize_text</code></li>
</ul>

<p>Our Host Agent receives the request: “Tell me a joke and summarize this article: [long article text]”</p>

<p>Here’s how the Host Agent’s internal logic might work:</p>

<ol>
  <li><strong>Analyze Request:</strong> The Host Agent realizes the request has two parts: telling a joke and summarizing text.</li>
  <li><strong>Match Skills:</strong>
    <ul>
      <li>It checks its known agents’ <a href="01_agent_card.md">Agent Cards</a>.</li>
      <li>It sees <code class="language-plaintext highlighter-rouge">Joke Teller Agent</code> has the <code class="language-plaintext highlighter-rouge">tell_joke</code> skill.</li>
      <li>It sees <code class="language-plaintext highlighter-rouge">Summarizer Agent</code> has the <code class="language-plaintext highlighter-rouge">summarize_text</code> skill.</li>
    </ul>
  </li>
  <li><strong>Delegate Task 1 (Joke):</strong>
    <ul>
      <li>It acts as an <a href="05_a2a_client_implementation.md">A2A Client</a>.</li>
      <li>It sends a <code class="language-plaintext highlighter-rouge">tasks/send</code> request to <code class="language-plaintext highlighter-rouge">http://joke-agent.com/a2a</code> with the message “Tell me a joke”.</li>
    </ul>
  </li>
  <li><strong>Delegate Task 2 (Summary):</strong>
    <ul>
      <li>It acts as an <a href="05_a2a_client_implementation.md">A2A Client</a> again.</li>
      <li>It sends a <code class="language-plaintext highlighter-rouge">tasks/send</code> request to <code class="language-plaintext highlighter-rouge">http://summary-agent.com/a2a</code> with the message containing the article text.</li>
    </ul>
  </li>
  <li><strong>Await Responses:</strong> It waits for both downstream tasks to complete (using their Task IDs to track them). Let’s say it gets:
    <ul>
      <li>From Joke Agent: “Why don’t scientists trust atoms? Because they make up everything!”</li>
      <li>From Summarizer Agent: “[Short summary of the article]”</li>
    </ul>
  </li>
  <li><strong>Combine &amp; Reply:</strong> It combines these results into a single response for the original user: “Okay, here’s a joke: Why don’t scientists trust atoms? Because they make up everything! \n\nAnd here’s the summary: [Short summary of the article]”</li>
</ol>

<h2 id="example-implementation-snippets-conceptual-python">Example Implementation Snippets (Conceptual Python)</h2>

<p>Building a full Host Agent often involves frameworks like Google’s Agent Development Kit (ADK), as seen in <code class="language-plaintext highlighter-rouge">samples/python/hosts/multiagent/host_agent.py</code>. However, let’s look at the core A2A concepts conceptually.</p>

<p>The Host Agent needs a way to manage connections to downstream agents. We might have a helper class like <code class="language-plaintext highlighter-rouge">RemoteAgentConnection</code> (inspired by <code class="language-plaintext highlighter-rouge">samples/python/hosts/multiagent/remote_agent_connection.py</code>) which internally uses an <a href="05_a2a_client_implementation.md">A2A Client</a>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Conceptual Helper Class (Manages client for one downstream agent)
</span><span class="kn">from</span> <span class="nn">common.client</span> <span class="kn">import</span> <span class="n">A2AClient</span>
<span class="kn">from</span> <span class="nn">common.types</span> <span class="kn">import</span> <span class="n">AgentCard</span><span class="p">,</span> <span class="n">TaskSendParams</span><span class="p">,</span> <span class="n">Task</span>

<span class="k">class</span> <span class="nc">RemoteAgentConnection</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">agent_card</span><span class="p">:</span> <span class="n">AgentCard</span><span class="p">):</span>
        <span class="c1"># Store the downstream agent's card
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">card</span> <span class="o">=</span> <span class="n">agent_card</span>
        <span class="c1"># Create an A2A client specifically for this agent
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">client</span> <span class="o">=</span> <span class="n">A2AClient</span><span class="p">(</span><span class="n">agent_card</span><span class="o">=</span><span class="n">agent_card</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Connection ready for agent: </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">card</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">send_task_to_remote</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">params</span><span class="p">:</span> <span class="n">TaskSendParams</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Task</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Host sending task </span><span class="si">{</span><span class="n">params</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="s"> to </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">card</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">..."</span><span class="p">)</span>
        <span class="c1"># Use the internal A2A client to send the task
</span>        <span class="c1"># (Simplified: assumes non-streaming for clarity)
</span>        <span class="n">response</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">client</span><span class="p">.</span><span class="n">send_task</span><span class="p">(</span><span class="n">params</span><span class="p">.</span><span class="n">model_dump</span><span class="p">())</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Host received response for task </span><span class="si">{</span><span class="n">params</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="s"> from </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">card</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">response</span><span class="p">.</span><span class="n">result</span> <span class="c1"># Return the final Task object
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li>This class holds the <a href="01_agent_card.md">Agent Card</a> of a downstream agent.</li>
  <li>It creates and holds an <a href="05_a2a_client_implementation.md">A2A Client</a> instance configured to talk to that specific agent’s A2A server URL.</li>
  <li>The <code class="language-plaintext highlighter-rouge">send_task_to_remote</code> method takes the task details (<code class="language-plaintext highlighter-rouge">TaskSendParams</code>) and uses the internal client to actually send the <a href="02_task.md">Task</a> over A2A.</li>
</ul>

<p>Now, the Host Agent’s main logic might look something like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Conceptual Host Agent Logic
</span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">common.types</span> <span class="kn">import</span> <span class="n">Message</span><span class="p">,</span> <span class="n">TextPart</span><span class="p">,</span> <span class="n">TaskSendParams</span>
<span class="kn">import</span> <span class="nn">uuid</span>

<span class="k">class</span> <span class="nc">HostAgentLogic</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Assume agent cards are loaded somehow
</span>        <span class="n">joke_agent_card</span> <span class="o">=</span> <span class="n">AgentCard</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Joke Agent"</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="s">"http://joke-agent.com/a2a"</span><span class="p">,</span> <span class="p">...)</span>
        <span class="n">summary_agent_card</span> <span class="o">=</span> <span class="n">AgentCard</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"Summarizer Agent"</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="s">"http://summary-agent.com/a2a"</span><span class="p">,</span> <span class="p">...)</span>

        <span class="c1"># Create connections to downstream agents
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">remote_connections</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">"Joke Agent"</span><span class="p">:</span> <span class="n">RemoteAgentConnection</span><span class="p">(</span><span class="n">joke_agent_card</span><span class="p">),</span>
            <span class="s">"Summarizer Agent"</span><span class="p">:</span> <span class="n">RemoteAgentConnection</span><span class="p">(</span><span class="n">summary_agent_card</span><span class="p">),</span>
        <span class="p">}</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Host Agent initialized with remote connections."</span><span class="p">)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">handle_user_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">user_request_text</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Host received user request: </span><span class="si">{</span><span class="n">user_request_text</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="c1"># Super simplified logic: If "joke" in request, call Joke Agent.
</span>        <span class="c1"># If "summarize" in request, call Summarizer Agent.
</span>
        <span class="n">tasks_to_run</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="s">"joke"</span> <span class="ow">in</span> <span class="n">user_request_text</span><span class="p">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="n">joke_conn</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">remote_connections</span><span class="p">[</span><span class="s">"Joke Agent"</span><span class="p">]</span>
            <span class="n">joke_params</span> <span class="o">=</span> <span class="n">TaskSendParams</span><span class="p">(</span>
                <span class="nb">id</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="p">.</span><span class="n">uuid4</span><span class="p">()),</span>
                <span class="n">message</span><span class="o">=</span><span class="n">Message</span><span class="p">(</span><span class="n">role</span><span class="o">=</span><span class="s">"user"</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="p">[</span><span class="n">TextPart</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s">"Tell joke"</span><span class="p">)])</span>
            <span class="p">)</span>
            <span class="c1"># Add the task-sending coroutine to the list
</span>            <span class="n">tasks_to_run</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">joke_conn</span><span class="p">.</span><span class="n">send_task_to_remote</span><span class="p">(</span><span class="n">joke_params</span><span class="p">))</span>

        <span class="k">if</span> <span class="s">"summarize"</span> <span class="ow">in</span> <span class="n">user_request_text</span><span class="p">.</span><span class="n">lower</span><span class="p">():</span>
            <span class="c1"># (Assume article_text is extracted from user_request_text)
</span>            <span class="n">article_text</span> <span class="o">=</span> <span class="s">"This is the article to summarize..."</span>
            <span class="n">summary_conn</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">remote_connections</span><span class="p">[</span><span class="s">"Summarizer Agent"</span><span class="p">]</span>
            <span class="n">summary_params</span> <span class="o">=</span> <span class="n">TaskSendParams</span><span class="p">(</span>
                <span class="nb">id</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="p">.</span><span class="n">uuid4</span><span class="p">()),</span>
                <span class="n">message</span><span class="o">=</span><span class="n">Message</span><span class="p">(</span><span class="n">role</span><span class="o">=</span><span class="s">"user"</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="p">[</span><span class="n">TextPart</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">article_text</span><span class="p">)])</span>
            <span class="p">)</span>
            <span class="n">tasks_to_run</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">summary_conn</span><span class="p">.</span><span class="n">send_task_to_remote</span><span class="p">(</span><span class="n">summary_params</span><span class="p">))</span>

        <span class="c1"># Run the downstream tasks concurrently
</span>        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Host dispatching </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">tasks_to_run</span><span class="p">)</span><span class="si">}</span><span class="s"> tasks..."</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks_to_run</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Host gathered results from downstream agents."</span><span class="p">)</span>

        <span class="c1"># Combine results (simplified)
</span>        <span class="n">final_response</span> <span class="o">=</span> <span class="s">""</span>
        <span class="k">for</span> <span class="n">task_result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">task_result</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">message</span> <span class="ow">and</span> <span class="n">task_result</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">message</span><span class="p">.</span><span class="n">parts</span><span class="p">:</span>
                <span class="n">final_response</span> <span class="o">+=</span> <span class="n">task_result</span><span class="p">.</span><span class="n">status</span><span class="p">.</span><span class="n">message</span><span class="p">.</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">text</span> <span class="o">+</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>

        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Host final response: </span><span class="si">{</span><span class="n">final_response</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">final_response</span>

<span class="c1"># --- Example Usage ---
# async def main():
#     host = HostAgentLogic()
#     await host.handle_user_request("Tell me a joke and summarize stuff.")
# asyncio.run(main())
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><strong>Initialization:</strong> The <code class="language-plaintext highlighter-rouge">HostAgentLogic</code> creates <code class="language-plaintext highlighter-rouge">RemoteAgentConnection</code> instances for each downstream agent it knows.</li>
  <li><strong>Request Handling:</strong> When <code class="language-plaintext highlighter-rouge">handle_user_request</code> is called, it figures out which downstream agents are needed based on the request text (very basic keyword matching here).</li>
  <li><strong>Prepare Tasks:</strong> It prepares the <code class="language-plaintext highlighter-rouge">TaskSendParams</code> for each required downstream task.</li>
  <li><strong>Concurrent Delegation:</strong> It uses <code class="language-plaintext highlighter-rouge">asyncio.gather</code> to run the <code class="language-plaintext highlighter-rouge">send_task_to_remote</code> calls for all needed agents <em>concurrently</em>. This means it doesn’t wait for the joke agent to finish before asking the summarizer agent to start.</li>
  <li><strong>Combine Results:</strong> After <code class="language-plaintext highlighter-rouge">asyncio.gather</code> finishes (meaning all downstream tasks have completed), it extracts the results from the returned <code class="language-plaintext highlighter-rouge">Task</code> objects and combines them into a final response.</li>
</ol>

<p>This example shows the core idea: the Host Agent uses its knowledge of other agents’ capabilities and acts as an A2A client to delegate work, potentially in parallel. Real host agents would have much more sophisticated logic for planning, delegation, and result synthesis, possibly using large language models themselves for coordination.</p>

<h2 id="under-the-hood-orchestration-flow">Under the Hood: Orchestration Flow</h2>

<p>Let’s trace the communication for our “Joke &amp; Summarize” example:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant Host as Host Agent (Server)
    participant HAClient as Host Agent (Internal A2A Client)
    participant Joke as Joke Agent (Server)
    participant Summary as Summarizer Agent (Server)

    User-&gt;&gt;Host: Send Task T0: "Tell joke &amp; summarize..."
    Note over Host: Analyzes request, needs Joke &amp; Summarizer

    Host-&gt;&gt;HAClient: Initiate A2A Task T1 to Joke Agent ("Tell joke")
    HAClient-&gt;&gt;Joke: POST /a2a (tasks/send, id=T1, msg="Tell joke")
    Note right of Joke: Joke Agent starts processing T1

    Host-&gt;&gt;HAClient: Initiate A2A Task T2 to Summarizer Agent ("Summarize text...")
    HAClient-&gt;&gt;Summary: POST /a2a (tasks/send, id=T2, msg="...")
    Note right of Summary: Summarizer Agent starts processing T2

    Joke--&gt;&gt;HAClient: 200 OK (JSON-RPC result: Task T1 object, state=completed, result="Why..?")
    HAClient--&gt;&gt;Host: Received result for T1

    Summary--&gt;&gt;HAClient: 200 OK (JSON-RPC result: Task T2 object, state=completed, result="[Summary...]")
    HAClient--&gt;&gt;Host: Received result for T2

    Note over Host: Combines results from T1 and T2
    Host--&gt;&gt;User: Respond Task T0 (state=completed, result="Joke: ... Summary: ...")
</code></pre>

<p><strong>Steps:</strong></p>

<ol>
  <li>User sends the initial request (Task T0) to the Host Agent.</li>
  <li>The Host Agent’s logic determines it needs both the Joke Agent and Summarizer Agent.</li>
  <li>The Host Agent uses its internal A2A client capabilities (represented by <code class="language-plaintext highlighter-rouge">HAClient</code>) to send Task T1 to the Joke Agent’s A2A server endpoint.</li>
  <li>Concurrently (or sequentially), the Host Agent uses its client capabilities to send Task T2 to the Summarizer Agent’s A2A server endpoint.</li>
  <li>The downstream agents (Joke, Summary) process their respective tasks and send back A2A responses (containing the final Task object with results) to the Host Agent’s client component.</li>
  <li>The Host Agent logic receives the results for T1 and T2.</li>
  <li>The Host Agent combines the results and sends the final response for the original Task T0 back to the user.</li>
</ol>

<p>The key is that the Host Agent speaks A2A <em>both</em> as a server (to the original user) and as a client (to the downstream agents).</p>

<p><strong>Relevant Files:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">samples/python/hosts/multiagent/host_agent.py</code>: Implements the host agent logic, deciding which tools (remote agents) to call.</li>
  <li><code class="language-plaintext highlighter-rouge">samples/python/hosts/multiagent/remote_agent_connection.py</code>: Wraps the <code class="language-plaintext highlighter-rouge">A2AClient</code> for easier use by the <code class="language-plaintext highlighter-rouge">HostAgent</code>. It handles sending the task via A2A (streaming or non-streaming).</li>
  <li><code class="language-plaintext highlighter-rouge">demo/ui/service/server/adk_host_manager.py</code>: Manages the lifecycle and state of the host agent within the demo application framework (using Google ADK). It shows how task callbacks from <code class="language-plaintext highlighter-rouge">RemoteAgentConnection</code> update the overall state.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>Multi-Agent Orchestration allows us to combine the strengths of specialized AI agents to tackle complex problems that a single agent might struggle with.</p>

<p>The <strong>Host Agent</strong> acts as the “project manager” in this system. It:</p>

<ul>
  <li>Understands the overall goal.</li>
  <li>Knows the capabilities of other available agents (via their <a href="01_agent_card.md">Agent Cards</a>).</li>
  <li>Delegates sub-tasks to appropriate downstream agents by acting as an <a href="05_a2a_client_implementation.md">A2A Client</a>.</li>
  <li>Coordinates the process and potentially combines the results.</li>
</ul>

<p>This pattern enables building sophisticated applications by composing modular, specialized agents that communicate using the standard A2A protocol.</p>

<p>Now that we’ve explored the core concepts and components of the A2A protocol, let’s see how they all come together in a practical demonstration.</p>

<p><strong>Next:</strong> <a href="09_demo_ui_application___service.md">Chapter 9: Demo UI Application &amp; Service</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
