<h1 id="chapter-6-task-handling-logic-server-side">Chapter 6: Task Handling Logic (Server-side)</h1>

<p>Welcome back! In <a href="05_a2a_client_implementation.md">Chapter 5: A2A Client Implementation</a>, we learned how to build the “customer” side – the <strong>A2A Client</strong> – that sends requests to an agent’s server. We saw how it formats messages and talks to the agent’s “embassy” (<a href="04_a2a_server_implementation.md">A2A Server Implementation</a>).</p>

<p>But what happens <em>inside</em> the embassy once a request arrives? Who actually reads the request, does the work, and prepares the response?</p>

<p>This chapter focuses on the <strong>Task Handling Logic</strong>. It solves the problem: <strong>What is the core “brain” inside the A2A Server that performs the requested work?</strong></p>

<h2 id="the-agents-brain---the-chef-in-the-kitchen">The Agent’s “Brain” - The Chef in the Kitchen</h2>

<p>Imagine our A2A Server (<a href="04_a2a_server_implementation.md">Chapter 4</a>) is like a restaurant’s front desk. It takes orders (<a href="02_task.md">Tasks</a>) from customers (<a href="05_a2a_client_implementation.md">A2A Clients</a>) using the standard A2A language (<a href="03_a2a_protocol___core_types.md">A2A Protocol &amp; Core Types</a>).</p>

<p>But the front desk doesn’t cook the food! It passes the order to the <strong>kitchen</strong>, where the <strong>chef</strong> takes over. The chef:</p>

<ol>
  <li><strong>Reads the Order:</strong> Understands what the customer wants (e.g., “Translate ‘hello’ to French”).</li>
  <li><strong>Prepares the Dish:</strong> Uses ingredients (data), tools (APIs, databases), and expertise (AI models like Gemini) to fulfill the request.</li>
  <li><strong>Updates the Waiter:</strong> Might send updates back like “Order is being prepared” (<code class="language-plaintext highlighter-rouge">working</code> state).</li>
  <li><strong>Finishes the Dish:</strong> Creates the final product (the translated text “Bonjour le monde”).</li>
  <li><strong>Plates the Dish:</strong> Packages the result (<code class="language-plaintext highlighter-rouge">Artifacts</code>) and signals completion (<code class="language-plaintext highlighter-rouge">completed</code> state).</li>
</ol>

<p>The <strong>Task Handling Logic</strong> is the “chef” inside your A2A Server. It’s the core piece of code that contains the agent’s specific skills and business logic.</p>

<h2 id="what-does-the-task-handler-do">What Does the Task Handler Do?</h2>

<p>When the A2A Server receives a request like <code class="language-plaintext highlighter-rouge">tasks/send</code>, it hands off the details to the Task Handling Logic. This logic is responsible for:</p>

<ul>
  <li><strong>Understanding the Request:</strong> Receiving the user’s <code class="language-plaintext highlighter-rouge">Message</code> and any other context associated with the <code class="language-plaintext highlighter-rouge">Task</code>.</li>
  <li><strong>Executing the Work:</strong>
    <ul>
      <li>Calling AI models (like Gemini via libraries like Genkit) for generation, analysis, etc.</li>
      <li>Using tools (like calling a weather API, searching a database, or using specific libraries like CrewAI or LangGraph).</li>
      <li>Performing custom calculations or data manipulation.</li>
    </ul>
  </li>
  <li><strong>Managing State:</strong> Signaling progress by updating the <code class="language-plaintext highlighter-rouge">Task</code>’s status (e.g., changing from <code class="language-plaintext highlighter-rouge">submitted</code> to <code class="language-plaintext highlighter-rouge">working</code>).</li>
  <li><strong>Generating Output:</strong> Creating the final results (<code class="language-plaintext highlighter-rouge">Artifacts</code>) or intermediate updates.</li>
  <li><strong>Handling Errors:</strong> Reporting back if something goes wrong (<code class="language-plaintext highlighter-rouge">failed</code> state).</li>
</ul>

<h2 id="implementing-the-brain">Implementing the “Brain”</h2>

<p>The <code class="language-plaintext highlighter-rouge">Google A2A</code> libraries provide structures to help you implement this logic. Let’s look at simplified examples.</p>

<h3 id="javascript-example-async-generator-handler">JavaScript Example (Async Generator Handler)</h3>

<p>In JavaScript, the task handler is often an <code class="language-plaintext highlighter-rouge">async function*</code> (an asynchronous generator). It receives <code class="language-plaintext highlighter-rouge">TaskContext</code> and uses <code class="language-plaintext highlighter-rouge">yield</code> to send back updates.</p>

<p>Imagine a simple agent that pretends to call an AI to greet the user.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: samples/js/src/server/handler.ts (Conceptual Example of a Handler)</span>
<span class="k">import</span> <span class="o">*</span> <span class="k">as</span> <span class="nx">schema</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../schema.js</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// For types like Task, Message, etc.</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">TaskContext</span><span class="p">,</span> <span class="nx">TaskYieldUpdate</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./handler.js</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// Handler types</span>

<span class="c1">// The Task Handling Logic for our 'Greeter Agent'</span>
<span class="k">async</span> <span class="kd">function</span><span class="o">*</span> <span class="nx">greeterAgentHandler</span><span class="p">(</span>
  <span class="nx">context</span><span class="p">:</span> <span class="nx">TaskContext</span>
<span class="p">):</span> <span class="nx">AsyncGenerator</span><span class="o">&lt;</span><span class="nx">TaskYieldUpdate</span><span class="o">&gt;</span> <span class="p">{</span> <span class="c1">// It yields updates</span>

  <span class="c1">// 1. Get the user's name from the input message</span>
  <span class="kd">const</span> <span class="nx">userMessageText</span> <span class="o">=</span> <span class="nx">context</span><span class="p">.</span><span class="nx">userMessage</span><span class="p">.</span><span class="nx">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">text</span> <span class="o">??</span> <span class="dl">"</span><span class="s2">there</span><span class="dl">"</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">userName</span> <span class="o">=</span> <span class="nx">userMessageText</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="s2"> </span><span class="dl">"</span><span class="p">).</span><span class="nx">pop</span><span class="p">();</span> <span class="c1">// Simple extraction</span>

  <span class="c1">// 2. Signal that work is starting</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`[GreeterAgent] Task </span><span class="p">${</span><span class="nx">context</span><span class="p">.</span><span class="nx">task</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span><span class="s2">: Starting`</span><span class="p">);</span>
  <span class="k">yield</span> <span class="p">{</span>
    <span class="na">state</span><span class="p">:</span> <span class="dl">"</span><span class="s2">working</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// Update status to 'working'</span>
    <span class="na">message</span><span class="p">:</span> <span class="p">{</span> <span class="na">role</span><span class="p">:</span> <span class="dl">"</span><span class="s2">agent</span><span class="dl">"</span><span class="p">,</span> <span class="na">parts</span><span class="p">:</span> <span class="p">[{</span> <span class="na">text</span><span class="p">:</span> <span class="dl">"</span><span class="s2">Thinking...</span><span class="dl">"</span> <span class="p">}]</span> <span class="p">}</span>
  <span class="p">};</span>

  <span class="c1">// 3. Simulate calling an AI (the "chef" uses an "ingredient")</span>
  <span class="k">await</span> <span class="k">new</span> <span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span> <span class="o">=&gt;</span> <span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span> <span class="mi">500</span><span class="p">));</span> <span class="c1">// Pretend work</span>
  <span class="kd">const</span> <span class="nx">greeting</span> <span class="o">=</span> <span class="s2">`Hello, </span><span class="p">${</span><span class="nx">userName</span><span class="p">}</span><span class="s2">! Welcome.`</span><span class="p">;</span>

  <span class="c1">// 4. Signal completion and provide the final message</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s2">`[GreeterAgent] Task </span><span class="p">${</span><span class="nx">context</span><span class="p">.</span><span class="nx">task</span><span class="p">.</span><span class="nx">id</span><span class="p">}</span><span class="s2">: Completing`</span><span class="p">);</span>
  <span class="k">yield</span> <span class="p">{</span>
    <span class="na">state</span><span class="p">:</span> <span class="dl">"</span><span class="s2">completed</span><span class="dl">"</span><span class="p">,</span> <span class="c1">// Update status to 'completed'</span>
    <span class="na">message</span><span class="p">:</span> <span class="p">{</span> <span class="na">role</span><span class="p">:</span> <span class="dl">"</span><span class="s2">agent</span><span class="dl">"</span><span class="p">,</span> <span class="na">parts</span><span class="p">:</span> <span class="p">[{</span> <span class="na">text</span><span class="p">:</span> <span class="nx">greeting</span> <span class="p">}]</span> <span class="p">}</span>
  <span class="p">};</span>
  <span class="c1">// For more complex results, we could yield Artifacts here too.</span>
<span class="p">}</span>

<span class="c1">// This handler function (`greeterAgentHandler`) would be passed</span>
<span class="c1">// to the A2AServer constructor, like in Chapter 4.</span>
<span class="c1">// const server = new A2AServer(greeterAgentHandler, { card: greeterAgentCard });</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><strong>Input:</strong> The function receives <code class="language-plaintext highlighter-rouge">context</code> which contains the current <code class="language-plaintext highlighter-rouge">task</code> and the <code class="language-plaintext highlighter-rouge">userMessage</code>. We extract the user’s name.</li>
  <li><strong>Signal Working:</strong> It <code class="language-plaintext highlighter-rouge">yield</code>s an update object setting the <code class="language-plaintext highlighter-rouge">state</code> to <code class="language-plaintext highlighter-rouge">working</code> and providing an optional status message. The A2A Server receives this yield.</li>
  <li><strong>Do Work:</strong> It simulates calling an AI to generate a greeting. In real agents (like <code class="language-plaintext highlighter-rouge">samples/js/src/agents/coder/index.ts</code> or <code class="language-plaintext highlighter-rouge">samples/js/src/agents/movie-agent/index.ts</code>), this is where you’d interact with Genkit, external APIs, or other tools.</li>
  <li><strong>Signal Completion:</strong> It <code class="language-plaintext highlighter-rouge">yield</code>s the final update, setting the <code class="language-plaintext highlighter-rouge">state</code> to <code class="language-plaintext highlighter-rouge">completed</code> and including the greeting in the agent’s <code class="language-plaintext highlighter-rouge">message</code>.</li>
</ol>

<h3 id="python-example-taskmanager-with-streaming">Python Example (TaskManager with Streaming)</h3>

<p>In Python, you typically subclass <code class="language-plaintext highlighter-rouge">TaskManager</code> and implement methods like <code class="language-plaintext highlighter-rouge">on_send_task</code> or <code class="language-plaintext highlighter-rouge">on_send_task_subscribe</code>. For streaming responses, <code class="language-plaintext highlighter-rouge">on_send_task_subscribe</code> can also be an async generator.</p>

<p>Let’s create a similar Greeter Agent.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File: my_agent/task_manager.py (Conceptual Example)
</span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Union</span><span class="p">,</span> <span class="n">AsyncIterable</span>
<span class="kn">from</span> <span class="nn">common.server.task_manager</span> <span class="kn">import</span> <span class="n">InMemoryTaskManager</span> <span class="c1"># Base class
</span><span class="kn">from</span> <span class="nn">common.types</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Task</span><span class="p">,</span> <span class="n">TaskSendParams</span><span class="p">,</span> <span class="n">TaskStatus</span><span class="p">,</span> <span class="n">TaskState</span><span class="p">,</span> <span class="n">Message</span><span class="p">,</span> <span class="n">TextPart</span><span class="p">,</span>
    <span class="n">SendTaskStreamingRequest</span><span class="p">,</span> <span class="n">SendTaskStreamingResponse</span><span class="p">,</span> <span class="n">TaskStatusUpdateEvent</span><span class="p">,</span>
    <span class="n">JSONRPCResponse</span>
<span class="p">)</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">GreeterTaskManager</span><span class="p">(</span><span class="n">InMemoryTaskManager</span><span class="p">):</span> <span class="c1"># Inherit from base
</span>
    <span class="c1"># Handle non-streaming requests (optional)
</span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_send_task</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">):</span>
        <span class="c1"># ... implementation for non-streaming ...
</span>        <span class="k">raise</span> <span class="nb">NotImplementedError</span><span class="p">()</span>

    <span class="c1"># Handle STREAMING requests using an async generator
</span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_send_task_subscribe</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">:</span> <span class="n">SendTaskStreamingRequest</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">AsyncIterable</span><span class="p">[</span><span class="n">SendTaskStreamingResponse</span><span class="p">],</span> <span class="n">JSONRPCResponse</span><span class="p">]:</span>

        <span class="n">task_params</span><span class="p">:</span> <span class="n">TaskSendParams</span> <span class="o">=</span> <span class="n">request</span><span class="p">.</span><span class="n">params</span>
        <span class="n">task_id</span> <span class="o">=</span> <span class="n">task_params</span><span class="p">.</span><span class="nb">id</span>
        <span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s">"[GreeterAgent] Task </span><span class="si">{</span><span class="n">task_id</span><span class="si">}</span><span class="s">: Received"</span><span class="p">)</span>

        <span class="c1"># 0. Set up internal queue for SSE events
</span>        <span class="c1"># (Handled by library/base class, conceptually)
</span>
        <span class="c1"># 1. Update store &amp; get initial Task object
</span>        <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">upsert_task</span><span class="p">(</span><span class="n">task_params</span><span class="p">)</span> <span class="c1"># Store the task initially
</span>
        <span class="c1"># --- Start the async generator part ---
</span>        <span class="k">async</span> <span class="k">def</span> <span class="nf">_process_task</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">AsyncIterable</span><span class="p">[</span><span class="n">SendTaskStreamingResponse</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># 2. Get user name from input
</span>                <span class="n">user_message_text</span> <span class="o">=</span> <span class="n">task_params</span><span class="p">.</span><span class="n">message</span><span class="p">.</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">text</span> <span class="k">if</span> <span class="n">task_params</span><span class="p">.</span><span class="n">message</span><span class="p">.</span><span class="n">parts</span> <span class="k">else</span> <span class="s">"there"</span>
                <span class="n">user_name</span> <span class="o">=</span> <span class="n">user_message_text</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">" "</span><span class="p">).</span><span class="n">pop</span><span class="p">()</span>

                <span class="c1"># 3. Signal working (Yield a status update event)
</span>                <span class="n">working_status</span> <span class="o">=</span> <span class="n">TaskStatus</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="n">TaskState</span><span class="p">.</span><span class="n">WORKING</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">Message</span><span class="p">(</span><span class="n">role</span><span class="o">=</span><span class="s">"agent"</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="p">[</span><span class="n">TextPart</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="s">"Thinking..."</span><span class="p">)]))</span>
                <span class="n">working_event</span> <span class="o">=</span> <span class="n">TaskStatusUpdateEvent</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">task_id</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="n">working_status</span><span class="p">,</span> <span class="n">final</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">SendTaskStreamingResponse</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="nb">id</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="n">working_event</span><span class="p">)</span>
                <span class="c1"># Update internal store (optional, depending on base class)
</span>                <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">update_store</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="n">working_status</span><span class="p">,</span> <span class="n">artifacts</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

                <span class="c1"># 4. Simulate AI call
</span>                <span class="k">await</span> <span class="n">asyncio</span><span class="p">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
                <span class="n">greeting</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"Hello, </span><span class="si">{</span><span class="n">user_name</span><span class="si">}</span><span class="s">! Welcome from Python."</span>

                <span class="c1"># 5. Signal completion (Yield final status update event)
</span>                <span class="n">completed_status</span> <span class="o">=</span> <span class="n">TaskStatus</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="n">TaskState</span><span class="p">.</span><span class="n">COMPLETED</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">Message</span><span class="p">(</span><span class="n">role</span><span class="o">=</span><span class="s">"agent"</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="p">[</span><span class="n">TextPart</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">greeting</span><span class="p">)]))</span>
                <span class="n">completed_event</span> <span class="o">=</span> <span class="n">TaskStatusUpdateEvent</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">task_id</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="n">completed_status</span><span class="p">,</span> <span class="n">final</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c1"># final=True
</span>                <span class="k">yield</span> <span class="n">SendTaskStreamingResponse</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="nb">id</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="n">completed_event</span><span class="p">)</span>
                <span class="c1"># Update internal store
</span>                <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">update_store</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="n">completed_status</span><span class="p">,</span> <span class="n">artifacts</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

                <span class="n">logger</span><span class="p">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s">"[GreeterAgent] Task </span><span class="si">{</span><span class="n">task_id</span><span class="si">}</span><span class="s">: Completed"</span><span class="p">)</span>

            <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">logger</span><span class="p">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s">"[GreeterAgent] Task </span><span class="si">{</span><span class="n">task_id</span><span class="si">}</span><span class="s">: Error - </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
                <span class="c1"># Signal failure
</span>                <span class="n">failed_status</span> <span class="o">=</span> <span class="n">TaskStatus</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="n">TaskState</span><span class="p">.</span><span class="n">FAILED</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">Message</span><span class="p">(</span><span class="n">role</span><span class="o">=</span><span class="s">"agent"</span><span class="p">,</span> <span class="n">parts</span><span class="o">=</span><span class="p">[</span><span class="n">TextPart</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="sa">f</span><span class="s">"Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)]))</span>
                <span class="n">failed_event</span> <span class="o">=</span> <span class="n">TaskStatusUpdateEvent</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">task_id</span><span class="p">,</span> <span class="n">status</span><span class="o">=</span><span class="n">failed_status</span><span class="p">,</span> <span class="n">final</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">yield</span> <span class="n">SendTaskStreamingResponse</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="nb">id</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="n">failed_event</span><span class="p">)</span>
                <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">update_store</span><span class="p">(</span><span class="n">task_id</span><span class="p">,</span> <span class="n">failed_status</span><span class="p">,</span> <span class="n">artifacts</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>

        <span class="c1"># Return the async generator
</span>        <span class="k">return</span> <span class="n">_process_task</span><span class="p">()</span>

<span class="c1"># This GreeterTaskManager class would be passed to the A2AServer
# server = A2AServer(task_manager=GreeterTaskManager(), ...)
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><strong>Inheritance:</strong> We create <code class="language-plaintext highlighter-rouge">GreeterTaskManager</code> inheriting from <code class="language-plaintext highlighter-rouge">InMemoryTaskManager</code> (which provides basic task storage).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">on_send_task_subscribe</code>:</strong> This method handles streaming requests. It first stores the initial task details.</li>
  <li><strong>Async Generator (<code class="language-plaintext highlighter-rouge">_process_task</code>):</strong> The core logic is inside an inner <code class="language-plaintext highlighter-rouge">async def</code> that returns an <code class="language-plaintext highlighter-rouge">AsyncIterable</code>. This allows us to <code class="language-plaintext highlighter-rouge">yield</code> updates over time, similar to the JavaScript generator.</li>
  <li><strong>Yielding Events:</strong> Instead of yielding raw status updates, we yield <code class="language-plaintext highlighter-rouge">SendTaskStreamingResponse</code> objects containing <code class="language-plaintext highlighter-rouge">TaskStatusUpdateEvent</code>. The <code class="language-plaintext highlighter-rouge">final=True</code> flag marks the last event. (<a href="07_streaming_communication__sse_.md">Chapter 7: Streaming Communication (SSE)</a> covers SSE in detail).</li>
  <li><strong>Updating Store:</strong> We explicitly call <code class="language-plaintext highlighter-rouge">self.update_store</code> after yielding events to keep the task’s state consistent in our <code class="language-plaintext highlighter-rouge">InMemoryTaskManager</code>.</li>
  <li><strong>Error Handling:</strong> A <code class="language-plaintext highlighter-rouge">try...except</code> block handles potential errors and yields a <code class="language-plaintext highlighter-rouge">failed</code> state event.</li>
</ol>

<p>Real-world Python agents might use frameworks like CrewAI (<code class="language-plaintext highlighter-rouge">samples/python/agents/crewai/agent.py</code>) or LangGraph (<code class="language-plaintext highlighter-rouge">samples/python/agents/langgraph/agent.py</code>) within these handler methods to orchestrate more complex logic.</p>

<h2 id="key-inputs-to-the-handler">Key Inputs to the Handler</h2>

<p>The handler needs information to do its job. The context typically includes:</p>

<ul>
  <li><strong>Task Details:</strong> The current <code class="language-plaintext highlighter-rouge">Task</code> object, including its unique <code class="language-plaintext highlighter-rouge">id</code>, current <code class="language-plaintext highlighter-rouge">status</code>, and any <code class="language-plaintext highlighter-rouge">metadata</code>.</li>
  <li><strong>User Message:</strong> The specific <code class="language-plaintext highlighter-rouge">Message</code> from the user that triggered this work (containing <code class="language-plaintext highlighter-rouge">Parts</code> like text or files).</li>
  <li><strong>History (Optional):</strong> Previous <code class="language-plaintext highlighter-rouge">Messages</code> exchanged within this <code class="language-plaintext highlighter-rouge">Task</code> for conversational context.</li>
  <li><strong>Cancellation Check:</strong> A way to see if the client has requested to cancel the task.</li>
</ul>

<p>These inputs are bundled in <code class="language-plaintext highlighter-rouge">TaskContext</code> (JS) or passed as parameters to the <code class="language-plaintext highlighter-rouge">TaskManager</code> methods (Python).</p>

<h2 id="signaling-progress-and-delivering-results">Signaling Progress and Delivering Results</h2>

<ul>
  <li><strong>Status Updates:</strong> Yielding status changes (<code class="language-plaintext highlighter-rouge">working</code>, <code class="language-plaintext highlighter-rouge">input-required</code>, <code class="language-plaintext highlighter-rouge">completed</code>, <code class="language-plaintext highlighter-rouge">failed</code>) keeps the client informed, especially for long-running tasks. This often includes a <code class="language-plaintext highlighter-rouge">Message</code> from the agent (e.g., “Looking up information…”, “Please provide the city name.”).</li>
  <li><strong>Artifacts (Results):</strong> For tasks that produce distinct outputs (like files, structured data, or images), the handler yields <code class="language-plaintext highlighter-rouge">Artifact</code> objects. These artifacts are collected and associated with the <code class="language-plaintext highlighter-rouge">Task</code>.
    <ul>
      <li>JS: Yield <code class="language-plaintext highlighter-rouge">schema.Artifact</code> objects directly. (<code class="language-plaintext highlighter-rouge">samples/js/src/agents/coder/index.ts</code>)</li>
      <li>Python (Streaming): Yield <code class="language-plaintext highlighter-rouge">SendTaskStreamingResponse</code> containing <code class="language-plaintext highlighter-rouge">TaskArtifactUpdateEvent</code>. (<code class="language-plaintext highlighter-rouge">demo/ui/service/server/adk_host_manager.py</code> shows <code class="language-plaintext highlighter-rouge">process_artifact_event</code>)</li>
    </ul>
  </li>
</ul>

<h2 id="connecting-to-the-server">Connecting to the Server</h2>

<p>As shown in <a href="04_a2a_server_implementation.md">Chapter 4</a>, you connect your Task Handling Logic to the <code class="language-plaintext highlighter-rouge">A2AServer</code> during its setup:</p>

<ul>
  <li><strong>JS:</strong> Pass the async generator function (<code class="language-plaintext highlighter-rouge">greeterAgentHandler</code>) to the <code class="language-plaintext highlighter-rouge">A2AServer</code> constructor.</li>
  <li><strong>Python:</strong> Pass an instance of your <code class="language-plaintext highlighter-rouge">TaskManager</code> subclass (<code class="language-plaintext highlighter-rouge">GreeterTaskManager()</code>) to the <code class="language-plaintext highlighter-rouge">A2AServer</code> constructor.</li>
</ul>

<p>The server then knows exactly which “chef” to call when an order comes in.</p>

<h2 id="under-the-hood-server-invoking-the-handler">Under the Hood: Server Invoking the Handler</h2>

<p>Let’s visualize how the server uses the handler when a streaming <code class="language-plaintext highlighter-rouge">tasks/sendSubscribe</code> request arrives:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant C as A2A Client
    participant S as A2A Server
    participant TH as Task Handler (e.g., greeterAgentHandler)
    participant AI as AI Model/Tool (Optional)
    participant TS as Task Store

    C-&gt;&gt;S: POST / (JSON-RPC: method="tasks/sendSubscribe", params={...})
    Note right of S: Receives request, parses JSON-RPC

    S-&gt;&gt;TS: Create/Get Task Record (ID: task-123)
    TS--&gt;&gt;S: Task Object (state: submitted)

    S-&gt;&gt;TH: Invoke handler(context) / Call on_send_task_subscribe()
    Note right of TH: Handler starts executing

    TH-&gt;&gt;TS: Update Task (state: working)
    TH--&gt;&gt;S: yield {state: "working", ...} / yield TaskStatusUpdateEvent(working)
    Note right of S: Receives yielded update

    S--&gt;&gt;C: Send SSE Event (data: TaskStatusUpdateEvent - working)
    Note left of C: Client receives 'working' status

    alt Handler needs AI/Tool
        TH-&gt;&gt;AI: Request generation("greet user")
        AI--&gt;&gt;TH: Response ("Hello there!")
    end

    TH-&gt;&gt;TS: Update Task (state: completed, message: "Hello...")
    TH--&gt;&gt;S: yield {state: "completed", ...} / yield TaskStatusUpdateEvent(completed, final=True)
    Note right of S: Receives final yielded update

    S--&gt;&gt;C: Send SSE Event (data: TaskStatusUpdateEvent - completed, final=True)
    Note left of C: Client receives 'completed' status, stream ends
</code></pre>

<p><strong>Steps:</strong></p>

<ol>
  <li><strong>Request In:</strong> The <code class="language-plaintext highlighter-rouge">A2A Server</code> receives the <code class="language-plaintext highlighter-rouge">tasks/sendSubscribe</code> request.</li>
  <li><strong>Task Prep:</strong> It looks up or creates the <code class="language-plaintext highlighter-rouge">Task</code> in the <code class="language-plaintext highlighter-rouge">Task Store</code>.</li>
  <li><strong>Invoke Handler:</strong> It calls your registered Task Handling Logic (e.g., <code class="language-plaintext highlighter-rouge">greeterAgentHandler</code> or <code class="language-plaintext highlighter-rouge">GreeterTaskManager.on_send_task_subscribe</code>), providing the necessary context.</li>
  <li><strong>Handler Executes &amp; Yields:</strong> Your handler runs. When it <code class="language-plaintext highlighter-rouge">yield</code>s a status update (like <code class="language-plaintext highlighter-rouge">working</code>):
    <ul>
      <li>It might update the <code class="language-plaintext highlighter-rouge">Task Store</code>.</li>
      <li>It returns the update to the <code class="language-plaintext highlighter-rouge">A2AServer</code>.</li>
    </ul>
  </li>
  <li><strong>Server Sends Update:</strong> The <code class="language-plaintext highlighter-rouge">A2AServer</code> formats the update as a Server-Sent Event (SSE) and sends it to the <code class="language-plaintext highlighter-rouge">A2A Client</code>.</li>
  <li><strong>(Optional) External Calls:</strong> The handler might call external services (AI, tools).</li>
  <li><strong>Handler Yields Final Result:</strong> When the handler is done, it <code class="language-plaintext highlighter-rouge">yield</code>s the final <code class="language-plaintext highlighter-rouge">completed</code> (or <code class="language-plaintext highlighter-rouge">failed</code>) status update (often marked as <code class="language-plaintext highlighter-rouge">final=True</code> in streaming).</li>
  <li><strong>Server Sends Final Update:</strong> The <code class="language-plaintext highlighter-rouge">A2AServer</code> sends the final SSE event to the client, closing the stream.</li>
</ol>

<p>Key files involved:</p>

<ul>
  <li><strong>JS Handler Definition:</strong> <code class="language-plaintext highlighter-rouge">samples/js/src/server/handler.ts</code> (defines <code class="language-plaintext highlighter-rouge">TaskContext</code>, <code class="language-plaintext highlighter-rouge">TaskYieldUpdate</code>, <code class="language-plaintext highlighter-rouge">TaskHandler</code>)</li>
  <li><strong>JS Agent Example:</strong> <code class="language-plaintext highlighter-rouge">samples/js/src/agents/coder/index.ts</code>, <code class="language-plaintext highlighter-rouge">samples/js/src/agents/movie-agent/index.ts</code></li>
  <li><strong>Python Base Manager:</strong> <code class="language-plaintext highlighter-rouge">samples/python/common/server/task_manager.py</code> (defines <code class="language-plaintext highlighter-rouge">TaskManager</code>, <code class="language-plaintext highlighter-rouge">InMemoryTaskManager</code>)</li>
  <li><strong>Python Agent Examples:</strong> <code class="language-plaintext highlighter-rouge">samples/python/agents/crewai/agent.py</code>, <code class="language-plaintext highlighter-rouge">samples/python/agents/langgraph/agent.py</code>, <code class="language-plaintext highlighter-rouge">demo/ui/service/server/adk_host_manager.py</code> (more complex, uses ADK)</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>The <strong>Task Handling Logic</strong> is the heart of your A2A agent – the “chef” that actually does the work. It receives requests via the <code class="language-plaintext highlighter-rouge">A2AServer</code>, interacts with AI models or tools, manages the task’s state transitions, and generates the final response or intermediate updates.</p>

<p>By implementing this logic (often as an async generator in JS or a <code class="language-plaintext highlighter-rouge">TaskManager</code> subclass in Python) and connecting it to your server, you define your agent’s unique capabilities and how it fulfills the tasks requested by clients.</p>

<p>We saw how handlers can <code class="language-plaintext highlighter-rouge">yield</code> updates. But how do these updates actually get sent back to the client in real-time? Let’s dive into the mechanism used for that: Streaming Communication using Server-Sent Events (SSE).</p>

<p><strong>Next:</strong> <a href="07_streaming_communication__sse_.md">Chapter 7: Streaming Communication (SSE)</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
