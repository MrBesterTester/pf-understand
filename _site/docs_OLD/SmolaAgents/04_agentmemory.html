<h1 id="chapter-4-agentmemory---the-agents-notepad">Chapter 4: AgentMemory - The Agent‚Äôs Notepad</h1>

<p>Welcome back! In <a href="03_tool.md">Chapter 3: Tool</a>, we equipped our agent with ‚Äúsuperpowers‚Äù ‚Äì tools like web search or calculators that let it interact with the world and perform actions. We saw how the agent‚Äôs ‚Äúbrain‚Äù (the LLM) decides which tool to use, and the agent executes it.</p>

<p>But wait‚Ä¶ how does the agent remember what it has already done? If it searches for the capital of France in Step 1, how does it remember ‚ÄúParis‚Äù when deciding what to do in Step 2 (like finding the weather in Paris)?</p>

<p>This is where <strong>AgentMemory</strong> comes in. Think of it as the agent‚Äôs dedicated notepad or, even better, a <strong>ship‚Äôs logbook</strong>.</p>

<h2 id="the-problem-an-agent-with-amnesia">The Problem: An Agent with Amnesia</h2>

<p>Imagine a captain sailing a ship on a long voyage. After each hour, they completely forget everything that happened before ‚Äì the course they set, the islands they passed, the storms they weathered. How could they possibly reach their destination? They‚Äôd be lost!</p>

<p><img src="https://img.icons8.com/ios/50/000000/confused.png" alt="Confused Captain" /> ‚ùì ‚ÄúWhere am I? What was I doing?‚Äù</p>

<p>An agent without memory is like that forgetful captain. It might perform a single action correctly, but it wouldn‚Äôt understand the context. It wouldn‚Äôt know:</p>

<ul>
  <li>What the original goal (task) was.</li>
  <li>What steps it has already taken.</li>
  <li>What results (observations) it got from those steps.</li>
  <li>What errors it might have encountered.</li>
</ul>

<p>Without this history, the agent can‚Äôt make informed decisions about what to do next. It can‚Äôt build upon previous results or learn from mistakes within the same task.</p>

<h2 id="the-solution-the-ships-logbook-agentmemory">The Solution: The Ship‚Äôs Logbook (<code class="language-plaintext highlighter-rouge">AgentMemory</code>)</h2>

<p>The <code class="language-plaintext highlighter-rouge">AgentMemory</code> is the component that solves this problem. It automatically records every significant event during the agent‚Äôs ‚Äúvoyage‚Äù (its execution run).</p>

<p><img src="https://img.icons8.com/ios/50/000000/scroll.png" alt="Ship's Logbook" /> üìú ‚ÄúLog Entry: Searched ‚ÄòCapital of France‚Äô. Result: ‚ÄòParis‚Äô.‚Äù</p>

<p>Just like a ship‚Äôs logbook helps the captain navigate, the <code class="language-plaintext highlighter-rouge">AgentMemory</code> helps the agent maintain context and proceed effectively.</p>

<h2 id="what-does-the-agentmemory-store">What Does the <code class="language-plaintext highlighter-rouge">AgentMemory</code> Store?</h2>

<p>The <code class="language-plaintext highlighter-rouge">AgentMemory</code> keeps a chronological record of the agent‚Äôs journey. For each run, it typically stores:</p>

<ol>
  <li><strong>System Prompt:</strong> The initial instructions given to the agent‚Äôs LLM brain (we‚Äôll see more in <a href="05_prompttemplates.md">Chapter 5: PromptTemplates</a>).</li>
  <li><strong>Initial Task:</strong> The main goal the user gave the agent (e.g., ‚ÄúWhat is the capital of France, and what is its current weather?‚Äù).</li>
  <li><strong>Steps:</strong> A list detailing each cycle of the agent‚Äôs operation:
    <ul>
      <li><strong>Planning (Optional):</strong> If the agent makes plans, the plan itself is recorded.</li>
      <li><strong>Thinking:</strong> The LLM‚Äôs reasoning process and the action it decided to take (e.g., ‚ÄúThought: I need the capital. Action: Use <code class="language-plaintext highlighter-rouge">search</code> tool‚Äù).</li>
      <li><strong>Action:</strong> The specific <a href="03_tool.md">Tool</a> called and the arguments used (e.g., <code class="language-plaintext highlighter-rouge">search("Capital of France")</code>). This could also be code execution for code-based agents.</li>
      <li><strong>Observation:</strong> The result received after performing the action (e.g., ‚ÄúParis‚Äù).</li>
      <li><strong>Errors:</strong> If something went wrong during the step (e.g., a tool failed), the error is noted.</li>
    </ul>
  </li>
</ol>

<p>This detailed history allows the agent (specifically, the LLM guiding it) to look back at any point and understand the full context before deciding the next move.</p>

<h2 id="how-is-agentmemory-used-mostly-automatic">How is <code class="language-plaintext highlighter-rouge">AgentMemory</code> Used? (Mostly Automatic!)</h2>

<p>The good news is that you, as the user, usually don‚Äôt need to interact directly with <code class="language-plaintext highlighter-rouge">AgentMemory</code>. The <code class="language-plaintext highlighter-rouge">MultiStepAgent</code> manages it automatically behind the scenes!</p>

<p>Here‚Äôs the key interaction:</p>

<ol>
  <li><strong>Before ‚ÄúThinking‚Äù:</strong> When the agent needs to decide the next step (the ‚ÄúThink‚Äù phase), the <code class="language-plaintext highlighter-rouge">MultiStepAgent</code> asks the <code class="language-plaintext highlighter-rouge">AgentMemory</code> to format the recorded history (task, previous actions, observations, errors) into a sequence of messages. This happens via a method often called <code class="language-plaintext highlighter-rouge">write_memory_to_messages</code>.</li>
  <li><strong>Consulting the Brain:</strong> This formatted history is sent to the LLM via the <a href="02_model_interface.md">Model Interface</a>. This gives the LLM the full context it needs to provide a sensible next step. (‚ÄúOkay, based on the task ‚ÄòCapital and Weather‚Äô, and the fact we just found ‚ÄòParis‚Äô, what should we do now?‚Äù).</li>
  <li><strong>After ‚ÄúActing‚Äù and ‚ÄúObserving‚Äù:</strong> Once the agent performs an action and gets an observation (or an error), the <code class="language-plaintext highlighter-rouge">MultiStepAgent</code> records this new information as a new step in the <code class="language-plaintext highlighter-rouge">AgentMemory</code>.</li>
</ol>

<p>So, the memory is constantly being read from (to inform the LLM) and written to (to record new events).</p>

<h2 id="example-revisited-capital-and-weather-logbook">Example Revisited: Capital and Weather Logbook</h2>

<p>Let‚Äôs trace our ‚ÄúCapital of France and Weather‚Äù example from <a href="01_multistepagent.md">Chapter 1: MultiStepAgent</a> and see what the <code class="language-plaintext highlighter-rouge">AgentMemory</code> logbook might look like (simplified):</p>

<p><strong>(Start of Run)</strong></p>

<ol>
  <li><strong>System Prompt:</strong> Recorded (e.g., ‚ÄúYou are a helpful assistant‚Ä¶‚Äù)</li>
  <li><strong>Task:</strong> Recorded (<code class="language-plaintext highlighter-rouge">task: "What is the capital of France, and what is its current weather?"</code>)</li>
</ol>

<p><strong>(Step 1)</strong></p>

<ol>
  <li><strong>Think/Action:</strong> Recorded (<code class="language-plaintext highlighter-rouge">thought: "Need capital.", action: search("Capital of France")</code>)</li>
  <li><strong>Observation:</strong> Recorded (<code class="language-plaintext highlighter-rouge">observation: "Paris"</code>)</li>
</ol>

<p><strong>(Step 2)</strong></p>

<ol>
  <li><strong>Think/Action:</strong> Recorded (<code class="language-plaintext highlighter-rouge">thought: "Have capital (Paris), need weather.", action: weather("Paris")</code>)</li>
  <li><strong>Observation:</strong> Recorded (<code class="language-plaintext highlighter-rouge">observation: "Sunny, 25¬∞C"</code>)</li>
</ol>

<p><strong>(Step 3)</strong></p>

<ol>
  <li><strong>Think/Action:</strong> Recorded (<code class="language-plaintext highlighter-rouge">thought: "Have capital and weather. Task complete.", action: final_answer("The capital of France is Paris, and the current weather there is Sunny, 25¬∞C.")</code>)</li>
  <li><strong>Observation:</strong> Recorded (Result of <code class="language-plaintext highlighter-rouge">final_answer</code> is the final output).</li>
</ol>

<p><strong>(End of Run)</strong></p>

<p>Now, before Step 2 started, the agent would read entries 1-4 from memory to give context to the LLM. Before Step 3, it would read entries 1-6. This prevents the agent from forgetting what it‚Äôs doing!</p>

<h2 id="under-the-hood-memory-structure">Under the Hood: Memory Structure</h2>

<p>How does <code class="language-plaintext highlighter-rouge">SmolaAgents</code> actually implement this?</p>

<p><strong>Core Idea:</strong> The <code class="language-plaintext highlighter-rouge">AgentMemory</code> object holds a list called <code class="language-plaintext highlighter-rouge">steps</code>. Each item in this list represents one distinct event or phase in the agent‚Äôs run. These items are usually instances of specific ‚ÄúStep‚Äù classes.</p>

<p><strong>Key Step Types (Simplified from <code class="language-plaintext highlighter-rouge">memory.py</code>):</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">SystemPromptStep</code>: Stores the initial system prompt text.</li>
  <li><code class="language-plaintext highlighter-rouge">TaskStep</code>: Stores the user‚Äôs task description (and potentially input images).</li>
  <li><code class="language-plaintext highlighter-rouge">PlanningStep</code> (Optional): Stores any explicit plans the agent generates.</li>
  <li><code class="language-plaintext highlighter-rouge">ActionStep</code>: This is the most common one, recording a single Think-Act-Observe cycle. It contains fields for:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">step_number</code></li>
      <li><code class="language-plaintext highlighter-rouge">model_input_messages</code>: What was sent to the LLM for thinking.</li>
      <li><code class="language-plaintext highlighter-rouge">model_output_message</code>: The LLM‚Äôs raw response (thought + action plan).</li>
      <li><code class="language-plaintext highlighter-rouge">tool_calls</code>: Which <a href="03_tool.md">Tool</a> was called (name, arguments). Stored as <code class="language-plaintext highlighter-rouge">ToolCall</code> objects.</li>
      <li><code class="language-plaintext highlighter-rouge">observations</code>: The result returned by the tool.</li>
      <li><code class="language-plaintext highlighter-rouge">error</code>: Any error that occurred.</li>
      <li><code class="language-plaintext highlighter-rouge">start_time</code>, <code class="language-plaintext highlighter-rouge">end_time</code>, <code class="language-plaintext highlighter-rouge">duration</code>: Timing information.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">FinalAnswerStep</code>: A special step indicating the final result returned by the agent.</li>
</ul>

<p><strong>Interaction Flow:</strong></p>

<p>Here‚Äôs how the <code class="language-plaintext highlighter-rouge">MultiStepAgent</code> uses <code class="language-plaintext highlighter-rouge">AgentMemory</code>:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant MSA as MultiStepAgent
    participant Memory as AgentMemory
    participant Model as LLM Brain
    participant Tool

    User-&gt;&gt;MSA: run("Task: Capital &amp; Weather?")
    MSA-&gt;&gt;Memory: Store TaskStep("Capital &amp; Weather?")
    loop Think-Act-Observe Cycle (Step 1)
        MSA-&gt;&gt;Memory: write_memory_to_messages() --&gt; Get History [Task]
        MSA-&gt;&gt;Model: What's next? (with History)
        Model--&gt;&gt;MSA: Think: Need capital. Act: search(...) -&gt; LLM Response
        MSA-&gt;&gt;Memory: Store LLM Response in new ActionStep
        MSA-&gt;&gt;Tool: Execute search(...)
        Tool--&gt;&gt;MSA: Observation: "Paris"
        MSA-&gt;&gt;Memory: Store Observation in current ActionStep
        MSA-&gt;&gt;Memory: Append finished ActionStep to steps list
    end
    loop Think-Act-Observe Cycle (Step 2)
        MSA-&gt;&gt;Memory: write_memory_to_messages() --&gt; Get History [Task, Step 1]
        MSA-&gt;&gt;Model: What's next? (with History)
        Model--&gt;&gt;MSA: Think: Need weather. Act: weather(...) -&gt; LLM Response
        MSA-&gt;&gt;Memory: Store LLM Response in new ActionStep
        MSA-&gt;&gt;Tool: Execute weather(...)
        Tool--&gt;&gt;MSA: Observation: "Sunny, 25C"
        MSA-&gt;&gt;Memory: Store Observation in current ActionStep
        MSA-&gt;&gt;Memory: Append finished ActionStep to steps list
    end
    MSA--&gt;&gt;User: Final Answer
</code></pre>

<p><strong>Code Glimpse (Simplified):</strong></p>

<p>Let‚Äôs look at some relevant pieces from <code class="language-plaintext highlighter-rouge">memory.py</code> and <code class="language-plaintext highlighter-rouge">agents.py</code>.</p>

<ul>
  <li>
    <p><strong>Memory Step Dataclasses (<code class="language-plaintext highlighter-rouge">memory.py</code>):</strong> Define the structure of log entries.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- File: memory.py (Simplified Step Structures) ---
</span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Dict</span>

<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">ToolCall</span><span class="p">:</span> <span class="c1"># Represents a tool invocation request
</span>    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">arguments</span><span class="p">:</span> <span class="n">Any</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">str</span> <span class="c1"># Unique ID for matching responses
</span>
<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">MemoryStep</span><span class="p">:</span> <span class="c1"># Base class for all memory entries
</span>    <span class="k">def</span> <span class="nf">to_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="c1"># Each step type knows how to format itself for the LLM
</span>        <span class="k">raise</span> <span class="nb">NotImplementedError</span>

<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">TaskStep</span><span class="p">(</span><span class="n">MemoryStep</span><span class="p">):</span>
    <span class="n">task</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># ... (potentially images)
</span>    <span class="k">def</span> <span class="nf">to_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="c1"># Format: {"role": "user", "content": [{"type": "text", "text": "New task: ..."}]}
</span>        <span class="c1"># ... simplified ...
</span>        <span class="k">return</span> <span class="p">[{</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"user"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="sa">f</span><span class="s">"New task:</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">task</span><span class="si">}</span><span class="s">"</span><span class="p">}]</span>

<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">ActionStep</span><span class="p">(</span><span class="n">MemoryStep</span><span class="p">):</span>
    <span class="n">step_number</span><span class="p">:</span> <span class="nb">int</span>
    <span class="c1"># model_input_messages: List = None # What was sent to LLM
</span>    <span class="n">model_output</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># LLM's thought/action text
</span>    <span class="n">tool_calls</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">ToolCall</span><span class="p">]</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># Parsed tool calls
</span>    <span class="n">observations</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># Tool results or code output
</span>    <span class="n">error</span><span class="p">:</span> <span class="n">Any</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># Any error encountered
</span>    <span class="c1"># ... other fields like timing ...
</span>
    <span class="k">def</span> <span class="nf">to_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="c1"># Formats the LLM output, tool calls, observations/errors
</span>        <span class="c1"># into messages for the next LLM call.
</span>        <span class="n">messages</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">model_output</span><span class="p">:</span>
             <span class="n">messages</span><span class="p">.</span><span class="n">append</span><span class="p">({</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"assistant"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">model_output</span><span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">tool_calls</span><span class="p">:</span>
             <span class="c1"># Simplified representation
</span>             <span class="n">messages</span><span class="p">.</span><span class="n">append</span><span class="p">({</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"tool_call"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="sa">f</span><span class="s">"Calling: </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">tool_calls</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">name</span><span class="si">}</span><span class="s">(...)"</span><span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">observations</span><span class="p">:</span>
             <span class="n">messages</span><span class="p">.</span><span class="n">append</span><span class="p">({</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"tool_response"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="sa">f</span><span class="s">"Observation:</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">observations</span><span class="si">}</span><span class="s">"</span><span class="p">})</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">error</span><span class="p">:</span>
             <span class="n">messages</span><span class="p">.</span><span class="n">append</span><span class="p">({</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"tool_response"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="sa">f</span><span class="s">"Error:</span><span class="se">\n</span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">error</span><span class="si">}</span><span class="s">"</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">messages</span>

<span class="c1"># ... potentially other step types like SystemPromptStep, PlanningStep ...
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><strong>AgentMemory Class (<code class="language-plaintext highlighter-rouge">memory.py</code>):</strong> Holds the list of steps.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- File: memory.py (Simplified AgentMemory) ---
</span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span>

<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">SystemPromptStep</span><span class="p">(</span><span class="n">MemoryStep</span><span class="p">):</span> <span class="c1"># Simplified
</span>    <span class="n">system_prompt</span><span class="p">:</span> <span class="nb">str</span>
    <span class="k">def</span> <span class="nf">to_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span> <span class="c1"># Simplified
</span>         <span class="k">return</span> <span class="p">[{</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"system"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="bp">self</span><span class="p">.</span><span class="n">system_prompt</span><span class="p">}]</span>

<span class="k">class</span> <span class="nc">AgentMemory</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">system_prompt</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># Initialize with the system prompt
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">system_prompt</span> <span class="o">=</span> <span class="n">SystemPromptStep</span><span class="p">(</span><span class="n">system_prompt</span><span class="o">=</span><span class="n">system_prompt</span><span class="p">)</span>
        <span class="c1"># The main logbook - a list of steps taken
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">steps</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">TaskStep</span><span class="p">,</span> <span class="n">ActionStep</span><span class="p">,</span> <span class="n">PlanningStep</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Clears the memory for a new run."""</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">steps</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">replay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">logger</span><span class="p">,</span> <span class="n">detailed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="bp">False</span><span class="p">):</span>
         <span class="s">"""Utility to print the memory steps nicely."""</span>
         <span class="c1"># ... implementation uses logger to print each step ...
</span>         <span class="k">pass</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p><strong>Agent Using Memory (<code class="language-plaintext highlighter-rouge">agents.py</code>):</strong> How <code class="language-plaintext highlighter-rouge">MultiStepAgent</code> reads and writes.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- File: agents.py (Simplified MultiStepAgent interactions) ---
</span><span class="kn">from</span> <span class="nn">.memory</span> <span class="kn">import</span> <span class="n">AgentMemory</span><span class="p">,</span> <span class="n">TaskStep</span><span class="p">,</span> <span class="n">ActionStep</span><span class="p">,</span> <span class="n">ToolCall</span> <span class="c1"># Import memory components
</span>
<span class="k">class</span> <span class="nc">MultiStepAgent</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">...,</span> <span class="n">memory</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AgentMemory</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="c1"># ... setup model, tools ...
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">system_prompt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">initialize_system_prompt</span><span class="p">()</span> <span class="c1"># Define system prompt
</span>        <span class="c1"># Create the memory instance
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">memory</span> <span class="o">=</span> <span class="n">memory</span> <span class="k">if</span> <span class="n">memory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="n">AgentMemory</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">system_prompt</span><span class="p">)</span>
        <span class="c1"># ... setup logger, monitor ...
</span>
    <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="p">...):</span>
        <span class="c1"># ... setup ...
</span>        <span class="k">if</span> <span class="n">reset</span><span class="p">:</span> <span class="c1"># Option to clear memory before a new run
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c1"># Record the initial task in memory
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">steps</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">TaskStep</span><span class="p">(</span><span class="n">task</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">task</span><span class="p">))</span>

        <span class="c1"># Start the internal execution loop (_run)
</span>        <span class="c1"># ... calls _run ...
</span>        <span class="n">final_result</span> <span class="o">=</span> <span class="c1"># ... get result from _run ...
</span>        <span class="k">return</span> <span class="n">final_result</span>

    <span class="k">def</span> <span class="nf">_run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">max_steps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="p">...)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">:</span>
        <span class="c1"># ... loop initialization ...
</span>        <span class="k">while</span> <span class="n">final_answer</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="p">.</span><span class="n">step_number</span> <span class="o">&lt;=</span> <span class="n">max_steps</span><span class="p">:</span>
            <span class="c1"># ... (handle planning steps if enabled) ...
</span>
            <span class="c1"># Create a placeholder for the current step's data
</span>            <span class="n">action_step</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_create_action_step</span><span class="p">(...)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># === Execute one step (Think -&gt; Act -&gt; Observe) ===
</span>                <span class="c1"># This method internally calls write_memory_to_messages,
</span>                <span class="c1"># calls the model, executes the tool, and populates
</span>                <span class="c1"># the 'action_step' object with results.
</span>                <span class="n">final_answer</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_execute_step</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">action_step</span><span class="p">)</span>

            <span class="k">except</span> <span class="n">AgentError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="c1"># Record errors in the memory step
</span>                <span class="n">action_step</span><span class="p">.</span><span class="n">error</span> <span class="o">=</span> <span class="n">e</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="c1"># Finalize timing etc. for the step
</span>                <span class="bp">self</span><span class="p">.</span><span class="n">_finalize_step</span><span class="p">(</span><span class="n">action_step</span><span class="p">,</span> <span class="p">...)</span>
                <span class="c1"># === Store the completed step in memory ===
</span>                <span class="bp">self</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">steps</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">action_step</span><span class="p">)</span>
                <span class="c1"># ... yield step details ...
</span>                <span class="bp">self</span><span class="p">.</span><span class="n">step_number</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># ... handle finish ...
</span>        <span class="k">yield</span> <span class="n">FinalAnswerStep</span><span class="p">(</span><span class="n">final_answer</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">write_memory_to_messages</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">summary_mode</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
        <span class="s">"""
        Reads history from memory and formats it for the LLM.
        """</span>
        <span class="n">messages</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">system_prompt</span><span class="p">.</span><span class="n">to_messages</span><span class="p">(</span><span class="n">summary_mode</span><span class="o">=</span><span class="n">summary_mode</span><span class="p">)</span>
        <span class="c1"># Go through each step recorded in memory
</span>        <span class="k">for</span> <span class="n">memory_step</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">memory</span><span class="p">.</span><span class="n">steps</span><span class="p">:</span>
            <span class="c1"># Ask each step to format itself into messages
</span>            <span class="n">messages</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">memory_step</span><span class="p">.</span><span class="n">to_messages</span><span class="p">(</span><span class="n">summary_mode</span><span class="o">=</span><span class="n">summary_mode</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">messages</span>

    <span class="k">def</span> <span class="nf">_execute_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">task</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">memory_step</span><span class="p">:</span> <span class="n">ActionStep</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">logger</span><span class="p">.</span><span class="n">log_rule</span><span class="p">(</span><span class="sa">f</span><span class="s">"Step </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">step_number</span><span class="si">}</span><span class="s">"</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">LogLevel</span><span class="p">.</span><span class="n">INFO</span><span class="p">)</span>
        <span class="c1"># === THINK ===
</span>        <span class="c1"># 1. Get history from memory
</span>        <span class="n">messages_for_llm</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">write_memory_to_messages</span><span class="p">()</span>
        <span class="n">memory_step</span><span class="p">.</span><span class="n">model_input_messages</span> <span class="o">=</span> <span class="n">messages_for_llm</span> <span class="c1"># Record input to LLM
</span>
        <span class="c1"># 2. Call the LLM brain
</span>        <span class="n">llm_response</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">model</span><span class="p">(</span><span class="n">messages_for_llm</span><span class="p">,</span> <span class="p">...)</span> <span class="c1"># Call Model Interface
</span>        <span class="n">memory_step</span><span class="p">.</span><span class="n">model_output_message</span> <span class="o">=</span> <span class="n">llm_response</span> <span class="c1"># Record LLM response
</span>
        <span class="c1"># 3. Parse LLM response for action
</span>        <span class="c1"># (Specific parsing logic depends on AgentType - ToolCallingAgent, CodeAgent)
</span>        <span class="n">tool_name</span><span class="p">,</span> <span class="n">arguments</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_parse_action</span><span class="p">(</span><span class="n">llm_response</span><span class="p">)</span> <span class="c1"># Simplified
</span>        <span class="n">memory_step</span><span class="p">.</span><span class="n">tool_calls</span> <span class="o">=</span> <span class="p">[</span><span class="n">ToolCall</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">tool_name</span><span class="p">,</span> <span class="n">arguments</span><span class="o">=</span><span class="n">arguments</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="p">...)]</span>

        <span class="c1"># === ACT &amp; OBSERVE ===
</span>        <span class="c1"># 4. Execute the action (tool call or code)
</span>        <span class="n">observation</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_execute_action</span><span class="p">(</span><span class="n">tool_name</span><span class="p">,</span> <span class="n">arguments</span><span class="p">)</span> <span class="c1"># Simplified
</span>
        <span class="c1"># 5. Record observation
</span>        <span class="n">memory_step</span><span class="p">.</span><span class="n">observations</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">observation</span><span class="p">)</span>

        <span class="c1"># 6. Check if it's the final answer
</span>        <span class="k">if</span> <span class="n">tool_name</span> <span class="o">==</span> <span class="s">"final_answer"</span><span class="p">:</span>
             <span class="k">return</span> <span class="n">observation</span> <span class="c1"># Return the final answer to stop the loop
</span>        <span class="k">else</span><span class="p">:</span>
             <span class="k">return</span> <span class="bp">None</span> <span class="c1"># Continue to the next step
</span>
    <span class="c1"># ... other methods like _create_action_step, _finalize_step ...
</span></code></pre></div>    </div>
  </li>
</ul>

<p><strong>Key Takeaways from Code:</strong></p>
<ul>
  <li>Memory holds a list of <code class="language-plaintext highlighter-rouge">Step</code> objects (<code class="language-plaintext highlighter-rouge">self.memory.steps</code>).</li>
  <li>The agent adds new <code class="language-plaintext highlighter-rouge">TaskStep</code> or <code class="language-plaintext highlighter-rouge">ActionStep</code> objects to this list as it progresses (<code class="language-plaintext highlighter-rouge">self.memory.steps.append(...)</code>).</li>
  <li>Before calling the LLM, <code class="language-plaintext highlighter-rouge">write_memory_to_messages</code> iterates through <code class="language-plaintext highlighter-rouge">self.memory.steps</code>, calling <code class="language-plaintext highlighter-rouge">to_messages()</code> on each step to build the history.</li>
  <li>Each step (like <code class="language-plaintext highlighter-rouge">ActionStep</code>) stores details like the LLM‚Äôs output (<code class="language-plaintext highlighter-rouge">model_output</code>), tool calls (<code class="language-plaintext highlighter-rouge">tool_calls</code>), and results (<code class="language-plaintext highlighter-rouge">observations</code> or <code class="language-plaintext highlighter-rouge">error</code>).</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p><code class="language-plaintext highlighter-rouge">AgentMemory</code> is the agent‚Äôs essential logbook, providing the context needed to navigate complex, multi-step tasks. It diligently records the initial task, system instructions, and every action, observation, and error along the way.</p>

<p>You‚Äôve learned:</p>

<ul>
  <li>Why memory is crucial for agents (avoiding amnesia).</li>
  <li>The ‚Äúship‚Äôs logbook‚Äù analogy.</li>
  <li>What kind of information <code class="language-plaintext highlighter-rouge">AgentMemory</code> stores (task, system prompt, steps with thoughts, actions, observations, errors).</li>
  <li>How the <code class="language-plaintext highlighter-rouge">MultiStepAgent</code> uses memory automatically: reading history before thinking, and writing results after acting/observing.</li>
  <li>The basic structure of <code class="language-plaintext highlighter-rouge">AgentMemory</code> and its <code class="language-plaintext highlighter-rouge">Step</code> objects (<code class="language-plaintext highlighter-rouge">TaskStep</code>, <code class="language-plaintext highlighter-rouge">ActionStep</code>).</li>
</ul>

<p>While you often don‚Äôt need to manipulate memory directly, understanding its role is key to understanding how agents maintain context and achieve complex goals. The content of this memory directly influences the prompts sent to the LLM. How can we customize those prompts? Let‚Äôs find out!</p>

<p><strong>Next Chapter:</strong> <a href="05_prompttemplates.md">Chapter 5: PromptTemplates</a> - Customizing Your Agent‚Äôs Instructions.</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
