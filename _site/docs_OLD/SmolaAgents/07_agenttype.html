<h1 id="chapter-7-agenttype---handling-more-than-just-text">Chapter 7: AgentType - Handling More Than Just Text</h1>

<p>Welcome back! In the previous chapters, especially when discussing <a href="03_tool.md">Tools</a> and the <a href="06_pythonexecutor.md">PythonExecutor</a>, we saw how agents can perform actions and generate results. So far, we’ve mostly focused on text-based tasks and results.</p>

<p>But what happens when an agent needs to work with images, audio, or other types of data? For example:</p>
<ul>
  <li>An agent uses a tool to generate an image based on a description.</li>
  <li>An agent uses a tool to transcribe an audio file into text.</li>
  <li>An agent receives an image as input and needs to describe it.</li>
</ul>

<p>How does the <code class="language-plaintext highlighter-rouge">SmolaAgents</code> framework handle these different kinds of data consistently? How does it make sure an image generated by a tool is displayed correctly in your notebook, or saved properly in the agent’s <a href="04_agentmemory.md">Memory</a>?</p>

<p>This is where the <strong><code class="language-plaintext highlighter-rouge">AgentType</code></strong> concept comes in!</p>

<h2 id="the-problem-shipping-different-kinds-of-cargo">The Problem: Shipping Different Kinds of Cargo</h2>

<p>Imagine you run a shipping company. Most of the time, you ship standard boxes (like text). But sometimes, customers need to ship different things:</p>
<ul>
  <li>Fresh produce that needs a refrigerated container (like audio data).</li>
  <li>Large machinery that needs a flatbed truck (like image data).</li>
</ul>

<p>You can’t just stuff the fresh produce into a standard box – it would spoil! And the machinery won’t even fit. You need specialized containers designed for specific types of cargo.</p>

<p><img src="https://img.icons8.com/plasticine/100/shipping-container.png" alt="Standard Box vs Specialized Containers" /> <img src="https://img.icons8.com/plasticine/100/temperature-sensitive.png" alt="Standard Box vs Specialized Containers" /> <img src="https://img.icons8.com/plasticine/100/image-file.png" alt="Standard Box vs Specialized Containers" /></p>

<p>Similarly, our agents need a way to handle data beyond simple text strings. Using Python’s built-in types directly (like a raw <code class="language-plaintext highlighter-rouge">PIL.Image</code> object for images) can cause problems:</p>
<ul>
  <li><strong>How do you display it?</strong> A raw image object doesn’t automatically show up as a picture in a Jupyter notebook.</li>
  <li><strong>How do you save it?</strong> How do you store an image or audio clip in the agent’s text-based <a href="04_agentmemory.md">Memory</a> log? You can’t just put the raw image data there.</li>
  <li><strong>How do you pass it around?</strong> How does the framework ensure different components (tools, agent core, memory) know how to handle these different data types consistently?</li>
</ul>

<h2 id="the-solution-specialized-data-containers-agenttype">The Solution: Specialized Data Containers (<code class="language-plaintext highlighter-rouge">AgentType</code>)</h2>

<p><code class="language-plaintext highlighter-rouge">SmolaAgents</code> introduces special “data containers” to solve this problem. These are custom data types that inherit from a base <code class="language-plaintext highlighter-rouge">AgentType</code> class:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">AgentText</code></strong>: For handling plain text. It behaves just like a standard Python string.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">AgentImage</code></strong>: For handling images (usually as <code class="language-plaintext highlighter-rouge">PIL.Image</code> objects).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">AgentAudio</code></strong>: For handling audio data (often as <code class="language-plaintext highlighter-rouge">torch.Tensor</code> or file paths).</li>
</ul>

<p>Think of these as the specialized shipping containers:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AgentText</code> is like the standard shipping box.</li>
  <li><code class="language-plaintext highlighter-rouge">AgentImage</code> is like a container designed to safely transport and display pictures.</li>
  <li><code class="language-plaintext highlighter-rouge">AgentAudio</code> is like a container designed to safely transport and play audio clips.</li>
</ul>

<p>These <code class="language-plaintext highlighter-rouge">AgentType</code> objects <strong>wrap</strong> the actual data (the string, the image object, the audio data) but add extra capabilities.</p>

<h2 id="why-use-agenttype-the-benefits">Why Use <code class="language-plaintext highlighter-rouge">AgentType</code>? (The Benefits)</h2>

<p>Using these specialized containers gives us several advantages:</p>

<ol>
  <li><strong>Consistent Handling:</strong> The <code class="language-plaintext highlighter-rouge">SmolaAgents</code> framework knows how to recognize and work with <code class="language-plaintext highlighter-rouge">AgentType</code> objects, regardless of whether they contain text, images, or audio.</li>
  <li><strong>Smart Display:</strong> Objects like <code class="language-plaintext highlighter-rouge">AgentImage</code> and <code class="language-plaintext highlighter-rouge">AgentAudio</code> know how to display themselves correctly in environments like Jupyter notebooks or Gradio interfaces. For example, an <code class="language-plaintext highlighter-rouge">AgentImage</code> will automatically render as an image, not just print <code class="language-plaintext highlighter-rouge">&lt;PIL.Image.Image ...&gt;</code>.</li>
  <li><strong>Proper Serialization:</strong> They know how to convert themselves into a string representation suitable for logging or storing in <a href="04_agentmemory.md">Memory</a>.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">AgentText</code> simply returns its string content.</li>
      <li><code class="language-plaintext highlighter-rouge">AgentImage</code> automatically saves the image to a temporary file and returns the <em>path</em> to that file when converted to a string (<code class="language-plaintext highlighter-rouge">to_string()</code> method). This path can be safely logged.</li>
      <li><code class="language-plaintext highlighter-rouge">AgentAudio</code> does something similar for audio data, saving it to a temporary <code class="language-plaintext highlighter-rouge">.wav</code> file.</li>
    </ul>
  </li>
  <li><strong>Clear Communication:</strong> Tools can clearly state what type of output they produce (e.g., <code class="language-plaintext highlighter-rouge">output_type="image"</code>), and the framework ensures the output is wrapped correctly.</li>
</ol>

<h2 id="how-is-agenttype-used-mostly-automatic">How is <code class="language-plaintext highlighter-rouge">AgentType</code> Used? (Mostly Automatic!)</h2>

<p>The best part is that you often don’t need to manually create or handle these <code class="language-plaintext highlighter-rouge">AgentType</code> objects. The framework does the heavy lifting.</p>

<p><strong>Scenario 1: A Tool Returning an Image</strong></p>

<p>Imagine you have a tool that generates images using a library like <code class="language-plaintext highlighter-rouge">diffusers</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- File: image_tool.py ---
</span><span class="kn">from</span> <span class="nn">smolagents</span> <span class="kn">import</span> <span class="n">Tool</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="c1"># Assume 'diffusion_pipeline' is a pre-loaded image generation model
# from diffusers import DiffusionPipeline
# diffusion_pipeline = DiffusionPipeline.from_pretrained(...)
</span>
<span class="k">class</span> <span class="nc">ImageGeneratorTool</span><span class="p">(</span><span class="n">Tool</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"image_generator"</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"Generates an image based on a text prompt."</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">"prompt"</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">"type"</span><span class="p">:</span> <span class="s">"string"</span><span class="p">,</span>
            <span class="s">"description"</span><span class="p">:</span> <span class="s">"The text description for the image."</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1"># Tell the framework this tool outputs an image!
</span>    <span class="n">output_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"image"</span> <span class="c1"># &lt;--- Crucial Hint!
</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prompt</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Image</span><span class="p">.</span><span class="n">Image</span><span class="p">:</span>
        <span class="s">"""Generates the image using a diffusion model."""</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"--- ImageGeneratorTool generating image for: '</span><span class="si">{</span><span class="n">prompt</span><span class="si">}</span><span class="s">' ---"</span><span class="p">)</span>
        <span class="c1"># image = diffusion_pipeline(prompt).images[0] # Actual generation
</span>        <span class="c1"># For simplicity, let's create a dummy blank image
</span>        <span class="n">image</span> <span class="o">=</span> <span class="n">Image</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="s">'RGB'</span><span class="p">,</span> <span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="n">color</span> <span class="o">=</span> <span class="s">'red'</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"--- Tool returning a PIL Image object ---"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">image</span>

<span class="c1"># --- How the framework uses it (conceptual) ---
</span><span class="n">image_tool</span> <span class="o">=</span> <span class="n">ImageGeneratorTool</span><span class="p">()</span>
<span class="n">prompt</span> <span class="o">=</span> <span class="s">"A red rectangle"</span>
<span class="n">raw_output</span> <span class="o">=</span> <span class="n">image_tool</span><span class="p">(</span><span class="n">prompt</span><span class="o">=</span><span class="n">prompt</span><span class="p">)</span> <span class="c1"># Calls forward(), gets a PIL.Image object
</span>
<span class="c1"># Framework automatically wraps the output because output_type="image"
# Uses handle_agent_output_types(raw_output, output_type="image")
</span><span class="kn">from</span> <span class="nn">smolagents.agent_types</span> <span class="kn">import</span> <span class="n">handle_agent_output_types</span>
<span class="n">wrapped_output</span> <span class="o">=</span> <span class="n">handle_agent_output_types</span><span class="p">(</span><span class="n">raw_output</span><span class="p">,</span> <span class="n">output_type</span><span class="o">=</span><span class="s">"image"</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Raw output type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">raw_output</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Wrapped output type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">wrapped_output</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># When storing in memory or logging, the framework calls to_string()
</span><span class="n">output_string</span> <span class="o">=</span> <span class="n">wrapped_output</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"String representation for logs: </span><span class="si">{</span><span class="n">output_string</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># Expected Output (path will vary):
# --- ImageGeneratorTool generating image for: 'A red rectangle' ---
# --- Tool returning a PIL Image object ---
# Raw output type: &lt;class 'PIL.Image.Image'&gt;
# Wrapped output type: &lt;class 'smolagents.agent_types.AgentImage'&gt;
# String representation for logs: /tmp/tmpxxxxxx/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.png
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li>We define <code class="language-plaintext highlighter-rouge">ImageGeneratorTool</code> and crucially set <code class="language-plaintext highlighter-rouge">output_type="image"</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">forward</code> method does its work and returns a standard <code class="language-plaintext highlighter-rouge">PIL.Image.Image</code> object.</li>
  <li>When the agent framework receives this output, it checks the tool’s <code class="language-plaintext highlighter-rouge">output_type</code>. Since it’s <code class="language-plaintext highlighter-rouge">"image"</code>, it automatically uses the <code class="language-plaintext highlighter-rouge">handle_agent_output_types</code> function (or similar internal logic) to wrap the <code class="language-plaintext highlighter-rouge">PIL.Image.Image</code> object inside an <code class="language-plaintext highlighter-rouge">AgentImage</code> container.</li>
  <li>If this <code class="language-plaintext highlighter-rouge">AgentImage</code> needs to be logged or stored in <a href="04_agentmemory.md">Memory</a>, the framework calls its <code class="language-plaintext highlighter-rouge">to_string()</code> method, which saves the image to a temporary file and returns the file path.</li>
</ol>

<p><strong>Scenario 2: Passing an <code class="language-plaintext highlighter-rouge">AgentType</code> to a Tool</strong></p>

<p>What if an <code class="language-plaintext highlighter-rouge">AgentImage</code> object (maybe retrieved from memory or state) needs to be passed <em>into</em> another tool, perhaps one that analyzes images?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- File: image_analyzer_tool.py ---
</span><span class="kn">from</span> <span class="nn">smolagents</span> <span class="kn">import</span> <span class="n">Tool</span>
<span class="kn">from</span> <span class="nn">PIL</span> <span class="kn">import</span> <span class="n">Image</span>
<span class="kn">from</span> <span class="nn">smolagents.agent_types</span> <span class="kn">import</span> <span class="n">AgentImage</span><span class="p">,</span> <span class="n">handle_agent_input_types</span>

<span class="k">class</span> <span class="nc">ImageAnalyzerTool</span><span class="p">(</span><span class="n">Tool</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"image_analyzer"</span>
    <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"Analyzes an image and returns its dimensions."</span>
    <span class="n">inputs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">"input_image"</span><span class="p">:</span> <span class="p">{</span>
            <span class="s">"type"</span><span class="p">:</span> <span class="s">"image"</span><span class="p">,</span> <span class="c1"># Expects an image type
</span>            <span class="s">"description"</span><span class="p">:</span> <span class="s">"The image to analyze."</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">output_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s">"string"</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_image</span><span class="p">:</span> <span class="n">Image</span><span class="p">.</span><span class="n">Image</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="s">"""Analyzes the image."""</span>
        <span class="c1"># IMPORTANT: input_image here is ALREADY the raw PIL.Image object!
</span>        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"--- ImageAnalyzerTool received image of type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">input_image</span><span class="p">)</span><span class="si">}</span><span class="s"> ---"</span><span class="p">)</span>
        <span class="n">width</span><span class="p">,</span> <span class="n">height</span> <span class="o">=</span> <span class="n">input_image</span><span class="p">.</span><span class="n">size</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s">"Image dimensions are </span><span class="si">{</span><span class="n">width</span><span class="si">}</span><span class="s">x</span><span class="si">{</span><span class="n">height</span><span class="si">}</span><span class="s">."</span>

<span class="c1"># --- How the framework uses it (conceptual) ---
</span><span class="n">analyzer_tool</span> <span class="o">=</span> <span class="n">ImageAnalyzerTool</span><span class="p">()</span>

<span class="c1"># Let's pretend 'agent_image_object' is an AgentImage retrieved from memory
# (It wraps a red PIL.Image.Image object like the one from Scenario 1)
</span><span class="n">agent_image_object</span> <span class="o">=</span> <span class="n">AgentImage</span><span class="p">(</span><span class="n">Image</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="s">'RGB'</span><span class="p">,</span> <span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="n">color</span> <span class="o">=</span> <span class="s">'red'</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Input object type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">agent_image_object</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># Framework automatically unwraps the input before calling 'forward'
# Uses handle_agent_input_types(input_image=agent_image_object)
# args_tuple, kwargs_dict = handle_agent_input_types(input_image=agent_image_object)
# result = analyzer_tool.forward(**kwargs_dict) # Simplified conceptual call
</span>
<span class="c1"># Simulate the unwrapping and call:
</span><span class="n">raw_image</span> <span class="o">=</span> <span class="n">agent_image_object</span><span class="p">.</span><span class="n">to_raw</span><span class="p">()</span> <span class="c1"># Get the underlying PIL Image
</span><span class="n">result</span> <span class="o">=</span> <span class="n">analyzer_tool</span><span class="p">.</span><span class="n">forward</span><span class="p">(</span><span class="n">input_image</span><span class="o">=</span><span class="n">raw_image</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Analysis result: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># Expected Output:
# Input object type: &lt;class 'smolagents.agent_types.AgentImage'&gt;
# --- ImageAnalyzerTool received image of type: &lt;class 'PIL.Image.Image'&gt; ---
# Analysis result: Image dimensions are 60x30.
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">ImageAnalyzerTool</code> defines its input <code class="language-plaintext highlighter-rouge">input_image</code> as type <code class="language-plaintext highlighter-rouge">"image"</code>. Its <code class="language-plaintext highlighter-rouge">forward</code> method expects a standard <code class="language-plaintext highlighter-rouge">PIL.Image.Image</code>.</li>
  <li>We have an <code class="language-plaintext highlighter-rouge">AgentImage</code> object (maybe from a previous step).</li>
  <li>When the framework prepares to call <code class="language-plaintext highlighter-rouge">analyzer_tool.forward</code>, it sees that the input <code class="language-plaintext highlighter-rouge">agent_image_object</code> is an <code class="language-plaintext highlighter-rouge">AgentType</code>. It uses <code class="language-plaintext highlighter-rouge">handle_agent_input_types</code> (or similar logic) to automatically call the <code class="language-plaintext highlighter-rouge">.to_raw()</code> method on <code class="language-plaintext highlighter-rouge">agent_image_object</code>.</li>
  <li>This <code class="language-plaintext highlighter-rouge">to_raw()</code> method extracts the underlying <code class="language-plaintext highlighter-rouge">PIL.Image.Image</code> object.</li>
  <li>The framework passes this <em>raw</em> image object to the <code class="language-plaintext highlighter-rouge">forward</code> method. The tool developer doesn’t need to worry about unwrapping the <code class="language-plaintext highlighter-rouge">AgentType</code> inside their tool logic.</li>
</ol>

<h2 id="under-the-hood-a-peek-at-the-code">Under the Hood: A Peek at the Code</h2>

<p>Let’s look at simplified versions of the <code class="language-plaintext highlighter-rouge">AgentType</code> classes and helper functions from <code class="language-plaintext highlighter-rouge">agent_types.py</code>.</p>

<ul>
  <li>
    <p><strong>Base <code class="language-plaintext highlighter-rouge">AgentType</code> Class:</strong></p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- File: agent_types.py (Simplified AgentType) ---
</span><span class="kn">import</span> <span class="nn">logging</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="p">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">AgentType</span><span class="p">:</span>
    <span class="s">"""Abstract base class for custom agent data types."""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># Stores the actual data (string, PIL Image, etc.)
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Default string conversion uses the to_string method
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">to_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Returns the underlying raw Python object."""</span>
        <span class="n">logger</span><span class="p">.</span><span class="n">error</span><span class="p">(</span><span class="s">"to_raw() called on base AgentType!"</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_value</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="s">"""Returns a string representation suitable for logging/memory."""</span>
        <span class="n">logger</span><span class="p">.</span><span class="n">error</span><span class="p">(</span><span class="s">"to_string() called on base AgentType!"</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_value</span><span class="p">)</span>

    <span class="c1"># Other potential common methods...
</span></code></pre></div>    </div>
    <ul>
      <li>It holds the original <code class="language-plaintext highlighter-rouge">_value</code>.</li>
      <li>Defines the basic methods <code class="language-plaintext highlighter-rouge">to_raw</code> and <code class="language-plaintext highlighter-rouge">to_string</code> that subclasses will implement properly.</li>
    </ul>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">AgentImage</code> Implementation:</strong></p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- File: agent_types.py (Simplified AgentImage) ---
</span><span class="kn">import</span> <span class="nn">PIL.Image</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">tempfile</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>

<span class="k">class</span> <span class="nc">AgentImage</span><span class="p">(</span><span class="n">AgentType</span><span class="p">):</span> <span class="c1"># Doesn't inherit from PIL.Image directly in reality, but conceptually similar
</span>    <span class="s">"""Handles image data, behaving like a PIL.Image."""</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="c1"># value can be PIL.Image, path string, bytes, etc.
</span>        <span class="n">AgentType</span><span class="p">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="c1"># Store original value form
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_raw_image</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># To store the loaded PIL Image
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_path</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># To store the path if saved to temp file
</span>
        <span class="c1"># Logic to load image from different input types (simplified)
</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">PIL</span><span class="p">.</span><span class="n">Image</span><span class="p">.</span><span class="n">Image</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">_raw_image</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">os</span><span class="p">.</span><span class="n">PathLike</span><span class="p">)):</span>
             <span class="c1"># We might load it lazily later in to_raw()
</span>             <span class="bp">self</span><span class="p">.</span><span class="n">_path</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="c1"># Assume it's already a path
</span>             <span class="c1"># In reality, it loads here if path exists
</span>        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
             <span class="bp">self</span><span class="p">.</span><span class="n">_raw_image</span> <span class="o">=</span> <span class="n">PIL</span><span class="p">.</span><span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="c1"># ... (handle tensors, etc.) ...
</span>        <span class="k">else</span><span class="p">:</span>
             <span class="k">raise</span> <span class="nb">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s">"Unsupported type for AgentImage: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">to_raw</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">PIL</span><span class="p">.</span><span class="n">Image</span><span class="p">.</span><span class="n">Image</span><span class="p">:</span>
        <span class="s">"""Returns the raw PIL.Image.Image object."""</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">_raw_image</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># Lazy loading if initialized with a path
</span>            <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">_path</span> <span class="ow">and</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_path</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">.</span><span class="n">_raw_image</span> <span class="o">=</span> <span class="n">PIL</span><span class="p">.</span><span class="n">Image</span><span class="p">.</span><span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_path</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                 <span class="c1"># Handle error or create placeholder
</span>                 <span class="k">raise</span> <span class="nb">ValueError</span><span class="p">(</span><span class="s">"Cannot get raw image data."</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_raw_image</span>

    <span class="k">def</span> <span class="nf">to_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="s">"""Saves image to temp file (if needed) and returns the path."""</span>
        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">_path</span> <span class="ow">and</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_path</span><span class="p">):</span>
            <span class="c1"># Already have a path (e.g., loaded from file initially)
</span>            <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_path</span>

        <span class="c1"># Need to save the raw image data to a temp file
</span>        <span class="n">raw_img</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">to_raw</span><span class="p">()</span> <span class="c1"># Ensure image is loaded
</span>        <span class="n">directory</span> <span class="o">=</span> <span class="n">tempfile</span><span class="p">.</span><span class="n">mkdtemp</span><span class="p">()</span>
        <span class="c1"># Generate a unique filename
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_path</span> <span class="o">=</span> <span class="n">os</span><span class="p">.</span><span class="n">path</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="p">.</span><span class="n">uuid4</span><span class="p">())</span> <span class="o">+</span> <span class="s">".png"</span><span class="p">)</span>
        <span class="n">raw_img</span><span class="p">.</span><span class="n">save</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">_path</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s">"png"</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"--- AgentImage saved to temp file: </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">_path</span><span class="si">}</span><span class="s"> ---"</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">_path</span>

    <span class="k">def</span> <span class="nf">_ipython_display_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Special method for display in Jupyter/IPython."""</span>
        <span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span>
        <span class="n">display</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">to_raw</span><span class="p">())</span> <span class="c1"># Display the raw PIL image
</span>
    <span class="c1"># We can also make AgentImage behave like PIL.Image by delegating methods
</span>    <span class="c1"># (e.g., using __getattr__ or explicit wrappers)
</span>    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
         <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">to_raw</span><span class="p">().</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
         <span class="bp">self</span><span class="p">.</span><span class="n">to_raw</span><span class="p">().</span><span class="n">save</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># ... other PIL.Image methods ...
</span></code></pre></div>    </div>
    <ul>
      <li>It can be initialized with various image sources (PIL object, path, bytes).</li>
      <li><code class="language-plaintext highlighter-rouge">to_raw()</code> ensures a PIL Image object is returned, loading from disk if necessary.</li>
      <li><code class="language-plaintext highlighter-rouge">to_string()</code> saves the image to a temporary PNG file if it doesn’t already have a path, and returns that path.</li>
      <li><code class="language-plaintext highlighter-rouge">_ipython_display_</code> allows Jupyter notebooks to automatically display the image.</li>
      <li>It can delegate common image methods (like <code class="language-plaintext highlighter-rouge">.size</code>, <code class="language-plaintext highlighter-rouge">.save</code>) to the underlying raw image.</li>
    </ul>
  </li>
  <li>
    <p><strong>Helper Functions (Conceptual):</strong></p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># --- File: agent_types.py / agents.py (Simplified Helpers) ---
</span>
<span class="c1"># Mapping from type name string to AgentType class
</span><span class="n">_AGENT_TYPE_MAPPING</span> <span class="o">=</span> <span class="p">{</span><span class="s">"string"</span><span class="p">:</span> <span class="n">AgentText</span><span class="p">,</span> <span class="s">"image"</span><span class="p">:</span> <span class="n">AgentImage</span><span class="p">,</span> <span class="s">"audio"</span><span class="p">:</span> <span class="n">AgentAudio</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">handle_agent_output_types</span><span class="p">(</span><span class="n">output</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">output_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
    <span class="s">"""Wraps raw output into an AgentType if needed."""</span>
    <span class="k">if</span> <span class="n">output_type</span> <span class="ow">in</span> <span class="n">_AGENT_TYPE_MAPPING</span><span class="p">:</span>
        <span class="c1"># If the tool explicitly defines output type (e.g., "image")
</span>        <span class="n">wrapper_class</span> <span class="o">=</span> <span class="n">_AGENT_TYPE_MAPPING</span><span class="p">[</span><span class="n">output_type</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">wrapper_class</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If no type defined, try to guess based on Python type (optional)
</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">AgentText</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">PIL</span><span class="p">.</span><span class="n">Image</span><span class="p">.</span><span class="n">Image</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">AgentImage</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="c1"># ... add checks for audio tensors etc. ...
</span>
        <span class="c1"># Otherwise, return the output as is
</span>        <span class="k">return</span> <span class="n">output</span>

<span class="k">def</span> <span class="nf">handle_agent_input_types</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
    <span class="s">"""Unwraps AgentType inputs into raw types before passing to a tool."""</span>
    <span class="n">processed_args</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
        <span class="c1"># If it's an AgentType instance, call to_raw(), otherwise keep as is
</span>        <span class="n">processed_args</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">to_raw</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">AgentType</span><span class="p">)</span> <span class="k">else</span> <span class="n">arg</span><span class="p">)</span>

    <span class="n">processed_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">processed_kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="n">to_raw</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">AgentType</span><span class="p">)</span> <span class="k">else</span> <span class="n">value</span>

    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">processed_args</span><span class="p">),</span> <span class="n">processed_kwargs</span>
</code></pre></div>    </div>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">handle_agent_output_types</code> checks the tool’s <code class="language-plaintext highlighter-rouge">output_type</code> or the actual Python type of the output and wraps it in the corresponding <code class="language-plaintext highlighter-rouge">AgentType</code> class (e.g., <code class="language-plaintext highlighter-rouge">AgentImage</code>).</li>
      <li><code class="language-plaintext highlighter-rouge">handle_agent_input_types</code> iterates through arguments, checks if any are <code class="language-plaintext highlighter-rouge">AgentType</code> instances, and calls <code class="language-plaintext highlighter-rouge">.to_raw()</code> on them to get the underlying data before the tool’s <code class="language-plaintext highlighter-rouge">forward</code> method is called.</li>
    </ul>
  </li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p><code class="language-plaintext highlighter-rouge">AgentType</code> (<code class="language-plaintext highlighter-rouge">AgentText</code>, <code class="language-plaintext highlighter-rouge">AgentImage</code>, <code class="language-plaintext highlighter-rouge">AgentAudio</code>) provides a crucial layer for handling diverse data types within the <code class="language-plaintext highlighter-rouge">SmolaAgents</code> framework. They act as specialized containers that ensure non-text data can be consistently processed, displayed correctly (especially in notebooks), and serialized appropriately for logging and memory.</p>

<p>You’ve learned:</p>

<ul>
  <li>Why standard Python types aren’t always enough for agent inputs/outputs.</li>
  <li>The “specialized shipping container” analogy for <code class="language-plaintext highlighter-rouge">AgentType</code>.</li>
  <li>The benefits: consistent handling, smart display, and proper serialization (like saving images/audio to temp files).</li>
  <li>How the framework automatically wraps tool outputs (<code class="language-plaintext highlighter-rouge">handle_agent_output_types</code>) and unwraps tool inputs (<code class="language-plaintext highlighter-rouge">handle_agent_input_types</code>).</li>
  <li>Seen simplified code examples for <code class="language-plaintext highlighter-rouge">AgentImage</code> and the helper functions.</li>
</ul>

<p>By using <code class="language-plaintext highlighter-rouge">AgentType</code>, <code class="language-plaintext highlighter-rouge">SmolaAgents</code> makes it much easier to build agents that can work seamlessly with multi-modal data like images and audio, without you having to manually handle the complexities of display and serialization in most cases.</p>

<p>Now that we understand how agents handle different data types, how can we keep track of everything the agent is doing, monitor its performance, and debug issues?</p>

<p><strong>Next Chapter:</strong> <a href="08_agentlogger___monitor.md">Chapter 8: AgentLogger &amp; Monitor</a> - Observing Your Agent in Action.</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
