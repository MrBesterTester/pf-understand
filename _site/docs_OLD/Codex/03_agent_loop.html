<h1 id="chapter-3-agent-loop">Chapter 3: Agent Loop</h1>

<p>In the <a href="02_input_handling__textbuffer_editor_.md">previous chapter</a>, we saw how Codex captures your commands and messages using a neat multi-line input editor. But once you hit Enter, where does that input <em>go</em>? What part of Codex actually understands your request, talks to the AI, and makes things happen?</p>

<p>Meet the <strong>Agent Loop</strong>, the heart and brain of the Codex CLI.</p>

<h2 id="whats-the-big-idea-like-a-helpful-assistant">What’s the Big Idea? Like a Helpful Assistant</h2>

<p>Imagine you have a very capable personal assistant. You give them a task, like “Find the latest sales report, summarize it, and email it to the team.” Your assistant doesn’t just magically do it all at once. They follow a process:</p>

<ol>
  <li><strong>Understand the Request:</strong> Listen carefully to what you asked for.</li>
  <li><strong>Gather Information:</strong> Look for the sales report file.</li>
  <li><strong>Perform Actions:</strong> Read the report, write a summary.</li>
  <li><strong>Ask for Confirmation (if needed):</strong> “I’ve drafted the summary and email. Should I send it now?”</li>
  <li><strong>Complete the Task:</strong> Send the email after getting your ‘yes’.</li>
  <li><strong>Report Back:</strong> Let you know the email has been sent.</li>
</ol>

<p>The <strong>Agent Loop</strong> in Codex acts much like this assistant. It’s the central piece of logic that manages the entire conversation and workflow between you and the AI model (like OpenAI’s GPT-4).</p>

<p>Let’s take our simple example: You type <code class="language-plaintext highlighter-rouge">codex "write a python script that prints hello world and run it"</code>.</p>

<p>The Agent Loop is responsible for:</p>

<ol>
  <li>Taking your input (“write a python script…”).</li>
  <li>Sending this request to the powerful AI model via the OpenAI API.</li>
  <li>Getting the AI’s response, which might include:
    <ul>
      <li>Text: “Okay, here’s the script…”</li>
      <li>A request to perform an action (a “function call”): “I need to run this command: <code class="language-plaintext highlighter-rouge">python -c 'print(\"hello world\")'</code>”</li>
    </ul>
  </li>
  <li>Showing you the text part of the response in the <a href="01_terminal_ui__ink_components_.md">Terminal UI</a>.</li>
  <li>Handling the “function call”:
    <ul>
      <li>Checking if it needs your permission based on the <a href="04_approval_policy___security.md">Approval Policy</a>.</li>
      <li>If needed, asking you “Allow command?” via the UI.</li>
      <li>If approved, actually running the command using the <a href="06_command_execution___sandboxing.md">Command Execution &amp; Sandboxing</a> system.</li>
    </ul>
  </li>
  <li>Getting the result of the command (the output “hello world”).</li>
  <li>Sending that result back to the AI (“I ran the command, and it printed ‘hello world’”).</li>
  <li>Getting the AI’s final response (maybe: “Great, the script ran successfully!”).</li>
  <li>Showing you the final response.</li>
  <li>Updating the conversation history with everything that happened.</li>
</ol>

<p>It’s called a “loop” because it often goes back and forth between you, the AI, and tools (like the command line) until your request is fully handled.</p>

<h2 id="how-it-works-the-conversation-cycle">How It Works: The Conversation Cycle</h2>

<p>The Agent Loop orchestrates a cycle:</p>

<pre><code class="language-mermaid">graph TD
    A[User Input] --&gt; B[Agent Loop]
    B --&gt; C{Send to AI Model}
    C --&gt; D[AI Response: Text or Tool Call]
    D --&gt; B
    B --&gt; E{Process Response}
    E -- Text --&gt; F[Show Text in UI]
    E -- Tool Call --&gt; G{Handle Tool Call}
    G --&gt; H{Needs Approval?}
    H -- Yes --&gt; I[Ask User via UI]
    I --&gt; J{User Approves?}
    H -- No --&gt; K[Execute Tool]
    J -- Yes --&gt; K
    J -- No --&gt; L[Report Denial to AI]
    K --&gt; M[Get Tool Result]
    M --&gt; B
    L --&gt; B
    F --&gt; N[Update History]
    M --&gt; N
    L --&gt; N
    N --&gt; O[Ready for next Input/Step]
</code></pre>

<ol>
  <li><strong>Input:</strong> Gets input from you (via the <a href="02_input_handling__textbuffer_editor_.md">Input Handling</a>).</li>
  <li><strong>AI Call:</strong> Sends the current conversation state (including your latest input and any previous steps) to the AI model (OpenAI API).</li>
  <li><strong>Response Processing:</strong> Receives the AI’s response. This could be simple text, or it could include a request to use a tool (like running a shell command). This is covered more in <a href="05_response___tool_call_handling.md">Response &amp; Tool Call Handling</a>.</li>
  <li><strong>Tool Handling:</strong> If the AI requested a tool:
    <ul>
      <li>Check the <a href="04_approval_policy___security.md">Approval Policy</a>.</li>
      <li>Potentially ask you for confirmation via the <a href="01_terminal_ui__ink_components_.md">Terminal UI</a>.</li>
      <li>If approved, execute the tool via <a href="06_command_execution___sandboxing.md">Command Execution &amp; Sandboxing</a>.</li>
      <li>Package the tool’s result (e.g., command output) to send back to the AI in the next step.</li>
    </ul>
  </li>
  <li><strong>Update State:</strong> Adds the AI’s message and any tool results to the conversation history. Shows updates in the UI.</li>
  <li><strong>Loop:</strong> If the task isn’t finished (e.g., because a tool was used and the AI needs to react to the result), it sends the updated conversation back to the AI (Step 2). If the task <em>is</em> finished, it waits for your next input.</li>
</ol>

<h2 id="using-the-agent-loop-from-the-uis-perspective">Using the Agent Loop (From the UI’s Perspective)</h2>

<p>You don’t directly interact with the <code class="language-plaintext highlighter-rouge">AgentLoop</code> class code when <em>using</em> Codex. Instead, the main UI component (<code class="language-plaintext highlighter-rouge">TerminalChat</code> in <code class="language-plaintext highlighter-rouge">terminal-chat.tsx</code>) creates and manages an <code class="language-plaintext highlighter-rouge">AgentLoop</code> instance.</p>

<p>Think of the UI component holding the “remote control” for the Agent Loop assistant.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: codex-cli/src/components/chat/terminal-chat.tsx (Highly Simplified)</span>
<span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span><span class="p">,</span> <span class="nx">useEffect</span><span class="p">,</span> <span class="nx">useRef</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">AgentLoop</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../../utils/agent/agent-loop</span><span class="dl">"</span><span class="p">;</span>
<span class="c1">// ... other imports: UI components, config types ...</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">TerminalChat</span><span class="p">({</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">approvalPolicy</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">})</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">items</span><span class="p">,</span> <span class="nx">setItems</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">([]);</span> <span class="c1">// Holds conversation messages</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">loading</span><span class="p">,</span> <span class="nx">setLoading</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span> <span class="c1">// Is the assistant busy?</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">confirmationPrompt</span><span class="p">,</span> <span class="nx">setConfirmationPrompt</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">// Command to review?</span>
  <span class="kd">const</span> <span class="nx">agentRef</span> <span class="o">=</span> <span class="nx">useRef</span><span class="o">&lt;</span><span class="nx">AgentLoop</span> <span class="o">|</span> <span class="kc">null</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">// Holds the assistant instance</span>

  <span class="c1">// Create the assistant when the component loads or config changes</span>
  <span class="nx">useEffect</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">agentRef</span><span class="p">.</span><span class="nx">current</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">AgentLoop</span><span class="p">({</span>
      <span class="na">model</span><span class="p">:</span> <span class="nx">config</span><span class="p">.</span><span class="nx">model</span><span class="p">,</span>
      <span class="na">config</span><span class="p">:</span> <span class="nx">config</span><span class="p">,</span>
      <span class="na">approvalPolicy</span><span class="p">:</span> <span class="nx">approvalPolicy</span><span class="p">,</span>
      <span class="c1">// --- Callbacks: How the assistant reports back ---</span>
      <span class="na">onItem</span><span class="p">:</span> <span class="p">(</span><span class="nx">newItem</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// When the assistant has a message/result</span>
        <span class="nx">setItems</span><span class="p">((</span><span class="nx">prev</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[...</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">newItem</span><span class="p">]);</span> <span class="c1">// Add it to our chat history</span>
      <span class="p">},</span>
      <span class="na">onLoading</span><span class="p">:</span> <span class="p">(</span><span class="nx">isLoading</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// When the assistant starts/stops thinking</span>
        <span class="nx">setLoading</span><span class="p">(</span><span class="nx">isLoading</span><span class="p">);</span>
      <span class="p">},</span>
      <span class="na">getCommandConfirmation</span><span class="p">:</span> <span class="k">async</span> <span class="p">(</span><span class="nx">command</span><span class="p">,</span> <span class="cm">/*...*/</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span> <span class="c1">// When the assistant needs approval</span>
        <span class="c1">// Show the command in the UI and wait for user's Yes/No</span>
        <span class="kd">const</span> <span class="nx">userDecision</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">showConfirmationUI</span><span class="p">(</span><span class="nx">command</span><span class="p">);</span>
        <span class="k">return</span> <span class="p">{</span> <span class="na">review</span><span class="p">:</span> <span class="nx">userDecision</span> <span class="cm">/* ... */</span> <span class="p">};</span>
      <span class="p">},</span>
      <span class="c1">// ... other callbacks like onLastResponseId ...</span>
    <span class="p">});</span>

    <span class="k">return</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">agentRef</span><span class="p">.</span><span class="nx">current</span><span class="p">?.</span><span class="nx">terminate</span><span class="p">();</span> <span class="c1">// Clean up when done</span>
  <span class="p">},</span> <span class="p">[</span><span class="nx">config</span><span class="p">,</span> <span class="nx">approvalPolicy</span> <span class="cm">/* ... */</span><span class="p">]);</span>

  <span class="c1">// --- Function to send user input to the assistant ---</span>
  <span class="kd">const</span> <span class="nx">submitInputToAgent</span> <span class="o">=</span> <span class="p">(</span><span class="nx">userInput</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">agentRef</span><span class="p">.</span><span class="nx">current</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Tell the assistant to process this input</span>
      <span class="nx">agentRef</span><span class="p">.</span><span class="nx">current</span><span class="p">.</span><span class="nx">run</span><span class="p">([</span><span class="nx">userInput</span> <span class="cm">/* ... */</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">};</span>

  <span class="c1">// --- UI Rendering ---</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">Box</span><span class="p">&gt;</span>
      <span class="si">{</span><span class="cm">/* Display 'items' using TerminalMessageHistory */</span><span class="si">}</span>
      <span class="si">{</span><span class="cm">/* Display input box (TerminalChatInput) or confirmationPrompt */</span><span class="si">}</span>
      <span class="si">{</span><span class="cm">/* Pass `submitInputToAgent` to the input box */</span><span class="si">}</span>
      <span class="si">{</span><span class="cm">/* Pass function to handle confirmation decision */</span><span class="si">}</span>
    <span class="p">&lt;/</span><span class="nc">Box</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><strong>Initialization:</strong> The UI creates an <code class="language-plaintext highlighter-rouge">AgentLoop</code>, giving it the necessary configuration (<a href="07_configuration_management.md">Configuration Management</a>) and crucial <strong>callback functions</strong>. These callbacks are how the Agent Loop communicates back to the UI:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">onItem</code>: “Here’s a new message (from user, AI, or tool) to display.”</li>
      <li><code class="language-plaintext highlighter-rouge">onLoading</code>: “I’m starting/stopping my work.”</li>
      <li><code class="language-plaintext highlighter-rouge">getCommandConfirmation</code>: “I need to run this command. Please ask the user and tell me their decision.”</li>
    </ul>
  </li>
  <li><strong>Running:</strong> When you submit input via the <code class="language-plaintext highlighter-rouge">&lt;TerminalChatInput&gt;</code>, the UI calls the <code class="language-plaintext highlighter-rouge">agentRef.current.run(...)</code> method, handing off your request to the Agent Loop.</li>
  <li><strong>Updates:</strong> The Agent Loop does its work, calling the <code class="language-plaintext highlighter-rouge">onItem</code> and <code class="language-plaintext highlighter-rouge">onLoading</code> callbacks whenever something changes. The UI listens to these callbacks and updates the display accordingly (setting state variables like <code class="language-plaintext highlighter-rouge">items</code> and <code class="language-plaintext highlighter-rouge">loading</code>, which causes React to re-render).</li>
  <li><strong>Confirmation:</strong> If the Agent Loop needs approval, it calls <code class="language-plaintext highlighter-rouge">getCommandConfirmation</code>. The UI pauses, shows the command review prompt, waits for your decision, and then returns the decision back to the Agent Loop, which then proceeds or stops based on your choice.</li>
</ul>

<h2 id="under-the-hood-a-step-by-step-flow">Under the Hood: A Step-by-Step Flow</h2>

<p>Let’s trace our “hello world” example again, focusing on the interactions:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant InkUI as Terminal UI (Ink)
    participant AgentLoop
    participant OpenAI
    participant CmdExec as Command Execution

    User-&gt;&gt;InkUI: Types "write &amp; run hello world", presses Enter
    InkUI-&gt;&gt;AgentLoop: Calls `run(["write &amp; run..."])`
    AgentLoop-&gt;&gt;AgentLoop: Sets loading=true (calls `onLoading(true)`)
    InkUI-&gt;&gt;User: Shows loading indicator
    AgentLoop-&gt;&gt;OpenAI: Sends request: ["write &amp; run..."]
    OpenAI--&gt;&gt;AgentLoop: Streams response: [Text: "Okay, try:", ToolCall: `shell(...)`]
    AgentLoop-&gt;&gt;InkUI: Calls `onItem(Text: "Okay, try:")`
    InkUI-&gt;&gt;User: Displays "Okay, try:"
    AgentLoop-&gt;&gt;AgentLoop: Processes ToolCall `shell(...)`
    Note over AgentLoop: Checks Approval Policy
    AgentLoop-&gt;&gt;InkUI: Calls `getCommandConfirmation(["python", "-c", "..."])`
    InkUI-&gt;&gt;User: Displays "Allow command: python -c '...'?" [Yes/No]
    User-&gt;&gt;InkUI: Clicks/Types 'Yes'
    InkUI--&gt;&gt;AgentLoop: Returns confirmation result ({ review: YES })
    AgentLoop-&gt;&gt;CmdExec: Executes `python -c 'print("hello world")'`
    CmdExec--&gt;&gt;AgentLoop: Returns result (stdout: "hello world", exit code: 0)
    AgentLoop-&gt;&gt;AgentLoop: Creates `function_call_output` item
    AgentLoop-&gt;&gt;OpenAI: Sends request: [..., ToolCall: `shell(...)`, Output: "hello world"]
    OpenAI--&gt;&gt;AgentLoop: Streams response: [Text: "Command ran successfully!"]
    AgentLoop-&gt;&gt;InkUI: Calls `onItem(Text: "Command ran...")`
    InkUI-&gt;&gt;User: Displays "Command ran successfully!"
    AgentLoop-&gt;&gt;AgentLoop: Sets loading=false (calls `onLoading(false)`)
    InkUI-&gt;&gt;User: Hides loading indicator, shows input prompt
</code></pre>

<p>This diagram shows the back-and-forth orchestration performed by the Agent Loop, coordinating between the UI, the AI model, and the command execution system.</p>

<h2 id="inside-agent-loopts">Inside <code class="language-plaintext highlighter-rouge">agent-loop.ts</code></h2>

<p>The core logic lives in <code class="language-plaintext highlighter-rouge">codex-cli/src/utils/agent/agent-loop.ts</code>. Let’s peek at a <em>very</em> simplified structure:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: codex-cli/src/utils/agent/agent-loop.ts (Simplified)</span>
<span class="k">import</span> <span class="nx">OpenAI</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">openai</span><span class="dl">"</span><span class="p">;</span>
<span class="c1">// ... other imports: types for config, responses, approval ...</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">handleExecCommand</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./handle-exec-command</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// For tool calls</span>

<span class="k">export</span> <span class="kd">class</span> <span class="nx">AgentLoop</span> <span class="p">{</span>
  <span class="k">private</span> <span class="nx">oai</span><span class="p">:</span> <span class="nx">OpenAI</span><span class="p">;</span> <span class="c1">// The OpenAI client instance</span>
  <span class="k">private</span> <span class="nx">model</span><span class="p">:</span> <span class="kr">string</span><span class="p">;</span>
  <span class="k">private</span> <span class="nx">config</span><span class="p">:</span> <span class="nx">AppConfig</span><span class="p">;</span>
  <span class="k">private</span> <span class="nx">approvalPolicy</span><span class="p">:</span> <span class="nx">ApprovalPolicy</span><span class="p">;</span>
  <span class="c1">// Callbacks provided by the UI:</span>
  <span class="k">private</span> <span class="nx">onItem</span><span class="p">:</span> <span class="p">(</span><span class="nx">item</span><span class="p">:</span> <span class="nx">ResponseItem</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
  <span class="k">private</span> <span class="nx">onLoading</span><span class="p">:</span> <span class="p">(</span><span class="nx">loading</span><span class="p">:</span> <span class="nx">boolean</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span><span class="p">;</span>
  <span class="k">private</span> <span class="nx">getCommandConfirmation</span><span class="p">:</span> <span class="p">(</span><span class="cm">/*...*/</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">CommandConfirmation</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="c1">// ... other state like current stream, cancellation flags ...</span>

  <span class="kd">constructor</span><span class="p">({</span> <span class="nx">model</span><span class="p">,</span> <span class="nx">config</span><span class="p">,</span> <span class="nx">approvalPolicy</span><span class="p">,</span> <span class="nx">onItem</span><span class="p">,</span> <span class="nx">onLoading</span><span class="p">,</span> <span class="nx">getCommandConfirmation</span><span class="p">,</span> <span class="cm">/*...*/</span> <span class="p">}:</span> <span class="nx">AgentLoopParams</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">model</span> <span class="o">=</span> <span class="nx">model</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">config</span> <span class="o">=</span> <span class="nx">config</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">approvalPolicy</span> <span class="o">=</span> <span class="nx">approvalPolicy</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">onItem</span> <span class="o">=</span> <span class="nx">onItem</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">onLoading</span> <span class="o">=</span> <span class="nx">onLoading</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">getCommandConfirmation</span> <span class="o">=</span> <span class="nx">getCommandConfirmation</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">oai</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">OpenAI</span><span class="p">({</span> <span class="cm">/* ... API key, base URL ... */</span> <span class="p">});</span>
    <span class="c1">// ... initialize other state ...</span>
  <span class="p">}</span>

  <span class="c1">// The main method called by the UI</span>
  <span class="k">public</span> <span class="k">async</span> <span class="nx">run</span><span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">ResponseInputItem</span><span class="o">&gt;</span><span class="p">,</span> <span class="nx">previousResponseId</span><span class="p">:</span> <span class="kr">string</span> <span class="o">=</span> <span class="dl">""</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">onLoading</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span> <span class="c1">// Signal start</span>
    <span class="kd">let</span> <span class="nx">turnInput</span> <span class="o">=</span> <span class="nx">input</span><span class="p">;</span> <span class="c1">// Input for this step of the loop</span>
    <span class="kd">let</span> <span class="nx">lastResponseId</span> <span class="o">=</span> <span class="nx">previousResponseId</span><span class="p">;</span>

    <span class="k">try</span> <span class="p">{</span>
      <span class="c1">// Keep looping as long as there's input (initially user msg, later tool results)</span>
      <span class="k">while</span> <span class="p">(</span><span class="nx">turnInput</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 1. Send current input history to OpenAI API</span>
        <span class="kd">const</span> <span class="nx">stream</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">oai</span><span class="p">.</span><span class="nx">responses</span><span class="p">.</span><span class="nx">create</span><span class="p">({</span>
          <span class="na">model</span><span class="p">:</span> <span class="k">this</span><span class="p">.</span><span class="nx">model</span><span class="p">,</span>
          <span class="na">input</span><span class="p">:</span> <span class="nx">turnInput</span><span class="p">,</span> <span class="c1">// Includes user message or tool results</span>
          <span class="na">previous_response_id</span><span class="p">:</span> <span class="nx">lastResponseId</span> <span class="o">||</span> <span class="kc">undefined</span><span class="p">,</span>
          <span class="na">stream</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
          <span class="c1">// ... other parameters like instructions, tools ...</span>
        <span class="p">});</span>

        <span class="nx">turnInput</span> <span class="o">=</span> <span class="p">[];</span> <span class="c1">// Clear input for the next loop iteration</span>

        <span class="c1">// 2. Process the stream of events from OpenAI</span>
        <span class="k">for</span> <span class="k">await</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">event</span> <span class="k">of</span> <span class="nx">stream</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">response.output_item.done</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
            <span class="kd">const</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">item</span><span class="p">;</span> <span class="c1">// Could be text, function_call, etc.</span>
            <span class="k">this</span><span class="p">.</span><span class="nx">onItem</span><span class="p">(</span><span class="nx">item</span> <span class="k">as</span> <span class="nx">ResponseItem</span><span class="p">);</span> <span class="c1">// Send item to UI to display</span>
          <span class="p">}</span>
          <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">response.completed</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">lastResponseId</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span> <span class="c1">// Remember the ID for the next call</span>
            <span class="c1">// Check the final output for tool calls</span>
            <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">event</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">output</span><span class="p">)</span> <span class="p">{</span>
              <span class="k">if</span> <span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">function_call</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
                 <span class="c1">// Handle the tool call (ask for approval, execute)</span>
                 <span class="c1">// This might add a 'function_call_output' to `turnInput`</span>
                 <span class="kd">const</span> <span class="nx">toolResults</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">handleFunctionCall</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
                 <span class="nx">turnInput</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">toolResults</span><span class="p">);</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">}</span>
          <span class="c1">// ... handle other event types ...</span>
        <span class="p">}</span> <span class="c1">// End stream processing</span>
      <span class="p">}</span> <span class="c1">// End while loop (no more input for this turn)</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// ... Handle errors (network issues, API errors etc.) ...</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">onItem</span><span class="p">(</span><span class="cm">/* Create system error message */</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">finally</span> <span class="p">{</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">onLoading</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span> <span class="c1">// Signal end</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Helper to handle tool/function calls</span>
  <span class="k">private</span> <span class="k">async</span> <span class="nx">handleFunctionCall</span><span class="p">(</span><span class="nx">item</span><span class="p">:</span> <span class="nx">ResponseFunctionToolCall</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nb">Array</span><span class="o">&lt;</span><span class="nx">ResponseInputItem</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="c1">// ... Parse arguments from 'item' ...</span>
    <span class="kd">const</span> <span class="nx">args</span> <span class="o">=</span> <span class="cm">/* ... parse item.arguments ... */</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">outputText</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">Error: Unknown function</span><span class="dl">"</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">metadata</span> <span class="o">=</span> <span class="p">{};</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">name</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">shell</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Example: handle shell commands</span>
       <span class="c1">// This uses the approval policy and getCommandConfirmation callback!</span>
       <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">handleExecCommand</span><span class="p">(</span>
         <span class="nx">args</span><span class="p">,</span>
         <span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span>
         <span class="k">this</span><span class="p">.</span><span class="nx">approvalPolicy</span><span class="p">,</span>
         <span class="k">this</span><span class="p">.</span><span class="nx">getCommandConfirmation</span><span class="p">,</span>
         <span class="cm">/* ... cancellation signal ... */</span>
       <span class="p">);</span>
       <span class="nx">outputText</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">outputText</span><span class="p">;</span>
       <span class="nx">metadata</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">metadata</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ... handle other function names ...</span>

    <span class="c1">// Format the result to send back to OpenAI in the next turn</span>
    <span class="kd">const</span> <span class="na">outputItem</span><span class="p">:</span> <span class="nx">ResponseInputItem</span><span class="p">.</span><span class="nx">FunctionCallOutput</span> <span class="o">=</span> <span class="p">{</span>
      <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">function_call_output</span><span class="dl">"</span><span class="p">,</span>
      <span class="na">call_id</span><span class="p">:</span> <span class="nx">item</span><span class="p">.</span><span class="nx">call_id</span><span class="p">,</span> <span class="c1">// Link to the specific function call</span>
      <span class="na">output</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span> <span class="na">output</span><span class="p">:</span> <span class="nx">outputText</span><span class="p">,</span> <span class="nx">metadata</span> <span class="p">}),</span>
    <span class="p">};</span>
    <span class="k">return</span> <span class="p">[</span><span class="nx">outputItem</span><span class="p">];</span> <span class="c1">// This goes into `turnInput` for the next loop</span>
  <span class="p">}</span>

  <span class="c1">// ... other methods like cancel(), terminate() ...</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><strong>Constructor:</strong> Sets up the connection to OpenAI and stores the configuration and callbacks passed in by the UI.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">run()</code>:</strong> This is the main engine.
    <ul>
      <li>It signals loading starts (<code class="language-plaintext highlighter-rouge">onLoading(true)</code>).</li>
      <li>It enters a <code class="language-plaintext highlighter-rouge">while</code> loop that continues as long as there’s something to send to the AI (initially the user’s message, later potentially the results from tools).</li>
      <li>Inside the loop, it calls <code class="language-plaintext highlighter-rouge">this.oai.responses.create()</code> to talk to the AI model, sending the current conversation turn.</li>
      <li>It processes the <code class="language-plaintext highlighter-rouge">stream</code> of events coming back from the AI.</li>
      <li>For each piece of content (<code class="language-plaintext highlighter-rouge">response.output_item.done</code>), it calls <code class="language-plaintext highlighter-rouge">onItem</code> to show it in the UI.</li>
      <li>When the AI’s turn is complete (<code class="language-plaintext highlighter-rouge">response.completed</code>), it checks if the AI asked to use any tools (<code class="language-plaintext highlighter-rouge">function_call</code>).</li>
      <li>If a tool call is found, it calls <code class="language-plaintext highlighter-rouge">handleFunctionCall</code>.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">handleFunctionCall()</code>:</strong>
    <ul>
      <li>Parses the details of the tool request (e.g., the command arguments).</li>
      <li>Uses <code class="language-plaintext highlighter-rouge">handleExecCommand</code> (which contains logic related to <a href="04_approval_policy___security.md">Approval Policy</a> and <a href="06_command_execution___sandboxing.md">Command Execution</a>) to potentially run the command, using the <code class="language-plaintext highlighter-rouge">getCommandConfirmation</code> callback if needed.</li>
      <li>Formats the result of the tool execution (e.g., command output) into a specific <code class="language-plaintext highlighter-rouge">function_call_output</code> message.</li>
      <li>Returns this output message. The <code class="language-plaintext highlighter-rouge">run</code> method adds this to <code class="language-plaintext highlighter-rouge">turnInput</code>, so the <em>next</em> iteration of the <code class="language-plaintext highlighter-rouge">while</code> loop will send this result back to the AI, letting it know what happened.</li>
    </ul>
  </li>
  <li><strong>Finally:</strong> Once the <code class="language-plaintext highlighter-rouge">while</code> loop finishes (meaning the AI didn’t request any more tools in its last response), it signals loading is done (<code class="language-plaintext highlighter-rouge">onLoading(false)</code>).</li>
</ul>

<p>This loop ensures that the conversation flows logically, handling text, tool requests, user approvals, and tool results in a structured way.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Agent Loop is the central orchestrator within Codex. It acts like a diligent assistant, taking your requests, interacting with the powerful AI model, managing tools like shell commands, ensuring safety through approvals, and keeping the conversation state updated. It connects the <a href="01_terminal_ui__ink_components_.md">Terminal UI</a> where you interact, the <a href="02_input_handling__textbuffer_editor_.md">Input Handling</a> that captures your text, the AI model that provides intelligence, and the systems that actually execute actions (<a href="06_command_execution___sandboxing.md">Command Execution &amp; Sandboxing</a>).</p>

<p>Understanding the Agent Loop helps you see how Codex manages the complex back-and-forth required to turn your natural language requests into concrete actions. But when the Agent Loop wants to run a command suggested by the AI, how does Codex decide whether to ask for your permission first? That crucial safety mechanism is the topic of our next chapter.</p>

<p>Next up: <a href="04_approval_policy___security.md">Approval Policy &amp; Security</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
