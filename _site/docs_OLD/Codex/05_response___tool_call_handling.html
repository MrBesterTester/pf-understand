<h1 id="chapter-5-response--tool-call-handling">Chapter 5: Response &amp; Tool Call Handling</h1>

<p>In the <a href="04_approval_policy___security.md">previous chapter</a>, we learned how Codex decides <em>if</em> it’s allowed to perform an action suggested by the AI, acting like a security guard based on the rules you set. But how does Codex understand the AI’s response in the first place, especially when the AI wants to do something specific, like run a command or change a file?</p>

<p>That’s where <strong>Response &amp; Tool Call Handling</strong> comes in. Think of this part of Codex as its “ears” and “hands.” It listens carefully to the instructions coming back from the AI model (the “response”) and, if the AI asks to perform an action (a “tool call”), it figures out <em>exactly</em> what the AI wants to do (like which command to run or what file change to make) and gets ready to do it.</p>

<h2 id="whats-the-big-idea-listening-to-the-ai-assistant">What’s the Big Idea? Listening to the AI Assistant</h2>

<p>Imagine you ask your super-smart assistant (the AI model) to do something like:</p>

<p><code class="language-plaintext highlighter-rouge">codex "What's the status of my project? Use git status."</code></p>

<p>The AI doesn’t just send back plain text like “Okay, I’ll run it.” Instead, it sends back a more structured message, almost like filling out a form:</p>

<ul>
  <li><strong>Text Part:</strong> “Okay, I will check the status of your project.”</li>
  <li><strong>Action Part (Tool Call):</strong>
    <ul>
      <li><strong>Tool Name:</strong> <code class="language-plaintext highlighter-rouge">shell</code> (meaning: use the command line)</li>
      <li><strong>Arguments:</strong> <code class="language-plaintext highlighter-rouge">["git", "status"]</code> (meaning: the specific command to run)</li>
    </ul>
  </li>
</ul>

<p>Codex needs to understand this structured response. It needs to:</p>

<ol>
  <li>Recognize the plain text part and show it to you in the <a href="01_terminal_ui__ink_components_.md">Terminal UI</a>.</li>
  <li>See the “Action Part” (the Tool Call) and understand:
    <ul>
      <li>Which tool the AI wants to use (<code class="language-plaintext highlighter-rouge">shell</code>).</li>
      <li>What specific details (arguments) are needed for that tool (<code class="language-plaintext highlighter-rouge">git status</code>).</li>
    </ul>
  </li>
</ol>

<p>This system is crucial because it translates the AI’s intent into something Codex can actually act upon.</p>

<h2 id="key-concepts">Key Concepts</h2>

<ol>
  <li>
    <p><strong>Structured Responses:</strong> The OpenAI API doesn’t just return a single block of text. It sends back data structured often like JSON. This allows the AI to clearly separate regular conversation text from requests to perform actions.</p>

    <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">//</span><span class="w"> </span><span class="err">Simplified</span><span class="w"> </span><span class="err">idea</span><span class="w"> </span><span class="err">of</span><span class="w"> </span><span class="err">an</span><span class="w"> </span><span class="err">AI</span><span class="w"> </span><span class="err">response</span><span class="w">
</span><span class="p">{</span><span class="w">
  </span><span class="nl">"id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"response_123"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"output"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"message"</span><span class="p">,</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">A</span><span class="w"> </span><span class="err">regular</span><span class="w"> </span><span class="err">text</span><span class="w"> </span><span class="err">message</span><span class="w">
      </span><span class="nl">"role"</span><span class="p">:</span><span class="w"> </span><span class="s2">"assistant"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"content"</span><span class="p">:</span><span class="w"> </span><span class="p">[{</span><span class="w"> </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"output_text"</span><span class="p">,</span><span class="w"> </span><span class="nl">"text"</span><span class="p">:</span><span class="w"> </span><span class="s2">"Okay, checking the status..."</span><span class="w"> </span><span class="p">}]</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
      </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"function_call"</span><span class="p">,</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">A</span><span class="w"> </span><span class="err">request</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">use</span><span class="w"> </span><span class="err">a</span><span class="w"> </span><span class="err">tool!</span><span class="w">
      </span><span class="nl">"name"</span><span class="p">:</span><span class="w"> </span><span class="s2">"shell"</span><span class="p">,</span><span class="w">
      </span><span class="nl">"arguments"</span><span class="p">:</span><span class="w"> </span><span class="s2">"{</span><span class="se">\"</span><span class="s2">command</span><span class="se">\"</span><span class="s2">: [</span><span class="se">\"</span><span class="s2">git</span><span class="se">\"</span><span class="s2">, </span><span class="se">\"</span><span class="s2">status</span><span class="se">\"</span><span class="s2">]}"</span><span class="p">,</span><span class="w"> </span><span class="err">//</span><span class="w"> </span><span class="err">Details</span><span class="w"> </span><span class="err">for</span><span class="w"> </span><span class="err">the</span><span class="w"> </span><span class="err">tool</span><span class="w">
      </span><span class="nl">"call_id"</span><span class="p">:</span><span class="w"> </span><span class="s2">"call_abc"</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">]</span><span class="w">
  </span><span class="err">//</span><span class="w"> </span><span class="err">...</span><span class="w"> </span><span class="err">other</span><span class="w"> </span><span class="err">info</span><span class="w"> </span><span class="err">...</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div>    </div>
    <p>This structure makes it easy for Codex to programmatically understand the different parts of the AI’s message.</p>
  </li>
  <li><strong>Tool Calls (Function Calls):</strong> When the AI wants to interact with the outside world (run a command, edit a file), it uses a special type of message in the response, often called a “function call” or “tool call”. In Codex, common tool names are:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">shell</code>: Execute a command in the terminal.</li>
      <li><code class="language-plaintext highlighter-rouge">apply_patch</code>: Modify a file using a specific format called a “patch”.</li>
    </ul>
  </li>
  <li><strong>Arguments:</strong> The tool call includes the necessary details, called “arguments,” usually formatted as a JSON string.
    <ul>
      <li>For the <code class="language-plaintext highlighter-rouge">shell</code> tool, the arguments specify the command to run (e.g., <code class="language-plaintext highlighter-rouge">{"command": ["git", "status"]}</code>).</li>
      <li>For the <code class="language-plaintext highlighter-rouge">apply_patch</code> tool, the arguments contain the patch text describing the file changes (e.g., <code class="language-plaintext highlighter-rouge">{"patch": "*** Begin Patch..."}</code>).</li>
    </ul>
  </li>
</ol>

<h2 id="how-it-works-decoding-the-ais-message">How It Works: Decoding the AI’s Message</h2>

<p>When the <a href="03_agent_loop.md">Agent Loop</a> receives a response from the OpenAI API, it goes through these steps:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant OpenAI
    participant AgentLoop as Agent Loop
    participant Parser as Response Parser
    participant UI as Terminal UI
    participant Approval as Approval Check

    OpenAI--&gt;&gt;AgentLoop: Sends structured response (Text + Tool Call)
    AgentLoop-&gt;&gt;Parser: Passes raw response data
    Parser-&gt;&gt;Parser: Extracts Text part ("Okay...")
    Parser--&gt;&gt;AgentLoop: Returns extracted Text
    AgentLoop-&gt;&gt;UI: Sends Text to display ("onItem" callback)
    Parser-&gt;&gt;Parser: Extracts Tool Call part (shell, ["git", "status"])
    Parser--&gt;&gt;AgentLoop: Returns Tool Name ("shell") &amp; Arguments (["git", "status"])
    AgentLoop-&gt;&gt;Approval: Sends Tool details for policy check
    Note over Approval: Next step: Chapter 4/6
</code></pre>

<ol>
  <li><strong>Receive Response:</strong> The <a href="03_agent_loop.md">Agent Loop</a> gets the structured response data from the OpenAI API.</li>
  <li><strong>Parse:</strong> It uses helper functions (often found in <code class="language-plaintext highlighter-rouge">utils/parsers.ts</code>) to examine the response structure.</li>
  <li><strong>Extract Text:</strong> If there’s a regular text message (<code class="language-plaintext highlighter-rouge">"type": "message"</code>), it’s extracted and sent to the <a href="01_terminal_ui__ink_components_.md">Terminal UI</a> via the <code class="language-plaintext highlighter-rouge">onItem</code> callback to be displayed.</li>
  <li><strong>Extract Tool Call:</strong> If there’s a tool call (<code class="language-plaintext highlighter-rouge">"type": "function_call"</code>):
    <ul>
      <li>The <strong>tool name</strong> (e.g., <code class="language-plaintext highlighter-rouge">shell</code>) is identified.</li>
      <li>The <strong>arguments</strong> string is extracted.</li>
      <li>The arguments string (which is often JSON) is parsed to get the actual details (e.g., the <code class="language-plaintext highlighter-rouge">command</code> array <code class="language-plaintext highlighter-rouge">["git", "status"]</code>).</li>
    </ul>
  </li>
  <li><strong>Prepare for Action:</strong> The Agent Loop now knows the specific tool and its arguments. It packages this information (tool name + parsed arguments) and prepares for the next stage: checking the <a href="04_approval_policy___security.md">Approval Policy &amp; Security</a> and, if approved, proceeding to <a href="06_command_execution___sandboxing.md">Command Execution &amp; Sandboxing</a>.</li>
</ol>

<h2 id="under-the-hood-parsing-the-details">Under the Hood: Parsing the Details</h2>

<p>Let’s look at simplified code snippets showing how this parsing happens.</p>

<h3 id="in-the-agent-loop-agent-loopts">In the Agent Loop (<code class="language-plaintext highlighter-rouge">agent-loop.ts</code>)</h3>

<p>The <code class="language-plaintext highlighter-rouge">AgentLoop</code> processes events streamed from the OpenAI API. When a complete response arrives or a specific tool call item is identified, it needs handling.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: codex-cli/src/utils/agent/agent-loop.ts (Simplified)</span>

<span class="c1">// Inside the loop processing OpenAI stream events...</span>
<span class="k">for</span> <span class="k">await</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">event</span> <span class="k">of</span> <span class="nx">stream</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">response.output_item.done</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">item</span><span class="p">;</span> <span class="c1">// Could be text, function_call, etc.</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">onItem</span><span class="p">(</span><span class="nx">item</span> <span class="k">as</span> <span class="nx">ResponseItem</span><span class="p">);</span> <span class="c1">// Send to UI</span>

    <span class="c1">// If it's a tool call, mark it for later processing</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">function_call</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Store item.call_id or item details</span>
      <span class="c1">// to handle after the stream finishes</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">event</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">response.completed</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Process the full response output once the stream is done</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">item</span> <span class="k">of</span> <span class="nx">event</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">output</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="kd">type</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">function_call</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// *** This is where we handle the tool call! ***</span>
        <span class="c1">// Calls a helper function like handleFunctionCall</span>
        <span class="kd">const</span> <span class="nx">toolResults</span> <span class="o">=</span> <span class="k">await</span> <span class="k">this</span><span class="p">.</span><span class="nx">handleFunctionCall</span><span class="p">(</span><span class="nx">item</span><span class="p">);</span>
        <span class="c1">// Prepare results to potentially send back to AI</span>
        <span class="nx">turnInput</span><span class="p">.</span><span class="nx">push</span><span class="p">(...</span><span class="nx">toolResults</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">lastResponseId</span> <span class="o">=</span> <span class="nx">event</span><span class="p">.</span><span class="nx">response</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// ... other event types ...</span>
<span class="p">}</span>

<span class="c1">// Helper function to process the tool call details</span>
<span class="k">private</span> <span class="k">async</span> <span class="nx">handleFunctionCall</span><span class="p">(</span><span class="nx">item</span><span class="p">:</span> <span class="nx">ResponseFunctionToolCall</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nb">Array</span><span class="o">&lt;</span><span class="nx">ResponseInputItem</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">name</span> <span class="o">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">name</span><span class="p">;</span> <span class="c1">// e.g., "shell"</span>
  <span class="kd">const</span> <span class="nx">rawArguments</span> <span class="o">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">arguments</span><span class="p">;</span> <span class="c1">// e.g., "{\"command\": [\"git\", \"status\"]}"</span>
  <span class="kd">const</span> <span class="nx">callId</span> <span class="o">=</span> <span class="nx">item</span><span class="p">.</span><span class="nx">call_id</span><span class="p">;</span>

  <span class="c1">// *** Use a parser to get structured arguments ***</span>
  <span class="kd">const</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">parseToolCallArguments</span><span class="p">(</span><span class="nx">rawArguments</span> <span class="o">??</span> <span class="dl">"</span><span class="s2">{}</span><span class="dl">"</span><span class="p">);</span> <span class="c1">// From parsers.ts</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">args</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Handle error: arguments couldn't be parsed</span>
    <span class="k">return</span> <span class="p">[</span><span class="cm">/* error output item */</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="kd">let</span> <span class="nx">outputText</span> <span class="o">=</span> <span class="s2">`Error: Unknown function </span><span class="p">${</span><span class="nx">name</span><span class="p">}</span><span class="s2">`</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">metadata</span> <span class="o">=</span> <span class="p">{};</span>

  <span class="c1">// Check which tool was called</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">name</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">shell</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// *** Prepare for execution ***</span>
    <span class="c1">// Call handleExecCommand, which checks approval and runs the command</span>
    <span class="kd">const</span> <span class="nx">result</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">handleExecCommand</span><span class="p">(</span>
      <span class="nx">args</span><span class="p">,</span> <span class="c1">// Contains { cmd: ["git", "status"], ... }</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">config</span><span class="p">,</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">approvalPolicy</span><span class="p">,</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">getCommandConfirmation</span><span class="p">,</span> <span class="c1">// Function to ask user via UI</span>
      <span class="cm">/* ... cancellation signal ... */</span>
    <span class="p">);</span>
    <span class="nx">outputText</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">outputText</span><span class="p">;</span>
    <span class="nx">metadata</span> <span class="o">=</span> <span class="nx">result</span><span class="p">.</span><span class="nx">metadata</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">name</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">apply_patch</span><span class="dl">"</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Similar logic, potentially using execApplyPatch after approval check</span>
    <span class="c1">// It would parse args.patch using logic from parse-apply-patch.ts</span>
  <span class="p">}</span>
  <span class="c1">// ... other tools ...</span>

  <span class="c1">// Create the result message to send back to the AI</span>
  <span class="kd">const</span> <span class="na">outputItem</span><span class="p">:</span> <span class="nx">ResponseInputItem</span><span class="p">.</span><span class="nx">FunctionCallOutput</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">function_call_output</span><span class="dl">"</span><span class="p">,</span>
    <span class="na">call_id</span><span class="p">:</span> <span class="nx">callId</span><span class="p">,</span>
    <span class="na">output</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span> <span class="na">output</span><span class="p">:</span> <span class="nx">outputText</span><span class="p">,</span> <span class="nx">metadata</span> <span class="p">}),</span>
  <span class="p">};</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">outputItem</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>The loop iterates through the response <code class="language-plaintext highlighter-rouge">output</code> items.</li>
  <li>If an item is a <code class="language-plaintext highlighter-rouge">function_call</code>, the <code class="language-plaintext highlighter-rouge">handleFunctionCall</code> helper is called.</li>
  <li><code class="language-plaintext highlighter-rouge">handleFunctionCall</code> extracts the <code class="language-plaintext highlighter-rouge">name</code> and <code class="language-plaintext highlighter-rouge">arguments</code>.</li>
  <li>It crucially calls <code class="language-plaintext highlighter-rouge">parseToolCallArguments</code> (from <code class="language-plaintext highlighter-rouge">utils/parsers.ts</code>) to turn the JSON string <code class="language-plaintext highlighter-rouge">arguments</code> into a usable object.</li>
  <li>Based on the <code class="language-plaintext highlighter-rouge">name</code> (<code class="language-plaintext highlighter-rouge">shell</code>, <code class="language-plaintext highlighter-rouge">apply_patch</code>), it calls the appropriate execution handler (like <code class="language-plaintext highlighter-rouge">handleExecCommand</code>), passing the parsed arguments. This handler coordinates with the <a href="04_approval_policy___security.md">Approval Policy &amp; Security</a> and <a href="06_command_execution___sandboxing.md">Command Execution &amp; Sandboxing</a> systems.</li>
</ul>

<h3 id="in-the-parsers-parsersts">In the Parsers (<code class="language-plaintext highlighter-rouge">parsers.ts</code>)</h3>

<p>This file contains helpers to decode the tool call details.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: codex-cli/src/utils/parsers.ts (Simplified)</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">formatCommandForDisplay</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">src/format-command.js</span><span class="dl">"</span><span class="p">;</span>
<span class="c1">// ... other imports ...</span>

<span class="cm">/**
 * Parses the raw JSON string from a tool call's arguments.
 * Expects specific shapes for known tools like 'shell'.
 */</span>
<span class="k">export</span> <span class="kd">function</span> <span class="nx">parseToolCallArguments</span><span class="p">(</span>
  <span class="nx">rawArguments</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span>
<span class="p">):</span> <span class="nx">ExecInput</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span> <span class="c1">// ExecInput contains { cmd, workdir, timeoutInMillis }</span>
  <span class="kd">let</span> <span class="nx">json</span><span class="p">:</span> <span class="nx">unknown</span><span class="p">;</span>
  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">json</span> <span class="o">=</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">(</span><span class="nx">rawArguments</span><span class="p">);</span> <span class="c1">// Basic JSON parsing</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">err</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Handle JSON parse errors</span>
    <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">json</span> <span class="o">!==</span> <span class="dl">"</span><span class="s2">object</span><span class="dl">"</span> <span class="o">||</span> <span class="nx">json</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>

  <span class="c1">// Look for 'command' or 'cmd' property, expecting an array of strings</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">cmd</span><span class="p">,</span> <span class="nx">command</span><span class="p">,</span> <span class="nx">patch</span> <span class="cm">/* other possible args */</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">json</span> <span class="k">as</span> <span class="nb">Record</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="nx">unknown</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">commandArray</span> <span class="o">=</span> <span class="nx">toStringArray</span><span class="p">(</span><span class="nx">cmd</span><span class="p">)</span> <span class="o">??</span> <span class="nx">toStringArray</span><span class="p">(</span><span class="nx">command</span><span class="p">);</span>

  <span class="c1">// If it's a shell command, require the command array</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">commandArray</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span>
      <span class="na">cmd</span><span class="p">:</span> <span class="nx">commandArray</span><span class="p">,</span>
      <span class="c1">// Optional: extract workdir and timeout too</span>
      <span class="na">workdir</span><span class="p">:</span> <span class="k">typeof</span> <span class="p">(</span><span class="nx">json</span> <span class="k">as</span> <span class="kr">any</span><span class="p">).</span><span class="nx">workdir</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span> <span class="p">?</span> <span class="p">(</span><span class="nx">json</span> <span class="k">as</span> <span class="kr">any</span><span class="p">).</span><span class="nx">workdir</span> <span class="p">:</span> <span class="kc">undefined</span><span class="p">,</span>
      <span class="na">timeoutInMillis</span><span class="p">:</span> <span class="k">typeof</span> <span class="p">(</span><span class="nx">json</span> <span class="k">as</span> <span class="kr">any</span><span class="p">).</span><span class="nx">timeout</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">number</span><span class="dl">"</span> <span class="p">?</span> <span class="p">(</span><span class="nx">json</span> <span class="k">as</span> <span class="kr">any</span><span class="p">).</span><span class="nx">timeout</span> <span class="p">:</span> <span class="kc">undefined</span><span class="p">,</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="c1">// If it's an apply_patch command, require the patch string</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">patch</span> <span class="o">===</span> <span class="dl">'</span><span class="s1">string</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Return a structure indicating it's a patch, maybe:</span>
    <span class="c1">// return { type: 'patch', patch: patch }; // Or incorporate into ExecInput if unified</span>
    <span class="c1">// For simplicity here, let's assume handleFunctionCall routes based on name,</span>
    <span class="c1">// so we might just return the raw parsed JSON for patch.</span>
    <span class="c1">// But a structured return is better. Let's adapt ExecInput slightly for demo:</span>
    <span class="k">return</span> <span class="p">{</span> <span class="na">cmd</span><span class="p">:</span> <span class="p">[</span><span class="dl">'</span><span class="s1">apply_patch</span><span class="dl">'</span><span class="p">],</span> <span class="na">patch</span><span class="p">:</span> <span class="nx">patch</span> <span class="p">};</span> <span class="c1">// Use a placeholder cmd</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span> <span class="c1">// Unknown or invalid arguments structure</span>
<span class="p">}</span>

<span class="c1">// Helper to check if an object is an array of strings</span>
<span class="kd">function</span> <span class="nx">toStringArray</span><span class="p">(</span><span class="nx">obj</span><span class="p">:</span> <span class="nx">unknown</span><span class="p">):</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">obj</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">every</span><span class="p">((</span><span class="nx">item</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">typeof</span> <span class="nx">item</span> <span class="o">===</span> <span class="dl">"</span><span class="s2">string</span><span class="dl">"</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">obj</span> <span class="k">as</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="kr">string</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**
 * Parses a full FunctionCall item for display/review purposes.
 */</span>
<span class="k">export</span> <span class="kd">function</span> <span class="nx">parseToolCall</span><span class="p">(</span>
  <span class="nx">toolCall</span><span class="p">:</span> <span class="nx">ResponseFunctionToolCall</span><span class="p">,</span>
<span class="p">):</span> <span class="nx">CommandReviewDetails</span> <span class="o">|</span> <span class="kc">undefined</span> <span class="p">{</span> <span class="c1">// CommandReviewDetails has { cmd, cmdReadableText, ... }</span>
  <span class="c1">// Use the argument parser</span>
  <span class="kd">const</span> <span class="nx">args</span> <span class="o">=</span> <span class="nx">parseToolCallArguments</span><span class="p">(</span><span class="nx">toolCall</span><span class="p">.</span><span class="nx">arguments</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">args</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span> <span class="k">return</span> <span class="kc">undefined</span><span class="p">;</span>

  <span class="c1">// Format the command nicely for display</span>
  <span class="kd">const</span> <span class="nx">cmdReadableText</span> <span class="o">=</span> <span class="nx">formatCommandForDisplay</span><span class="p">(</span><span class="nx">args</span><span class="p">.</span><span class="nx">cmd</span><span class="p">);</span>

  <span class="c1">// ... potentially add auto-approval info ...</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">cmd</span><span class="p">:</span> <span class="nx">args</span><span class="p">.</span><span class="nx">cmd</span><span class="p">,</span>
    <span class="na">cmdReadableText</span><span class="p">:</span> <span class="nx">cmdReadableText</span><span class="p">,</span>
    <span class="c1">// ... other details ...</span>
  <span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">parseToolCallArguments</code> takes the raw JSON string (<code class="language-plaintext highlighter-rouge">{"command": ["git", "status"]}</code>) and uses <code class="language-plaintext highlighter-rouge">JSON.parse</code>.</li>
  <li>It then checks if the parsed object has the expected structure (e.g., a <code class="language-plaintext highlighter-rouge">command</code> property that is an array of strings for <code class="language-plaintext highlighter-rouge">shell</code>, or a <code class="language-plaintext highlighter-rouge">patch</code> string for <code class="language-plaintext highlighter-rouge">apply_patch</code>).</li>
  <li>It returns a structured object (<code class="language-plaintext highlighter-rouge">ExecInput</code>) containing the validated arguments, or <code class="language-plaintext highlighter-rouge">undefined</code> if parsing fails.</li>
  <li><code class="language-plaintext highlighter-rouge">parseToolCall</code> uses <code class="language-plaintext highlighter-rouge">parseToolCallArguments</code> and then formats the command nicely for display using <code class="language-plaintext highlighter-rouge">formatCommandForDisplay</code>.</li>
</ul>

<h3 id="handling-patches-parse-apply-patchts">Handling Patches (<code class="language-plaintext highlighter-rouge">parse-apply-patch.ts</code>)</h3>

<p>When the tool is <code class="language-plaintext highlighter-rouge">apply_patch</code>, the arguments contain a multi-line string describing the changes. Codex has specific logic to parse this format.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: codex-cli/src/utils/agent/parse-apply-patch.ts (Conceptual)</span>

<span class="c1">// Defines types like ApplyPatchOp (create, delete, update)</span>

<span class="k">export</span> <span class="kd">function</span> <span class="nx">parseApplyPatch</span><span class="p">(</span><span class="nx">patch</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">ApplyPatchOp</span><span class="o">&gt;</span> <span class="o">|</span> <span class="kc">null</span> <span class="p">{</span>
  <span class="c1">// 1. Check for "*** Begin Patch" and "*** End Patch" markers.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">patch</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="dl">"</span><span class="s2">*** Begin Patch</span><span class="se">\n</span><span class="dl">"</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="nx">patch</span><span class="p">.</span><span class="nx">endsWith</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="s2">*** End Patch</span><span class="dl">"</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">null</span><span class="p">;</span> <span class="c1">// Invalid format</span>
  <span class="p">}</span>

  <span class="c1">// 2. Extract the body between the markers.</span>
  <span class="kd">const</span> <span class="nx">patchBody</span> <span class="o">=</span> <span class="cm">/* ... extract body ... */</span><span class="p">;</span>
  <span class="kd">const</span> <span class="nx">lines</span> <span class="o">=</span> <span class="nx">patchBody</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">);</span>

  <span class="kd">const</span> <span class="nx">operations</span><span class="p">:</span> <span class="nb">Array</span><span class="o">&lt;</span><span class="nx">ApplyPatchOp</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">line</span> <span class="k">of</span> <span class="nx">lines</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 3. Check for operation markers:</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="dl">"</span><span class="s2">*** Add File: </span><span class="dl">"</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">operations</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">create</span><span class="dl">"</span><span class="p">,</span> <span class="na">path</span><span class="p">:</span> <span class="cm">/* path */</span><span class="p">,</span> <span class="na">content</span><span class="p">:</span> <span class="dl">""</span> <span class="p">});</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="dl">"</span><span class="s2">*** Delete File: </span><span class="dl">"</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">operations</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">delete</span><span class="dl">"</span><span class="p">,</span> <span class="na">path</span><span class="p">:</span> <span class="cm">/* path */</span> <span class="p">});</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">line</span><span class="p">.</span><span class="nx">startsWith</span><span class="p">(</span><span class="dl">"</span><span class="s2">*** Update File: </span><span class="dl">"</span><span class="p">))</span> <span class="p">{</span>
      <span class="nx">operations</span><span class="p">.</span><span class="nx">push</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">"</span><span class="s2">update</span><span class="dl">"</span><span class="p">,</span> <span class="na">path</span><span class="p">:</span> <span class="cm">/* path */</span><span class="p">,</span> <span class="na">update</span><span class="p">:</span> <span class="dl">""</span><span class="p">,</span> <span class="na">added</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="na">deleted</span><span class="p">:</span> <span class="mi">0</span> <span class="p">});</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">operations</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 4. If inside an operation, parse the content/diff lines (+/-)</span>
      <span class="kd">const</span> <span class="nx">lastOp</span> <span class="o">=</span> <span class="nx">operations</span><span class="p">[</span><span class="nx">operations</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
      <span class="c1">// ... add line content to create/update operation ...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Invalid line outside of an operation</span>
      <span class="k">return</span> <span class="kc">null</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">operations</span><span class="p">;</span> <span class="c1">// Return the list of parsed operations</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This parser specifically understands the <code class="language-plaintext highlighter-rouge">*** Add File:</code>, <code class="language-plaintext highlighter-rouge">*** Delete File:</code>, <code class="language-plaintext highlighter-rouge">*** Update File:</code> markers and the <code class="language-plaintext highlighter-rouge">+</code>/<code class="language-plaintext highlighter-rouge">-</code> lines within patches to figure out exactly which files to change and how.</p>

<h3 id="displaying-tool-calls-terminal-chat-response-itemtsx">Displaying Tool Calls (<code class="language-plaintext highlighter-rouge">terminal-chat-response-item.tsx</code>)</h3>

<p>The UI needs to show tool calls differently from regular messages.</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: codex-cli/src/components/chat/terminal-chat-response-item.tsx (Simplified)</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">parseToolCall</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">../../utils/parsers</span><span class="dl">"</span><span class="p">;</span>
<span class="c1">// ... other imports: Box, Text from ink ...</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">TerminalChatResponseItem</span><span class="p">({</span> <span class="nx">item</span> <span class="p">}:</span> <span class="p">{</span> <span class="nl">item</span><span class="p">:</span> <span class="nx">ResponseItem</span> <span class="p">}):</span> <span class="nx">React</span><span class="p">.</span><span class="nx">ReactElement</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="kd">type</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">message</span><span class="dl">"</span><span class="p">:</span>
      <span class="c1">// ... render regular message ...</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">function_call</span><span class="dl">"</span><span class="p">:</span> <span class="c1">// &lt;-- Handle tool calls</span>
      <span class="k">return</span> <span class="p">&lt;</span><span class="nc">TerminalChatResponseToolCall</span> <span class="na">message</span><span class="p">=</span><span class="si">{</span><span class="nx">item</span><span class="si">}</span> <span class="p">/&gt;;</span>
    <span class="k">case</span> <span class="dl">"</span><span class="s2">function_call_output</span><span class="dl">"</span><span class="p">:</span>
      <span class="c1">// ... render tool output ...</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="c1">// ... other cases ...</span>
  <span class="p">}</span>
  <span class="c1">// ... fallback ...</span>
<span class="p">}</span>

<span class="kd">function</span> <span class="nx">TerminalChatResponseToolCall</span><span class="p">({</span> <span class="nx">message</span> <span class="p">}:</span> <span class="p">{</span> <span class="nl">message</span><span class="p">:</span> <span class="nx">ResponseFunctionToolCallItem</span> <span class="p">})</span> <span class="p">{</span>
  <span class="c1">// Use the parser to get displayable details</span>
  <span class="kd">const</span> <span class="nx">details</span> <span class="o">=</span> <span class="nx">parseToolCall</span><span class="p">(</span><span class="nx">message</span><span class="p">);</span> <span class="c1">// From parsers.ts</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">details</span><span class="p">)</span> <span class="k">return</span> <span class="p">&lt;</span><span class="nc">Text</span> <span class="na">color</span><span class="p">=</span><span class="s">"red"</span><span class="p">&gt;</span>Invalid tool call<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;;</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">Box</span> <span class="na">flexDirection</span><span class="p">=</span><span class="s">"column"</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="nc">Text</span> <span class="na">color</span><span class="p">=</span><span class="s">"magentaBright"</span> <span class="na">bold</span><span class="p">&gt;</span>command<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span>
      <span class="si">{</span><span class="cm">/* Display the nicely formatted command */</span><span class="si">}</span>
      <span class="p">&lt;</span><span class="nc">Text</span><span class="p">&gt;&lt;</span><span class="nc">Text</span> <span class="na">dimColor</span><span class="p">&gt;</span>$<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span> <span class="si">{</span><span class="nx">details</span><span class="p">.</span><span class="nx">cmdReadableText</span><span class="si">}</span><span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nc">Box</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>The main component checks the <code class="language-plaintext highlighter-rouge">item.type</code>.</li>
  <li>If it’s <code class="language-plaintext highlighter-rouge">function_call</code>, it renders a specific component (<code class="language-plaintext highlighter-rouge">TerminalChatResponseToolCall</code>).</li>
  <li>This component uses <code class="language-plaintext highlighter-rouge">parseToolCall</code> (from <code class="language-plaintext highlighter-rouge">utils/parsers.ts</code>) to get the details and displays the command in a distinct style (e.g., with a <code class="language-plaintext highlighter-rouge">$</code> prefix and magenta color).</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve now seen how Codex acts as an interpreter for the AI. It doesn’t just receive text; it receives structured instructions. The <strong>Response &amp; Tool Call Handling</strong> system is responsible for parsing these instructions, figuring out if the AI wants to use a tool (like <code class="language-plaintext highlighter-rouge">shell</code> or <code class="language-plaintext highlighter-rouge">apply_patch</code>), and extracting the precise arguments needed for that tool. This crucial step translates the AI’s intentions into actionable details that Codex can then use to interact with your system, always respecting the rules set by the <a href="04_approval_policy___security.md">Approval Policy &amp; Security</a>.</p>

<p>Now that Codex understands <em>what</em> command the AI wants to run (e.g., <code class="language-plaintext highlighter-rouge">git status</code>), how does it actually <em>execute</em> that command safely, especially if running in <code class="language-plaintext highlighter-rouge">full-auto</code> mode? That’s the topic of our next chapter.</p>

<p>Next up: <a href="06_command_execution___sandboxing.md">Command Execution &amp; Sandboxing</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
