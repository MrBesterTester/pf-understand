<h1 id="chapter-2-input-handling-textbuffereditor">Chapter 2: Input Handling (TextBuffer/Editor)</h1>

<p>In the <a href="01_terminal_ui__ink_components_.md">previous chapter</a>, we saw how Codex uses Ink and React to draw the chat interface in your terminal. We learned about components like <code class="language-plaintext highlighter-rouge">&lt;TerminalChatInput&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;MultilineTextEditor&gt;</code> that show an input box. But how does that input box <em>actually work</em>?</p>

<h2 id="why-a-fancy-input-box">Why a Fancy Input Box?</h2>

<p>Imagine you want Codex to write a small Python script. You might type something like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Write</span> <span class="n">a</span> <span class="n">python</span> <span class="n">function</span> <span class="n">that</span><span class="p">:</span>
<span class="mf">1.</span> <span class="n">Takes</span> <span class="n">a</span> <span class="nb">list</span> <span class="n">of</span> <span class="n">numbers</span><span class="p">.</span>
<span class="mf">2.</span> <span class="n">Returns</span> <span class="n">a</span> <span class="n">new</span> <span class="nb">list</span> <span class="n">containing</span> <span class="n">only</span> <span class="n">the</span> <span class="n">even</span> <span class="n">numbers</span><span class="p">.</span>
<span class="n">Make</span> <span class="n">sure</span> <span class="n">it</span> <span class="n">handles</span> <span class="n">empty</span> <span class="n">lists</span> <span class="n">gracefully</span><span class="p">.</span>
</code></pre></div></div>

<p>Or maybe you’re reviewing a command Codex proposed and want to give detailed feedback. A simple, single-line input field like your shell’s basic prompt would be really awkward for this! You’d want to:</p>

<ul>
  <li>Write multiple lines easily.</li>
  <li>Use arrow keys to move your cursor around to fix typos.</li>
  <li>Maybe jump back a whole word (<code class="language-plaintext highlighter-rouge">Ctrl+LeftArrow</code>) or delete a word (<code class="language-plaintext highlighter-rouge">Ctrl+Backspace</code>).</li>
  <li>Press <code class="language-plaintext highlighter-rouge">Up</code> or <code class="language-plaintext highlighter-rouge">Down</code> arrow to bring back previous messages you sent (history).</li>
  <li>Perhaps even open the current text in your main code editor (like VS Code or Vim) for complex edits (<code class="language-plaintext highlighter-rouge">Ctrl+X</code>).</li>
</ul>

<p>This is where the <strong>Input Handling</strong> system comes in. It’s like a mini text editor built right into the Codex chat interface, designed to make typing potentially complex prompts and messages much easier than a standard terminal input line.</p>

<h2 id="key-idea-the-textbuffer">Key Idea: The <code class="language-plaintext highlighter-rouge">TextBuffer</code></h2>

<p>The heart of this system is a class called <code class="language-plaintext highlighter-rouge">TextBuffer</code> (found in <code class="language-plaintext highlighter-rouge">text-buffer.ts</code>). Think of <code class="language-plaintext highlighter-rouge">TextBuffer</code> like the hidden document model behind a simple text editor (like Notepad or TextEdit):</p>

<ul>
  <li><strong>It holds the text:</strong> It stores all the lines of text you’ve typed into the input box in an internal list (an array of strings called <code class="language-plaintext highlighter-rouge">lines</code>).</li>
  <li><strong>It knows where the cursor is:</strong> It keeps track of the cursor’s position (which <code class="language-plaintext highlighter-rouge">row</code> and <code class="language-plaintext highlighter-rouge">column</code> it’s on).</li>
  <li><strong>It handles edits:</strong> When you press keys like letters, numbers, Backspace, Delete, or Enter, the <code class="language-plaintext highlighter-rouge">TextBuffer</code> modifies the text and updates the cursor position accordingly.</li>
  <li><strong>It manages scrolling:</strong> If your text gets longer than the input box can display, the <code class="language-plaintext highlighter-rouge">TextBuffer</code> figures out which part of the text should be visible.</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">MultilineTextEditor</code> React component we saw in Chapter 1 uses an instance of this <code class="language-plaintext highlighter-rouge">TextBuffer</code> internally to manage the state of the text being edited.</p>

<h2 id="how-you-use-it-indirectly">How You Use It (Indirectly)</h2>

<p>You don’t directly interact with <code class="language-plaintext highlighter-rouge">TextBuffer</code> yourself. You interact with the <code class="language-plaintext highlighter-rouge">&lt;MultilineTextEditor&gt;</code> component displayed by Ink. But understanding <code class="language-plaintext highlighter-rouge">TextBuffer</code> helps you see <em>how</em> the editor works.</p>

<p>Let’s look at a simplified view of how the <code class="language-plaintext highlighter-rouge">&lt;TerminalChatNewInput&gt;</code> component uses <code class="language-plaintext highlighter-rouge">&lt;MultilineTextEditor&gt;</code>:</p>

<div class="language-tsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: codex-cli/src/components/chat/terminal-chat-new-input.tsx (Simplified)</span>
<span class="k">import</span> <span class="nx">React</span><span class="p">,</span> <span class="p">{</span> <span class="nx">useState</span><span class="p">,</span> <span class="nx">useCallback</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">react</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">Box</span><span class="p">,</span> <span class="nx">Text</span><span class="p">,</span> <span class="nx">useInput</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">ink</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="nx">MultilineTextEditor</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">./multiline-editor</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// Our editor component</span>
<span class="c1">// ... other imports</span>

<span class="k">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">TerminalChatInput</span><span class="p">({</span> <span class="nx">submitInput</span><span class="p">,</span> <span class="nx">active</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">})</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">input</span><span class="p">,</span> <span class="nx">setInput</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span> <span class="c1">// Holds the current text in the editor state</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">history</span><span class="p">,</span> <span class="nx">setHistory</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">([]);</span> <span class="c1">// Holds past submitted messages</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">historyIndex</span><span class="p">,</span> <span class="nx">setHistoryIndex</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="o">&lt;</span><span class="kr">number</span> <span class="o">|</span> <span class="kc">null</span><span class="o">&gt;</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
  <span class="c1">// Used to force re-render editor when history changes text</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">editorKey</span><span class="p">,</span> <span class="nx">setEditorKey</span><span class="p">]</span> <span class="o">=</span> <span class="nx">useState</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="kd">const</span> <span class="nx">editorRef</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">useRef</span><span class="p">(</span><span class="cm">/* ... */</span><span class="p">);</span> <span class="c1">// Handle to the editor</span>

  <span class="c1">// --- History Handling (Simplified) ---</span>
  <span class="nx">useInput</span><span class="p">((</span><span class="nx">_input</span><span class="p">,</span> <span class="nx">key</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// Check if Up/Down arrow pressed AND cursor is at top/bottom line</span>
    <span class="kd">const</span> <span class="nx">isAtTop</span> <span class="o">=</span> <span class="nx">editorRef</span><span class="p">.</span><span class="nx">current</span><span class="p">?.</span><span class="nx">isCursorAtFirstRow</span><span class="p">();</span>
    <span class="kd">const</span> <span class="nx">isAtBottom</span> <span class="o">=</span> <span class="nx">editorRef</span><span class="p">.</span><span class="nx">current</span><span class="p">?.</span><span class="nx">isCursorAtLastRow</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="nx">key</span><span class="p">.</span><span class="nx">upArrow</span> <span class="o">&amp;&amp;</span> <span class="nx">isAtTop</span> <span class="o">&amp;&amp;</span> <span class="nx">history</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Logic to go back in history</span>
      <span class="kd">const</span> <span class="nx">newIndex</span> <span class="o">=</span> <span class="nx">historyIndex</span> <span class="o">===</span> <span class="kc">null</span> <span class="p">?</span> <span class="nx">history</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">historyIndex</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
      <span class="nx">setHistoryIndex</span><span class="p">(</span><span class="nx">newIndex</span><span class="p">);</span>
      <span class="nx">setInput</span><span class="p">(</span><span class="nx">history</span><span class="p">[</span><span class="nx">newIndex</span><span class="p">]</span> <span class="o">??</span> <span class="dl">""</span><span class="p">);</span> <span class="c1">// Set the text to the historical item</span>
      <span class="nx">setEditorKey</span><span class="p">(</span><span class="nx">k</span> <span class="o">=&gt;</span> <span class="nx">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Force editor to re-mount with new text</span>
      <span class="c1">// ... save draft if needed ...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">key</span><span class="p">.</span><span class="nx">downArrow</span> <span class="o">&amp;&amp;</span> <span class="nx">isAtBottom</span> <span class="o">&amp;&amp;</span> <span class="nx">historyIndex</span> <span class="o">!==</span> <span class="kc">null</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Logic to go forward in history or restore draft</span>
      <span class="c1">// ... similar logic using setInput, setHistoryIndex, setEditorKey ...</span>
    <span class="p">}</span>
    <span class="c1">// Note: If not handling history, the key press falls through to MultilineTextEditor</span>
  <span class="p">},</span> <span class="p">{</span> <span class="na">isActive</span><span class="p">:</span> <span class="nx">active</span> <span class="p">});</span>


  <span class="c1">// --- Submission Handling ---</span>
  <span class="kd">const</span> <span class="nx">onSubmit</span> <span class="o">=</span> <span class="nx">useCallback</span><span class="p">((</span><span class="nx">textFromEditor</span><span class="p">:</span> <span class="kr">string</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">trimmedText</span> <span class="o">=</span> <span class="nx">textFromEditor</span><span class="p">.</span><span class="nx">trim</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">trimmedText</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span> <span class="c1">// Ignore empty submissions</span>

    <span class="c1">// Add to history</span>
    <span class="nx">setHistory</span><span class="p">(</span><span class="nx">prev</span> <span class="o">=&gt;</span> <span class="p">[...</span><span class="nx">prev</span><span class="p">,</span> <span class="nx">textFromEditor</span><span class="p">]);</span>
    <span class="nx">setHistoryIndex</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span> <span class="c1">// Reset history navigation</span>

    <span class="c1">// Send the input to the Agent Loop!</span>
    <span class="nx">submitInput</span><span class="p">(</span><span class="cm">/* ... create input item from trimmedText ... */</span><span class="p">);</span>

    <span class="c1">// Clear the input for the next message</span>
    <span class="nx">setInput</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
    <span class="nx">setEditorKey</span><span class="p">(</span><span class="nx">k</span> <span class="o">=&gt;</span> <span class="nx">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Force editor reset</span>

  <span class="p">},</span> <span class="p">[</span><span class="nx">submitInput</span><span class="p">,</span> <span class="nx">setHistory</span> <span class="cm">/* ... */</span><span class="p">]);</span>

  <span class="k">return</span> <span class="p">(</span>
    <span class="p">&lt;</span><span class="nc">Box</span> <span class="na">flexDirection</span><span class="p">=</span><span class="s">"column"</span> <span class="na">borderStyle</span><span class="p">=</span><span class="s">"round"</span><span class="p">&gt;</span>
      <span class="si">{</span><span class="cm">/* The actual editor component */</span><span class="si">}</span>
      <span class="p">&lt;</span><span class="nc">MultilineTextEditor</span>
        <span class="na">ref</span><span class="p">=</span><span class="si">{</span><span class="nx">editorRef</span><span class="si">}</span> <span class="c1">// Connect ref for cursor position checks</span>
        <span class="na">key</span><span class="p">=</span><span class="si">{</span><span class="nx">editorKey</span><span class="si">}</span> <span class="c1">// Force re-render on key change</span>
        <span class="na">initialText</span><span class="p">=</span><span class="si">{</span><span class="nx">input</span><span class="si">}</span> <span class="c1">// Tell editor what text to display initially</span>
        <span class="na">focus</span><span class="p">=</span><span class="si">{</span><span class="nx">active</span><span class="si">}</span> <span class="c1">// Tell editor whether to capture keys</span>
        <span class="na">onChange</span><span class="p">=</span><span class="si">{</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">setInput</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span><span class="si">}</span> <span class="c1">// Update React state when text changes internally</span>
        <span class="na">onSubmit</span><span class="p">=</span><span class="si">{</span><span class="nx">onSubmit</span><span class="si">}</span> <span class="c1">// Tell editor what to do on Enter</span>
        <span class="na">height</span><span class="p">=</span><span class="si">{</span><span class="mi">8</span><span class="si">}</span> <span class="c1">// Example height</span>
      <span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nc">Text</span> <span class="na">dimColor</span><span class="p">&gt;</span>ctrl+c exit | enter send | ↑↓ history | ctrl+x editor<span class="p">&lt;/</span><span class="nc">Text</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="nc">Box</span><span class="p">&gt;</span>
  <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">initialText={input}</code>:</strong> The <code class="language-plaintext highlighter-rouge">&lt;MultilineTextEditor&gt;</code> starts with the text held in the <code class="language-plaintext highlighter-rouge">input</code> state variable. This is how history navigation works – we change <code class="language-plaintext highlighter-rouge">input</code> and force a re-render.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">onChange={(text) =&gt; setInput(text)}</code>:</strong> Whenever the text <em>inside</em> the <code class="language-plaintext highlighter-rouge">MultilineTextEditor</code> (managed by its internal <code class="language-plaintext highlighter-rouge">TextBuffer</code>) changes, it calls this function. We update the <code class="language-plaintext highlighter-rouge">input</code> state variable in the parent component (<code class="language-plaintext highlighter-rouge">TerminalChatNewInput</code>) to keep track, though often the editor manages its own state primarily.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">onSubmit={onSubmit}</code>:</strong> When you press Enter (in a way that signifies submission, not just adding a newline), the <code class="language-plaintext highlighter-rouge">MultilineTextEditor</code> calls this <code class="language-plaintext highlighter-rouge">onSubmit</code> function, passing the final text content. This function then sends the message off to the <a href="03_agent_loop.md">Agent Loop</a> and clears the input.</li>
  <li><strong>History (<code class="language-plaintext highlighter-rouge">useInput</code>):</strong> The parent component (<code class="language-plaintext highlighter-rouge">TerminalChatNewInput</code>) uses Ink’s <code class="language-plaintext highlighter-rouge">useInput</code> hook to <em>intercept</em> the Up/Down arrow keys <em>before</em> they even reach the <code class="language-plaintext highlighter-rouge">MultilineTextEditor</code>. It checks if the cursor (using <code class="language-plaintext highlighter-rouge">editorRef.current?.isCursorAtFirstRow()</code>) is at the very top/bottom edge of the text. If so, it handles history navigation by changing the <code class="language-plaintext highlighter-rouge">input</code> state and forcing the editor to update using <code class="language-plaintext highlighter-rouge">setEditorKey</code>. If the cursor isn’t at the edge, it lets the arrow key “fall through” to the <code class="language-plaintext highlighter-rouge">MultilineTextEditor</code>, which then just moves the cursor normally within the text via its internal <code class="language-plaintext highlighter-rouge">TextBuffer</code>.</li>
</ul>

<h2 id="under-the-hood-keystroke-to-display">Under the Hood: Keystroke to Display</h2>

<p>Let’s trace what happens when you type a character, say ‘h’, into the input box:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant Terminal
    participant InkUI as Ink/React (MultilineTextEditor)
    participant TextBuffer
    participant AgentLoop as Agent Loop (Not involved)

    User-&gt;&gt;Terminal: Presses 'h' key
    Terminal-&gt;&gt;InkUI: Terminal sends key event to Ink
    InkUI-&gt;&gt;InkUI: `useInput` hook captures 'h'
    InkUI-&gt;&gt;TextBuffer: Calls `handleInput('h', { ... }, viewport)`
    TextBuffer-&gt;&gt;TextBuffer: Finds current line ("") and cursor (0,0)
    TextBuffer-&gt;&gt;TextBuffer: Calls `insert('h')`
    TextBuffer-&gt;&gt;TextBuffer: Updates `lines` to `["h"]`
    TextBuffer-&gt;&gt;TextBuffer: Updates `cursorCol` to 1
    TextBuffer-&gt;&gt;TextBuffer: Increments internal `version`
    TextBuffer--&gt;&gt;InkUI: Returns `true` (buffer was modified)
    InkUI-&gt;&gt;InkUI: Triggers a React re-render because internal state changed
    InkUI-&gt;&gt;TextBuffer: Calls `getVisibleLines(viewport)` -&gt; returns `["h"]`
    InkUI-&gt;&gt;TextBuffer: Calls `getCursor()` -&gt; returns `[0, 1]`
    InkUI-&gt;&gt;Terminal: Renders the updated text ("h") with cursor highlight
</code></pre>

<ol>
  <li><strong>Keystroke:</strong> You press the ‘h’ key.</li>
  <li><strong>Capture:</strong> Ink’s <code class="language-plaintext highlighter-rouge">useInput</code> hook within <code class="language-plaintext highlighter-rouge">&lt;MultilineTextEditor&gt;</code> receives the key event.</li>
  <li><strong>Delegate:</strong> <code class="language-plaintext highlighter-rouge">&lt;MultilineTextEditor&gt;</code> calls the <code class="language-plaintext highlighter-rouge">handleInput</code> method on its internal <code class="language-plaintext highlighter-rouge">TextBuffer</code> instance, passing the input character (‘h’), key modifier flags (like Shift, Ctrl - none in this case), and the current visible area size (viewport).</li>
  <li><strong>Update State:</strong> <code class="language-plaintext highlighter-rouge">TextBuffer.handleInput</code> determines it’s a simple character insertion. It calls its internal <code class="language-plaintext highlighter-rouge">insert</code> method.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">insert</code> Method:</strong>
    <ul>
      <li>Gets the current line (e.g., <code class="language-plaintext highlighter-rouge">""</code>).</li>
      <li>Splits the line at the cursor position (0).</li>
      <li>Inserts the character: <code class="language-plaintext highlighter-rouge">""</code> + <code class="language-plaintext highlighter-rouge">'h'</code> + <code class="language-plaintext highlighter-rouge">""</code> -&gt; <code class="language-plaintext highlighter-rouge">"h"</code>.</li>
      <li>Updates the <code class="language-plaintext highlighter-rouge">lines</code> array: <code class="language-plaintext highlighter-rouge">["h"]</code>.</li>
      <li>Updates the cursor column: <code class="language-plaintext highlighter-rouge">0</code> -&gt; <code class="language-plaintext highlighter-rouge">1</code>.</li>
      <li>Increments an internal version number to track changes.</li>
    </ul>
  </li>
  <li><strong>Signal Change:</strong> <code class="language-plaintext highlighter-rouge">handleInput</code> returns <code class="language-plaintext highlighter-rouge">true</code> because the buffer was modified.</li>
  <li><strong>Re-render:</strong> The <code class="language-plaintext highlighter-rouge">&lt;MultilineTextEditor&gt;</code> component detects the change (either via the return value or its internal state update) and triggers a React re-render.</li>
  <li><strong>Get Display Data:</strong> During the render, <code class="language-plaintext highlighter-rouge">&lt;MultilineTextEditor&gt;</code> calls methods on the <code class="language-plaintext highlighter-rouge">TextBuffer</code> like:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">getVisibleLines()</code>: Gets the lines of text that should currently be visible based on scrolling.</li>
      <li><code class="language-plaintext highlighter-rouge">getCursor()</code>: Gets the current row and column of the cursor.</li>
    </ul>
  </li>
  <li><strong>Draw:</strong> The component uses this information to render the text (<code class="language-plaintext highlighter-rouge">h</code>) in the terminal. It uses the cursor position to draw the cursor, often by rendering the character <em>at</em> the cursor position with an inverted background color (like <code class="language-plaintext highlighter-rouge">chalk.inverse(char)</code>).</li>
</ol>

<p>This same loop happens for every key press: Backspace calls <code class="language-plaintext highlighter-rouge">TextBuffer.backspace()</code>, arrow keys call <code class="language-plaintext highlighter-rouge">TextBuffer.move()</code>, Enter calls <code class="language-plaintext highlighter-rouge">TextBuffer.newline()</code> (or triggers <code class="language-plaintext highlighter-rouge">onSubmit</code>), etc.</p>

<h2 id="diving-into-textbuffer-code-simplified">Diving into <code class="language-plaintext highlighter-rouge">TextBuffer</code> Code (Simplified)</h2>

<p>Let’s peek inside <code class="language-plaintext highlighter-rouge">text-buffer.ts</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// File: codex-cli/src/text-buffer.ts (Simplified)</span>

<span class="c1">// Helper to check if a character is part of a "word"</span>
<span class="kd">function</span> <span class="nx">isWordChar</span><span class="p">(</span><span class="nx">ch</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
  <span class="c1">// Simplified: returns true if not whitespace or basic punctuation</span>
  <span class="k">return</span> <span class="nx">ch</span> <span class="o">!==</span> <span class="kc">undefined</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="sr">/</span><span class="se">[\s</span><span class="sr">,.;!?</span><span class="se">]</span><span class="sr">/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">ch</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Helper to get the length respecting multi-byte characters (like emoji)</span>
<span class="kd">function</span> <span class="nx">cpLen</span><span class="p">(</span><span class="nx">str</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">str</span><span class="p">).</span><span class="nx">length</span><span class="p">;</span> <span class="p">}</span>
<span class="c1">// Helper to slice respecting multi-byte characters</span>
<span class="kd">function</span> <span class="nx">cpSlice</span><span class="p">(</span><span class="nx">str</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">start</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span> <span class="nx">end</span><span class="p">?:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">Array</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">str</span><span class="p">).</span><span class="nx">slice</span><span class="p">(</span><span class="nx">start</span><span class="p">,</span> <span class="nx">end</span><span class="p">).</span><span class="nx">join</span><span class="p">(</span><span class="dl">''</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">export</span> <span class="k">default</span> <span class="kd">class</span> <span class="nx">TextBuffer</span> <span class="p">{</span>
  <span class="c1">// --- Core State ---</span>
  <span class="k">private</span> <span class="nx">lines</span><span class="p">:</span> <span class="kr">string</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[</span><span class="dl">""</span><span class="p">];</span> <span class="c1">// The text, line by line</span>
  <span class="k">private</span> <span class="nx">cursorRow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>          <span class="c1">// Cursor's current line number</span>
  <span class="k">private</span> <span class="nx">cursorCol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>          <span class="c1">// Cursor's column (character index) on the line</span>
  <span class="c1">// ... scrollRow, scrollCol for viewport management ...</span>
  <span class="k">private</span> <span class="nx">version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>            <span class="c1">// Increments on each change</span>

  <span class="kd">constructor</span><span class="p">(</span><span class="nx">text</span> <span class="o">=</span> <span class="dl">""</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">lines</span> <span class="o">=</span> <span class="nx">text</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">lines</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">lines</span> <span class="o">=</span> <span class="p">[</span><span class="dl">""</span><span class="p">];</span>
    <span class="c1">// Start cursor at the end</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">lines</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">lineLen</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// --- Internal Helpers ---</span>
  <span class="k">private</span> <span class="nx">line</span><span class="p">(</span><span class="nx">r</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">string</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">lines</span><span class="p">[</span><span class="nx">r</span><span class="p">]</span> <span class="o">??</span> <span class="dl">""</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">private</span> <span class="nx">lineLen</span><span class="p">(</span><span class="nx">r</span><span class="p">:</span> <span class="kr">number</span><span class="p">):</span> <span class="kr">number</span> <span class="p">{</span> <span class="k">return</span> <span class="nx">cpLen</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">line</span><span class="p">(</span><span class="nx">r</span><span class="p">));</span> <span class="p">}</span>
  <span class="k">private</span> <span class="nx">ensureCursorInRange</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span> <span class="cm">/* Makes sure row/col are valid */</span> <span class="p">}</span>

  <span class="c1">// --- Public Accessors ---</span>
  <span class="nx">getCursor</span><span class="p">():</span> <span class="p">[</span><span class="kr">number</span><span class="p">,</span> <span class="kr">number</span><span class="p">]</span> <span class="p">{</span> <span class="k">return</span> <span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span><span class="p">];</span> <span class="p">}</span>
  <span class="nx">getText</span><span class="p">():</span> <span class="kr">string</span> <span class="p">{</span> <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">lines</span><span class="p">.</span><span class="nx">join</span><span class="p">(</span><span class="dl">"</span><span class="se">\n</span><span class="dl">"</span><span class="p">);</span> <span class="p">}</span>
  <span class="nx">getVisibleLines</span><span class="p">(</span><span class="cm">/* viewport */</span><span class="p">):</span> <span class="kr">string</span><span class="p">[]</span> <span class="p">{</span>
    <span class="c1">// ... calculate visible lines based on scrollRow/Col ...</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">lines</span><span class="p">;</span> <span class="c1">// Simplified: return all lines</span>
  <span class="p">}</span>

  <span class="c1">// --- Editing Operations ---</span>
  <span class="nx">insert</span><span class="p">(</span><span class="nx">ch</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="c1">// ... handle potential newlines by calling insertStr ...</span>
    <span class="kd">const</span> <span class="nx">line</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">line</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="p">);</span>
    <span class="c1">// Use cpSlice for multi-byte character safety</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">lines</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="p">]</span> <span class="o">=</span>
      <span class="nx">cpSlice</span><span class="p">(</span><span class="nx">line</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span><span class="p">)</span> <span class="o">+</span> <span class="nx">ch</span> <span class="o">+</span> <span class="nx">cpSlice</span><span class="p">(</span><span class="nx">line</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span><span class="p">);</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span> <span class="o">+=</span> <span class="nx">cpLen</span><span class="p">(</span><span class="nx">ch</span><span class="p">);</span> <span class="c1">// Use cpLen</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">version</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">newline</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">line</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">line</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">before</span> <span class="o">=</span> <span class="nx">cpSlice</span><span class="p">(</span><span class="nx">line</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span><span class="p">);</span>
    <span class="kd">const</span> <span class="nx">after</span> <span class="o">=</span> <span class="nx">cpSlice</span><span class="p">(</span><span class="nx">line</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span><span class="p">);</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">lines</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="p">]</span> <span class="o">=</span> <span class="nx">before</span><span class="p">;</span> <span class="c1">// Keep text before cursor on current line</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">lines</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">after</span><span class="p">);</span> <span class="c1">// Insert text after cursor as new line</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="o">++</span><span class="p">;</span> <span class="c1">// Move cursor down</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// Move cursor to start of new line</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">version</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="nx">backspace</span><span class="p">():</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// If not at start of line</span>
      <span class="kd">const</span> <span class="nx">line</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">line</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">lines</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="p">]</span> <span class="o">=</span>
        <span class="nx">cpSlice</span><span class="p">(</span><span class="nx">line</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nx">cpSlice</span><span class="p">(</span><span class="nx">line</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span><span class="p">);</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span><span class="o">--</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">version</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// If at start of line (but not first line)</span>
      <span class="c1">// Merge with previous line</span>
      <span class="kd">const</span> <span class="nx">prevLine</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">line</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
      <span class="kd">const</span> <span class="nx">currentLine</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">line</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="p">);</span>
      <span class="kd">const</span> <span class="nx">newCol</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">lineLen</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Cursor goes to end of merged line</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">lines</span><span class="p">[</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nx">prevLine</span> <span class="o">+</span> <span class="nx">currentLine</span><span class="p">;</span> <span class="c1">// Combine lines</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">lines</span><span class="p">.</span><span class="nx">splice</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// Remove the now-empty current line</span>

      <span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="o">--</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span> <span class="o">=</span> <span class="nx">newCol</span><span class="p">;</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">version</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Do nothing if at row 0, col 0</span>
  <span class="p">}</span>

  <span class="nx">move</span><span class="p">(</span><span class="nx">dir</span><span class="p">:</span> <span class="dl">'</span><span class="s1">left</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">right</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">up</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">down</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">wordLeft</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">wordRight</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">home</span><span class="dl">'</span> <span class="o">|</span> <span class="dl">'</span><span class="s1">end</span><span class="dl">'</span><span class="p">):</span> <span class="k">void</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="nx">dir</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="dl">'</span><span class="s1">left</span><span class="dl">'</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span><span class="o">--</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Move to end of prev line */</span> <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="dl">'</span><span class="s1">right</span><span class="dl">'</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">lineLen</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="p">))</span> <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span><span class="o">++</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span> <span class="o">&lt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">lines</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Move to start of next line */</span> <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="dl">'</span><span class="s1">up</span><span class="dl">'</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="o">--</span><span class="p">;</span>
          <span class="c1">// Try to maintain horizontal position (handle preferredCol logic)</span>
          <span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span> <span class="o">=</span> <span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorCol</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">lineLen</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">cursorRow</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="c1">// ... other cases (down, home, end) ...</span>
      <span class="k">case</span> <span class="dl">'</span><span class="s1">wordLeft</span><span class="dl">'</span><span class="p">:</span> <span class="p">{</span>
        <span class="c1">// Scan backwards from cursorCol, skip whitespace, then skip word chars</span>
        <span class="c1">// Update this.cursorCol to the start of the word/whitespace run</span>
        <span class="c1">// ... implementation details ...</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// ... wordRight ...</span>
    <span class="p">}</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">ensureCursorInRange</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// --- High-Level Input Handler ---</span>
  <span class="nx">handleInput</span><span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span> <span class="o">|</span> <span class="kc">undefined</span><span class="p">,</span> <span class="nx">key</span><span class="p">:</span> <span class="nb">Record</span><span class="o">&lt;</span><span class="kr">string</span><span class="p">,</span> <span class="nx">boolean</span><span class="o">&gt;</span><span class="p">,</span> <span class="cm">/* viewport */</span><span class="p">):</span> <span class="nx">boolean</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">beforeVersion</span> <span class="o">=</span> <span class="k">this</span><span class="p">.</span><span class="nx">version</span><span class="p">;</span>
    <span class="c1">// Check key flags (key.leftArrow, key.backspace, key.ctrl, etc.)</span>
    <span class="c1">// and the `input` character itself.</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">key</span><span class="p">.</span><span class="nx">leftArrow</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">key</span><span class="p">.</span><span class="nx">ctrl</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">key</span><span class="p">.</span><span class="nx">meta</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">move</span><span class="p">(</span><span class="dl">'</span><span class="s1">left</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">key</span><span class="p">.</span><span class="nx">rightArrow</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">key</span><span class="p">.</span><span class="nx">ctrl</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">key</span><span class="p">.</span><span class="nx">meta</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">move</span><span class="p">(</span><span class="dl">'</span><span class="s1">right</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">key</span><span class="p">.</span><span class="nx">upArrow</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">move</span><span class="p">(</span><span class="dl">'</span><span class="s1">up</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">key</span><span class="p">.</span><span class="nx">downArrow</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">move</span><span class="p">(</span><span class="dl">'</span><span class="s1">down</span><span class="dl">'</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="nx">key</span><span class="p">.</span><span class="nx">ctrl</span> <span class="o">||</span> <span class="nx">key</span><span class="p">.</span><span class="nx">meta</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">key</span><span class="p">.</span><span class="nx">leftArrow</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">move</span><span class="p">(</span><span class="dl">'</span><span class="s1">wordLeft</span><span class="dl">'</span><span class="p">);</span>
    <span class="c1">// ... handle wordRight, home, end ...</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">key</span><span class="p">.</span><span class="nx">backspace</span> <span class="o">||</span> <span class="nx">input</span> <span class="o">===</span> <span class="dl">'</span><span class="se">\</span><span class="s1">x7f</span><span class="dl">'</span> <span class="cm">/* DEL char */</span><span class="p">)</span> <span class="k">this</span><span class="p">.</span><span class="nx">backspace</span><span class="p">();</span>
    <span class="c1">// ... handle delete, newline (Enter) ...</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nx">input</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">key</span><span class="p">.</span><span class="nx">ctrl</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="nx">key</span><span class="p">.</span><span class="nx">meta</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// If it's a printable character (and not a special key combo)</span>
      <span class="k">this</span><span class="p">.</span><span class="nx">insert</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// ... ensure cursor visible based on viewport ...</span>
    <span class="k">return</span> <span class="k">this</span><span class="p">.</span><span class="nx">version</span> <span class="o">!==</span> <span class="nx">beforeVersion</span><span class="p">;</span> <span class="c1">// Return true if text changed</span>
  <span class="p">}</span>

  <span class="c1">// --- External Editor ---</span>
  <span class="k">async</span> <span class="nx">openInExternalEditor</span><span class="p">():</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="k">void</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// 1. Get editor from $VISUAL or $EDITOR env var (fallback to vi/notepad)</span>
    <span class="c1">// 2. Write this.getText() to a temporary file</span>
    <span class="c1">// 3. Use Node's `spawnSync` to run the editor command with the temp file path</span>
    <span class="c1">//    (This blocks until the editor is closed)</span>
    <span class="c1">// 4. Read the content back from the temp file</span>
    <span class="c1">// 5. Update this.lines, this.cursorRow, this.cursorCol</span>
    <span class="c1">// 6. Clean up the temp file</span>
    <span class="k">this</span><span class="p">.</span><span class="nx">version</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">lines</code> array holds the actual text content.</li>
  <li><code class="language-plaintext highlighter-rouge">cursorRow</code> and <code class="language-plaintext highlighter-rouge">cursorCol</code> track the insertion point.</li>
  <li>Methods like <code class="language-plaintext highlighter-rouge">insert</code>, <code class="language-plaintext highlighter-rouge">backspace</code>, <code class="language-plaintext highlighter-rouge">newline</code>, and <code class="language-plaintext highlighter-rouge">move</code> directly manipulate <code class="language-plaintext highlighter-rouge">lines</code>, <code class="language-plaintext highlighter-rouge">cursorRow</code>, and <code class="language-plaintext highlighter-rouge">cursorCol</code>. They use helpers like <code class="language-plaintext highlighter-rouge">cpLen</code> and <code class="language-plaintext highlighter-rouge">cpSlice</code> to correctly handle characters that might take up more than one byte (like emojis).</li>
  <li><code class="language-plaintext highlighter-rouge">handleInput</code> acts as the main entry point, deciding which specific editing operation to perform based on the key pressed.</li>
  <li><code class="language-plaintext highlighter-rouge">openInExternalEditor</code> handles the <code class="language-plaintext highlighter-rouge">Ctrl+X</code> magic by saving to a temp file, running your system’s default editor, and reloading the content.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve now seen how Codex provides a surprisingly powerful text editing experience right within your terminal. It goes far beyond a simple input line by using the <code class="language-plaintext highlighter-rouge">&lt;MultilineTextEditor&gt;</code> component, which relies heavily on the internal <code class="language-plaintext highlighter-rouge">TextBuffer</code> class. This class manages the text content, cursor position, and editing operations like insertion, deletion, multi-line handling, cursor navigation (including word jumps), and even integration with external editors. This allows you to compose complex prompts or provide detailed feedback without leaving the terminal interface.</p>

<p>With the UI drawn and user input handled, what happens next? How does Codex take your input, think about it, and generate a response or decide to run a command? That’s the job of the core logic loop.</p>

<p>Next up: <a href="03_agent_loop.md">Agent Loop</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
