<h1 id="chapter-8-array_function-protocol--overrides-overrides">Chapter 8: <strong>array_function</strong> Protocol / Overrides (<code class="language-plaintext highlighter-rouge">overrides</code>)</h1>

<p>Welcome to the final chapter of our NumPy Core exploration! In <a href="07_umath_module.md">Chapter 7: umath Module</a>, we learned how NumPy implements its fast, element-wise mathematical functions (<code class="language-plaintext highlighter-rouge">ufuncs</code>) using optimized C code. We’ve seen the core components: the <code class="language-plaintext highlighter-rouge">ndarray</code> container, <code class="language-plaintext highlighter-rouge">dtype</code> descriptions, <code class="language-plaintext highlighter-rouge">ufunc</code> operations, numeric types, printing, and the C modules (<code class="language-plaintext highlighter-rouge">multiarray</code>, <code class="language-plaintext highlighter-rouge">umath</code>) that power them.</p>

<p>But NumPy doesn’t exist in isolation. The Python scientific ecosystem is full of other libraries that also work with array-like data. Think of libraries like Dask (for parallel computing on large datasets that don’t fit in memory) or CuPy (for running NumPy-like operations on GPUs). How can these <em>different</em> types of arrays work smoothly with standard NumPy functions like <code class="language-plaintext highlighter-rouge">np.sum</code>, <code class="language-plaintext highlighter-rouge">np.mean</code>, or <code class="language-plaintext highlighter-rouge">np.concatenate</code>?</p>

<h2 id="what-problem-does-__array_function__-solve-speaking-numpys-language">What Problem Does <code class="language-plaintext highlighter-rouge">__array_function__</code> Solve? Speaking NumPy’s Language</h2>

<p>Imagine you have a special type of array, maybe one that lives on a GPU (like a CuPy array) or one that represents a computation spread across many machines (like a Dask array). You want to calculate the sum of its elements.</p>

<p>Ideally, you’d just write:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Assume 'my_special_array' is an instance of a custom array type
# (e.g., from CuPy or Dask)
</span><span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">my_special_array</span><span class="p">)</span>
</code></pre></div></div>

<p>But wait, <code class="language-plaintext highlighter-rouge">np.sum</code> is a NumPy function, designed primarily for NumPy’s <code class="language-plaintext highlighter-rouge">ndarray</code> (<a href="01_ndarray__n_dimensional_array_.md">Chapter 1: ndarray (N-dimensional array)</a>). How can it possibly know how to sum elements on a GPU or coordinate a distributed calculation?</p>

<p>Before the <code class="language-plaintext highlighter-rouge">__array_function__</code> protocol, this was tricky. Either the library (like CuPy) had to provide its <em>own</em> complete set of functions (<code class="language-plaintext highlighter-rouge">cupy.sum</code>), or NumPy would have needed specific code to handle every possible external array type, which is impossible to maintain.</p>

<p>We need a way for NumPy functions to ask the input objects: “Hey, do <em>you</em> know how to handle this operation (<code class="language-plaintext highlighter-rouge">np.sum</code> in this case)?” If the object says yes, NumPy can step back and let the object take control.</p>

<p>This is exactly what the <code class="language-plaintext highlighter-rouge">__array_function__</code> protocol (defined in NEP-18) allows. It’s like a common language or negotiation rule that lets different array libraries “override” or take over the execution of NumPy functions when their objects are involved.</p>

<p><strong>Analogy:</strong> Think of NumPy functions as a universal remote control. Initially, it only knows how to control NumPy-brand TVs (<code class="language-plaintext highlighter-rouge">ndarray</code>s). The <code class="language-plaintext highlighter-rouge">__array_function__</code> protocol is like adding a feature where the remote, when pointed at a different brand TV (like a CuPy array), asks the TV: “Do you understand this button (e.g., ‘sum’)?” If the TV responds, “Yes, here’s how I do ‘sum’,” the remote lets the TV handle it.</p>

<h2 id="what-is-the-__array_function__-protocol">What is the <code class="language-plaintext highlighter-rouge">__array_function__</code> Protocol?</h2>

<p>The <code class="language-plaintext highlighter-rouge">__array_function__</code> protocol is a special method that array-like objects can implement. When a NumPy function is called with arguments that include one or more objects defining <code class="language-plaintext highlighter-rouge">__array_function__</code>, NumPy follows these steps:</p>

<ol>
  <li><strong>Check Arguments:</strong> NumPy looks at all the input arguments passed to the function (e.g., <code class="language-plaintext highlighter-rouge">np.sum(my_array, axis=0)</code>).</li>
  <li><strong>Find Overrides:</strong> It identifies which arguments have an <code class="language-plaintext highlighter-rouge">__array_function__</code> method.</li>
  <li><strong>Prioritize:</strong> It sorts these arguments based on a special attribute (<code class="language-plaintext highlighter-rouge">__array_priority__</code>) or by their position in the function call if priorities are equal. Subclasses are also considered.</li>
  <li><strong>Negotiate:</strong> It calls the <code class="language-plaintext highlighter-rouge">__array_function__</code> method of the highest-priority object. It passes two key pieces of information to this method:
    <ul>
      <li>The original NumPy function object itself (e.g., <code class="language-plaintext highlighter-rouge">np.sum</code>).</li>
      <li>The arguments (<code class="language-plaintext highlighter-rouge">*args</code>) and keyword arguments (<code class="language-plaintext highlighter-rouge">**kwargs</code>) that were originally passed to the NumPy function.</li>
    </ul>
  </li>
  <li><strong>Delegate:</strong> The object’s <code class="language-plaintext highlighter-rouge">__array_function__</code> method now has control. It can:
    <ul>
      <li>Handle the operation itself (e.g., perform a GPU sum if it’s a CuPy array) and return the result.</li>
      <li>Decide it <em>cannot</em> handle this specific function or combination of arguments and return a special value <code class="language-plaintext highlighter-rouge">NotImplemented</code>. In this case, NumPy tries the <code class="language-plaintext highlighter-rouge">__array_function__</code> method of the <em>next</em> highest-priority object.</li>
      <li>Potentially call the original NumPy function on converted inputs if needed.</li>
    </ul>
  </li>
  <li><strong>Fallback:</strong> If <em>no</em> object’s <code class="language-plaintext highlighter-rouge">__array_function__</code> method handles the call (they all return <code class="language-plaintext highlighter-rouge">NotImplemented</code>), NumPy raises a <code class="language-plaintext highlighter-rouge">TypeError</code>. <em>Crucially, NumPy usually does NOT fall back to its own default implementation on the foreign objects unless explicitly told to by the override.</em></li>
</ol>

<h2 id="using-__array_function__-implementing-a-simple-override">Using <code class="language-plaintext highlighter-rouge">__array_function__</code> (Implementing a Simple Override)</h2>

<p>Let’s create a very basic array-like class that overrides <code class="language-plaintext highlighter-rouge">np.sum</code> but lets other functions pass through (by returning <code class="language-plaintext highlighter-rouge">NotImplemented</code>).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="k">class</span> <span class="nc">MySimpleArray</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="c1"># Store data internally, maybe as a NumPy array for simplicity here
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

    <span class="c1"># This is the magic method!
</span>    <span class="k">def</span> <span class="nf">__array_function__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">types</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"MySimpleArray.__array_function__ got called for </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">:</span>
            <span class="c1"># Handle np.sum ourselves!
</span>            <span class="k">print</span><span class="p">(</span><span class="s">"-&gt; Handling np.sum internally!"</span><span class="p">)</span>
            <span class="c1"># Convert args to NumPy arrays if they are MySimpleArray
</span>            <span class="n">np_args</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">.</span><span class="n">_data</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MySimpleArray</span><span class="p">)</span> <span class="k">else</span> <span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">args</span><span class="p">]</span>
            <span class="n">np_kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">.</span><span class="n">_data</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">MySimpleArray</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="c1"># Perform the actual sum using NumPy on the internal data
</span>            <span class="k">return</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="o">*</span><span class="n">np_args</span><span class="p">,</span> <span class="o">**</span><span class="n">np_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For any other function, say we don't handle it
</span>            <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"-&gt; Don't know how to handle </span><span class="si">{</span><span class="n">func</span><span class="p">.</span><span class="n">__name__</span><span class="si">}</span><span class="s">, returning NotImplemented."</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">NotImplemented</span>

    <span class="c1"># Make it look a bit like an array for printing
</span>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s">"MySimpleArray(</span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">_data</span><span class="si">}</span><span class="s">)"</span>

<span class="c1"># --- Try it out ---
</span><span class="n">my_arr</span> <span class="o">=</span> <span class="n">MySimpleArray</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Array:"</span><span class="p">,</span> <span class="n">my_arr</span><span class="p">)</span>

<span class="c1"># Call np.sum
</span><span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Calling np.sum(my_arr):"</span><span class="p">)</span>
<span class="n">total</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">my_arr</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Result:"</span><span class="p">,</span> <span class="n">total</span><span class="p">)</span>

<span class="c1"># Call np.mean (which our class doesn't handle)
</span><span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Calling np.mean(my_arr):"</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">mean_val</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">mean</span><span class="p">(</span><span class="n">my_arr</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Result:"</span><span class="p">,</span> <span class="n">mean_val</span><span class="p">)</span>
<span class="k">except</span> <span class="nb">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Caught expected TypeError:"</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Output:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Array: MySimpleArray([1 2 3 4])

Calling np.sum(my_arr):
MySimpleArray.__array_function__ got called for sum
-&gt; Handling np.sum internally!
Result: 10

Calling np.mean(my_arr):
MySimpleArray.__array_function__ got called for mean
-&gt; Don't know how to handle mean, returning NotImplemented.
Caught expected TypeError: no implementation found for 'numpy.mean' on types that implement __array_function__: [&lt;class '__main__.MySimpleArray'&gt;]
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li>We created <code class="language-plaintext highlighter-rouge">MySimpleArray</code> which holds some data (here, a standard NumPy array <code class="language-plaintext highlighter-rouge">_data</code>).</li>
  <li>We implemented <code class="language-plaintext highlighter-rouge">__array_function__(self, func, types, args, kwargs)</code>.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">func</code>: The NumPy function being called (e.g., <code class="language-plaintext highlighter-rouge">np.sum</code>, <code class="language-plaintext highlighter-rouge">np.mean</code>).</li>
      <li><code class="language-plaintext highlighter-rouge">types</code>: A tuple of unique types implementing <code class="language-plaintext highlighter-rouge">__array_function__</code> in the arguments.</li>
      <li><code class="language-plaintext highlighter-rouge">args</code>, <code class="language-plaintext highlighter-rouge">kwargs</code>: The original arguments passed to <code class="language-plaintext highlighter-rouge">func</code>.</li>
    </ul>
  </li>
  <li>Inside <code class="language-plaintext highlighter-rouge">__array_function__</code>, we check if <code class="language-plaintext highlighter-rouge">func</code> is <code class="language-plaintext highlighter-rouge">np.sum</code>.
    <ul>
      <li>If yes, we print a message, extract the internal <code class="language-plaintext highlighter-rouge">_data</code> from any <code class="language-plaintext highlighter-rouge">MySimpleArray</code> arguments, call <code class="language-plaintext highlighter-rouge">np.sum</code> on that data, and return the result. NumPy uses this returned value directly.</li>
      <li>If no (like for <code class="language-plaintext highlighter-rouge">np.mean</code>), we print a message and return <code class="language-plaintext highlighter-rouge">NotImplemented</code>.</li>
    </ul>
  </li>
  <li>When we call <code class="language-plaintext highlighter-rouge">np.sum(my_arr)</code>, NumPy detects <code class="language-plaintext highlighter-rouge">__array_function__</code> on <code class="language-plaintext highlighter-rouge">my_arr</code>. It calls it. Our method handles <code class="language-plaintext highlighter-rouge">np.sum</code> and returns <code class="language-plaintext highlighter-rouge">10</code>.</li>
  <li>When we call <code class="language-plaintext highlighter-rouge">np.mean(my_arr)</code>, NumPy again calls <code class="language-plaintext highlighter-rouge">__array_function__</code>. This time, our method returns <code class="language-plaintext highlighter-rouge">NotImplemented</code>. Since no other arguments handle it, NumPy raises a <code class="language-plaintext highlighter-rouge">TypeError</code> because it doesn’t know how to calculate the mean of <code class="language-plaintext highlighter-rouge">MySimpleArray</code> by default.</li>
</ol>

<p>This example demonstrates how an external library object can selectively take control of NumPy functions. Libraries like CuPy or Dask implement <code class="language-plaintext highlighter-rouge">__array_function__</code> much more thoroughly, handling many NumPy functions to perform operations on their specific data representations (GPU arrays, distributed arrays).</p>

<h2 id="a-glimpse-under-the-hood-overridespy">A Glimpse Under the Hood (<code class="language-plaintext highlighter-rouge">overrides.py</code>)</h2>

<p>How does NumPy actually manage this dispatching process? The logic lives primarily in the <code class="language-plaintext highlighter-rouge">numpy/core/overrides.py</code> module.</p>

<ol>
  <li><strong>Decorator:</strong> Many NumPy functions (especially those intended to be public and potentially overridden) are decorated with <code class="language-plaintext highlighter-rouge">@array_function_dispatch(...)</code> or a similar helper (<code class="language-plaintext highlighter-rouge">@array_function_from_dispatcher</code>). You can see this decorator used in files like <code class="language-plaintext highlighter-rouge">numpy/core/function_base.py</code> (for <code class="language-plaintext highlighter-rouge">linspace</code>, <code class="language-plaintext highlighter-rouge">logspace</code>, etc.) or <code class="language-plaintext highlighter-rouge">numpy/core/numeric.py</code> (for <code class="language-plaintext highlighter-rouge">sum</code>, <code class="language-plaintext highlighter-rouge">mean</code>, etc. indirectly via ufunc machinery).
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Example from numpy/core/function_base.py (simplified)
</span><span class="kn">from</span> <span class="nn">numpy._core</span> <span class="kn">import</span> <span class="n">overrides</span>

<span class="n">array_function_dispatch</span> <span class="o">=</span> <span class="n">functools</span><span class="p">.</span><span class="n">partial</span><span class="p">(</span>
    <span class="n">overrides</span><span class="p">.</span><span class="n">array_function_dispatch</span><span class="p">,</span> <span class="n">module</span><span class="o">=</span><span class="s">'numpy'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_linspace_dispatcher</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="p">...):</span>
    <span class="c1"># This helper identifies arguments relevant for dispatch
</span>    <span class="k">return</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">)</span>

<span class="o">@</span><span class="n">array_function_dispatch</span><span class="p">(</span><span class="n">_linspace_dispatcher</span><span class="p">)</span> <span class="c1"># Decorator applied!
</span><span class="k">def</span> <span class="nf">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="p">...):</span>
    <span class="c1"># ... Actual implementation for NumPy arrays ...
</span>    <span class="k">pass</span>
</code></pre></div>    </div>
  </li>
  <li><strong>Dispatcher Class:</strong> The decorator wraps the original function (like <code class="language-plaintext highlighter-rouge">linspace</code>) in a special callable object, often an instance of <code class="language-plaintext highlighter-rouge">_ArrayFunctionDispatcher</code>.</li>
  <li><strong>Call Interception:</strong> When you call the decorated NumPy function (e.g., <code class="language-plaintext highlighter-rouge">np.linspace(...)</code>), you’re actually calling the <code class="language-plaintext highlighter-rouge">_ArrayFunctionDispatcher</code> object.</li>
  <li><strong>Argument Check (<code class="language-plaintext highlighter-rouge">_get_implementing_args</code>):</strong> The dispatcher object first calls the little helper function provided to the decorator (like <code class="language-plaintext highlighter-rouge">_linspace_dispatcher</code>) to figure out which arguments are relevant for checking the <code class="language-plaintext highlighter-rouge">__array_function__</code> protocol. Then, it calls the C helper function <code class="language-plaintext highlighter-rouge">_get_implementing_args</code> (defined in <code class="language-plaintext highlighter-rouge">numpy/core/src/multiarray/overrides.c</code>) which efficiently inspects the relevant arguments, finds those with <code class="language-plaintext highlighter-rouge">__array_function__</code>, and sorts them according to priority and type relationships.</li>
  <li><strong>Delegation Loop:</strong> The dispatcher iterates through the implementing arguments found in step 4 (from highest priority to lowest). For each one, it calls its <code class="language-plaintext highlighter-rouge">__array_function__</code> method.</li>
  <li><strong>Handle Result:</strong>
    <ul>
      <li>If <code class="language-plaintext highlighter-rouge">__array_function__</code> returns a value other than <code class="language-plaintext highlighter-rouge">NotImplemented</code>, the dispatcher immediately returns that value to the original caller. The process stops.</li>
      <li>If <code class="language-plaintext highlighter-rouge">__array_function__</code> returns <code class="language-plaintext highlighter-rouge">NotImplemented</code>, the dispatcher continues to the next implementing argument in the list.</li>
    </ul>
  </li>
  <li><strong>Error or Default:</strong> If the loop finishes without any override handling the call, a <code class="language-plaintext highlighter-rouge">TypeError</code> is raised.</li>
</ol>

<p>Here’s a simplified sequence diagram for <code class="language-plaintext highlighter-rouge">np.sum(my_arr)</code>:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant NumPyFunc as np.sum (Dispatcher Object)
    participant Overrides as numpy.core.overrides
    participant CustomArr as my_arr (MySimpleArray)

    User-&gt;&gt;NumPyFunc: np.sum(my_arr)
    NumPyFunc-&gt;&gt;Overrides: Get relevant args (my_arr)
    Overrides-&gt;&gt;Overrides: _get_implementing_args([my_arr])
    Overrides--&gt;&gt;NumPyFunc: Found [my_arr] implements __array_function__
    NumPyFunc-&gt;&gt;CustomArr: call __array_function__(func=np.sum, ...)
    CustomArr-&gt;&gt;CustomArr: Check if func is np.sum (Yes)
    CustomArr-&gt;&gt;CustomArr: Perform custom sum logic
    CustomArr--&gt;&gt;NumPyFunc: Return result (e.g., 10)
    NumPyFunc--&gt;&gt;User: Return result (10)
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">numpy/core/overrides.py</code> file defines the Python-level infrastructure (<code class="language-plaintext highlighter-rouge">array_function_dispatch</code>, <code class="language-plaintext highlighter-rouge">_ArrayFunctionDispatcher</code>), while the core logic for efficiently finding and sorting implementing arguments (<code class="language-plaintext highlighter-rouge">_get_implementing_args</code>) is implemented in C for performance.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The <code class="language-plaintext highlighter-rouge">__array_function__</code> protocol is a powerful mechanism that makes NumPy far more extensible and integrated with the wider Python ecosystem. You’ve learned:</p>

<ul>
  <li>It allows objects from <strong>other libraries</strong> (like Dask, CuPy) to <strong>override</strong> how NumPy functions behave when passed instances of those objects.</li>
  <li>It works via a special method, <code class="language-plaintext highlighter-rouge">__array_function__</code>, that implementing objects define.</li>
  <li>NumPy <strong>negotiates</strong> with arguments: it checks for the method and <strong>delegates</strong> the call if an argument handles it.</li>
  <li>This enables writing code that looks like standard NumPy (<code class="language-plaintext highlighter-rouge">np.sum(my_obj)</code>) but can operate seamlessly on diverse array types (CPU, GPU, distributed).</li>
  <li>The dispatch logic is managed primarily by decorators and helpers in <code class="language-plaintext highlighter-rouge">numpy/core/overrides.py</code>, relying on a C function (<code class="language-plaintext highlighter-rouge">_get_implementing_args</code>) for efficient argument checking.</li>
</ul>

<p>This protocol is a key part of why NumPy remains central to scientific computing in Python, allowing it to interact smoothly with specialized array libraries without requiring NumPy itself to know the specifics of each one.</p>

<p>This concludes our tour through the core concepts of NumPy! We hope this journey from the fundamental <code class="language-plaintext highlighter-rouge">ndarray</code> to the sophisticated <code class="language-plaintext highlighter-rouge">__array_function__</code> protocol has given you a deeper appreciation for how NumPy works under the hood.</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
