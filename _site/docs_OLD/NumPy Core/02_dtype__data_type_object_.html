<h1 id="chapter-2-dtype-data-type-object">Chapter 2: dtype (Data Type Object)</h1>

<p>In <a href="01_ndarray__n_dimensional_array_.md">Chapter 1: ndarray (N-dimensional array)</a>, we learned that NumPy’s <code class="language-plaintext highlighter-rouge">ndarray</code> is a powerful grid designed to hold items <strong>of the same type</strong>. This “same type” requirement is fundamental to NumPy’s speed and efficiency. But how does NumPy know <em>what kind</em> of data it’s storing? That’s where the <code class="language-plaintext highlighter-rouge">dtype</code> comes in!</p>

<h2 id="what-problem-does-dtype-solve">What Problem Does <code class="language-plaintext highlighter-rouge">dtype</code> Solve?</h2>

<p>Imagine you have a list of numbers in Python: <code class="language-plaintext highlighter-rouge">[1, 2, 3]</code>. Are these small integers? Big integers? Numbers with decimal points? Python figures this out on the fly, which is flexible but can be slow for large datasets.</p>

<p>NumPy needs to be much faster. To achieve speed, it needs to know <em>exactly</em> what kind of data is in an array <em>before</em> doing any calculations. Is it a tiny integer that fits in 1 byte? A standard integer using 4 bytes? A decimal number needing 8 bytes?</p>

<p>Knowing the exact type and size allows NumPy to:</p>
<ol>
  <li><strong>Allocate Memory Efficiently:</strong> If you have a million small integers, NumPy can reserve exactly the right amount of memory, not wasting space.</li>
  <li><strong>Perform Fast Math:</strong> NumPy can use highly optimized, low-level C or Fortran code that works directly with specific number types (like 32-bit integers or 64-bit floats). These low-level operations are much faster than Python’s flexible number handling.</li>
</ol>

<p>Think of it like packing boxes. If you know you’re only packing small screws (like <code class="language-plaintext highlighter-rouge">int8</code>), you can use small, efficiently packed boxes. If you’re packing large bolts (<code class="language-plaintext highlighter-rouge">int64</code>), you need bigger boxes. If you just have a mixed bag (like a Python list), you need a much larger, less efficient container to hold everything. The <code class="language-plaintext highlighter-rouge">dtype</code> is the label on the box telling NumPy exactly what’s inside.</p>

<h2 id="what-is-a-dtype-data-type-object">What is a <code class="language-plaintext highlighter-rouge">dtype</code> (Data Type Object)?</h2>

<p>A <code class="language-plaintext highlighter-rouge">dtype</code> is a special <strong>object</strong> in NumPy that describes the <strong>type</strong> and <strong>size</strong> of data stored in an <code class="language-plaintext highlighter-rouge">ndarray</code>. Every <code class="language-plaintext highlighter-rouge">ndarray</code> has a <code class="language-plaintext highlighter-rouge">dtype</code> associated with it.</p>

<p>It’s like specifying the “column type” in a database or spreadsheet. If you set a column to “Integer”, you expect only whole numbers in that column. If you set it to “Decimal”, you expect numbers with potential decimal points. Similarly, the <code class="language-plaintext highlighter-rouge">dtype</code> ensures all elements in a NumPy array are consistent.</p>

<p>Let’s see it in action. Remember from Chapter 1 how we could check the attributes of an array?</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="c1"># Create an array of integers
</span><span class="n">int_array</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Integer array: </span><span class="si">{</span><span class="n">int_array</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Data type: </span><span class="si">{</span><span class="n">int_array</span><span class="p">.</span><span class="n">dtype</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># Create an array of floating-point numbers (decimals)
</span><span class="n">float_array</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.5</span><span class="p">,</span> <span class="mf">3.14</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">Float array: </span><span class="si">{</span><span class="n">float_array</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Data type: </span><span class="si">{</span><span class="n">float_array</span><span class="p">.</span><span class="n">dtype</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># Create an array of booleans (True/False)
</span><span class="n">bool_array</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="bp">True</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="bp">True</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">Boolean array: </span><span class="si">{</span><span class="n">bool_array</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Data type: </span><span class="si">{</span><span class="n">bool_array</span><span class="p">.</span><span class="n">dtype</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Output:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Integer array: [1 2 3]
Data type: int64

Float array: [1.   2.5  3.14]
Data type: float64

Boolean array: [ True False  True]
Data type: bool
</code></pre></div></div>

<p>Look at the <code class="language-plaintext highlighter-rouge">Data type:</code> lines.</p>
<ul>
  <li>For <code class="language-plaintext highlighter-rouge">int_array</code>, NumPy chose <code class="language-plaintext highlighter-rouge">int64</code>. This means each element is a 64-bit signed integer (a whole number that can be positive or negative, stored using 64 bits or 8 bytes). The <code class="language-plaintext highlighter-rouge">64</code> tells us the size.</li>
  <li>For <code class="language-plaintext highlighter-rouge">float_array</code>, NumPy chose <code class="language-plaintext highlighter-rouge">float64</code>. Each element is a 64-bit floating-point number (a number with a potential decimal point, following the standard IEEE 754 format, stored using 64 bits or 8 bytes).</li>
  <li>For <code class="language-plaintext highlighter-rouge">bool_array</code>, NumPy chose <code class="language-plaintext highlighter-rouge">bool</code>. Each element is a boolean value (True or False), typically stored using 1 byte.</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">dtype</code> object holds this crucial information.</p>

<h2 id="specifying-the-dtype">Specifying the <code class="language-plaintext highlighter-rouge">dtype</code></h2>

<p>NumPy usually makes a good guess about the <code class="language-plaintext highlighter-rouge">dtype</code> when you create an array from a list. But sometimes you need to be explicit, especially if you want to save memory or ensure a specific precision.</p>

<p>You can specify the <code class="language-plaintext highlighter-rouge">dtype</code> when creating an array using the <code class="language-plaintext highlighter-rouge">dtype</code> argument:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="n">np</span>

<span class="c1"># Create an array, specifying 32-bit integers
</span><span class="n">arr_i32</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">int32</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Array: </span><span class="si">{</span><span class="n">arr_i32</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Data type: </span><span class="si">{</span><span class="n">arr_i32</span><span class="p">.</span><span class="n">dtype</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Bytes per element: </span><span class="si">{</span><span class="n">arr_i32</span><span class="p">.</span><span class="n">itemsize</span><span class="si">}</span><span class="s">"</span><span class="p">)</span> <span class="c1"># itemsize shows bytes
</span>
<span class="c1"># Create an array, specifying 32-bit floats
</span><span class="n">arr_f32</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">Array: </span><span class="si">{</span><span class="n">arr_f32</span><span class="si">}</span><span class="s">"</span><span class="p">)</span> <span class="c1"># Notice the decimal points now!
</span><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Data type: </span><span class="si">{</span><span class="n">arr_f32</span><span class="p">.</span><span class="n">dtype</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Bytes per element: </span><span class="si">{</span><span class="n">arr_f32</span><span class="p">.</span><span class="n">itemsize</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># Create an array using string codes for dtype
</span><span class="n">arr_f64_str</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s">'float64'</span><span class="p">)</span> <span class="c1"># Equivalent to np.float64
</span><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">Array: </span><span class="si">{</span><span class="n">arr_f64_str</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Data type: </span><span class="si">{</span><span class="n">arr_f64_str</span><span class="p">.</span><span class="n">dtype</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Bytes per element: </span><span class="si">{</span><span class="n">arr_f64_str</span><span class="p">.</span><span class="n">itemsize</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Output:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Array: [1 2 3]
Data type: int32
Bytes per element: 4

Array: [1. 2. 3.]
Data type: float32
Bytes per element: 4

Array: [4. 5. 6.]
Data type: float64
Bytes per element: 8
</code></pre></div></div>

<p>Notice a few things:</p>
<ol>
  <li>We used <code class="language-plaintext highlighter-rouge">np.int32</code> and <code class="language-plaintext highlighter-rouge">np.float32</code> to explicitly ask for 32-bit types.</li>
  <li>The <code class="language-plaintext highlighter-rouge">.itemsize</code> attribute shows how many <em>bytes</em> each element takes. <code class="language-plaintext highlighter-rouge">int32</code> and <code class="language-plaintext highlighter-rouge">float32</code> use 4 bytes, while <code class="language-plaintext highlighter-rouge">float64</code> uses 8 bytes. Choosing <code class="language-plaintext highlighter-rouge">int32</code> instead of the default <code class="language-plaintext highlighter-rouge">int64</code> uses half the memory!</li>
  <li>You can use string codes like <code class="language-plaintext highlighter-rouge">'float64'</code> (or <code class="language-plaintext highlighter-rouge">'f8'</code>) instead of the type object <code class="language-plaintext highlighter-rouge">np.float64</code>.</li>
</ol>

<h3 id="common-data-type-codes">Common Data Type Codes</h3>

<p>NumPy offers various ways to specify dtypes. Here are the most common:</p>

<table>
  <thead>
    <tr>
      <th style="text-align: left">Type Category</th>
      <th style="text-align: left">NumPy Type Objects</th>
      <th style="text-align: left">String Codes (Common)</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left"><strong>Boolean</strong></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">np.bool_</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'?'</code> or <code class="language-plaintext highlighter-rouge">'bool'</code></td>
      <td style="text-align: left">True / False</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Signed Integer</strong></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">np.int8</code>, <code class="language-plaintext highlighter-rouge">np.int16</code>, <code class="language-plaintext highlighter-rouge">np.int32</code>, <code class="language-plaintext highlighter-rouge">np.int64</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'i1'</code>, <code class="language-plaintext highlighter-rouge">'i2'</code>, <code class="language-plaintext highlighter-rouge">'i4'</code>, <code class="language-plaintext highlighter-rouge">'i8'</code></td>
      <td style="text-align: left">Whole numbers (positive/negative)</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Unsigned Int</strong></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">np.uint8</code>, <code class="language-plaintext highlighter-rouge">np.uint16</code>, <code class="language-plaintext highlighter-rouge">np.uint32</code>, <code class="language-plaintext highlighter-rouge">np.uint64</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'u1'</code>, <code class="language-plaintext highlighter-rouge">'u2'</code>, <code class="language-plaintext highlighter-rouge">'u4'</code>, <code class="language-plaintext highlighter-rouge">'u8'</code></td>
      <td style="text-align: left">Whole numbers (non-negative)</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Floating Point</strong></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">np.float16</code>, <code class="language-plaintext highlighter-rouge">np.float32</code>, <code class="language-plaintext highlighter-rouge">np.float64</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'f2'</code>, <code class="language-plaintext highlighter-rouge">'f4'</code>, <code class="language-plaintext highlighter-rouge">'f8'</code></td>
      <td style="text-align: left">Decimal numbers</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Complex Float</strong></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">np.complex64</code>, <code class="language-plaintext highlighter-rouge">np.complex128</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'c8'</code>, <code class="language-plaintext highlighter-rouge">'c16'</code></td>
      <td style="text-align: left">Complex numbers (real+imaginary)</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>String (Fixed)</strong></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">np.bytes_</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'S'</code> + number</td>
      <td style="text-align: left">Fixed-length byte strings</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Unicode (Fixed)</strong></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">np.str_</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'U'</code> + number</td>
      <td style="text-align: left">Fixed-length unicode strings</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Object</strong></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">np.object_</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'O'</code></td>
      <td style="text-align: left">Python objects</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Datetime</strong></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">np.datetime64</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'M8'</code> + unit</td>
      <td style="text-align: left">Date and time values</td>
    </tr>
    <tr>
      <td style="text-align: left"><strong>Timedelta</strong></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">np.timedelta64</code></td>
      <td style="text-align: left"><code class="language-plaintext highlighter-rouge">'m8'</code> + unit</td>
      <td style="text-align: left">Time durations</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>The numbers in the string codes (<code class="language-plaintext highlighter-rouge">i4</code>, <code class="language-plaintext highlighter-rouge">f8</code>, <code class="language-plaintext highlighter-rouge">u2</code>) usually represent the number of <strong>bytes</strong>. So <code class="language-plaintext highlighter-rouge">i4</code> = 4-byte integer (<code class="language-plaintext highlighter-rouge">int32</code>), <code class="language-plaintext highlighter-rouge">f8</code> = 8-byte float (<code class="language-plaintext highlighter-rouge">float64</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">'S'</code> and <code class="language-plaintext highlighter-rouge">'U'</code> often need a number after them (e.g., <code class="language-plaintext highlighter-rouge">'S10'</code>, <code class="language-plaintext highlighter-rouge">'U25'</code>) to specify the maximum length of the string.</li>
  <li><code class="language-plaintext highlighter-rouge">'M8'</code> and <code class="language-plaintext highlighter-rouge">'m8'</code> usually have a unit like <code class="language-plaintext highlighter-rouge">[D]</code> for day or <code class="language-plaintext highlighter-rouge">[s]</code> for second (e.g., <code class="language-plaintext highlighter-rouge">'M8[D]'</code>). We’ll explore numeric types more in <a href="04_numeric_types___numerictypes__.md">Chapter 4: Numeric Types (<code class="language-plaintext highlighter-rouge">numerictypes</code>)</a>.</li>
</ul>

<p>Using explicit dtypes is important when:</p>
<ul>
  <li>You need to control memory usage (e.g., using <code class="language-plaintext highlighter-rouge">int8</code> if your numbers are always small).</li>
  <li>You are reading data from a file that has a specific binary format.</li>
  <li>You need a specific precision for calculations.</li>
</ul>

<h2 id="a-glimpse-under-the-hood">A Glimpse Under the Hood</h2>

<p>How does NumPy manage this <code class="language-plaintext highlighter-rouge">dtype</code> information internally?</p>

<p>The Python <code class="language-plaintext highlighter-rouge">dtype</code> object you interact with (like <code class="language-plaintext highlighter-rouge">arr.dtype</code>) is essentially a wrapper around more detailed information stored in a C structure within NumPy’s core. This C structure (often referred to as <code class="language-plaintext highlighter-rouge">PyArray_Descr</code>) contains everything NumPy needs to know to interpret the raw bytes in the <code class="language-plaintext highlighter-rouge">ndarray</code>’s memory block:</p>

<ol>
  <li><strong>Type Kind:</strong> Is it an integer, float, boolean, string, etc.? (Represented by a character like <code class="language-plaintext highlighter-rouge">'i'</code>, <code class="language-plaintext highlighter-rouge">'f'</code>, <code class="language-plaintext highlighter-rouge">'b'</code>, <code class="language-plaintext highlighter-rouge">'S'</code>).</li>
  <li><strong>Item Size:</strong> How many bytes does one element occupy? (e.g., 1, 2, 4, 8).</li>
  <li><strong>Byte Order:</strong> How are multi-byte numbers stored? (Little-endian <code class="language-plaintext highlighter-rouge">&lt;</code> or Big-endian <code class="language-plaintext highlighter-rouge">&gt;</code>. Important for reading files created on different types of computers).</li>
  <li><strong>Element Type:</strong> A pointer to the specific C-level functions that know how to operate on this data type.</li>
  <li><strong>Fields (for Structured Types):</strong> If it’s a structured dtype (like a C struct or a database row), information about the names, dtypes, and offsets of each field.</li>
  <li><strong>Subarray (for Nested Types):</strong> Information if the dtype itself represents an array.</li>
</ol>

<p>When you create an array or perform an operation:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant P as Python Code (Your script)
    participant NPF as NumPy Python Func (e.g., np.array)
    participant C_API as NumPy C API
    participant DTypeC as C Struct (PyArray_Descr)
    participant Mem as Memory

    P-&gt;&gt;NPF: np.array([1, 2], dtype='int32')
    NPF-&gt;&gt;C_API: Parse dtype string 'int32'
    C_API-&gt;&gt;DTypeC: Create/Find PyArray_Descr for int32 (kind='i', itemsize=4, etc.)
    C_API-&gt;&gt;Mem: Allocate memory (2 items * 4 bytes/item = 8 bytes)
    C_API-&gt;&gt;Mem: Copy data [1, 2] into memory as 32-bit ints
    C_API--&gt;&gt;NPF: Return C ndarray struct (pointing to Mem and DTypeC)
    NPF--&gt;&gt;P: Return Python ndarray object wrapping the C struct
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">dtype</code> is created or retrieved <em>once</em> and then referenced by potentially many arrays. This C-level description allows NumPy’s core functions, especially the <a href="03_ufunc__universal_function_.md">ufunc (Universal Function)</a>s we’ll see next, to work directly on the raw memory with maximum efficiency.</p>

<p>The Python code in <code class="language-plaintext highlighter-rouge">numpy/core/_dtype.py</code> helps manage the creation and representation (like the nice string output you see when you <code class="language-plaintext highlighter-rouge">print(arr.dtype)</code>) of these <code class="language-plaintext highlighter-rouge">dtype</code> objects in Python. For instance, functions like <code class="language-plaintext highlighter-rouge">_kind_name</code>, <code class="language-plaintext highlighter-rouge">__str__</code>, and <code class="language-plaintext highlighter-rouge">__repr__</code> in <code class="language-plaintext highlighter-rouge">_dtype.py</code> are used to generate the user-friendly names and representations based on the underlying C structure’s information. The <code class="language-plaintext highlighter-rouge">_dtype_ctypes.py</code> file helps bridge the gap between NumPy dtypes and Python’s built-in <code class="language-plaintext highlighter-rouge">ctypes</code> module, allowing interoperability.</p>

<h2 id="beyond-simple-numbers-structured-data-and-byte-order">Beyond Simple Numbers: Structured Data and Byte Order</h2>

<p><code class="language-plaintext highlighter-rouge">dtype</code>s can do more than just describe simple numbers:</p>

<ul>
  <li><strong>Structured Arrays:</strong> You can define a <code class="language-plaintext highlighter-rouge">dtype</code> that represents a mix of types, like a row in a table or a C struct. This is useful for representing structured data efficiently.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Define a structured dtype: a name (up to 10 chars) and an age (4-byte int)
</span><span class="n">person_dtype</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s">'name'</span><span class="p">,</span> <span class="s">'S10'</span><span class="p">),</span> <span class="p">(</span><span class="s">'age'</span><span class="p">,</span> <span class="s">'i4'</span><span class="p">)])</span>
<span class="n">people</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">array</span><span class="p">([(</span><span class="s">'Alice'</span><span class="p">,</span> <span class="mi">30</span><span class="p">),</span> <span class="p">(</span><span class="s">'Bob'</span><span class="p">,</span> <span class="mi">25</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">person_dtype</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">people</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">people</span><span class="p">.</span><span class="n">dtype</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">people</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="s">'name'</span><span class="p">])</span> <span class="c1"># Access fields by name
</span></code></pre></div>    </div>
    <p><strong>Output:</strong></p>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[(b'Alice', 30) (b'Bob', 25)]
[('name', 'S10'), ('age', '&lt;i4')]
b'Alice'
</code></pre></div>    </div>
  </li>
  <li><strong>Byte Order:</strong> Computers can store multi-byte numbers in different ways (“endianness”). <code class="language-plaintext highlighter-rouge">dtype</code>s can specify byte order (<code class="language-plaintext highlighter-rouge">&lt;</code> for little-endian, <code class="language-plaintext highlighter-rouge">&gt;</code> for big-endian) which is crucial for reading binary data correctly across different systems. Notice the <code class="language-plaintext highlighter-rouge">'&lt;i4'</code> in the output above – the <code class="language-plaintext highlighter-rouge">&lt;</code> indicates little-endian, which is common on x86 processors.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve now learned about the <code class="language-plaintext highlighter-rouge">dtype</code> object, the crucial piece of metadata that tells NumPy <em>what kind</em> of data is stored in an <code class="language-plaintext highlighter-rouge">ndarray</code>. You saw:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">dtype</code> describes the <strong>type</strong> and <strong>size</strong> of array elements.</li>
  <li>It’s essential for NumPy’s <strong>memory efficiency</strong> and <strong>computational speed</strong>.</li>
  <li>How to <strong>inspect</strong> (<code class="language-plaintext highlighter-rouge">arr.dtype</code>) and <strong>specify</strong> (<code class="language-plaintext highlighter-rouge">dtype=...</code>) data types using type objects (<code class="language-plaintext highlighter-rouge">np.int32</code>) or string codes (<code class="language-plaintext highlighter-rouge">'i4'</code>).</li>
  <li>That the Python <code class="language-plaintext highlighter-rouge">dtype</code> object represents lower-level C information (<code class="language-plaintext highlighter-rouge">PyArray_Descr</code>) used for efficient operations.</li>
  <li><code class="language-plaintext highlighter-rouge">dtype</code>s can also handle more complex scenarios like <strong>structured data</strong> and <strong>byte order</strong>.</li>
</ul>

<p>Understanding <code class="language-plaintext highlighter-rouge">dtype</code>s is key to understanding how NumPy manages data efficiently. With the container (<code class="language-plaintext highlighter-rouge">ndarray</code>) and its contents (<code class="language-plaintext highlighter-rouge">dtype</code>) defined, we can now explore how NumPy performs fast calculations on these arrays.</p>

<p>Next up, we’ll dive into the workhorses of NumPy’s element-wise computations: <a href="03_ufunc__universal_function_.md">Chapter 3: ufunc (Universal Function)</a>.</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
