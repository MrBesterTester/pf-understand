<h1 id="chapter-7-iterator---your-guide-through-the-database">Chapter 7: Iterator - Your Guide Through the Database</h1>

<p>Welcome back! In <a href="06_version___versionset.md">Chapter 6: Version &amp; VersionSet</a>, we learned how LevelDB keeps track of all the live SSTable files using <code class="language-plaintext highlighter-rouge">Version</code> objects and the <code class="language-plaintext highlighter-rouge">VersionSet</code>. This catalog helps LevelDB efficiently find a single key by looking first in the <a href="02_memtable.md">MemTable</a> and then pinpointing the right <a href="01_table___sstable___tablecache.md">SSTables</a> to check.</p>

<p>But what if you don’t want just <em>one</em> key? What if you want to see <em>all</em> the key-value pairs in the database, or all the keys within a specific range?</p>

<h2 id="whats-the-problem-scanning-multiple-keys">What’s the Problem? Scanning Multiple Keys</h2>

<p>Imagine you have a database storing user scores, with keys like <code class="language-plaintext highlighter-rouge">score:userA</code>, <code class="language-plaintext highlighter-rouge">score:userB</code>, <code class="language-plaintext highlighter-rouge">score:userC</code>, etc. How would you find all the users whose usernames start with ‘user’? Or how would you list all scores from highest to lowest?</p>

<p>Calling <code class="language-plaintext highlighter-rouge">db-&gt;Get()</code> repeatedly for every possible key isn’t practical or efficient. We need a way to easily <strong>scan</strong> or <strong>traverse</strong> through the key-value pairs stored in the database, in sorted order.</p>

<p>Furthermore, this scan needs to be smart. It has to combine the data from the current MemTable (the fast notepad), potentially an older immutable MemTable, and all the different SSTable files on disk. It also needs to correctly handle situations where a key was updated or deleted – showing you only the <em>latest</em> live version of the data, just like <code class="language-plaintext highlighter-rouge">Get</code> does.</p>

<h2 id="iterator-your-database-research-assistant">Iterator: Your Database Research Assistant</h2>

<p>LevelDB provides the <code class="language-plaintext highlighter-rouge">Iterator</code> concept to solve this. Think of an <code class="language-plaintext highlighter-rouge">Iterator</code> as a <strong>super-smart research assistant</strong>.</p>

<p>You tell the assistant what you’re looking for (e.g., “start from the beginning” or “find keys starting with ‘user’”). The assistant then efficiently looks through the current notepad (<code class="language-plaintext highlighter-rouge">MemTable</code>), the previous notepad (<code class="language-plaintext highlighter-rouge">imm_</code>), and all the relevant books on the shelves (<code class="language-plaintext highlighter-rouge">SSTables</code>), using the latest catalog (<code class="language-plaintext highlighter-rouge">Version</code>).</p>

<p>As the assistant finds relevant entries, it presents them to you one by one, in perfect sorted order by key. Crucially, the assistant knows how to:</p>

<ol>
  <li><strong>Merge Sources:</strong> Combine results from memory (MemTable) and disk (SSTables) seamlessly.</li>
  <li><strong>Handle Versions:</strong> If the same key exists in multiple places (e.g., an old value in an SSTable and a newer value in the MemTable), the assistant only shows you the <em>most recent</em> one based on the database’s internal sequence numbers.</li>
  <li><strong>Handle Deletions:</strong> If a key has been deleted, the assistant knows to <em>skip</em> it entirely, even if older versions of the key exist in SSTables.</li>
  <li><strong>Provide a Snapshot:</strong> An iterator typically operates on a consistent snapshot of the database. Data added <em>after</em> the iterator was created won’t suddenly appear during your scan.</li>
</ol>

<p>The main iterator you interact with, obtained via <code class="language-plaintext highlighter-rouge">db-&gt;NewIterator()</code>, is often implemented internally by a class called <code class="language-plaintext highlighter-rouge">DBIter</code>. <code class="language-plaintext highlighter-rouge">DBIter</code> coordinates the work of lower-level iterators.</p>

<h2 id="how-to-use-an-iterator">How to Use an Iterator</h2>

<p>Using an iterator is quite straightforward. Here’s a typical pattern:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"leveldb/db.h"</span><span class="cp">
#include</span> <span class="cpf">"leveldb/iterator.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="c1">// ... assume db is an open LevelDB database ...</span>

<span class="c1">// 1. Create an iterator</span>
<span class="n">leveldb</span><span class="o">::</span><span class="n">ReadOptions</span> <span class="n">options</span><span class="p">;</span>
<span class="c1">// options.snapshot = db-&gt;GetSnapshot(); // Optional: Use a specific snapshot</span>
<span class="n">leveldb</span><span class="o">::</span><span class="n">Iterator</span><span class="o">*</span> <span class="n">it</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">NewIterator</span><span class="p">(</span><span class="n">options</span><span class="p">);</span>

<span class="c1">// 2. Position the iterator (e.g., seek to the first key &gt;= "start_key")</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">start_key</span> <span class="o">=</span> <span class="s">"user:"</span><span class="p">;</span>
<span class="n">it</span><span class="o">-&gt;</span><span class="n">Seek</span><span class="p">(</span><span class="n">start_key</span><span class="p">);</span>

<span class="c1">// 3. Loop through the keys</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Keys starting with '"</span> <span class="o">&lt;&lt;</span> <span class="n">start_key</span> <span class="o">&lt;&lt;</span> <span class="s">"':"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">Valid</span><span class="p">();</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">leveldb</span><span class="o">::</span><span class="n">Slice</span> <span class="n">key</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">();</span>
  <span class="n">leveldb</span><span class="o">::</span><span class="n">Slice</span> <span class="n">value</span> <span class="o">=</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">();</span>

  <span class="c1">// Optional: Stop if we go past the desired range</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key</span><span class="p">.</span><span class="n">starts_with</span><span class="p">(</span><span class="n">start_key</span><span class="p">))</span> <span class="p">{</span>
     <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">key</span><span class="p">.</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" =&gt; "</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="p">.</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 4. Check for errors (optional but recommended)</span>
<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">it</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">().</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">"Iterator error: "</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">().</span><span class="n">ToString</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 5. Clean up the iterator and snapshot (if used)</span>
<span class="k">delete</span> <span class="n">it</span><span class="p">;</span>
<span class="c1">// if (options.snapshot != nullptr) {</span>
<span class="c1">//   db-&gt;ReleaseSnapshot(options.snapshot);</span>
<span class="c1">// }</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">db-&gt;NewIterator(options)</code>:</strong> You ask the database for a new iterator. You can pass <code class="language-plaintext highlighter-rouge">ReadOptions</code>, optionally including a specific snapshot you obtained earlier using <code class="language-plaintext highlighter-rouge">db-&gt;GetSnapshot()</code>. If you don’t provide a snapshot, the iterator uses an implicit snapshot of the database state at the time of creation.</li>
  <li><strong>Positioning:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">it-&gt;Seek(slice)</code>: Moves the iterator to the first key-value pair whose key is greater than or equal to the <code class="language-plaintext highlighter-rouge">slice</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">it-&gt;SeekToFirst()</code>: Moves to the very first key-value pair in the database.</li>
      <li><code class="language-plaintext highlighter-rouge">it-&gt;SeekToLast()</code>: Moves to the very last key-value pair.</li>
    </ul>
  </li>
  <li><strong>Looping:</strong>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">it-&gt;Valid()</code>: Returns <code class="language-plaintext highlighter-rouge">true</code> if the iterator is currently pointing to a valid key-value pair, <code class="language-plaintext highlighter-rouge">false</code> otherwise (e.g., if you’ve reached the end).</li>
      <li><code class="language-plaintext highlighter-rouge">it-&gt;Next()</code>: Moves the iterator to the next key-value pair in sorted order.</li>
      <li><code class="language-plaintext highlighter-rouge">it-&gt;Prev()</code>: Moves to the previous key-value pair (less common, but supported).</li>
      <li><code class="language-plaintext highlighter-rouge">it-&gt;key()</code>: Returns a <code class="language-plaintext highlighter-rouge">Slice</code> representing the current key.</li>
      <li><code class="language-plaintext highlighter-rouge">it-&gt;value()</code>: Returns a <code class="language-plaintext highlighter-rouge">Slice</code> representing the current value. <strong>Important:</strong> The <code class="language-plaintext highlighter-rouge">Slice</code>s returned by <code class="language-plaintext highlighter-rouge">key()</code> and <code class="language-plaintext highlighter-rouge">value()</code> are only valid until the next call that modifies the iterator (<code class="language-plaintext highlighter-rouge">Next</code>, <code class="language-plaintext highlighter-rouge">Prev</code>, <code class="language-plaintext highlighter-rouge">Seek</code>, etc.). If you need to keep the data longer, make a copy (e.g., <code class="language-plaintext highlighter-rouge">key.ToString()</code>).</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">it-&gt;status()</code>:</strong> After the loop, check this to see if any errors occurred during iteration (e.g., disk corruption).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">delete it;</code>:</strong> Crucially, you <strong>must</strong> delete the iterator when you’re done with it to free up resources. If you used an explicit snapshot, release it too.</li>
</ol>

<p>This simple interface lets you scan through potentially vast amounts of data spread across memory and disk files without needing to know the complex details of where each piece resides.</p>

<h2 id="under-the-hood-merging-and-filtering">Under the Hood: Merging and Filtering</h2>

<p>How does the iterator provide this unified, sorted view? It doesn’t load everything into memory! Instead, it uses a clever strategy involving <strong>merging</strong> and <strong>filtering</strong>.</p>

<ol>
  <li><strong>Gather Internal Iterators:</strong> When you call <code class="language-plaintext highlighter-rouge">db-&gt;NewIterator()</code>, the <code class="language-plaintext highlighter-rouge">DBImpl</code> asks for iterators from all the relevant sources, based on the current <a href="06_version___versionset.md">Version</a>:
    <ul>
      <li>An iterator for the active <code class="language-plaintext highlighter-rouge">MemTable</code>.</li>
      <li>An iterator for the immutable <code class="language-plaintext highlighter-rouge">imm_</code> (if it exists).</li>
      <li>Iterators for all the files in Level-0.</li>
      <li>A special “concatenating” iterator for Level-1 (which opens SSTable files lazily as needed).</li>
      <li>Similar concatenating iterators for Level-2, Level-3, etc.</li>
    </ul>
  </li>
  <li>
    <p><strong>Create MergingIterator:</strong> These individual iterators are then passed to a <code class="language-plaintext highlighter-rouge">MergingIterator</code>. The <code class="language-plaintext highlighter-rouge">MergingIterator</code> acts like a zipper, taking multiple sorted streams and producing a single output stream that is also sorted. It keeps track of the current position in each input iterator and always yields the smallest key currently available across all inputs.</p>
  </li>
  <li><strong>Wrap with DBIter:</strong> The <code class="language-plaintext highlighter-rouge">MergingIterator</code> produces <em>internal</em> keys (with sequence numbers and types). This merged stream is then wrapped by the <code class="language-plaintext highlighter-rouge">DBIter</code>. <code class="language-plaintext highlighter-rouge">DBIter</code> is the “research assistant” we talked about. It reads the stream from the <code class="language-plaintext highlighter-rouge">MergingIterator</code> and performs the final filtering:
    <ul>
      <li>It compares the sequence number of each internal key with the iterator’s snapshot sequence number. Keys newer than the snapshot are ignored.</li>
      <li>It keeps track of the current user key. If it sees multiple versions of the same user key, it only considers the one with the highest sequence number (that’s still &lt;= the snapshot sequence).</li>
      <li>If the most recent entry for a user key is a deletion marker (<code class="language-plaintext highlighter-rouge">kTypeDeletion</code>), it skips that key entirely.</li>
      <li>Only when it finds a valid, non-deleted key (<code class="language-plaintext highlighter-rouge">kTypeValue</code>) with the highest sequence number for that user key (within the snapshot) does it make that key/value available via <code class="language-plaintext highlighter-rouge">it-&gt;key()</code> and <code class="language-plaintext highlighter-rouge">it-&gt;value()</code>.</li>
    </ul>
  </li>
</ol>

<p><strong>Sequence Diagram:</strong></p>

<pre><code class="language-mermaid">sequenceDiagram
    participant App as Application
    participant DBImpl
    participant MemTable as Active MemTable
    participant ImmMemTable as Immutable MemTable
    participant Version as Current Version
    participant MergingIter as MergingIterator
    participant DBIter

    App-&gt;&gt;DBImpl: NewIterator(options)
    DBImpl-&gt;&gt;MemTable: NewIterator()
    MemTable--&gt;&gt;DBImpl: Return mem_iter
    DBImpl-&gt;&gt;ImmMemTable: NewIterator()
    ImmMemTable--&gt;&gt;DBImpl: Return imm_iter
    DBImpl-&gt;&gt;Version: AddIterators(options)  # Gets SSTable iterators
    Version--&gt;&gt;DBImpl: Return sstable_iters_list
    DBImpl-&gt;&gt;MergingIter: Create(mem_iter, imm_iter, sstable_iters...)
    MergingIter--&gt;&gt;DBImpl: Return merged_iter
    DBImpl-&gt;&gt;DBIter: Create(merged_iter, snapshot_seq)
    DBIter--&gt;&gt;DBImpl: Return db_iter
    DBImpl--&gt;&gt;App: Return db_iter (as Iterator*)

    App-&gt;&gt;DBIter: Seek("some_key")
    DBIter-&gt;&gt;MergingIter: Seek to internal key for "some_key"
    Note right of DBIter: DBIter finds the first valid user entry &gt;= "some_key"
    DBIter--&gt;&gt;App: Iterator positioned

    App-&gt;&gt;DBIter: Valid()?
    DBIter--&gt;&gt;App: true

    App-&gt;&gt;DBIter: key()
    DBIter--&gt;&gt;App: Return "user_key_A"

    App-&gt;&gt;DBIter: Next()
    DBIter-&gt;&gt;MergingIter: Next() until user key changes
    Note right of DBIter: DBIter skips older versions or deleted keys
    DBIter-&gt;&gt;MergingIter: Next() to find next user key's latest version
    DBIter--&gt;&gt;App: Iterator positioned at next valid entry

</code></pre>

<h2 id="code-dive-dbimplnewiterator-and-dbiter">Code Dive: <code class="language-plaintext highlighter-rouge">DBImpl::NewIterator</code> and <code class="language-plaintext highlighter-rouge">DBIter</code></h2>

<p>Let’s look at how this is initiated in the code.</p>

<p><strong>1. Creating the Iterator (<code class="language-plaintext highlighter-rouge">db_impl.cc</code>)</strong></p>

<p>When you call <code class="language-plaintext highlighter-rouge">db-&gt;NewIterator(options)</code>, it eventually calls <code class="language-plaintext highlighter-rouge">DBImpl::NewIterator</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- File: db/db_impl.cc ---</span>

<span class="n">Iterator</span><span class="o">*</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">NewIterator</span><span class="p">(</span><span class="k">const</span> <span class="n">ReadOptions</span><span class="o">&amp;</span> <span class="n">options</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SequenceNumber</span> <span class="n">latest_snapshot</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">seed</span><span class="p">;</span> <span class="c1">// Used for read sampling randomization</span>

  <span class="c1">// (1) Create the internal merging iterator</span>
  <span class="n">Iterator</span><span class="o">*</span> <span class="n">internal_iter</span> <span class="o">=</span> <span class="n">NewInternalIterator</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">latest_snapshot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seed</span><span class="p">);</span>

  <span class="c1">// (2) Determine the sequence number for the snapshot</span>
  <span class="n">SequenceNumber</span> <span class="n">snapshot_seq</span> <span class="o">=</span>
      <span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">snapshot</span> <span class="o">!=</span> <span class="nb">nullptr</span>
           <span class="o">?</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">SnapshotImpl</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">options</span><span class="p">.</span><span class="n">snapshot</span><span class="p">)</span>
                 <span class="o">-&gt;</span><span class="n">sequence_number</span><span class="p">()</span>
           <span class="o">:</span> <span class="n">latest_snapshot</span><span class="p">);</span>

  <span class="c1">// (3) Wrap the internal iterator with DBIter</span>
  <span class="k">return</span> <span class="n">NewDBIterator</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="c1">// Pass DBImpl pointer for read sampling</span>
                       <span class="n">user_comparator</span><span class="p">(),</span>
                       <span class="n">internal_iter</span><span class="p">,</span>
                       <span class="n">snapshot_seq</span><span class="p">,</span>
                       <span class="n">seed</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">NewInternalIterator</code>: This helper function (we’ll glance at it next) creates the <code class="language-plaintext highlighter-rouge">MergingIterator</code> that combines MemTables and SSTables.</li>
  <li><code class="language-plaintext highlighter-rouge">snapshot_seq</code>: It figures out which sequence number to use. If the user provided an explicit <code class="language-plaintext highlighter-rouge">options.snapshot</code>, it uses that snapshot’s sequence number. Otherwise, it uses the latest sequence number in the database when the iterator was created (<code class="language-plaintext highlighter-rouge">latest_snapshot</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">NewDBIterator</code>: This function (defined in <code class="language-plaintext highlighter-rouge">db_iter.cc</code>) creates the <code class="language-plaintext highlighter-rouge">DBIter</code> object, passing it the underlying <code class="language-plaintext highlighter-rouge">internal_iter</code> and the <code class="language-plaintext highlighter-rouge">snapshot_seq</code> to use for filtering.</li>
</ol>

<p><strong>2. Creating the Internal Iterator (<code class="language-plaintext highlighter-rouge">db_impl.cc</code>)</strong></p>

<p>The <code class="language-plaintext highlighter-rouge">NewInternalIterator</code> gathers all the source iterators:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- File: db/db_impl.cc ---</span>

<span class="n">Iterator</span><span class="o">*</span> <span class="n">DBImpl</span><span class="o">::</span><span class="n">NewInternalIterator</span><span class="p">(</span><span class="k">const</span> <span class="n">ReadOptions</span><span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span>
                                      <span class="n">SequenceNumber</span><span class="o">*</span> <span class="n">latest_snapshot</span><span class="p">,</span>
                                      <span class="kt">uint32_t</span><span class="o">*</span> <span class="n">seed</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">mutex_</span><span class="p">.</span><span class="n">Lock</span><span class="p">();</span> <span class="c1">// Need lock to access shared state (mem_, imm_, versions_)</span>
  <span class="o">*</span><span class="n">latest_snapshot</span> <span class="o">=</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">LastSequence</span><span class="p">();</span>
  <span class="o">*</span><span class="n">seed</span> <span class="o">=</span> <span class="o">++</span><span class="n">seed_</span><span class="p">;</span> <span class="c1">// For random sampling</span>

  <span class="c1">// Collect together all needed child iterators</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Iterator</span><span class="o">*&gt;</span> <span class="n">list</span><span class="p">;</span>
  <span class="c1">// Add iterator for active MemTable</span>
  <span class="n">list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">mem_</span><span class="o">-&gt;</span><span class="n">NewIterator</span><span class="p">());</span>
  <span class="n">mem_</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">();</span> <span class="c1">// Manage lifetime with ref counting</span>

  <span class="c1">// Add iterator for immutable MemTable (if it exists)</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">imm_</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">list</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">imm_</span><span class="o">-&gt;</span><span class="n">NewIterator</span><span class="p">());</span>
    <span class="n">imm_</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Add iterators for all SSTable files in the current Version</span>
  <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">AddIterators</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
  <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">();</span>

  <span class="c1">// Create the MergingIterator</span>
  <span class="n">Iterator</span><span class="o">*</span> <span class="n">internal_iter</span> <span class="o">=</span>
      <span class="n">NewMergingIterator</span><span class="p">(</span><span class="o">&amp;</span><span class="n">internal_comparator_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">list</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="c1">// Register cleanup function to Unref MemTables/Version when iterator is deleted</span>
  <span class="n">IterState</span><span class="o">*</span> <span class="n">cleanup</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IterState</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_</span><span class="p">,</span> <span class="n">mem_</span><span class="p">,</span> <span class="n">imm_</span><span class="p">,</span> <span class="n">versions_</span><span class="o">-&gt;</span><span class="n">current</span><span class="p">());</span>
  <span class="n">internal_iter</span><span class="o">-&gt;</span><span class="n">RegisterCleanup</span><span class="p">(</span><span class="n">CleanupIteratorState</span><span class="p">,</span> <span class="n">cleanup</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>

  <span class="n">mutex_</span><span class="p">.</span><span class="n">Unlock</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">internal_iter</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li>It locks the database mutex to safely access the current MemTables (<code class="language-plaintext highlighter-rouge">mem_</code>, <code class="language-plaintext highlighter-rouge">imm_</code>) and the current <code class="language-plaintext highlighter-rouge">Version</code>.</li>
  <li>It creates iterators for <code class="language-plaintext highlighter-rouge">mem_</code> and <code class="language-plaintext highlighter-rouge">imm_</code> using their <code class="language-plaintext highlighter-rouge">NewIterator()</code> methods (<a href="02_memtable.md">MemTable</a> uses a SkipList iterator).</li>
  <li>It calls <code class="language-plaintext highlighter-rouge">versions_-&gt;current()-&gt;AddIterators(...)</code>. This method (in <code class="language-plaintext highlighter-rouge">version_set.cc</code>) adds iterators for Level-0 files and the special concatenating iterators for Levels 1+ to the <code class="language-plaintext highlighter-rouge">list</code>. See <a href="06_version___versionset.md">Version &amp; VersionSet</a>.</li>
  <li><code class="language-plaintext highlighter-rouge">NewMergingIterator</code> creates the iterator that merges all sources in <code class="language-plaintext highlighter-rouge">list</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">RegisterCleanup</code> ensures that the MemTables and Version are properly <code class="language-plaintext highlighter-rouge">Unref</code>‘d when the iterator is eventually deleted.</li>
  <li>It returns the <code class="language-plaintext highlighter-rouge">MergingIterator</code>.</li>
</ol>

<p><strong>3. <code class="language-plaintext highlighter-rouge">DBIter</code> Filtering Logic (<code class="language-plaintext highlighter-rouge">db_iter.cc</code>)</strong></p>

<p>The <code class="language-plaintext highlighter-rouge">DBIter</code> class takes the <code class="language-plaintext highlighter-rouge">MergingIterator</code> and applies the filtering logic. Let’s look at a simplified <code class="language-plaintext highlighter-rouge">Next()</code> method:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- File: db/db_iter.cc ---</span>

<span class="kt">void</span> <span class="n">DBIter</span><span class="o">::</span><span class="n">Next</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">valid_</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">direction_</span> <span class="o">==</span> <span class="n">kReverse</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ... code to switch from moving backward to forward ...</span>
    <span class="c1">// Position iter_ at the first entry &gt;= saved_key_</span>
    <span class="c1">// Fall through to FindNextUserEntry...</span>
    <span class="n">direction_</span> <span class="o">=</span> <span class="n">kForward</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// We are moving forward. Save the current user key so we can skip</span>
    <span class="c1">// all other entries for it.</span>
    <span class="n">SaveKey</span><span class="p">(</span><span class="n">ExtractUserKey</span><span class="p">(</span><span class="n">iter_</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">()),</span> <span class="o">&amp;</span><span class="n">saved_key_</span><span class="p">);</span>
    <span class="c1">// Advance the internal iterator.</span>
    <span class="n">iter_</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// Find the next user key entry that is visible at our sequence number.</span>
  <span class="n">FindNextUserEntry</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">saved_key_</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Find the next entry for a different user key, skipping deleted</span>
<span class="c1">// or older versions of the key in 'skip'.</span>
<span class="kt">void</span> <span class="n">DBIter</span><span class="o">::</span><span class="n">FindNextUserEntry</span><span class="p">(</span><span class="kt">bool</span> <span class="n">skipping</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Loop until we hit an acceptable entry</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">iter_</span><span class="o">-&gt;</span><span class="n">Valid</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">valid_</span><span class="p">);</span> <span class="c1">// iter_ might be invalid if Next() moved past end</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">direction_</span> <span class="o">==</span> <span class="n">kForward</span><span class="p">);</span>

  <span class="k">do</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">iter_</span><span class="o">-&gt;</span><span class="n">Valid</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// Reached end of internal iterator</span>
        <span class="n">valid_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ParsedInternalKey</span> <span class="n">ikey</span><span class="p">;</span>
    <span class="c1">// Parse the internal key (key, sequence, type)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ParseKey</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ikey</span><span class="p">))</span> <span class="p">{</span>
      <span class="c1">// Check if the sequence number is visible in our snapshot</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ikey</span><span class="p">.</span><span class="n">sequence</span> <span class="o">&lt;=</span> <span class="n">sequence_</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// Check the type (Put or Deletion)</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">ikey</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="n">kTypeDeletion</span><span class="p">:</span>
            <span class="c1">// This key is deleted. Save the user key so we skip</span>
            <span class="c1">// any older versions of it we might encounter later.</span>
            <span class="n">SaveKey</span><span class="p">(</span><span class="n">ikey</span><span class="p">.</span><span class="n">user_key</span><span class="p">,</span> <span class="n">skip</span><span class="p">);</span>
            <span class="n">skipping</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Ensure we skip older versions</span>
            <span class="k">break</span><span class="p">;</span>
          <span class="k">case</span> <span class="n">kTypeValue</span><span class="p">:</span>
            <span class="c1">// This is a potential result (a Put operation).</span>
            <span class="c1">// Is it for the user key we are trying to skip?</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">skipping</span> <span class="o">&amp;&amp;</span>
                <span class="n">user_comparator_</span><span class="o">-&gt;</span><span class="n">Compare</span><span class="p">(</span><span class="n">ikey</span><span class="p">.</span><span class="n">user_key</span><span class="p">,</span> <span class="o">*</span><span class="n">skip</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
              <span class="c1">// Yes, it's hidden by a newer deletion or is an older version</span>
              <span class="c1">// of the key we just yielded. Skip it.</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
              <span class="c1">// Found a valid entry!</span>
              <span class="n">valid_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
              <span class="c1">// Clear skip key since we found a new valid key</span>
              <span class="c1">// saved_key_.clear(); // Done in Next() or Seek()</span>
              <span class="k">return</span><span class="p">;</span> <span class="c1">// Exit the loop, iterator is now positioned correctly.</span>
            <span class="p">}</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Corrupted key, mark iterator as invalid</span>
      <span class="n">valid_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="n">status_</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">Corruption</span><span class="p">(</span><span class="s">"corrupted internal key in DBIter"</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Current internal key was skipped (too new, deleted, hidden), move to next.</span>
    <span class="n">iter_</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span> <span class="c1">// Loop until we return or reach the end</span>
<span class="p">}</span>

</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">Next()</code> method first handles switching direction if needed. If moving forward, it saves the current user key (<code class="language-plaintext highlighter-rouge">saved_key_</code>) so it can skip other entries for the same key. It then advances the underlying <code class="language-plaintext highlighter-rouge">iter_</code> (the <code class="language-plaintext highlighter-rouge">MergingIterator</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">FindNextUserEntry</code> is the core loop. It repeatedly gets the next entry from <code class="language-plaintext highlighter-rouge">iter_</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">ParseKey(&amp;ikey)</code> decodes the internal key, sequence number, and type.</li>
  <li>It checks if <code class="language-plaintext highlighter-rouge">ikey.sequence &lt;= sequence_</code> (the iterator’s snapshot sequence number). If the entry is too new, it’s skipped.</li>
  <li>If it’s a <code class="language-plaintext highlighter-rouge">kTypeDeletion</code>, the user key is saved in <code class="language-plaintext highlighter-rouge">skip</code>, and the <code class="language-plaintext highlighter-rouge">skipping</code> flag is set to true. Any older entries for this <code class="language-plaintext highlighter-rouge">user_key</code> will be ignored.</li>
  <li>If it’s a <code class="language-plaintext highlighter-rouge">kTypeValue</code>:
    <ul>
      <li>It checks if <code class="language-plaintext highlighter-rouge">skipping</code> is true and if the current <code class="language-plaintext highlighter-rouge">ikey.user_key</code> is less than or equal to the key in <code class="language-plaintext highlighter-rouge">skip</code>. If so, it means this entry is hidden by a newer deletion or is an older version of a key we just processed, so it’s skipped.</li>
      <li>Otherwise, this is the newest, visible version of this user key! The loop terminates, <code class="language-plaintext highlighter-rouge">valid_</code> is set to true, and the <code class="language-plaintext highlighter-rouge">DBIter</code> is now positioned at this entry.</li>
    </ul>
  </li>
  <li>If the current entry from <code class="language-plaintext highlighter-rouge">iter_</code> was skipped for any reason, the loop continues by calling <code class="language-plaintext highlighter-rouge">iter_-&gt;Next()</code>.</li>
</ul>

<p>This careful dance ensures that <code class="language-plaintext highlighter-rouge">DBIter</code> only exposes the correct, latest, non-deleted user key/value pairs according to the snapshot sequence number, while efficiently merging data from all underlying sources.</p>

<h2 id="conclusion">Conclusion</h2>

<p>LevelDB’s <code class="language-plaintext highlighter-rouge">Iterator</code> provides a powerful and convenient way to scan through key-value pairs. It acts like a smart assistant, giving you a unified, sorted view across data stored in the <code class="language-plaintext highlighter-rouge">MemTable</code> and numerous <code class="language-plaintext highlighter-rouge">SSTable</code> files.</p>

<p>Under the hood, it uses a <code class="language-plaintext highlighter-rouge">MergingIterator</code> to combine multiple sorted sources and the <code class="language-plaintext highlighter-rouge">DBIter</code> wrapper to filter out deleted entries and older versions based on sequence numbers and the requested snapshot.</p>

<p>This ability to efficiently scan sorted data is not just useful for application queries, but it’s also fundamental to how LevelDB maintains itself. How does LevelDB merge old SSTables and incorporate data flushed from the MemTable to keep the database structure efficient? It uses these very same iterator concepts!</p>

<p>Next up: <a href="08_compaction.md">Chapter 8: Compaction</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
