<h1 id="chapter-2-memtable">Chapter 2: MemTable</h1>

<p>In <a href="01_table___sstable___tablecache.md">Chapter 1: Table / SSTable &amp; TableCache</a>, we learned how LevelDB stores the bulk of its data permanently on disk in sorted, immutable files called SSTables. We also saw how the <code class="language-plaintext highlighter-rouge">TableCache</code> helps access these files efficiently.</p>

<p>But imagine you’re updating your data frequently – adding new users, changing scores, deleting temporary items. Writing every tiny change directly to a new SSTable file on disk would be incredibly slow, like carving every single note onto a stone tablet! We need a faster way to handle recent changes.</p>

<h2 id="whats-the-problem-slow-disk-writes-for-every-change">What’s the Problem? Slow Disk Writes for Every Change</h2>

<p>Disk drives (even fast SSDs) are much slower than your computer’s main memory (RAM). If LevelDB wrote every <code class="language-plaintext highlighter-rouge">Put</code> or <code class="language-plaintext highlighter-rouge">Delete</code> operation straight to an SSTable file, your application would constantly be waiting for the disk, making it feel sluggish.</p>

<p>How can we accept new writes quickly but still eventually store them permanently on disk?</p>

<h2 id="memtable-the-fast-in-memory-notepad">MemTable: The Fast In-Memory Notepad</h2>

<p>LevelDB’s solution is the <strong>MemTable</strong>. Think of it as a <strong>temporary notepad</strong> or a <strong>scratchpad</strong> that lives entirely in your computer’s fast RAM.</p>

<ol>
  <li><strong>In-Memory:</strong> It’s stored in RAM, making reads and writes extremely fast.</li>
  <li><strong>Holds Recent Writes:</strong> When you <code class="language-plaintext highlighter-rouge">Put</code> a new key-value pair or <code class="language-plaintext highlighter-rouge">Delete</code> a key, the change goes into the MemTable first.</li>
  <li><strong>Sorted:</strong> Just like SSTables, the data inside the MemTable is kept sorted by key. This is important for efficiency later.</li>
  <li><strong>Temporary:</strong> It’s only a temporary holding area. Eventually, its contents get written out to a permanent SSTable file on disk.</li>
</ol>

<p>So, when you write data:</p>

<p><em>Your Application</em> -&gt; <code class="language-plaintext highlighter-rouge">Put("user123", "data")</code> -&gt; <strong>MemTable</strong> (Fast RAM write!)</p>

<p>This makes write operations feel almost instantaneous to your application.</p>

<h2 id="how-reads-use-the-memtable">How Reads Use the MemTable</h2>

<p>When you try to read data using <code class="language-plaintext highlighter-rouge">Get(key)</code>, LevelDB is smart. It knows the most recent data might still be on the “notepad” (MemTable). So, it checks there <em>first</em>:</p>

<ol>
  <li><strong>Check MemTable:</strong> Look for the key in the current MemTable.
    <ul>
      <li>If the key is found, return the value immediately (super fast!).</li>
      <li>If a “deletion marker” for the key is found, stop and report “Not Found” (the key was recently deleted).</li>
    </ul>
  </li>
  <li><strong>Check Older MemTable (Immutable):</strong> If there’s an older MemTable being flushed (we’ll cover this next), check that too.</li>
  <li><strong>Check SSTables:</strong> If the key wasn’t found in memory (or wasn’t deleted there), <em>then</em> LevelDB looks for it in the SSTable files on disk, using the <a href="01_table___sstable___tablecache.md">Table / SSTable &amp; TableCache</a> we learned about in Chapter 1.</li>
</ol>

<p>This “check memory first” strategy ensures that you always read the most up-to-date value, even if it hasn’t hit the disk yet.</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Client as App Read (Get)
    participant LevelDB
    participant MemTable as Active MemTable (RAM)
    participant ImMemTable as Immutable MemTable (RAM, if exists)
    participant TableCache as SSTable Cache (Disk/RAM)

    Client-&gt;&gt;LevelDB: Get("some_key")
    LevelDB-&gt;&gt;MemTable: Have "some_key"?
    alt Key found in Active MemTable
        MemTable--&gt;&gt;LevelDB: Yes, value is "xyz"
        LevelDB--&gt;&gt;Client: Return "xyz"
    else Key Deleted in Active MemTable
        MemTable--&gt;&gt;LevelDB: Yes, it's deleted
        LevelDB--&gt;&gt;Client: Return NotFound
    else Not in Active MemTable
        MemTable--&gt;&gt;LevelDB: No
        LevelDB-&gt;&gt;ImMemTable: Have "some_key"?
        alt Key found in Immutable MemTable
             ImMemTable--&gt;&gt;LevelDB: Yes, value is "abc"
             LevelDB--&gt;&gt;Client: Return "abc"
        else Key Deleted in Immutable MemTable
             ImMemTable--&gt;&gt;LevelDB: Yes, it's deleted
             LevelDB--&gt;&gt;Client: Return NotFound
        else Not in Immutable MemTable
            ImMemTable--&gt;&gt;LevelDB: No
            LevelDB-&gt;&gt;TableCache: Get("some_key") from SSTables
            TableCache--&gt;&gt;LevelDB: Found "old_value" / NotFound
            LevelDB--&gt;&gt;Client: Return "old_value" / NotFound
        end
    end
</code></pre>

<h2 id="what-happens-when-the-notepad-fills-up">What Happens When the Notepad Fills Up?</h2>

<p>The MemTable lives in RAM, which is limited. We can’t just keep adding data to it forever. LevelDB has a configured size limit for the MemTable ( <code class="language-plaintext highlighter-rouge">options.write_buffer_size</code>, often a few megabytes).</p>

<p>When the MemTable gets close to this size:</p>

<ol>
  <li><strong>Freeze!</strong> LevelDB declares the current MemTable “immutable” (meaning read-only). No new writes go into this specific MemTable anymore. Let’s call it <code class="language-plaintext highlighter-rouge">imm_</code> (Immutable MemTable).</li>
  <li><strong>New Notepad:</strong> LevelDB immediately creates a <em>new</em>, empty MemTable (<code class="language-plaintext highlighter-rouge">mem_</code>) to accept incoming writes. Your application doesn’t pause; new writes just start going to the fresh MemTable.</li>
  <li><strong>Flush to Disk:</strong> A background task starts working on the frozen <code class="language-plaintext highlighter-rouge">imm_</code>. It reads all the sorted key-value pairs from <code class="language-plaintext highlighter-rouge">imm_</code> and uses the <code class="language-plaintext highlighter-rouge">BuildTable</code> process (from <a href="01_table___sstable___tablecache.md">Chapter 1</a>) to write them into a brand new SSTable file on disk. This new file becomes part of “Level-0” (we’ll learn more about levels in <a href="08_compaction.md">Chapter 8: Compaction</a>).</li>
  <li><strong>Discard:</strong> Once the <code class="language-plaintext highlighter-rouge">imm_</code> is successfully written to the SSTable file, the in-memory <code class="language-plaintext highlighter-rouge">imm_</code> is discarded, freeing up RAM.</li>
</ol>

<p>This process ensures that writes are always fast (going to the <em>new</em> <code class="language-plaintext highlighter-rouge">mem_</code>) while the <em>old</em> data is efficiently flushed to disk in the background.</p>

<pre><code class="language-mermaid">graph TD
    subgraph Writes
        A[Incoming Writes: Put/Delete] --&gt; B(Active MemTable mem_);
    end

    subgraph MemTable Full
        B -- Reaches Size Limit --&gt; C{Freeze mem_ -&gt; becomes imm_};
        C --&gt; D(Create New Empty mem_);
        A --&gt; D;
        C --&gt; E{Background Flush};
    end

    subgraph Background Flush
        E -- Reads Data --&gt; F(Immutable MemTable imm_);
        F -- Uses BuildTable --&gt; G([Level-0 SSTable on Disk]);
        G -- Flush Complete --&gt; H{Discard imm_};
    end

    style G fill:#f9f,stroke:#333,stroke-width:2px
</code></pre>

<h2 id="under-the-hood-keeping-it-sorted-with-a-skiplist">Under the Hood: Keeping it Sorted with a SkipList</h2>

<p>We mentioned that the MemTable keeps keys sorted. Why?</p>

<ol>
  <li><strong>Efficient Flushing:</strong> When flushing the MemTable to an SSTable, the data needs to be written in sorted order. If the MemTable is already sorted, this is very efficient – we just read through it sequentially.</li>
  <li><strong>Efficient Reads:</strong> Keeping it sorted allows for faster lookups within the MemTable itself.</li>
</ol>

<p>How does LevelDB keep the MemTable sorted while allowing fast inserts? It uses a clever data structure called a <strong>SkipList</strong>.</p>

<p>Imagine a sorted linked list. To find an element, you might have to traverse many nodes. Now, imagine adding some “express lanes” (higher-level links) that skip over several nodes at a time. You can use these express lanes to quickly get close to your target, then drop down to the detailed level (the base list) to find the exact spot. This is the core idea of a SkipList!</p>

<ul>
  <li><strong>Fast Inserts:</strong> Adding a new item is generally fast.</li>
  <li><strong>Fast Lookups:</strong> Finding an item is much faster than a simple linked list, often close to the speed of more complex balanced trees.</li>
  <li><strong>Efficient Iteration:</strong> Reading all items in sorted order (needed for flushing) is straightforward.</li>
</ul>

<p>The MemTable essentially wraps a SkipList provided by <code class="language-plaintext highlighter-rouge">skiplist.h</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- File: db/memtable.h ---</span>

<span class="cp">#include</span> <span class="cpf">"db/skiplist.h"</span><span class="c1"> // The SkipList data structure</span><span class="cp">
#include</span> <span class="cpf">"util/arena.h"</span><span class="c1">   // Memory allocator</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MemTable</span> <span class="p">{</span>
 <span class="nl">private:</span>
  <span class="c1">// The core data structure: a SkipList.</span>
  <span class="c1">// The Key is 'const char*' pointing into the Arena.</span>
  <span class="c1">// KeyComparator helps compare keys correctly (we'll see this later).</span>
  <span class="k">typedef</span> <span class="n">SkipList</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">,</span> <span class="n">KeyComparator</span><span class="o">&gt;</span> <span class="n">Table</span><span class="p">;</span>

  <span class="n">Arena</span> <span class="n">arena_</span><span class="p">;</span>   <span class="c1">// Allocates memory for nodes efficiently</span>
  <span class="n">Table</span> <span class="n">table_</span><span class="p">;</span>   <span class="c1">// The actual SkipList instance</span>
  <span class="kt">int</span> <span class="n">refs_</span><span class="p">;</span>      <span class="c1">// Reference count for managing lifetime</span>
  <span class="c1">// ... other members like KeyComparator ...</span>

 <span class="nl">public:</span>
  <span class="c1">// Add an entry (Put or Delete marker)</span>
  <span class="kt">void</span> <span class="n">Add</span><span class="p">(</span><span class="n">SequenceNumber</span> <span class="n">seq</span><span class="p">,</span> <span class="n">ValueType</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span>
           <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">);</span>

  <span class="c1">// Look up a key</span>
  <span class="kt">bool</span> <span class="n">Get</span><span class="p">(</span><span class="k">const</span> <span class="n">LookupKey</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">value</span><span class="p">,</span> <span class="n">Status</span><span class="o">*</span> <span class="n">s</span><span class="p">);</span>

  <span class="c1">// Create an iterator to scan the MemTable's contents</span>
  <span class="n">Iterator</span><span class="o">*</span> <span class="n">NewIterator</span><span class="p">();</span>

  <span class="c1">// Estimate memory usage</span>
  <span class="kt">size_t</span> <span class="n">ApproximateMemoryUsage</span><span class="p">();</span>

  <span class="c1">// Constructor, Ref/Unref omitted for brevity...</span>
<span class="p">};</span>
</code></pre></div></div>

<p>This header shows the <code class="language-plaintext highlighter-rouge">MemTable</code> class uses an <code class="language-plaintext highlighter-rouge">Arena</code> for memory management and a <code class="language-plaintext highlighter-rouge">Table</code> (which is a <code class="language-plaintext highlighter-rouge">SkipList</code>) to store the data.</p>

<h2 id="adding-and-getting-data-code-view">Adding and Getting Data (Code View)</h2>

<p>Let’s look at simplified versions of <code class="language-plaintext highlighter-rouge">Add</code> and <code class="language-plaintext highlighter-rouge">Get</code>.</p>

<p><strong>Adding an Entry:</strong></p>

<p>When you call <code class="language-plaintext highlighter-rouge">db-&gt;Put(key, value)</code> or <code class="language-plaintext highlighter-rouge">db-&gt;Delete(key)</code>, it eventually calls <code class="language-plaintext highlighter-rouge">MemTable::Add</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- File: db/memtable.cc ---</span>

<span class="kt">void</span> <span class="n">MemTable</span><span class="o">::</span><span class="n">Add</span><span class="p">(</span><span class="n">SequenceNumber</span> <span class="n">s</span><span class="p">,</span> <span class="n">ValueType</span> <span class="n">type</span><span class="p">,</span> <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">,</span>
                   <span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Calculate size needed for the entry in the skiplist.</span>
  <span class="c1">// Format includes key size, key, sequence number + type tag, value size, value.</span>
  <span class="kt">size_t</span> <span class="n">key_size</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="kt">size_t</span> <span class="n">val_size</span> <span class="o">=</span> <span class="n">value</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
  <span class="kt">size_t</span> <span class="n">internal_key_size</span> <span class="o">=</span> <span class="n">key_size</span> <span class="o">+</span> <span class="mi">8</span><span class="p">;</span> <span class="c1">// 8 bytes for seq + type</span>
  <span class="k">const</span> <span class="kt">size_t</span> <span class="n">encoded_len</span> <span class="o">=</span> <span class="n">VarintLength</span><span class="p">(</span><span class="n">internal_key_size</span><span class="p">)</span> <span class="o">+</span>
                             <span class="n">internal_key_size</span> <span class="o">+</span> <span class="n">VarintLength</span><span class="p">(</span><span class="n">val_size</span><span class="p">)</span> <span class="o">+</span>
                             <span class="n">val_size</span><span class="p">;</span>

  <span class="c1">// Allocate memory from the Arena</span>
  <span class="kt">char</span><span class="o">*</span> <span class="n">buf</span> <span class="o">=</span> <span class="n">arena_</span><span class="p">.</span><span class="n">Allocate</span><span class="p">(</span><span class="n">encoded_len</span><span class="p">);</span>

  <span class="c1">// Encode the entry into the buffer 'buf' (details omitted)</span>
  <span class="c1">// Format: [key_len][key_bytes][seq_num|type][value_len][value_bytes]</span>
  <span class="c1">// ... encoding logic ...</span>

  <span class="c1">// Insert the buffer pointer into the SkipList. The SkipList uses the</span>
  <span class="c1">// KeyComparator to know how to sort based on the encoded format.</span>
  <span class="n">table_</span><span class="p">.</span><span class="n">Insert</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><strong>Calculate Size:</strong> Determines how much memory is needed to store the key, value, sequence number, and type. (We’ll cover sequence numbers and internal keys in <a href="09_internalkey___dbformat.md">Chapter 9</a>).</li>
  <li><strong>Allocate:</strong> Gets a chunk of memory from the <code class="language-plaintext highlighter-rouge">Arena</code>. Arenas are efficient allocators for many small objects with similar lifetimes.</li>
  <li><strong>Encode:</strong> Copies the key, value, and metadata into the allocated buffer (<code class="language-plaintext highlighter-rouge">buf</code>).</li>
  <li><strong>Insert:</strong> Calls <code class="language-plaintext highlighter-rouge">table_.Insert(buf)</code>, where <code class="language-plaintext highlighter-rouge">table_</code> is the SkipList. The SkipList takes care of finding the correct sorted position and linking the new entry.</li>
</ol>

<p><strong>Getting an Entry:</strong></p>

<p>When you call <code class="language-plaintext highlighter-rouge">db-&gt;Get(key)</code>, it checks the MemTable first using <code class="language-plaintext highlighter-rouge">MemTable::Get</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- File: db/memtable.cc ---</span>

<span class="kt">bool</span> <span class="n">MemTable</span><span class="o">::</span><span class="n">Get</span><span class="p">(</span><span class="k">const</span> <span class="n">LookupKey</span><span class="o">&amp;</span> <span class="n">lkey</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">value</span><span class="p">,</span> <span class="n">Status</span><span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Get the specially formatted key to search for in the MemTable.</span>
  <span class="n">Slice</span> <span class="n">memkey</span> <span class="o">=</span> <span class="n">lkey</span><span class="p">.</span><span class="n">memtable_key</span><span class="p">();</span>

  <span class="c1">// Create an iterator for the SkipList.</span>
  <span class="n">Table</span><span class="o">::</span><span class="n">Iterator</span> <span class="n">iter</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table_</span><span class="p">);</span>

  <span class="c1">// Seek to the first entry &gt;= the key we are looking for.</span>
  <span class="n">iter</span><span class="p">.</span><span class="n">Seek</span><span class="p">(</span><span class="n">memkey</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="p">.</span><span class="n">Valid</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// Did we find something at or after our key?</span>
    <span class="c1">// Decode the key found in the SkipList</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">iter</span><span class="p">.</span><span class="n">key</span><span class="p">();</span>
    <span class="c1">// ... decode logic to get user_key, sequence, type ...</span>
    <span class="n">Slice</span> <span class="n">found_user_key</span> <span class="o">=</span> <span class="cm">/* decoded user key */</span><span class="p">;</span>
    <span class="n">ValueType</span> <span class="n">found_type</span> <span class="o">=</span> <span class="cm">/* decoded type */</span><span class="p">;</span>

    <span class="c1">// Check if the user key matches exactly</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">comparator_</span><span class="p">.</span><span class="n">comparator</span><span class="p">.</span><span class="n">user_comparator</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Compare</span><span class="p">(</span>
            <span class="n">found_user_key</span><span class="p">,</span> <span class="n">lkey</span><span class="p">.</span><span class="n">user_key</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// It's the right key! Check the type.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">found_type</span> <span class="o">==</span> <span class="n">kTypeValue</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Is it a Put record?</span>
        <span class="c1">// Decode the value and return it</span>
        <span class="n">Slice</span> <span class="n">v</span> <span class="o">=</span> <span class="cm">/* decoded value */</span><span class="p">;</span>
        <span class="n">value</span><span class="o">-&gt;</span><span class="n">assign</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Found the value!</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// Must be kTypeDeletion</span>
        <span class="c1">// Found a deletion marker for this key. Report "NotFound".</span>
        <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="n">Status</span><span class="o">::</span><span class="n">NotFound</span><span class="p">(</span><span class="n">Slice</span><span class="p">());</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Found a deletion!</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// Key not found in this MemTable</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><strong>Get Search Key:</strong> Prepares the key in the format used internally by the MemTable (<code class="language-plaintext highlighter-rouge">LookupKey</code>).</li>
  <li><strong>Create Iterator:</strong> Gets a <code class="language-plaintext highlighter-rouge">SkipList::Iterator</code>.</li>
  <li><strong>Seek:</strong> Uses the iterator’s <code class="language-plaintext highlighter-rouge">Seek</code> method to efficiently find the first entry in the SkipList whose key is greater than or equal to the search key.</li>
  <li><strong>Check Found Entry:</strong> If <code class="language-plaintext highlighter-rouge">Seek</code> finds an entry (<code class="language-plaintext highlighter-rouge">iter.Valid()</code>):
    <ul>
      <li>It decodes the entry found in the SkipList.</li>
      <li>It compares the <em>user</em> part of the key to ensure it’s an exact match (not just the next key in sorted order).</li>
      <li>If the keys match, it checks the <code class="language-plaintext highlighter-rouge">type</code>:
        <ul>
          <li>If it’s <code class="language-plaintext highlighter-rouge">kTypeValue</code>, it decodes the value and returns <code class="language-plaintext highlighter-rouge">true</code>.</li>
          <li>If it’s <code class="language-plaintext highlighter-rouge">kTypeDeletion</code>, it sets the status to <code class="language-plaintext highlighter-rouge">NotFound</code> and returns <code class="language-plaintext highlighter-rouge">true</code> (indicating we found definitive information about the key – it’s deleted).</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Not Found:</strong> If no matching key is found, it returns <code class="language-plaintext highlighter-rouge">false</code>.</li>
</ol>

<h2 id="conclusion">Conclusion</h2>

<p>The <strong>MemTable</strong> is LevelDB’s crucial in-memory cache for recent writes. It acts like a fast notepad:</p>

<ul>
  <li>Accepts new <code class="language-plaintext highlighter-rouge">Put</code> and <code class="language-plaintext highlighter-rouge">Delete</code> operations quickly in RAM.</li>
  <li>Keeps entries sorted using an efficient <strong>SkipList</strong>.</li>
  <li>Allows recent data to be read quickly without touching the disk.</li>
  <li>When full, it’s frozen, flushed to a new Level-0 <strong>SSTable</strong> file on disk in the background, and then discarded.</li>
</ul>

<p>This design allows LevelDB to provide very fast write performance while still ensuring data is eventually persisted safely to disk.</p>

<p>However, what happens if the power goes out <em>after</em> data is written to the MemTable but <em>before</em> it’s flushed to an SSTable? Isn’t the data in RAM lost? To solve this, LevelDB uses another component alongside the MemTable: the Write-Ahead Log (WAL).</p>

<p>Next up: <a href="03_write_ahead_log__wal____logwriter_logreader.md">Chapter 3: Write-Ahead Log (WAL) &amp; LogWriter/LogReader</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
