<h1 id="chapter-3-write-ahead-log-wal--logwriterlogreader">Chapter 3: Write-Ahead Log (WAL) &amp; LogWriter/LogReader</h1>

<p>In <a href="02_memtable.md">Chapter 2: MemTable</a>, we saw how LevelDB uses an in-memory <code class="language-plaintext highlighter-rouge">MemTable</code> (like a fast notepad) to quickly accept new writes (<code class="language-plaintext highlighter-rouge">Put</code> or <code class="language-plaintext highlighter-rouge">Delete</code>) before they are eventually flushed to an <a href="01_table___sstable___tablecache.md">SSTable</a> file on disk.</p>

<p>This is great for speed! But what if the unthinkable happens? Imagine you’ve just written some important data. It’s sitting safely in the <code class="language-plaintext highlighter-rouge">MemTable</code> in RAM, but <em>before</em> LevelDB gets a chance to write it to a permanent SSTable file, the power cord gets kicked out, or the server crashes!</p>

<p>Uh oh. Since RAM is volatile, anything in the <code class="language-plaintext highlighter-rouge">MemTable</code> that hadn’t been saved to disk is <strong>gone</strong> forever when the power goes out. That’s not very reliable for a database!</p>

<h2 id="whats-the-problem-losing-data-on-crashes">What’s the Problem? Losing Data on Crashes</h2>

<p>How can LevelDB make sure that once your write operation <em>returns successfully</em>, the data is safe, even if the system crashes immediately afterwards? Relying only on the <code class="language-plaintext highlighter-rouge">MemTable</code> isn’t enough because it lives in volatile RAM. We need a way to make writes durable (permanent) much sooner.</p>

<h2 id="write-ahead-log-wal-the-databases-safety-journal">Write-Ahead Log (WAL): The Database’s Safety Journal</h2>

<p>LevelDB’s solution is the <strong>Write-Ahead Log (WAL)</strong>, often just called the <strong>log</strong>.</p>

<p>Think of the WAL as a <strong>ship’s logbook</strong> or a <strong>court reporter’s transcript</strong>.</p>

<ol>
  <li><strong>Write First:</strong> Before the captain takes any significant action (like changing course), they write it down in the logbook <em>first</em>. Similarly, before LevelDB modifies the <code class="language-plaintext highlighter-rouge">MemTable</code> (which is in RAM), it <strong>first appends</strong> a description of the change (e.g., “Put key ‘user1’ with value ‘dataA’”) to a special file on disk – the WAL file.</li>
  <li><strong>Append-Only:</strong> Like a logbook, entries are just added sequentially to the end. LevelDB doesn’t go back and modify old entries in the current WAL file. This makes writing very fast – it’s just adding to the end of a file.</li>
  <li><strong>On Disk:</strong> Crucially, this WAL file lives on the persistent disk (HDD or SSD), not just in volatile RAM.</li>
  <li><strong>Durability:</strong> By writing to the WAL <em>before</em> acknowledging a write to the user, LevelDB ensures that even if the server crashes immediately after, the record of the operation is safely stored on disk in the log.</li>
</ol>

<p>So, the write process looks like this:</p>

<p><em>Your Application</em> -&gt; <code class="language-plaintext highlighter-rouge">Put("user123", "data")</code> -&gt; <strong>1. Append to WAL file (Disk)</strong> -&gt; <strong>2. Add to MemTable (RAM)</strong> -&gt; <em>Return Success</em></p>

<pre><code class="language-mermaid">sequenceDiagram
    participant App as Application
    participant LevelDB
    participant WAL as WAL File (Disk)
    participant MemTable as MemTable (RAM)

    App-&gt;&gt;LevelDB: Put("key", "value")
    LevelDB-&gt;&gt;WAL: Append Put("key", "value") Record
    Note right of WAL: Physical disk write
    WAL--&gt;&gt;LevelDB: Append successful
    LevelDB-&gt;&gt;MemTable: Add("key", "value")
    MemTable--&gt;&gt;LevelDB: Add successful
    LevelDB--&gt;&gt;App: Write successful
</code></pre>

<p>This “write-ahead” step ensures durability.</p>

<h2 id="what-happens-during-recovery-replaying-the-logbook">What Happens During Recovery? Replaying the Logbook</h2>

<p>Now, let’s say the server crashes and restarts. LevelDB needs to recover its state. How does the WAL help?</p>

<ol>
  <li><strong>Check for Log:</strong> When LevelDB starts up, it looks for a WAL file.</li>
  <li><strong>Read the Log:</strong> If a WAL file exists, it means the database might not have shut down cleanly, and the last <code class="language-plaintext highlighter-rouge">MemTable</code>’s contents (which were only in RAM) were lost. LevelDB creates a <code class="language-plaintext highlighter-rouge">LogReader</code> to read through the WAL file from beginning to end.</li>
  <li><strong>Rebuild MemTable:</strong> For each operation record found in the WAL (like “Put key ‘user1’ value ‘dataA’”, “Delete key ‘user2’”), LevelDB re-applies that operation to a <em>new</em>, empty <code class="language-plaintext highlighter-rouge">MemTable</code> in memory. It’s like rereading the ship’s logbook to reconstruct what happened right before the incident.</li>
  <li><strong>Recovery Complete:</strong> Once the entire WAL is replayed, the <code class="language-plaintext highlighter-rouge">MemTable</code> is back to the state it was in right before the crash. LevelDB can now continue operating normally, accepting new reads and writes. The data from the WAL is now safely in the new <code class="language-plaintext highlighter-rouge">MemTable</code>, ready to be flushed to an SSTable later.</li>
</ol>

<p>The WAL file essentially acts as a temporary backup for the <code class="language-plaintext highlighter-rouge">MemTable</code> until the <code class="language-plaintext highlighter-rouge">MemTable</code>’s contents are permanently stored in an SSTable. Once a <code class="language-plaintext highlighter-rouge">MemTable</code> is successfully flushed to an SSTable, the corresponding WAL file is no longer needed and can be deleted.</p>

<h2 id="logwriter-appending-to-the-log">LogWriter: Appending to the Log</h2>

<p>The component responsible for writing records to the WAL file is <code class="language-plaintext highlighter-rouge">log::Writer</code>. Think of it as the dedicated writer making entries in our ship’s logbook.</p>

<p>When LevelDB processes a write operation (often coming from a <a href="05_writebatch.md">WriteBatch</a>, which we’ll see later), it serializes the batch of changes into a single chunk of data (a <code class="language-plaintext highlighter-rouge">Slice</code>) and asks the <code class="language-plaintext highlighter-rouge">log::Writer</code> to add it to the current log file.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- Simplified from db/db_impl.cc ---</span>
<span class="c1">// Inside DBImpl::Write(...) after preparing the batch:</span>

<span class="n">Status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">log_</span><span class="o">-&gt;</span><span class="n">AddRecord</span><span class="p">(</span><span class="n">WriteBatchInternal</span><span class="o">::</span><span class="n">Contents</span><span class="p">(</span><span class="n">write_batch</span><span class="p">));</span>
<span class="c1">// ... check status ...</span>
<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">options</span><span class="p">.</span><span class="n">sync</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Optionally ensure the data hits the physical disk</span>
  <span class="n">status</span> <span class="o">=</span> <span class="n">logfile_</span><span class="o">-&gt;</span><span class="n">Sync</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
  <span class="c1">// Only if WAL write succeeded, apply to MemTable</span>
  <span class="n">status</span> <span class="o">=</span> <span class="n">WriteBatchInternal</span><span class="o">::</span><span class="n">InsertInto</span><span class="p">(</span><span class="n">write_batch</span><span class="p">,</span> <span class="n">mem_</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// ... handle status ...</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">WriteBatchInternal::Contents(write_batch)</code>: Gets the serialized representation of the write operations (like one or more Puts/Deletes).</li>
  <li><code class="language-plaintext highlighter-rouge">log_-&gt;AddRecord(...)</code>: Calls the <code class="language-plaintext highlighter-rouge">log::Writer</code> instance (<code class="language-plaintext highlighter-rouge">log_</code>) to append this serialized data as a single record to the current WAL file (<code class="language-plaintext highlighter-rouge">logfile_</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">logfile_-&gt;Sync()</code>: If the <code class="language-plaintext highlighter-rouge">sync</code> option is set (which is the default for ensuring durability), this command tells the operating system to <em>really</em> make sure the data written to the log file has reached the physical disk platters/flash, not just sitting in some OS buffer. This is crucial for surviving power loss.</li>
  <li><code class="language-plaintext highlighter-rouge">WriteBatchInternal::InsertInto(write_batch, mem_)</code>: Only <em>after</em> the log write is confirmed (and synced, if requested) does LevelDB apply the changes to the in-memory <code class="language-plaintext highlighter-rouge">MemTable</code>.</li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">log::Writer</code> itself handles the details of how records are actually formatted within the log file. Log files are composed of fixed-size blocks (e.g., 32KB). A single record from <code class="language-plaintext highlighter-rouge">AddRecord</code> might be small enough to fit entirely within the remaining space in the current block, or it might be large and need to be split (fragmented) across multiple physical records spanning block boundaries.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- Simplified from db/log_writer.cc ---</span>

<span class="n">Status</span> <span class="n">Writer</span><span class="o">::</span><span class="n">AddRecord</span><span class="p">(</span><span class="k">const</span> <span class="n">Slice</span><span class="o">&amp;</span> <span class="n">slice</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">slice</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
  <span class="kt">size_t</span> <span class="n">left</span> <span class="o">=</span> <span class="n">slice</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">// How much data is left to write?</span>
  <span class="n">Status</span> <span class="n">s</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">begin</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Is this the first fragment of this record?</span>

  <span class="k">do</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">leftover</span> <span class="o">=</span> <span class="n">kBlockSize</span> <span class="o">-</span> <span class="n">block_offset_</span><span class="p">;</span> <span class="c1">// Space left in current block</span>
    <span class="c1">// ... if leftover &lt; kHeaderSize, fill trailer and start new block ...</span>

    <span class="c1">// Calculate how much of the data can fit in this block</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">avail</span> <span class="o">=</span> <span class="n">kBlockSize</span> <span class="o">-</span> <span class="n">block_offset_</span> <span class="o">-</span> <span class="n">kHeaderSize</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">size_t</span> <span class="n">fragment_length</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">avail</span><span class="p">)</span> <span class="o">?</span> <span class="n">left</span> <span class="o">:</span> <span class="n">avail</span><span class="p">;</span>

    <span class="c1">// Determine the type of this physical record (fragment)</span>
    <span class="n">RecordType</span> <span class="n">type</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">bool</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">fragment_length</span><span class="p">);</span> <span class="c1">// Is this the last fragment?</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">begin</span> <span class="o">&amp;&amp;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">type</span> <span class="o">=</span> <span class="n">kFullType</span><span class="p">;</span>     <span class="c1">// Fits entirely in one piece</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">begin</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">type</span> <span class="o">=</span> <span class="n">kFirstType</span><span class="p">;</span>    <span class="c1">// First piece of a multi-piece record</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">type</span> <span class="o">=</span> <span class="n">kLastType</span><span class="p">;</span>     <span class="c1">// Last piece of a multi-piece record</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">type</span> <span class="o">=</span> <span class="n">kMiddleType</span><span class="p">;</span>   <span class="c1">// Middle piece of a multi-piece record</span>
    <span class="p">}</span>

    <span class="c1">// Write this physical record (header + data fragment) to the file</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">EmitPhysicalRecord</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">fragment_length</span><span class="p">);</span>

    <span class="c1">// Advance pointers and update remaining size</span>
    <span class="n">ptr</span> <span class="o">+=</span> <span class="n">fragment_length</span><span class="p">;</span>
    <span class="n">left</span> <span class="o">-=</span> <span class="n">fragment_length</span><span class="p">;</span>
    <span class="n">begin</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// Subsequent fragments are not the 'begin' fragment</span>

  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// Loop until all data is written or error</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Simplified - Writes header (checksum, length, type) and payload</span>
<span class="n">Status</span> <span class="n">Writer</span><span class="o">::</span><span class="n">EmitPhysicalRecord</span><span class="p">(</span><span class="n">RecordType</span> <span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... format header (buf) with checksum, length, type ...</span>
  <span class="c1">// ... compute checksum ...</span>
  <span class="c1">// ... Encode checksum into header ...</span>

  <span class="c1">// Write header and payload fragment</span>
  <span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">dest_</span><span class="o">-&gt;</span><span class="n">Append</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">kHeaderSize</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">dest_</span><span class="o">-&gt;</span><span class="n">Append</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">length</span><span class="p">));</span>
    <span class="c1">// LevelDB might Flush() here or let the caller Sync() later</span>
  <span class="p">}</span>
  <span class="n">block_offset_</span> <span class="o">+=</span> <span class="n">kHeaderSize</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span> <span class="c1">// Update position in current block</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">AddRecord</code> method takes the user’s data (<code class="language-plaintext highlighter-rouge">slice</code>) and potentially breaks it into smaller <code class="language-plaintext highlighter-rouge">fragment_length</code> chunks.</li>
  <li>Each chunk is written as a “physical record” using <code class="language-plaintext highlighter-rouge">EmitPhysicalRecord</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">EmitPhysicalRecord</code> prepends a small header (<code class="language-plaintext highlighter-rouge">kHeaderSize</code>, 7 bytes) containing a checksum (for detecting corruption), the length of this fragment, and the <code class="language-plaintext highlighter-rouge">RecordType</code> (<code class="language-plaintext highlighter-rouge">kFullType</code>, <code class="language-plaintext highlighter-rouge">kFirstType</code>, <code class="language-plaintext highlighter-rouge">kMiddleType</code>, or <code class="language-plaintext highlighter-rouge">kLastType</code>).</li>
  <li>The <code class="language-plaintext highlighter-rouge">RecordType</code> tells the <code class="language-plaintext highlighter-rouge">LogReader</code> later how to reassemble these fragments back into the original complete record.</li>
</ul>

<h2 id="logreader-reading-the-log-for-recovery">LogReader: Reading the Log for Recovery</h2>

<p>The counterpart to <code class="language-plaintext highlighter-rouge">LogWriter</code> is <code class="language-plaintext highlighter-rouge">log::Reader</code>. This is the component used during database startup (recovery) to read the records back from a WAL file. Think of it as the person carefully reading the ship’s logbook after an incident.</p>

<p>The <code class="language-plaintext highlighter-rouge">log::Reader</code> reads the log file sequentially, block by block. It parses the physical record headers, verifies checksums, and pieces together the fragments (<code class="language-plaintext highlighter-rouge">kFirstType</code>, <code class="language-plaintext highlighter-rouge">kMiddleType</code>, <code class="language-plaintext highlighter-rouge">kLastType</code>) to reconstruct the original data records that were passed to <code class="language-plaintext highlighter-rouge">AddRecord</code>.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- Simplified from db/db_impl.cc ---</span>
<span class="c1">// Inside DBImpl::RecoverLogFile(...)</span>

<span class="c1">// Create the log reader for the specific log file number</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">fname</span> <span class="o">=</span> <span class="n">LogFileName</span><span class="p">(</span><span class="n">dbname_</span><span class="p">,</span> <span class="n">log_number</span><span class="p">);</span>
<span class="n">SequentialFile</span><span class="o">*</span> <span class="n">file</span><span class="p">;</span>
<span class="n">Status</span> <span class="n">status</span> <span class="o">=</span> <span class="n">env_</span><span class="o">-&gt;</span><span class="n">NewSequentialFile</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file</span><span class="p">);</span>
<span class="c1">// ... check status ...</span>

<span class="c1">// Set up reporter for corruption errors</span>
<span class="n">log</span><span class="o">::</span><span class="n">Reader</span><span class="o">::</span><span class="n">Reporter</span> <span class="n">reporter</span><span class="p">;</span>
<span class="c1">// ... initialize reporter ...</span>
<span class="n">log</span><span class="o">::</span><span class="n">Reader</span> <span class="nf">reader</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">reporter</span><span class="p">,</span> <span class="nb">true</span> <span class="cm">/*checksum*/</span><span class="p">,</span> <span class="mi">0</span> <span class="cm">/*initial_offset*/</span><span class="p">);</span>

<span class="c1">// Read records one by one and apply them to a temporary MemTable</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">scratch</span><span class="p">;</span>
<span class="n">Slice</span> <span class="n">record</span><span class="p">;</span>
<span class="n">WriteBatch</span> <span class="n">batch</span><span class="p">;</span>
<span class="n">MemTable</span><span class="o">*</span> <span class="n">mem</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">MemTable</span><span class="p">(</span><span class="n">internal_comparator_</span><span class="p">);</span>
<span class="n">mem</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">();</span>

<span class="k">while</span> <span class="p">(</span><span class="n">reader</span><span class="p">.</span><span class="n">ReadRecord</span><span class="p">(</span><span class="o">&amp;</span><span class="n">record</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scratch</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">status</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
  <span class="c1">// record now holds a complete record originally passed to AddRecord</span>

  <span class="c1">// Parse the record back into a WriteBatch</span>
  <span class="n">WriteBatchInternal</span><span class="o">::</span><span class="n">SetContents</span><span class="p">(</span><span class="o">&amp;</span><span class="n">batch</span><span class="p">,</span> <span class="n">record</span><span class="p">);</span>

  <span class="c1">// Apply the operations from the batch to the MemTable</span>
  <span class="n">status</span> <span class="o">=</span> <span class="n">WriteBatchInternal</span><span class="o">::</span><span class="n">InsertInto</span><span class="p">(</span><span class="o">&amp;</span><span class="n">batch</span><span class="p">,</span> <span class="n">mem</span><span class="p">);</span>
  <span class="c1">// ... check status ...</span>

  <span class="c1">// Update the max sequence number seen</span>
  <span class="k">const</span> <span class="n">SequenceNumber</span> <span class="n">last_seq</span> <span class="o">=</span> <span class="cm">/* ... get from batch ... */</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">last_seq</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">max_sequence</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">max_sequence</span> <span class="o">=</span> <span class="n">last_seq</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Optional: If MemTable gets too big during recovery, flush it</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">mem</span><span class="o">-&gt;</span><span class="n">ApproximateMemoryUsage</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">options_</span><span class="p">.</span><span class="n">write_buffer_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">WriteLevel0Table</span><span class="p">(</span><span class="n">mem</span><span class="p">,</span> <span class="n">edit</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span> <span class="c1">// Flush to SSTable</span>
    <span class="n">mem</span><span class="o">-&gt;</span><span class="n">Unref</span><span class="p">();</span>
    <span class="n">mem</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MemTable</span><span class="p">(</span><span class="n">internal_comparator_</span><span class="p">);</span>
    <span class="n">mem</span><span class="o">-&gt;</span><span class="n">Ref</span><span class="p">();</span>
    <span class="c1">// ... check status ...</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">delete</span> <span class="n">file</span><span class="p">;</span> <span class="c1">// Close the log file</span>
<span class="c1">// ... handle final MemTable (mem) if not null ...</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li>A <code class="language-plaintext highlighter-rouge">log::Reader</code> is created, pointing to the WAL file (<code class="language-plaintext highlighter-rouge">.log</code>) that needs recovery.</li>
  <li>The code loops using <code class="language-plaintext highlighter-rouge">reader.ReadRecord(&amp;record, &amp;scratch)</code>.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">record</code>: This <code class="language-plaintext highlighter-rouge">Slice</code> will point to the reassembled data of the next complete logical record found in the log.</li>
      <li><code class="language-plaintext highlighter-rouge">scratch</code>: A temporary string buffer the reader might use if a record spans multiple blocks.</li>
    </ul>
  </li>
  <li>Inside the loop:
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">record</code> (which contains a serialized <code class="language-plaintext highlighter-rouge">WriteBatch</code>) is parsed back into a <code class="language-plaintext highlighter-rouge">WriteBatch</code> object.</li>
      <li><code class="language-plaintext highlighter-rouge">WriteBatchInternal::InsertInto(&amp;batch, mem)</code> applies the operations (Puts/Deletes) from the recovered batch to the in-memory <code class="language-plaintext highlighter-rouge">MemTable</code> (<code class="language-plaintext highlighter-rouge">mem</code>).</li>
      <li>The code keeps track of the latest sequence number encountered.</li>
      <li>Optionally, if the <code class="language-plaintext highlighter-rouge">MemTable</code> fills up <em>during</em> recovery, it can be flushed to an SSTable just like during normal operation.</li>
    </ul>
  </li>
  <li>This continues until <code class="language-plaintext highlighter-rouge">ReadRecord</code> returns <code class="language-plaintext highlighter-rouge">false</code> (end of log file) or an error occurs.</li>
</ol>

<p>The <code class="language-plaintext highlighter-rouge">log::Reader::ReadRecord</code> implementation handles the details of reading blocks, finding headers, checking checksums, and combining <code class="language-plaintext highlighter-rouge">kFirstType</code>, <code class="language-plaintext highlighter-rouge">kMiddleType</code>, <code class="language-plaintext highlighter-rouge">kLastType</code> fragments.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- Simplified from db/log_reader.cc ---</span>

<span class="c1">// Reads the next complete logical record. Returns true if successful.</span>
<span class="kt">bool</span> <span class="n">Reader</span><span class="o">::</span><span class="n">ReadRecord</span><span class="p">(</span><span class="n">Slice</span><span class="o">*</span> <span class="n">record</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">scratch</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... skip records before initial_offset if necessary ...</span>

  <span class="n">scratch</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">record</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="n">in_fragmented_record</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="n">Slice</span> <span class="n">fragment</span><span class="p">;</span> <span class="c1">// To hold data from one physical record</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Reads the next physical record (header + data fragment) from the file blocks.</span>
    <span class="c1">// Handles reading across block boundaries internally.</span>
    <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">record_type</span> <span class="o">=</span> <span class="n">ReadPhysicalRecord</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fragment</span><span class="p">);</span>

    <span class="c1">// ... handle resyncing logic after seeking ...</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">record_type</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="n">kFullType</span><span class="p">:</span>
        <span class="c1">// ... sanity check for unexpected fragments ...</span>
        <span class="o">*</span><span class="n">record</span> <span class="o">=</span> <span class="n">fragment</span><span class="p">;</span> <span class="c1">// Got a complete record in one piece</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

      <span class="k">case</span> <span class="n">kFirstType</span><span class="p">:</span>
        <span class="c1">// ... sanity check for unexpected fragments ...</span>
        <span class="n">scratch</span><span class="o">-&gt;</span><span class="n">assign</span><span class="p">(</span><span class="n">fragment</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">fragment</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="c1">// Start of a new fragmented record</span>
        <span class="n">in_fragmented_record</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="n">kMiddleType</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_fragmented_record</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Report corruption */</span> <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span> <span class="n">scratch</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">fragment</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">fragment</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="p">}</span> <span class="c1">// Append middle piece</span>
        <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="n">kLastType</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">in_fragmented_record</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* Report corruption */</span> <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
          <span class="n">scratch</span><span class="o">-&gt;</span><span class="n">append</span><span class="p">(</span><span class="n">fragment</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="n">fragment</span><span class="p">.</span><span class="n">size</span><span class="p">());</span> <span class="c1">// Append final piece</span>
          <span class="o">*</span><span class="n">record</span> <span class="o">=</span> <span class="n">Slice</span><span class="p">(</span><span class="o">*</span><span class="n">scratch</span><span class="p">);</span> <span class="c1">// Reassembled record is complete</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="n">kEof</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="c1">// End of log file</span>

      <span class="k">case</span> <span class="n">kBadRecord</span><span class="p">:</span>
        <span class="c1">// ... report corruption, clear state ...</span>
        <span class="n">in_fragmented_record</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">scratch</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span> <span class="c1">// Try to find the next valid record</span>

      <span class="nl">default:</span>
        <span class="c1">// ... report corruption ...</span>
        <span class="n">in_fragmented_record</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">scratch</span><span class="o">-&gt;</span><span class="n">clear</span><span class="p">();</span>
        <span class="k">break</span><span class="p">;</span> <span class="c1">// Try to find the next valid record</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">ReadRecord</code> calls <code class="language-plaintext highlighter-rouge">ReadPhysicalRecord</code> repeatedly in a loop.</li>
  <li><code class="language-plaintext highlighter-rouge">ReadPhysicalRecord</code> (internal helper, not shown in full) reads from the file, parses the 7-byte header, checks the CRC, and returns the type and the data fragment (<code class="language-plaintext highlighter-rouge">result</code>). It handles skipping block trailers and reading new blocks as needed.</li>
  <li>Based on the <code class="language-plaintext highlighter-rouge">record_type</code>, <code class="language-plaintext highlighter-rouge">ReadRecord</code> either returns the complete record (<code class="language-plaintext highlighter-rouge">kFullType</code>), starts assembling fragments (<code class="language-plaintext highlighter-rouge">kFirstType</code>), appends fragments (<code class="language-plaintext highlighter-rouge">kMiddleType</code>), or finishes assembling and returns the record (<code class="language-plaintext highlighter-rouge">kLastType</code>).</li>
  <li>It manages the <code class="language-plaintext highlighter-rouge">scratch</code> buffer to hold the fragments being assembled.</li>
</ul>

<h2 id="recovery-process-diagram">Recovery Process Diagram</h2>

<p>Here’s how the WAL is used during database startup if a crash occurred:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant App as Application Startup
    participant LevelDB as DB::Open()
    participant Env as Environment (OS/FS)
    participant LogReader as log::Reader
    participant MemTable as New MemTable (RAM)

    App-&gt;&gt;LevelDB: Open Database
    LevelDB-&gt;&gt;Env: Check for CURRENT file, MANIFEST, etc.
    LevelDB-&gt;&gt;Env: Look for .log files &gt;= Manifest LogNumber
    alt Log file(s) found
        LevelDB-&gt;&gt;LogReader : Create Reader for log file
        loop Read Log Records
            LogReader -&gt;&gt; Env: Read next block(s) from log file
            Env--&gt;&gt;LogReader: Return data
            LogReader -&gt;&gt; LogReader : Parse physical records, reassemble logical record
            alt Record Found
                LogReader --&gt;&gt; LevelDB: Return next record (WriteBatch data)
                LevelDB -&gt;&gt; MemTable: Apply WriteBatch to MemTable
            else End of Log or Error
                LogReader --&gt;&gt; LevelDB: Indicate EOF / Error
                Note right of LevelDB: Loop will exit
            end
        end
        LevelDB -&gt;&gt; LogReader : Destroy Reader
        Note right of LevelDB: MemTable now holds recovered state.
    else No relevant log files
        Note right of LevelDB: Clean shutdown or new DB. No log replay needed.
    end
    LevelDB--&gt;&gt;App: Database Opened Successfully
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>The <strong>Write-Ahead Log (WAL)</strong> is a critical component for ensuring <strong>durability</strong> in LevelDB. By writing every operation to an append-only log file on disk <em>before</em> applying it to the in-memory <code class="language-plaintext highlighter-rouge">MemTable</code> and acknowledging the write, LevelDB guarantees that no acknowledged data is lost even if the server crashes.</p>

<ul>
  <li>The <code class="language-plaintext highlighter-rouge">log::Writer</code> handles appending records to the current WAL file, dealing with block formatting and fragmentation.</li>
  <li>The <code class="language-plaintext highlighter-rouge">log::Reader</code> handles reading records back from the WAL file during recovery, verifying checksums and reassembling fragmented records.</li>
  <li>This recovery process replays the logged operations to rebuild the <code class="language-plaintext highlighter-rouge">MemTable</code> state that was lost in the crash.</li>
</ul>

<p>The WAL, MemTable, and SSTables work together: WAL provides fast durability for recent writes, MemTable provides fast access to those recent writes in memory, and SSTables provide persistent, sorted storage for the bulk of the data.</p>

<p>Now that we understand the core storage structures (SSTables, MemTable, WAL), we can start looking at how they are managed and coordinated.</p>

<p>Next up: <a href="04_dbimpl.md">Chapter 4: DBImpl</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
