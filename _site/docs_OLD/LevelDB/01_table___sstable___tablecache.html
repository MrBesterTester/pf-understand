<h1 id="chapter-1-table--sstable--tablecache">Chapter 1: Table / SSTable &amp; TableCache</h1>

<p>Welcome to your LevelDB journey! This is the first chapter where we’ll start exploring the fundamental building blocks of LevelDB.</p>

<p>Imagine you’re building a system to store a massive amount of data, like user profiles or product information. You need a way to save this data permanently (so it doesn’t disappear when the computer turns off) and retrieve it quickly. How does LevelDB handle this?</p>

<p>The core idea we’ll explore in this chapter is how LevelDB stores the bulk of its data on disk in special files and how it accesses them efficiently.</p>

<h2 id="whats-the-problem-storing-lots-of-data-permanently">What’s the Problem? Storing Lots of Data Permanently</h2>

<p>Databases need to store key-value pairs (like <code class="language-plaintext highlighter-rouge">user_id</code> -&gt; <code class="language-plaintext highlighter-rouge">user_data</code>) persistently. This means writing the data to disk. However, disks are much slower than computer memory (RAM). If we just wrote every tiny change directly to a file, it would be very slow. Also, how do we organize the data on disk so we can find a specific key quickly without reading <em>everything</em>?</p>

<p>LevelDB’s solution involves files called <strong>SSTables</strong> (Sorted String Tables), often just called <strong>Tables</strong> in the code.</p>

<h2 id="sstable-the-sorted-immutable-book-on-the-shelf">SSTable: The Sorted, Immutable Book on the Shelf</h2>

<p>Think of an SSTable as a <strong>permanently bound book</strong> in a library.</p>

<ol>
  <li><strong>Stores Key-Value Pairs:</strong> Just like a dictionary or an encyclopedia volume, an SSTable contains data entries, specifically key-value pairs.</li>
  <li><strong>Sorted:</strong> The keys inside an SSTable file are always stored in sorted order (like words in a dictionary). This is crucial for finding data quickly later on. If you’re looking for the key “zebra”, you know you don’t need to look in the “A” section.</li>
  <li><strong>Immutable:</strong> Once an SSTable file is written to disk, LevelDB <strong>never changes it</strong>. It’s like a printed book – you can’t erase or rewrite a page. If you need to update or delete data, LevelDB writes <em>new</em> information in <em>newer</em> SSTables. (We’ll see how this works in later chapters like <a href="08_compaction.md">Compaction</a>). This immutability makes many things simpler and safer.</li>
  <li><strong>It’s a File:</strong> At the end of the day, an SSTable is just a file on your computer’s disk. LevelDB gives these files names like <code class="language-plaintext highlighter-rouge">000005.ldb</code> or <code class="language-plaintext highlighter-rouge">000010.sst</code>.</li>
</ol>

<p>Here’s how LevelDB determines the filename for an SSTable:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- File: filename.cc ---</span>

<span class="c1">// Creates a filename like "dbname/000005.ldb"</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">TableFileName</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">dbname</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">number</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
  <span class="c1">// Uses a helper to format the number with leading zeros</span>
  <span class="c1">// and adds the '.ldb' or '.sst' suffix.</span>
  <span class="k">return</span> <span class="n">MakeFileName</span><span class="p">(</span><span class="n">dbname</span><span class="p">,</span> <span class="n">number</span><span class="p">,</span> <span class="s">"ldb"</span><span class="p">);</span> <span class="c1">// or "sst"</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This simple function takes the database name (e.g., <code class="language-plaintext highlighter-rouge">/path/to/my/db</code>) and a unique number and creates the actual filename used on disk. The <code class="language-plaintext highlighter-rouge">.ldb</code> or <code class="language-plaintext highlighter-rouge">.sst</code> extension helps identify it as a LevelDB table file.</p>

<h2 id="creating-sstables-buildtable">Creating SSTables: <code class="language-plaintext highlighter-rouge">BuildTable</code></h2>

<p>How do these sorted, immutable files get created? This happens during processes like “flushing” data from memory or during “compaction” (which we’ll cover in later chapters: <a href="02_memtable.md">MemTable</a> and <a href="08_compaction.md">Compaction</a>).</p>

<p>The function responsible for writing a new SSTable file is <code class="language-plaintext highlighter-rouge">BuildTable</code>. Think of <code class="language-plaintext highlighter-rouge">BuildTable</code> as the <strong>printing press and binding machine</strong> for our book analogy. It takes data (often from memory, represented by an <code class="language-plaintext highlighter-rouge">Iterator</code>) and writes it out to a new, sorted SSTable file on disk.</p>

<p>Let’s look at a simplified view of <code class="language-plaintext highlighter-rouge">BuildTable</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- File: builder.cc ---</span>

<span class="c1">// Builds an SSTable file from the key/value pairs provided by 'iter'.</span>
<span class="n">Status</span> <span class="nf">BuildTable</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">dbname</span><span class="p">,</span> <span class="n">Env</span><span class="o">*</span> <span class="n">env</span><span class="p">,</span> <span class="k">const</span> <span class="n">Options</span><span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span>
                  <span class="n">TableCache</span><span class="o">*</span> <span class="n">table_cache</span><span class="p">,</span> <span class="n">Iterator</span><span class="o">*</span> <span class="n">iter</span><span class="p">,</span> <span class="n">FileMetaData</span><span class="o">*</span> <span class="n">meta</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Status</span> <span class="n">s</span><span class="p">;</span>
  <span class="c1">// ... setup: determine filename, open the file for writing ...</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">fname</span> <span class="o">=</span> <span class="n">TableFileName</span><span class="p">(</span><span class="n">dbname</span><span class="p">,</span> <span class="n">meta</span><span class="o">-&gt;</span><span class="n">number</span><span class="p">);</span>
  <span class="n">WritableFile</span><span class="o">*</span> <span class="n">file</span><span class="p">;</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">env</span><span class="o">-&gt;</span><span class="n">NewWritableFile</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file</span><span class="p">);</span>
  <span class="c1">// ... handle potential errors ...</span>

  <span class="c1">// TableBuilder does the heavy lifting of formatting the file</span>
  <span class="n">TableBuilder</span><span class="o">*</span> <span class="n">builder</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TableBuilder</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

  <span class="c1">// Find the first key to store as the smallest key in metadata</span>
  <span class="n">iter</span><span class="o">-&gt;</span><span class="n">SeekToFirst</span><span class="p">();</span>
  <span class="n">meta</span><span class="o">-&gt;</span><span class="n">smallest</span><span class="p">.</span><span class="n">DecodeFrom</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">());</span>

  <span class="c1">// Loop through all key-value pairs from the input iterator</span>
  <span class="n">Slice</span> <span class="n">key</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">Valid</span><span class="p">();</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">();</span>
    <span class="c1">// Add the key and value to the table being built</span>
    <span class="n">builder</span><span class="o">-&gt;</span><span class="n">Add</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">value</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="c1">// Store the last key as the largest key in metadata</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">meta</span><span class="o">-&gt;</span><span class="n">largest</span><span class="p">.</span><span class="n">DecodeFrom</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// Finish writing the file (adds index blocks, etc.)</span>
  <span class="n">s</span> <span class="o">=</span> <span class="n">builder</span><span class="o">-&gt;</span><span class="n">Finish</span><span class="p">();</span>
  <span class="c1">// ... more steps: update metadata, sync file to disk, close file ...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">meta</span><span class="o">-&gt;</span><span class="n">file_size</span> <span class="o">=</span> <span class="n">builder</span><span class="o">-&gt;</span><span class="n">FileSize</span><span class="p">();</span>
      <span class="n">s</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">Sync</span><span class="p">();</span> <span class="c1">// Ensure data is physically written</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">s</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">Close</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="c1">// ... cleanup: delete builder, file; handle errors ...</span>

  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><strong>Input:</strong> <code class="language-plaintext highlighter-rouge">BuildTable</code> receives data via an <code class="language-plaintext highlighter-rouge">Iterator</code>. An iterator is like a cursor that lets you go through key-value pairs one by one, already in sorted order. It also gets other necessary info like the database name (<code class="language-plaintext highlighter-rouge">dbname</code>), environment (<code class="language-plaintext highlighter-rouge">env</code>), options, the <code class="language-plaintext highlighter-rouge">TableCache</code> (we’ll see this next!), and a <code class="language-plaintext highlighter-rouge">FileMetaData</code> object to store information <em>about</em> the new file (like its number, size, smallest key, and largest key).</li>
  <li><strong>File Creation:</strong> It creates a new, empty file using <code class="language-plaintext highlighter-rouge">env-&gt;NewWritableFile</code>.</li>
  <li><strong>TableBuilder:</strong> It uses a helper object called <code class="language-plaintext highlighter-rouge">TableBuilder</code> to handle the complex details of formatting the SSTable file structure (data blocks, index blocks, etc.).</li>
  <li><strong>Iteration &amp; Adding:</strong> It loops through the <code class="language-plaintext highlighter-rouge">Iterator</code>. For each key-value pair, it calls <code class="language-plaintext highlighter-rouge">builder-&gt;Add()</code>. Because the input <code class="language-plaintext highlighter-rouge">Iterator</code> provides keys in sorted order, the <code class="language-plaintext highlighter-rouge">TableBuilder</code> can write them sequentially to the file.</li>
  <li><strong>Metadata:</strong> It records the very first key (<code class="language-plaintext highlighter-rouge">meta-&gt;smallest</code>) and the very last key (<code class="language-plaintext highlighter-rouge">meta-&gt;largest</code>) it processes. This is useful later for quickly knowing the range of keys stored in this file without opening it.</li>
  <li><strong>Finishing Up:</strong> It calls <code class="language-plaintext highlighter-rouge">builder-&gt;Finish()</code> to write out the final pieces of the SSTable (like the index). Then it <code class="language-plaintext highlighter-rouge">Sync</code>s the file to ensure the data is safely on disk and <code class="language-plaintext highlighter-rouge">Close</code>s it.</li>
  <li><strong>Output:</strong> If successful, a new <code class="language-plaintext highlighter-rouge">.ldb</code> file exists on disk containing the sorted key-value pairs, and the <code class="language-plaintext highlighter-rouge">meta</code> object is filled with details about this file.</li>
</ol>

<h2 id="accessing-sstables-efficiently-tablecache">Accessing SSTables Efficiently: <code class="language-plaintext highlighter-rouge">TableCache</code></h2>

<p>Okay, so we have these SSTable files on disk. But reading from disk is slow. If we need to read from the same SSTable file multiple times (which is common), opening and closing it repeatedly, or re-reading its internal index structure, would be inefficient.</p>

<p>This is where the <code class="language-plaintext highlighter-rouge">TableCache</code> comes in. Think of the <code class="language-plaintext highlighter-rouge">TableCache</code> as a <strong>smart librarian</strong>.</p>

<ol>
  <li><strong>Keeps Files Open:</strong> The librarian might keep the most popular books near the front desk instead of running to the far shelves every time someone asks for them. Similarly, the <code class="language-plaintext highlighter-rouge">TableCache</code> keeps recently used SSTable files open.</li>
  <li><strong>Caches Structures:</strong> Just opening the file isn’t enough. LevelDB needs to read some index information <em>within</em> the SSTable file to find keys quickly. The <code class="language-plaintext highlighter-rouge">TableCache</code> also keeps this parsed information in memory (RAM). It uses a specific caching strategy called LRU (Least Recently Used) to decide which table information to keep in memory if the cache gets full.</li>
  <li><strong>Provides Access:</strong> When LevelDB needs to read data from a specific SSTable (identified by its file number), it asks the <code class="language-plaintext highlighter-rouge">TableCache</code>. The cache checks if it already has that table open and ready in memory. If yes (a “cache hit”), it returns access quickly. If no (a “cache miss”), it opens the actual file from disk, reads the necessary index info, stores it in the cache for next time, and then returns access.</li>
</ol>

<p>Let’s see how the <code class="language-plaintext highlighter-rouge">TableCache</code> finds a table:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- File: table_cache.cc ---</span>

<span class="c1">// Tries to find the Table structure for a given file number.</span>
<span class="c1">// If not in cache, opens the file and loads it.</span>
<span class="n">Status</span> <span class="n">TableCache</span><span class="o">::</span><span class="n">FindTable</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">file_number</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">file_size</span><span class="p">,</span>
                             <span class="n">Cache</span><span class="o">::</span><span class="n">Handle</span><span class="o">**</span> <span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Status</span> <span class="n">s</span><span class="p">;</span>
  <span class="c1">// Create a key for the cache lookup (based on file number)</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">file_number</span><span class="p">)];</span>
  <span class="n">EncodeFixed64</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">file_number</span><span class="p">);</span>
  <span class="n">Slice</span> <span class="n">key</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>

  <span class="c1">// 1. Try looking up the table in the cache</span>
  <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">cache_</span><span class="o">-&gt;</span><span class="n">Lookup</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">handle</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// Cache Miss!</span>
    <span class="c1">// 2. If not found, open the actual file from disk</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">fname</span> <span class="o">=</span> <span class="n">TableFileName</span><span class="p">(</span><span class="n">dbname_</span><span class="p">,</span> <span class="n">file_number</span><span class="p">);</span>
    <span class="n">RandomAccessFile</span><span class="o">*</span> <span class="n">file</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">env_</span><span class="o">-&gt;</span><span class="n">NewRandomAccessFile</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file</span><span class="p">);</span> <span class="c1">// Open the file</span>
    <span class="c1">// ... handle errors, potentially check for old .sst filename ...</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
      <span class="c1">// 3. Parse the Table structure (index etc.) from the file</span>
      <span class="n">s</span> <span class="o">=</span> <span class="n">Table</span><span class="o">::</span><span class="n">Open</span><span class="p">(</span><span class="n">options_</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">file_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
      <span class="c1">// 4. Store the opened file and parsed Table in the cache</span>
      <span class="n">TableAndFile</span><span class="o">*</span> <span class="n">tf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">TableAndFile</span><span class="p">;</span>
      <span class="n">tf</span><span class="o">-&gt;</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span><span class="p">;</span>
      <span class="n">tf</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
      <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">cache_</span><span class="o">-&gt;</span><span class="n">Insert</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">tf</span><span class="p">,</span> <span class="mi">1</span> <span class="cm">/*charge*/</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">DeleteEntry</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// Error occurred, cleanup</span>
      <span class="k">delete</span> <span class="n">file</span><span class="p">;</span>
      <span class="c1">// Note: Errors are NOT cached. We'll retry opening next time.</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="c1">// else: Cache Hit! *handle is already valid.</span>
  <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><strong>Lookup:</strong> It first tries <code class="language-plaintext highlighter-rouge">cache_-&gt;Lookup</code> using the <code class="language-plaintext highlighter-rouge">file_number</code>.</li>
  <li><strong>Cache Miss:</strong> If <code class="language-plaintext highlighter-rouge">Lookup</code> returns <code class="language-plaintext highlighter-rouge">nullptr</code>, it means the table isn’t in the cache. It then proceeds to open the file (<code class="language-plaintext highlighter-rouge">env_-&gt;NewRandomAccessFile</code>).</li>
  <li><strong>Table::Open:</strong> It calls <code class="language-plaintext highlighter-rouge">Table::Open</code>, which reads the file’s footer, parses the index block, and sets up a <code class="language-plaintext highlighter-rouge">Table</code> object ready for lookups.</li>
  <li><strong>Insert:</strong> If opening and parsing succeed, it creates a <code class="language-plaintext highlighter-rouge">TableAndFile</code> struct (holding both the file handle and the <code class="language-plaintext highlighter-rouge">Table</code> object) and inserts it into the cache using <code class="language-plaintext highlighter-rouge">cache_-&gt;Insert</code>. Now, the next time <code class="language-plaintext highlighter-rouge">FindTable</code> is called for this <code class="language-plaintext highlighter-rouge">file_number</code>, it will be a cache hit.</li>
  <li><strong>Cache Hit:</strong> If <code class="language-plaintext highlighter-rouge">Lookup</code> initially returned a valid handle, <code class="language-plaintext highlighter-rouge">FindTable</code> simply returns <code class="language-plaintext highlighter-rouge">Status::OK()</code>, and the caller can use the handle to get the <code class="language-plaintext highlighter-rouge">Table</code> object.</li>
</ol>

<p>When LevelDB needs to read data, it often gets an <code class="language-plaintext highlighter-rouge">Iterator</code> for a specific SSTable via the <code class="language-plaintext highlighter-rouge">TableCache</code>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- File: table_cache.cc ---</span>

<span class="c1">// Returns an iterator for reading the specified SSTable file.</span>
<span class="n">Iterator</span><span class="o">*</span> <span class="n">TableCache</span><span class="o">::</span><span class="n">NewIterator</span><span class="p">(</span><span class="k">const</span> <span class="n">ReadOptions</span><span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span>
                                  <span class="kt">uint64_t</span> <span class="n">file_number</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">file_size</span><span class="p">,</span>
                                  <span class="n">Table</span><span class="o">**</span> <span class="n">tableptr</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ... setup ...</span>
  <span class="n">Cache</span><span class="o">::</span><span class="n">Handle</span><span class="o">*</span> <span class="n">handle</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="c1">// Use FindTable to get the Table object (from cache or by opening file)</span>
  <span class="n">Status</span> <span class="n">s</span> <span class="o">=</span> <span class="n">FindTable</span><span class="p">(</span><span class="n">file_number</span><span class="p">,</span> <span class="n">file_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">handle</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">ok</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">NewErrorIterator</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="c1">// Return an iterator that yields the error</span>
  <span class="p">}</span>

  <span class="c1">// Get the Table object from the cache handle</span>
  <span class="n">Table</span><span class="o">*</span> <span class="n">table</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">TableAndFile</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">cache_</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
  <span class="c1">// Ask the Table object to create a new iterator for its data</span>
  <span class="n">Iterator</span><span class="o">*</span> <span class="n">result</span> <span class="o">=</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">NewIterator</span><span class="p">(</span><span class="n">options</span><span class="p">);</span>

  <span class="c1">// Important: Register cleanup to release the cache handle when iterator is done</span>
  <span class="n">result</span><span class="o">-&gt;</span><span class="n">RegisterCleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">UnrefEntry</span><span class="p">,</span> <span class="n">cache_</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>

  <span class="c1">// Optionally return the Table object itself</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">tableptr</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">tableptr</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This function uses <code class="language-plaintext highlighter-rouge">FindTable</code> to get the <code class="language-plaintext highlighter-rouge">Table</code> object (either from the cache or by loading it from disk) and then asks that <code class="language-plaintext highlighter-rouge">Table</code> object to provide an <code class="language-plaintext highlighter-rouge">Iterator</code> to step through its key-value pairs. It also cleverly registers a cleanup function (<code class="language-plaintext highlighter-rouge">UnrefEntry</code>) so that when the iterator is no longer needed, the cache handle is released, allowing the cache to potentially evict the table later if needed.</p>

<p>Here’s a diagram showing how a read might use the <code class="language-plaintext highlighter-rouge">TableCache</code>:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Client as Read Operation
    participant TableCache
    participant Cache as LRUCache
    participant OS/FileSystem as FS
    participant TableObject as In-Memory Table Rep

    Client-&gt;&gt;TableCache: Get("some_key", file_num=5, size=1MB)
    TableCache-&gt;&gt;Cache: Lookup(file_num=5)?
    alt Cache Hit
        Cache--&gt;&gt;TableCache: Return handle for Table 5
        TableCache-&gt;&gt;TableObject: Find "some_key" within Table 5 data
        TableObject--&gt;&gt;TableCache: Return value / not found
        TableCache--&gt;&gt;Client: Return value / not found
    else Cache Miss
        Cache--&gt;&gt;TableCache: Not found (nullptr)
        TableCache-&gt;&gt;FS: Open file "000005.ldb"
        FS--&gt;&gt;TableCache: Return file handle
        TableCache-&gt;&gt;TableObject: Create Table 5 representation from file handle + size
        TableObject--&gt;&gt;TableCache: Return Table 5 object
        TableCache-&gt;&gt;Cache: Insert(file_num=5, Table 5 object)
        Note right of Cache: Table 5 now cached
        TableCache-&gt;&gt;TableObject: Find "some_key" within Table 5 data
        TableObject--&gt;&gt;TableCache: Return value / not found
        TableCache--&gt;&gt;Client: Return value / not found
    end
</code></pre>

<h2 id="conclusion">Conclusion</h2>

<p>In this chapter, we learned about two fundamental concepts in LevelDB:</p>

<ol>
  <li><strong>SSTable (Table):</strong> These are the immutable, sorted files on disk where LevelDB stores the bulk of its key-value data. Think of them as sorted, bound books. They are created using <code class="language-plaintext highlighter-rouge">BuildTable</code>.</li>
  <li><strong>TableCache:</strong> This acts like an efficient librarian for SSTables. It keeps recently used tables open and their index structures cached in memory (RAM) to speed up access, avoiding slow disk reads whenever possible. It provides access to table data, often via iterators.</li>
</ol>

<p>These two components work together to provide persistent storage and relatively fast access to the data within those files.</p>

<p>But where does the data <em>come from</em> before it gets written into an SSTable? Often, it lives in memory first. In the next chapter, we’ll look at the in-memory structure where recent writes are held before being flushed to an SSTable.</p>

<p>Next up: <a href="02_memtable.md">Chapter 2: MemTable</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
