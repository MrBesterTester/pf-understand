<h1 id="chapter-2-easier-server-building-with-fastmcp">Chapter 2: Easier Server Building with <code class="language-plaintext highlighter-rouge">FastMCP</code></h1>

<p>In <a href="01_cli___mcp__command_.md">Chapter 1: Your Control Panel - The <code class="language-plaintext highlighter-rouge">mcp</code> Command-Line Interface</a>, we learned how to use the <code class="language-plaintext highlighter-rouge">mcp</code> command to run, test, and install MCP servers. We even saw a tiny example of a server file. But how do we <em>build</em> that server code without getting lost in complex details?</p>

<p>Imagine you want to build a simple AI assistant that can just echo back whatever you type. Writing all the code to handle connections, interpret messages according to the MCP protocol, manage capabilities – it sounds like a lot of work just for an echo!</p>

<p>This is where <code class="language-plaintext highlighter-rouge">FastMCP</code> comes in. It’s designed to make building MCP servers much, much easier.</p>

<h2 id="what-is-fastmcp">What is <code class="language-plaintext highlighter-rouge">FastMCP</code>?</h2>

<p>Think of the low-level parts of the MCP protocol like individual kitchen tools: a pot, a pan, a knife, a whisk. You <em>could</em> use them all individually to cook a meal, but you’d need to know exactly when and how to use each one.</p>

<p><code class="language-plaintext highlighter-rouge">FastMCP</code> is like a fancy <strong>kitchen multi-cooker</strong>. It bundles many common functions together in an easy-to-use package. You provide the ingredients (your Python functions and data) and press simple buttons (special markers called <strong>decorators</strong> like <code class="language-plaintext highlighter-rouge">@tool</code>, <code class="language-plaintext highlighter-rouge">@resource</code>, <code class="language-plaintext highlighter-rouge">@prompt</code>), and <code class="language-plaintext highlighter-rouge">FastMCP</code> handles the complex cooking process (managing the low-level MCP details) for you.</p>

<p><strong>Key benefits of using <code class="language-plaintext highlighter-rouge">FastMCP</code>:</strong></p>

<ul>
  <li><strong>Simplicity:</strong> Hides a lot of the complex MCP protocol details.</li>
  <li><strong>Developer-Friendly:</strong> Uses familiar Python concepts like functions and decorators.</li>
  <li><strong>Less Boilerplate:</strong> Reduces the amount of repetitive setup code you need to write.</li>
  <li><strong>Built-in Features:</strong> Includes easy ways to manage settings, automatically tell clients what your server can do (capability generation), and handle common tasks.</li>
</ul>

<h2 id="your-first-fastmcp-server-the-foundation">Your First <code class="language-plaintext highlighter-rouge">FastMCP</code> Server: The Foundation</h2>

<p>Let’s start with the absolute minimum needed to create a <code class="language-plaintext highlighter-rouge">FastMCP</code> server.</p>

<p><strong>File: <code class="language-plaintext highlighter-rouge">my_simple_server.py</code></strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1. Import the FastMCP class
</span><span class="kn">from</span> <span class="nn">mcp.server.fastmcp</span> <span class="kn">import</span> <span class="n">FastMCP</span>

<span class="c1"># 2. Create an instance of the FastMCP server
#    Give it a name clients might see.
#    Optionally, provide general instructions.
</span><span class="n">server</span> <span class="o">=</span> <span class="n">FastMCP</span><span class="p">(</span>
    <span class="n">name</span><span class="o">=</span><span class="s">"MySimpleServer"</span><span class="p">,</span>
    <span class="n">instructions</span><span class="o">=</span><span class="s">"This is a very simple example server."</span>
<span class="p">)</span>

<span class="c1"># 3. Add the standard Python block to run the server
#    when the script is executed directly.
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Starting </span><span class="si">{</span><span class="n">server</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">..."</span><span class="p">)</span>
    <span class="c1"># This tells FastMCP to start listening for connections
</span>    <span class="n">server</span><span class="p">.</span><span class="n">run</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">server</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s"> finished."</span><span class="p">)</span> <span class="c1"># Usually only seen after stopping (Ctrl+C)
</span></code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">from mcp.server.fastmcp import FastMCP</code></strong>: We import the main <code class="language-plaintext highlighter-rouge">FastMCP</code> class from the SDK.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">server = FastMCP(...)</code></strong>: We create our “multi-cooker” object.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">name="MySimpleServer"</code>: This is a human-readable name for your server. Clients might display this name.</li>
      <li><code class="language-plaintext highlighter-rouge">instructions="..."</code>: This provides a general description or purpose for the server. Clients can use this to understand what the server does.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">if __name__ == "__main__":</code></strong>: This is a standard Python pattern. The code inside this block only runs when you execute the script directly (e.g., using <code class="language-plaintext highlighter-rouge">python my_simple_server.py</code> or <code class="language-plaintext highlighter-rouge">mcp run my_simple_server.py</code>).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">server.run()</code></strong>: This is the command that actually starts the server. It tells <code class="language-plaintext highlighter-rouge">FastMCP</code> to begin listening for incoming connections and handling MCP messages. By default, it uses the “stdio” transport (reading/writing from the terminal), which we discussed briefly in Chapter 1.</li>
</ol>

<p>If you save this code as <code class="language-plaintext highlighter-rouge">my_simple_server.py</code> and run it using <code class="language-plaintext highlighter-rouge">mcp run my_simple_server.py</code> (as learned in Chapter 1), it will start! It won’t <em>do</em> much yet, because we haven’t added any specific capabilities, but it’s a functioning MCP server.</p>

<h2 id="adding-features-with-decorators-the-buttons">Adding Features with Decorators: The “Buttons”</h2>

<p>Our multi-cooker (<code class="language-plaintext highlighter-rouge">FastMCP</code>) is running, but it doesn’t have any cooking programs yet. How do we add features, like our “echo” tool? We use <strong>decorators</strong>.</p>

<p>Decorators in Python are special markers starting with <code class="language-plaintext highlighter-rouge">@</code> that you place above a function definition. They modify or enhance the function in some way. <code class="language-plaintext highlighter-rouge">FastMCP</code> uses decorators like <code class="language-plaintext highlighter-rouge">@server.tool()</code>, <code class="language-plaintext highlighter-rouge">@server.resource()</code>, and <code class="language-plaintext highlighter-rouge">@server.prompt()</code> to easily register your Python functions as capabilities that clients can use.</p>

<p>Let’s add an “echo” tool using the <code class="language-plaintext highlighter-rouge">@server.tool()</code> decorator.</p>

<p><strong>File: <code class="language-plaintext highlighter-rouge">echo_server.py</code> (Simpler Version)</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">mcp.server.fastmcp</span> <span class="kn">import</span> <span class="n">FastMCP</span>

<span class="c1"># 1. Create the server instance
</span><span class="n">server</span> <span class="o">=</span> <span class="n">FastMCP</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"EchoServer"</span><span class="p">)</span>

<span class="c1"># 2. Define the tool using the @server.tool decorator
</span><span class="o">@</span><span class="n">server</span><span class="p">.</span><span class="n">tool</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="s">"echo"</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s">"Repeats the input message back."</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">echo</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
  <span class="s">"""
  This function is now registered as the 'echo' tool.
  'message: str' tells FastMCP the tool expects one argument
  named 'message' which should be a string.
  '-&gt; str' tells FastMCP the tool will return a string.
  """</span>
  <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Tool 'echo' called with message: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s">"</span><span class="p">)</span> <span class="c1"># Server-side log
</span>  <span class="c1"># 3. The function's logic directly implements the tool
</span>  <span class="k">return</span> <span class="sa">f</span><span class="s">"You said: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s">"</span>

<span class="c1"># 4. Standard run block
</span><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Starting </span><span class="si">{</span><span class="n">server</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">..."</span><span class="p">)</span>
    <span class="n">server</span><span class="p">.</span><span class="n">run</span><span class="p">()</span> <span class="c1"># Start listening
</span>    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">server</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s"> finished."</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">server = FastMCP(...)</code></strong>: Same as before, creates our server object.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">@server.tool(...)</code></strong>: This is the magic!
    <ul>
      <li>We use the <code class="language-plaintext highlighter-rouge">@tool()</code> method of our <code class="language-plaintext highlighter-rouge">server</code> object as a decorator.</li>
      <li><code class="language-plaintext highlighter-rouge">name="echo"</code>: We explicitly tell <code class="language-plaintext highlighter-rouge">FastMCP</code> that this tool should be called <code class="language-plaintext highlighter-rouge">echo</code> by clients. If we omitted this, it would default to the function name (<code class="language-plaintext highlighter-rouge">echo</code>).</li>
      <li><code class="language-plaintext highlighter-rouge">description="..."</code>: A helpful description for clients.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">def echo(message: str) -&gt; str:</code></strong>: This is a standard Python function.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">message: str</code>: This is a <strong>type hint</strong>. It tells <code class="language-plaintext highlighter-rouge">FastMCP</code> (and other tools) that this function expects one argument named <code class="language-plaintext highlighter-rouge">message</code>, and that argument should be a string. <code class="language-plaintext highlighter-rouge">FastMCP</code> uses this information to automatically validate input from clients and generate documentation.</li>
      <li><code class="language-plaintext highlighter-rouge">-&gt; str</code>: This type hint indicates that the function will return a string. <code class="language-plaintext highlighter-rouge">FastMCP</code> uses this to know what kind of output to expect.</li>
      <li>The function body contains the logic for our tool.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">server.run()</code></strong>: Starts the server, which now knows about the <code class="language-plaintext highlighter-rouge">echo</code> tool thanks to the decorator.</li>
</ol>

<p>Now, if you run <code class="language-plaintext highlighter-rouge">mcp run echo_server.py</code>, the server will start and will be capable of responding to requests for the <code class="language-plaintext highlighter-rouge">echo</code> tool! A client could send a “callTool” request with the name “echo” and an argument <code class="language-plaintext highlighter-rouge">{"message": "Hello!"}</code>, and <code class="language-plaintext highlighter-rouge">FastMCP</code> would automatically run your <code class="language-plaintext highlighter-rouge">echo</code> function and send back the result <code class="language-plaintext highlighter-rouge">"You said: Hello!"</code>.</p>

<p>We’ll explore <code class="language-plaintext highlighter-rouge">@server.resource()</code> and <code class="language-plaintext highlighter-rouge">@server.prompt()</code> in later chapters:</p>
<ul>
  <li><a href="03_fastmcp_resources___resource____resourcemanager__.md">Chapter 3: FastMCP Resources (<code class="language-plaintext highlighter-rouge">Resource</code>, <code class="language-plaintext highlighter-rouge">ResourceManager</code>)</a></li>
  <li><a href="05_fastmcp_prompts___prompt____promptmanager__.md">Chapter 5: FastMCP Prompts (<code class="language-plaintext highlighter-rouge">Prompt</code>, <code class="language-plaintext highlighter-rouge">PromptManager</code>)</a></li>
</ul>

<h2 id="how-fastmcp-works-under-the-hood-simplified">How <code class="language-plaintext highlighter-rouge">FastMCP</code> Works Under the Hood (Simplified)</h2>

<p>It feels simple to use, but what’s <code class="language-plaintext highlighter-rouge">FastMCP</code> actually doing?</p>

<ol>
  <li><strong>Initialization:</strong> When you create <code class="language-plaintext highlighter-rouge">FastMCP()</code>, it sets up internal managers for tools, resources, and prompts (like <code class="language-plaintext highlighter-rouge">_tool_manager</code>, <code class="language-plaintext highlighter-rouge">_resource_manager</code>, <code class="language-plaintext highlighter-rouge">_prompt_manager</code>).</li>
  <li><strong>Registration:</strong> When Python encounters <code class="language-plaintext highlighter-rouge">@server.tool(...)</code> above your <code class="language-plaintext highlighter-rouge">echo</code> function, it calls the <code class="language-plaintext highlighter-rouge">server.tool()</code> method. This method takes your <code class="language-plaintext highlighter-rouge">echo</code> function and its details (name, description, parameter types from hints) and registers it with the internal <code class="language-plaintext highlighter-rouge">_tool_manager</code>.</li>
  <li><strong>Running:</strong> When you call <code class="language-plaintext highlighter-rouge">server.run()</code>, <code class="language-plaintext highlighter-rouge">FastMCP</code> starts the underlying low-level MCP server machinery. This machinery listens for incoming connections (e.g., via stdio or web protocols).</li>
  <li><strong>Handling Requests:</strong> When a client connects and sends an MCP message like <code class="language-plaintext highlighter-rouge">{"method": "callTool", "params": {"name": "echo", "arguments": {"message": "Test"}}}</code>:
    <ul>
      <li>The low-level server receives the raw message.</li>
      <li><code class="language-plaintext highlighter-rouge">FastMCP</code>’s core logic takes over. It sees it’s a <code class="language-plaintext highlighter-rouge">callTool</code> request for the tool named <code class="language-plaintext highlighter-rouge">echo</code>.</li>
      <li>It asks its <code class="language-plaintext highlighter-rouge">_tool_manager</code> if it knows about a tool named <code class="language-plaintext highlighter-rouge">echo</code>.</li>
      <li>The <code class="language-plaintext highlighter-rouge">_tool_manager</code> finds the registered <code class="language-plaintext highlighter-rouge">echo</code> function.</li>
      <li><code class="language-plaintext highlighter-rouge">FastMCP</code> extracts the <code class="language-plaintext highlighter-rouge">arguments</code> (<code class="language-plaintext highlighter-rouge">{"message": "Test"}</code>) from the request.</li>
      <li>It validates these arguments against the function’s signature (<code class="language-plaintext highlighter-rouge">message: str</code>).</li>
      <li>It calls your actual Python <code class="language-plaintext highlighter-rouge">echo</code> function, passing <code class="language-plaintext highlighter-rouge">"Test"</code> as the <code class="language-plaintext highlighter-rouge">message</code> argument.</li>
      <li>Your function runs and returns <code class="language-plaintext highlighter-rouge">"You said: Test"</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">FastMCP</code> takes this return value, packages it into a valid MCP <code class="language-plaintext highlighter-rouge">callTool</code> response message, and sends it back to the client via the low-level machinery.</li>
    </ul>
  </li>
</ol>

<p><strong>Sequence Diagram:</strong></p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Client
    participant FastMCP_Server as FastMCP (echo_server.py)
    participant ToolManager as _tool_manager
    participant EchoFunction as echo()

    Client-&gt;&gt;+FastMCP_Server: Send MCP Request: callTool(name="echo", args={"message": "Test"})
    FastMCP_Server-&gt;&gt;+ToolManager: Find tool named "echo"
    ToolManager--&gt;&gt;-FastMCP_Server: Return registered 'echo' function info
    FastMCP_Server-&gt;&gt;+EchoFunction: Call echo(message="Test")
    EchoFunction--&gt;&gt;-FastMCP_Server: Return "You said: Test"
    FastMCP_Server-&gt;&gt;-Client: Send MCP Response: result="You said: Test"
</code></pre>

<p><strong>Looking at the Code (Briefly):</strong></p>

<p>You don’t need to understand every line, but seeing where things happen can be helpful.</p>

<p><strong>Inside <code class="language-plaintext highlighter-rouge">server/fastmcp/server.py</code> (Simplified <code class="language-plaintext highlighter-rouge">FastMCP.__init__</code>):</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># (...) imports (...)
</span><span class="kn">from</span> <span class="nn">.tools</span> <span class="kn">import</span> <span class="n">ToolManager</span>
<span class="kn">from</span> <span class="nn">.resources</span> <span class="kn">import</span> <span class="n">ResourceManager</span>
<span class="kn">from</span> <span class="nn">.prompts</span> <span class="kn">import</span> <span class="n">PromptManager</span>

<span class="k">class</span> <span class="nc">FastMCP</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">instructions</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">settings</span><span class="p">:</span> <span class="n">Any</span>
    <span class="p">):</span>
        <span class="c1"># Stores settings like debug mode, log level etc.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">Settings</span><span class="p">(</span><span class="o">**</span><span class="n">settings</span><span class="p">)</span>

        <span class="c1"># Creates the underlying low-level MCP server
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_mcp_server</span> <span class="o">=</span> <span class="n">MCPServer</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span> <span class="ow">or</span> <span class="s">"FastMCP"</span><span class="p">,</span>
            <span class="n">instructions</span><span class="o">=</span><span class="n">instructions</span><span class="p">,</span>
            <span class="c1"># ... other low-level setup ...
</span>        <span class="p">)</span>
        <span class="c1"># Creates the managers to keep track of registered items
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_tool_manager</span> <span class="o">=</span> <span class="n">ToolManager</span><span class="p">(</span>
            <span class="n">warn_on_duplicate_tools</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">settings</span><span class="p">.</span><span class="n">warn_on_duplicate_tools</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_resource_manager</span> <span class="o">=</span> <span class="n">ResourceManager</span><span class="p">(</span>
            <span class="c1"># ...
</span>        <span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_prompt_manager</span> <span class="o">=</span> <span class="n">PromptManager</span><span class="p">(</span>
            <span class="c1"># ...
</span>        <span class="p">)</span>

        <span class="c1"># Connects MCP requests (like 'callTool') to FastMCP methods
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_setup_handlers</span><span class="p">()</span>
        <span class="c1"># (...)
</span></code></pre></div></div>

<p>This shows that <code class="language-plaintext highlighter-rouge">FastMCP</code> creates helper objects (<code class="language-plaintext highlighter-rouge">_tool_manager</code>, etc.) to organize the tools, resources, and prompts you register.</p>

<p><strong>Inside <code class="language-plaintext highlighter-rouge">server/fastmcp/server.py</code> (Simplified <code class="language-plaintext highlighter-rouge">FastMCP.tool</code> decorator):</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># (...) imports (...)
</span><span class="kn">from</span> <span class="nn">mcp.types</span> <span class="kn">import</span> <span class="n">AnyFunction</span> <span class="c1"># Represents any kind of Python function
</span>
<span class="k">class</span> <span class="nc">FastMCP</span><span class="p">:</span>
    <span class="c1"># (...) other methods (...)
</span>
    <span class="k">def</span> <span class="nf">tool</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">AnyFunction</span><span class="p">],</span> <span class="n">AnyFunction</span><span class="p">]:</span>
        <span class="s">"""Decorator to register a tool."""</span>
        <span class="c1"># (...) error checking (...)
</span>
        <span class="c1"># This is the actual function that gets applied to your 'echo' function
</span>        <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">fn</span><span class="p">:</span> <span class="n">AnyFunction</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyFunction</span><span class="p">:</span>
            <span class="c1"># Tells the tool manager to remember this function 'fn'
</span>            <span class="c1"># associating it with the given name and description.
</span>            <span class="c1"># It also inspects 'fn' to figure out its parameters (like 'message: str')
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">add_tool</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fn</span> <span class="c1"># Returns the original function unchanged
</span>
        <span class="k">return</span> <span class="n">decorator</span> <span class="c1"># Returns the 'decorator' function
</span>
    <span class="k">def</span> <span class="nf">add_tool</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">fn</span><span class="p">:</span> <span class="n">AnyFunction</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
        <span class="n">description</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="bp">None</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""Add a tool to the server."""</span>
        <span class="c1"># This passes the function and its info to the ToolManager
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_tool_manager</span><span class="p">.</span><span class="n">add_tool</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">)</span>

</code></pre></div></div>

<p>This shows how the <code class="language-plaintext highlighter-rouge">@server.tool()</code> decorator ultimately calls <code class="language-plaintext highlighter-rouge">self._tool_manager.add_tool()</code> to register your function.</p>

<p><strong>Inside <code class="language-plaintext highlighter-rouge">server/fastmcp/server.py</code> (Simplified <code class="language-plaintext highlighter-rouge">FastMCP.call_tool</code> handler):</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># (...) imports (...)
</span>
<span class="k">class</span> <span class="nc">FastMCP</span><span class="p">:</span>
    <span class="c1"># (...) other methods (...)
</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">call_tool</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">arguments</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">TextContent</span> <span class="o">|</span> <span class="n">ImageContent</span> <span class="o">|</span> <span class="n">EmbeddedResource</span><span class="p">]:</span>
        <span class="s">"""Call a tool by name with arguments."""</span>
        <span class="c1"># Gets a 'Context' object (more on this later!)
</span>        <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_context</span><span class="p">()</span>
        <span class="c1"># Asks the ToolManager to find and execute the tool
</span>        <span class="c1"># The ToolManager handles finding your 'echo' function,
</span>        <span class="c1"># validating arguments, and calling it.
</span>        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">_tool_manager</span><span class="p">.</span><span class="n">call_tool</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">arguments</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
        <span class="c1"># Converts the function's return value (e.g., "You said: Test")
</span>        <span class="c1"># into the format MCP expects for the response.
</span>        <span class="n">converted_result</span> <span class="o">=</span> <span class="n">_convert_to_content</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">converted_result</span>

    <span class="k">def</span> <span class="nf">_setup_handlers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="s">"""Set up core MCP protocol handlers."""</span>
        <span class="c1"># This line connects the low-level 'callTool' message
</span>        <span class="c1"># to the 'self.call_tool' method shown above.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_mcp_server</span><span class="p">.</span><span class="n">call_tool</span><span class="p">()(</span><span class="bp">self</span><span class="p">.</span><span class="n">call_tool</span><span class="p">)</span>
        <span class="c1"># (...) other handlers for listTools, readResource etc. (...)
</span></code></pre></div></div>

<p>This shows how an incoming <code class="language-plaintext highlighter-rouge">callTool</code> message gets routed to the <code class="language-plaintext highlighter-rouge">call_tool</code> method, which then uses the <code class="language-plaintext highlighter-rouge">_tool_manager</code> to run your registered function.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve now seen how <code class="language-plaintext highlighter-rouge">FastMCP</code> provides a much simpler way to build MCP servers compared to handling the low-level protocol directly. Like a multi-cooker, it offers convenient “buttons” (decorators like <code class="language-plaintext highlighter-rouge">@server.tool()</code>) to add features (like tools) to your server using standard Python functions. It handles the underlying complexity of receiving requests, calling your code, and sending responses.</p>

<p>You learned how to:</p>
<ul>
  <li>Create a basic <code class="language-plaintext highlighter-rouge">FastMCP</code> server instance.</li>
  <li>Define a Python function that performs a task.</li>
  <li>Use the <code class="language-plaintext highlighter-rouge">@server.tool()</code> decorator to register that function as a tool clients can call.</li>
  <li>Understand the basic flow of how <code class="language-plaintext highlighter-rouge">FastMCP</code> handles a tool call request using its internal managers.</li>
</ul>

<p>While our <code class="language-plaintext highlighter-rouge">echo</code> tool was simple, <code class="language-plaintext highlighter-rouge">FastMCP</code> provides the foundation for building much more complex and powerful AI agents and tools.</p>

<p>In the next chapters, we’ll explore the other “buttons” on our multi-cooker, starting with how to provide data and files using <code class="language-plaintext highlighter-rouge">@server.resource()</code> in <a href="03_fastmcp_resources___resource____resourcemanager__.md">Chapter 3: FastMCP Resources (<code class="language-plaintext highlighter-rouge">Resource</code>, <code class="language-plaintext highlighter-rouge">ResourceManager</code>)</a>.</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
