<h1 id="chapter-4-tool---giving-agents-specific-capabilities">Chapter 4: Tool - Giving Agents Specific Capabilities</h1>

<p>In the previous chapters, we learned about Agents as workers (<a href="01_agent.md">Chapter 1</a>), how they can communicate directly or using announcements (<a href="02_messaging_system__topic___subscription_.md">Chapter 2</a>), and the <code class="language-plaintext highlighter-rouge">AgentRuntime</code> that manages them (<a href="03_agentruntime.md">Chapter 3</a>).</p>

<p>Agents can process messages and coordinate, but what if an agent needs to perform a very specific action, like looking up information online, running a piece of code, accessing a database, or even just finding out the current date? They need specialized <em>capabilities</em>.</p>

<p>This is where the concept of a <strong>Tool</strong> comes in.</p>

<h2 id="motivation-agents-need-skills">Motivation: Agents Need Skills!</h2>

<p>Imagine our <code class="language-plaintext highlighter-rouge">Writer</code> agent from before. It receives facts and writes a draft. Now, let’s say we want the <code class="language-plaintext highlighter-rouge">Writer</code> (or perhaps a smarter <code class="language-plaintext highlighter-rouge">Assistant</code> agent helping it) to always include the current date in the blog post title.</p>

<p>How does the agent get the current date? It doesn’t inherently know it. It needs a specific <em>skill</em> or <em>tool</em> for that.</p>

<p>A <code class="language-plaintext highlighter-rouge">Tool</code> in AutoGen Core represents exactly this: a specific, well-defined capability that an Agent can use. Think of it like giving an employee (Agent) a specialized piece of equipment (Tool), like a calculator, a web browser, or a calendar lookup program.</p>

<h2 id="key-concepts-understanding-tools">Key Concepts: Understanding Tools</h2>

<p>Let’s break down what defines a Tool:</p>

<ol>
  <li><strong>It’s a Specific Capability:</strong> A Tool performs one well-defined task. Examples:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">search_web(query: str)</code></li>
      <li><code class="language-plaintext highlighter-rouge">run_python_code(code: str)</code></li>
      <li><code class="language-plaintext highlighter-rouge">get_stock_price(ticker: str)</code></li>
      <li><code class="language-plaintext highlighter-rouge">get_current_date()</code></li>
    </ul>
  </li>
  <li><strong>It Has a Schema (The Manual):</strong> This is crucial! For an Agent (especially one powered by a Large Language Model - LLM) to know <em>when</em> and <em>how</em> to use a tool, the tool needs a clear description or “manual”. This is called the <code class="language-plaintext highlighter-rouge">ToolSchema</code>. It typically includes:
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">name</code></strong>: A unique identifier for the tool (e.g., <code class="language-plaintext highlighter-rouge">get_current_date</code>).</li>
      <li><strong><code class="language-plaintext highlighter-rouge">description</code></strong>: A clear explanation of what the tool does, which helps the LLM decide if this tool is appropriate for the current task (e.g., “Fetches the current date in YYYY-MM-DD format”).</li>
      <li><strong><code class="language-plaintext highlighter-rouge">parameters</code></strong>: Defines what inputs the tool needs. This is itself a schema (<code class="language-plaintext highlighter-rouge">ParametersSchema</code>) describing the input fields, their types, and which ones are required. For our <code class="language-plaintext highlighter-rouge">get_current_date</code> example, it might need no parameters. For <code class="language-plaintext highlighter-rouge">get_stock_price</code>, it would need a <code class="language-plaintext highlighter-rouge">ticker</code> parameter of type string.</li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># From: tools/_base.py (Simplified Concept)
</span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">TypedDict</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">NotRequired</span>

<span class="k">class</span> <span class="nc">ParametersSchema</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span> <span class="c1"># Usually "object"
</span>    <span class="n">properties</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="c1"># Defines input fields and their types
</span>    <span class="n">required</span><span class="p">:</span> <span class="n">NotRequired</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="c1"># List of required field names
</span>
<span class="k">class</span> <span class="nc">ToolSchema</span><span class="p">(</span><span class="n">TypedDict</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">description</span><span class="p">:</span> <span class="n">NotRequired</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="n">parameters</span><span class="p">:</span> <span class="n">NotRequired</span><span class="p">[</span><span class="n">ParametersSchema</span><span class="p">]</span>
    <span class="c1"># 'strict' flag also possible (Chapter 5 related)
</span></code></pre></div>    </div>
    <p>This schema allows an LLM to understand: “Ah, there’s a tool called <code class="language-plaintext highlighter-rouge">get_current_date</code> that takes no inputs and gives me the current date. I should use that now!”</p>
  </li>
  <li><strong>It Can Be Executed:</strong> Once an agent decides to use a tool (often based on the schema), there needs to be a mechanism to actually <em>run</em> the tool’s underlying function and get the result.</li>
</ol>

<h2 id="use-case-example-adding-a-get_current_date-tool">Use Case Example: Adding a <code class="language-plaintext highlighter-rouge">get_current_date</code> Tool</h2>

<p>Let’s equip an agent with the ability to find the current date.</p>

<p><strong>Goal:</strong> Define a tool that gets the current date and show how it could be executed by a specialized agent.</p>

<p><strong>Step 1: Define the Python Function</strong></p>

<p>First, we need the actual Python code that performs the action.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File: get_date_function.py
</span><span class="kn">import</span> <span class="nn">datetime</span>

<span class="k">def</span> <span class="nf">get_current_date</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
    <span class="s">"""Fetches the current date as a string."""</span>
    <span class="n">today</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">date</span><span class="p">.</span><span class="n">today</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">today</span><span class="p">.</span><span class="n">isoformat</span><span class="p">()</span> <span class="c1"># Returns date like "2023-10-27"
</span>
<span class="c1"># Test the function
</span><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Function output: </span><span class="si">{</span><span class="n">get_current_date</span><span class="p">()</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>
<p>This is a standard Python function. It takes no arguments and returns the date as a string.</p>

<p><strong>Step 2: Wrap it as a <code class="language-plaintext highlighter-rouge">FunctionTool</code></strong></p>

<p>AutoGen Core provides a convenient way to turn a Python function like this into a <code class="language-plaintext highlighter-rouge">Tool</code> object using <code class="language-plaintext highlighter-rouge">FunctionTool</code>. It automatically inspects the function’s signature (arguments and return type) and docstring to help build the <code class="language-plaintext highlighter-rouge">ToolSchema</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File: create_date_tool.py
</span><span class="kn">from</span> <span class="nn">autogen_core.tools</span> <span class="kn">import</span> <span class="n">FunctionTool</span>
<span class="kn">from</span> <span class="nn">get_date_function</span> <span class="kn">import</span> <span class="n">get_current_date</span> <span class="c1"># Import our function
</span>
<span class="c1"># Create the Tool instance
# We provide the function and a clear description for the LLM
</span><span class="n">date_tool</span> <span class="o">=</span> <span class="n">FunctionTool</span><span class="p">(</span>
    <span class="n">func</span><span class="o">=</span><span class="n">get_current_date</span><span class="p">,</span>
    <span class="n">description</span><span class="o">=</span><span class="s">"Use this tool to get the current date in YYYY-MM-DD format."</span>
    <span class="c1"># Name defaults to function name 'get_current_date'
</span><span class="p">)</span>

<span class="c1"># Let's see what FunctionTool generated
</span><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Tool Name: </span><span class="si">{</span><span class="n">date_tool</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Tool Description: </span><span class="si">{</span><span class="n">date_tool</span><span class="p">.</span><span class="n">description</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># The schema defines inputs (none in this case)
# print(f"Tool Schema Parameters: {date_tool.schema['parameters']}")
# Output (simplified): {'type': 'object', 'properties': {}, 'required': []}
</span></code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">FunctionTool</code> wraps our <code class="language-plaintext highlighter-rouge">get_current_date</code> function. It uses the function name as the tool name and the description we provided. It also correctly determines from the function signature that there are no input parameters (<code class="language-plaintext highlighter-rouge">properties: {}</code>).</p>

<p><strong>Step 3: How an Agent Might Request Tool Use</strong></p>

<p>Now we have a <code class="language-plaintext highlighter-rouge">date_tool</code>. How is it used? Typically, an LLM-powered agent (which we’ll see more of in <a href="05_chatcompletionclient.md">Chapter 5: ChatCompletionClient</a>) analyzes a request and decides a tool is needed. It then generates a request to <em>call</em> that tool, often using a specific message type like <code class="language-plaintext highlighter-rouge">FunctionCall</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File: tool_call_request.py
</span><span class="kn">from</span> <span class="nn">autogen_core</span> <span class="kn">import</span> <span class="n">FunctionCall</span> <span class="c1"># Represents a request to call a tool
</span>
<span class="c1"># Imagine an LLM agent decided to use the date tool.
# It constructs this message, providing the tool name and arguments (as JSON string).
</span><span class="n">date_call_request</span> <span class="o">=</span> <span class="n">FunctionCall</span><span class="p">(</span>
    <span class="nb">id</span><span class="o">=</span><span class="s">"call_date_001"</span><span class="p">,</span> <span class="c1"># A unique ID for this specific call attempt
</span>    <span class="n">name</span><span class="o">=</span><span class="s">"get_current_date"</span><span class="p">,</span> <span class="c1"># Matches the Tool's name
</span>    <span class="n">arguments</span><span class="o">=</span><span class="s">"{}"</span> <span class="c1"># An empty JSON object because no arguments are needed
</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"FunctionCall message:"</span><span class="p">,</span> <span class="n">date_call_request</span><span class="p">)</span>
<span class="c1"># Output: FunctionCall(id='call_date_001', name='get_current_date', arguments='{}')
</span></code></pre></div></div>
<p>This <code class="language-plaintext highlighter-rouge">FunctionCall</code> message is like a work order: “Please execute the tool named <code class="language-plaintext highlighter-rouge">get_current_date</code> with these arguments.”</p>

<p><strong>Step 4: The <code class="language-plaintext highlighter-rouge">ToolAgent</code> Executes the Tool</strong></p>

<p>Who receives this <code class="language-plaintext highlighter-rouge">FunctionCall</code> message? Usually, a specialized agent called <code class="language-plaintext highlighter-rouge">ToolAgent</code>. You create a <code class="language-plaintext highlighter-rouge">ToolAgent</code> and give it the list of tools it knows how to execute. When it receives a <code class="language-plaintext highlighter-rouge">FunctionCall</code>, it finds the matching tool and runs it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File: tool_agent_example.py
</span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">autogen_core.tool_agent</span> <span class="kn">import</span> <span class="n">ToolAgent</span>
<span class="kn">from</span> <span class="nn">autogen_core.models</span> <span class="kn">import</span> <span class="n">FunctionExecutionResult</span>
<span class="kn">from</span> <span class="nn">create_date_tool</span> <span class="kn">import</span> <span class="n">date_tool</span> <span class="c1"># Import the tool we created
</span><span class="kn">from</span> <span class="nn">tool_call_request</span> <span class="kn">import</span> <span class="n">date_call_request</span> <span class="c1"># Import the request message
</span>
<span class="c1"># Create an agent specifically designed to execute tools
</span><span class="n">tool_executor</span> <span class="o">=</span> <span class="n">ToolAgent</span><span class="p">(</span>
    <span class="n">description</span><span class="o">=</span><span class="s">"I can execute tools like getting the date."</span><span class="p">,</span>
    <span class="n">tools</span><span class="o">=</span><span class="p">[</span><span class="n">date_tool</span><span class="p">]</span> <span class="c1"># Give it the list of tools it manages
</span><span class="p">)</span>

<span class="c1"># --- Simulation of Runtime delivering the message ---
# In a real app, the AgentRuntime (Chapter 3) would route the
# date_call_request message to this tool_executor agent.
# We simulate the call to its message handler here:
</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">simulate_execution</span><span class="p">():</span>
    <span class="c1"># Fake context (normally provided by runtime)
</span>    <span class="k">class</span> <span class="nc">MockContext</span><span class="p">:</span> <span class="n">cancellation_token</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">ctx</span> <span class="o">=</span> <span class="n">MockContext</span><span class="p">()</span>

    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"ToolAgent received request: </span><span class="si">{</span><span class="n">date_call_request</span><span class="p">.</span><span class="n">name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="n">result</span><span class="p">:</span> <span class="n">FunctionExecutionResult</span> <span class="o">=</span> <span class="k">await</span> <span class="n">tool_executor</span><span class="p">.</span><span class="n">handle_function_call</span><span class="p">(</span>
        <span class="n">message</span><span class="o">=</span><span class="n">date_call_request</span><span class="p">,</span>
        <span class="n">ctx</span><span class="o">=</span><span class="n">ctx</span>
    <span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"ToolAgent produced result: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">simulate_execution</span><span class="p">())</span>
</code></pre></div></div>

<p><strong>Expected Output:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ToolAgent received request: get_current_date
ToolAgent produced result: FunctionExecutionResult(content='2023-10-27', call_id='call_date_001', is_error=False, name='get_current_date') # Date will be current date
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">ToolAgent</code> received the <code class="language-plaintext highlighter-rouge">FunctionCall</code>, found the <code class="language-plaintext highlighter-rouge">date_tool</code> in its list, executed the underlying <code class="language-plaintext highlighter-rouge">get_current_date</code> function, and packaged the result (the date string) into a <code class="language-plaintext highlighter-rouge">FunctionExecutionResult</code> message. This result message can then be sent back to the agent that originally requested the tool use.</p>

<h2 id="under-the-hood-how-tool-execution-works">Under the Hood: How Tool Execution Works</h2>

<p>Let’s visualize the typical flow when an LLM agent decides to use a tool managed by a <code class="language-plaintext highlighter-rouge">ToolAgent</code>.</p>

<p><strong>Conceptual Flow:</strong></p>

<pre><code class="language-mermaid">sequenceDiagram
    participant LLMA as LLM Agent (Decides)
    participant Caller as Caller Agent (Orchestrates)
    participant ToolA as ToolAgent (Executes)
    participant ToolFunc as Tool Function (e.g., get_current_date)

    Note over LLMA: Analyzes conversation, decides tool needed.
    LLMA-&gt;&gt;Caller: Sends AssistantMessage containing FunctionCall(name='get_current_date', args='{}')
    Note over Caller: Receives LLM response, sees FunctionCall.
    Caller-&gt;&gt;+ToolA: Uses runtime.send_message(message=FunctionCall, recipient=ToolAgent_ID)
    Note over ToolA: Receives FunctionCall via on_message.
    ToolA-&gt;&gt;ToolA: Looks up 'get_current_date' in its internal list of Tools.
    ToolA-&gt;&gt;+ToolFunc: Calls tool.run_json(args={}) -&gt; triggers get_current_date()
    ToolFunc--&gt;&gt;-ToolA: Returns the result (e.g., "2023-10-27")
    ToolA-&gt;&gt;ToolA: Creates FunctionExecutionResult message with the content.
    ToolA--&gt;&gt;-Caller: Returns FunctionExecutionResult via runtime messaging.
    Note over Caller: Receives the tool result.
    Caller-&gt;&gt;LLMA: Sends FunctionExecutionResultMessage to LLM for next step.
    Note over LLMA: Now knows the current date.
</code></pre>

<ol>
  <li><strong>Decision:</strong> An LLM-powered agent decides a tool is needed based on the conversation and the available tools’ descriptions. It generates a <code class="language-plaintext highlighter-rouge">FunctionCall</code>.</li>
  <li><strong>Request:</strong> A “Caller” agent (often the same LLM agent or a managing agent) sends this <code class="language-plaintext highlighter-rouge">FunctionCall</code> message to the dedicated <code class="language-plaintext highlighter-rouge">ToolAgent</code> using the <code class="language-plaintext highlighter-rouge">AgentRuntime</code>.</li>
  <li><strong>Lookup:</strong> The <code class="language-plaintext highlighter-rouge">ToolAgent</code> receives the message, extracts the tool <code class="language-plaintext highlighter-rouge">name</code> (<code class="language-plaintext highlighter-rouge">get_current_date</code>), and finds the corresponding <code class="language-plaintext highlighter-rouge">Tool</code> object (our <code class="language-plaintext highlighter-rouge">date_tool</code>) in the list it was configured with.</li>
  <li><strong>Execution:</strong> The <code class="language-plaintext highlighter-rouge">ToolAgent</code> calls the <code class="language-plaintext highlighter-rouge">run_json</code> method on the <code class="language-plaintext highlighter-rouge">Tool</code> object, passing the arguments from the <code class="language-plaintext highlighter-rouge">FunctionCall</code>. For a <code class="language-plaintext highlighter-rouge">FunctionTool</code>, <code class="language-plaintext highlighter-rouge">run_json</code> validates the arguments against the generated schema and then executes the original Python function (<code class="language-plaintext highlighter-rouge">get_current_date</code>).</li>
  <li><strong>Result:</strong> The Python function returns its result (the date string).</li>
  <li><strong>Response:</strong> The <code class="language-plaintext highlighter-rouge">ToolAgent</code> wraps this result string in a <code class="language-plaintext highlighter-rouge">FunctionExecutionResult</code> message, including the original <code class="language-plaintext highlighter-rouge">call_id</code>, and sends it back to the Caller agent.</li>
  <li><strong>Continuation:</strong> The Caller agent typically sends this result back to the LLM agent, allowing the conversation or task to continue with the new information.</li>
</ol>

<p><strong>Code Glimpse:</strong></p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">Tool</code> Protocol (<code class="language-plaintext highlighter-rouge">tools/_base.py</code>):</strong> Defines the basic contract any tool must fulfill. Key methods are <code class="language-plaintext highlighter-rouge">schema</code> (property returning the <code class="language-plaintext highlighter-rouge">ToolSchema</code>) and <code class="language-plaintext highlighter-rouge">run_json</code> (method to execute the tool with JSON-like arguments).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">BaseTool</code> (<code class="language-plaintext highlighter-rouge">tools/_base.py</code>):</strong> An abstract class that helps implement the <code class="language-plaintext highlighter-rouge">Tool</code> protocol, especially using Pydantic models for defining arguments (<code class="language-plaintext highlighter-rouge">args_type</code>) and return values (<code class="language-plaintext highlighter-rouge">return_type</code>). It automatically generates the <code class="language-plaintext highlighter-rouge">parameters</code> part of the schema from the <code class="language-plaintext highlighter-rouge">args_type</code> model.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">FunctionTool</code> (<code class="language-plaintext highlighter-rouge">tools/_function_tool.py</code>):</strong> Inherits from <code class="language-plaintext highlighter-rouge">BaseTool</code>. Its magic lies in automatically creating the <code class="language-plaintext highlighter-rouge">args_type</code> Pydantic model by inspecting the wrapped Python function’s signature (<code class="language-plaintext highlighter-rouge">args_base_model_from_signature</code>). Its <code class="language-plaintext highlighter-rouge">run</code> method handles calling the original sync or async Python function.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Inside FunctionTool (Simplified Concept)
</span><span class="k">class</span> <span class="nc">FunctionTool</span><span class="p">(</span><span class="n">BaseTool</span><span class="p">[</span><span class="n">BaseModel</span><span class="p">,</span> <span class="n">BaseModel</span><span class="p">]):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="p">...):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_signature</span> <span class="o">=</span> <span class="n">get_typed_signature</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="c1"># Automatically create Pydantic model for arguments
</span>        <span class="n">args_model</span> <span class="o">=</span> <span class="n">args_base_model_from_signature</span><span class="p">(...)</span>
        <span class="c1"># Get return type from signature
</span>        <span class="n">return_type</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_signature</span><span class="p">.</span><span class="n">return_annotation</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">(</span><span class="n">args_model</span><span class="p">,</span> <span class="n">return_type</span><span class="p">,</span> <span class="p">...)</span>

    <span class="k">async</span> <span class="k">def</span> <span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">BaseModel</span><span class="p">,</span> <span class="p">...):</span>
        <span class="c1"># Extract arguments from the 'args' model
</span>        <span class="n">kwargs</span> <span class="o">=</span> <span class="n">args</span><span class="p">.</span><span class="n">model_dump</span><span class="p">()</span>
        <span class="c1"># Call the original Python function (sync or async)
</span>        <span class="n">result</span> <span class="o">=</span> <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">_call_underlying_func</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span> <span class="c1"># Must match the expected return_type
</span></code></pre></div>    </div>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">ToolAgent</code> (<code class="language-plaintext highlighter-rouge">tool_agent/_tool_agent.py</code>):</strong> A specialized <code class="language-plaintext highlighter-rouge">RoutedAgent</code>. It registers a handler specifically for <code class="language-plaintext highlighter-rouge">FunctionCall</code> messages.
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Inside ToolAgent (Simplified Concept)
</span><span class="k">class</span> <span class="nc">ToolAgent</span><span class="p">(</span><span class="n">RoutedAgent</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="p">...,</span> <span class="n">tools</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tool</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">(...)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_tools</span> <span class="o">=</span> <span class="p">{</span><span class="n">tool</span><span class="p">.</span><span class="n">name</span><span class="p">:</span> <span class="n">tool</span> <span class="k">for</span> <span class="n">tool</span> <span class="ow">in</span> <span class="n">tools</span><span class="p">}</span> <span class="c1"># Store tools by name
</span>
    <span class="o">@</span><span class="n">message_handler</span> <span class="c1"># Registers this for FunctionCall messages
</span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">handle_function_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">FunctionCall</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">MessageContext</span><span class="p">):</span>
        <span class="c1"># Find the tool by name
</span>        <span class="n">tool</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_tools</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tool</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># Handle error: Tool not found
</span>            <span class="k">raise</span> <span class="n">ToolNotFoundException</span><span class="p">(...)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Parse arguments string into a dictionary
</span>            <span class="n">arguments</span> <span class="o">=</span> <span class="n">json</span><span class="p">.</span><span class="n">loads</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">arguments</span><span class="p">)</span>
            <span class="c1"># Execute the tool's run_json method
</span>            <span class="n">result_obj</span> <span class="o">=</span> <span class="k">await</span> <span class="n">tool</span><span class="p">.</span><span class="n">run_json</span><span class="p">(</span><span class="n">args</span><span class="o">=</span><span class="n">arguments</span><span class="p">,</span> <span class="p">...)</span>
            <span class="c1"># Convert result object back to string if needed
</span>            <span class="n">result_str</span> <span class="o">=</span> <span class="n">tool</span><span class="p">.</span><span class="n">return_value_as_string</span><span class="p">(</span><span class="n">result_obj</span><span class="p">)</span>
            <span class="c1"># Create the success result message
</span>            <span class="k">return</span> <span class="n">FunctionExecutionResult</span><span class="p">(</span><span class="n">content</span><span class="o">=</span><span class="n">result_str</span><span class="p">,</span> <span class="p">...)</span>
        <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Handle execution errors
</span>            <span class="k">return</span> <span class="n">FunctionExecutionResult</span><span class="p">(</span><span class="n">content</span><span class="o">=</span><span class="sa">f</span><span class="s">"Error: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">,</span> <span class="n">is_error</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="p">...)</span>
</code></pre></div>    </div>
    <p>Its core logic is: find tool -&gt; parse args -&gt; run tool -&gt; return result/error.</p>
  </li>
</ul>

<h2 id="next-steps">Next Steps</h2>

<p>You’ve learned how <strong>Tools</strong> provide specific capabilities to Agents, defined by a <strong>Schema</strong> that LLMs can understand. We saw how <code class="language-plaintext highlighter-rouge">FunctionTool</code> makes it easy to wrap existing Python functions and how <code class="language-plaintext highlighter-rouge">ToolAgent</code> acts as the executor for these tools.</p>

<p>This ability for agents to use tools is fundamental to building powerful and versatile AI systems that can interact with the real world or perform complex calculations.</p>

<p>Now that agents can use tools, we need to understand more about the agents that <em>decide</em> which tools to use, which often involves interacting with Large Language Models:</p>

<ul>
  <li><a href="05_chatcompletionclient.md">Chapter 5: ChatCompletionClient</a>: How agents interact with LLMs like GPT to generate responses or decide on actions (like calling a tool).</li>
  <li><a href="06_chatcompletioncontext.md">Chapter 6: ChatCompletionContext</a>: How the history of the conversation, including tool calls and results, is managed when talking to an LLM.</li>
</ul>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
