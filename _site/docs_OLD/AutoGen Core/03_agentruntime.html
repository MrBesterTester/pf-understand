<h1 id="chapter-3-agentruntime---the-office-manager">Chapter 3: AgentRuntime - The Office Manager</h1>

<p>In <a href="01_agent.md">Chapter 1: Agent</a>, we met the workers (<code class="language-plaintext highlighter-rouge">Agent</code>) of our system. In <a href="02_messaging_system__topic___subscription_.md">Chapter 2: Messaging System</a>, we saw how they can communicate broadly using topics and subscriptions. But who hires these agents? Who actually delivers the messages, whether direct or published? And who keeps the whole system running smoothly?</p>

<p>This is where the <strong><code class="language-plaintext highlighter-rouge">AgentRuntime</code></strong> comes in. It’s the central nervous system, the operating system, or perhaps the most fitting analogy: <strong>the office manager</strong> for all your agents.</p>

<h2 id="motivation-why-do-we-need-an-office-manager">Motivation: Why Do We Need an Office Manager?</h2>

<p>Imagine an office full of employees (Agents). You have researchers, writers, maybe coders.</p>
<ul>
  <li>How does a new employee get hired and set up?</li>
  <li>When one employee wants to send a memo directly to another, who makes sure it gets to the right desk?</li>
  <li>When someone posts an announcement on the company bulletin board (publishes to a topic), who ensures everyone who signed up for that type of announcement sees it?</li>
  <li>Who starts the workday and ensures everything keeps running?</li>
</ul>

<p>Without an office manager, it would be chaos! The <code class="language-plaintext highlighter-rouge">AgentRuntime</code> serves this crucial role in AutoGen Core. It handles:</p>

<ol>
  <li><strong>Agent Creation:</strong> “Onboarding” new agents when they are needed.</li>
  <li><strong>Message Routing:</strong> Delivering direct messages (<code class="language-plaintext highlighter-rouge">send_message</code>) and published messages (<code class="language-plaintext highlighter-rouge">publish_message</code>).</li>
  <li><strong>Lifecycle Management:</strong> Starting, running, and stopping the whole system.</li>
  <li><strong>State Management:</strong> Keeping track of the overall system state (optional).</li>
</ol>

<h2 id="key-concepts-understanding-the-managers-job">Key Concepts: Understanding the Manager’s Job</h2>

<p>Let’s break down the main responsibilities of the <code class="language-plaintext highlighter-rouge">AgentRuntime</code>:</p>

<ol>
  <li><strong>Agent Instantiation (Hiring):</strong>
    <ul>
      <li>You don’t usually create agent objects directly (like <code class="language-plaintext highlighter-rouge">my_agent = ResearcherAgent()</code>). Why? Because the agent needs to know <em>about</em> the runtime (the office it works in) to send messages, publish announcements, etc.</li>
      <li>Instead, you tell the <code class="language-plaintext highlighter-rouge">AgentRuntime</code>: “I need an agent of type ‘researcher’. Here’s a recipe (a <strong>factory function</strong>) for how to create one.” This is done using <code class="language-plaintext highlighter-rouge">runtime.register_factory(...)</code>.</li>
      <li>When a message needs to go to a ‘researcher’ agent with a specific key (e.g., ‘researcher-01’), the runtime checks if it already exists. If not, it uses the registered factory function to create (instantiate) the agent.</li>
      <li><strong>Crucially</strong>, while creating the agent, the runtime provides special context (<code class="language-plaintext highlighter-rouge">AgentInstantiationContext</code>) so the new agent automatically gets its unique <code class="language-plaintext highlighter-rouge">AgentId</code> and a reference to the <code class="language-plaintext highlighter-rouge">AgentRuntime</code> itself. This is like giving a new employee their ID badge and telling them who the office manager is.</li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified Concept - How a BaseAgent gets its ID and runtime access
# From: _agent_instantiation.py and _base_agent.py
</span>
<span class="c1"># Inside the agent's __init__ method (when inheriting from BaseAgent):
</span><span class="k">class</span> <span class="nc">MyAgent</span><span class="p">(</span><span class="n">BaseAgent</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">description</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="c1"># This magic happens *because* the AgentRuntime is creating the agent
</span>        <span class="c1"># inside a special context.
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_runtime</span> <span class="o">=</span> <span class="n">AgentInstantiationContext</span><span class="p">.</span><span class="n">current_runtime</span><span class="p">()</span> <span class="c1"># Gets the manager
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_id</span> <span class="o">=</span> <span class="n">AgentInstantiationContext</span><span class="p">.</span><span class="n">current_agent_id</span><span class="p">()</span>     <span class="c1"># Gets its own ID
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">_description</span> <span class="o">=</span> <span class="n">description</span>
        <span class="c1"># ... rest of initialization ...
</span></code></pre></div>    </div>
    <p>This ensures agents are properly integrated into the system from the moment they are created.</p>
  </li>
  <li><strong>Message Delivery (Mail Room):</strong>
    <ul>
      <li><strong>Direct Send (<code class="language-plaintext highlighter-rouge">send_message</code>):</strong> When an agent calls <code class="language-plaintext highlighter-rouge">await agent_context.send_message(message, recipient_id)</code>, it’s actually telling the <code class="language-plaintext highlighter-rouge">AgentRuntime</code>, “Please deliver this <code class="language-plaintext highlighter-rouge">message</code> directly to the agent identified by <code class="language-plaintext highlighter-rouge">recipient_id</code>.” The runtime finds the recipient agent (creating it if necessary) and calls its <code class="language-plaintext highlighter-rouge">on_message</code> method. It’s like putting a specific name on an envelope and handing it to the mail room.</li>
      <li><strong>Publish (<code class="language-plaintext highlighter-rouge">publish_message</code>):</strong> When an agent calls <code class="language-plaintext highlighter-rouge">await agent_context.publish_message(message, topic_id)</code>, it tells the runtime, “Post this <code class="language-plaintext highlighter-rouge">message</code> to the announcement board named <code class="language-plaintext highlighter-rouge">topic_id</code>.” The runtime then checks its list of <strong>subscriptions</strong> (who signed up for which boards). For every matching subscription, it figures out the correct recipient agent(s) (based on the subscription rule) and delivers the message to their <code class="language-plaintext highlighter-rouge">on_message</code> method.</li>
    </ul>
  </li>
  <li><strong>Lifecycle Management (Opening/Closing the Office):</strong>
    <ul>
      <li>The runtime needs to be started to begin processing messages. Typically, you call <code class="language-plaintext highlighter-rouge">runtime.start()</code>. This usually kicks off a background process or loop that watches for incoming messages.</li>
      <li>When work is done, you need to stop the runtime gracefully. <code class="language-plaintext highlighter-rouge">runtime.stop_when_idle()</code> is common – it waits until all messages currently in the queue have been processed, then stops. <code class="language-plaintext highlighter-rouge">runtime.stop()</code> stops more abruptly.</li>
    </ul>
  </li>
  <li><strong>State Management (Office Records):</strong>
    <ul>
      <li>The runtime can save the state of <em>all</em> the agents it manages (<code class="language-plaintext highlighter-rouge">runtime.save_state()</code>) and load it back later (<code class="language-plaintext highlighter-rouge">runtime.load_state()</code>). This is useful for pausing and resuming complex multi-agent interactions. It can also save/load state for individual agents (<code class="language-plaintext highlighter-rouge">runtime.agent_save_state()</code> / <code class="language-plaintext highlighter-rouge">runtime.agent_load_state()</code>). We’ll touch more on state in <a href="07_memory.md">Chapter 7: Memory</a>.</li>
    </ul>
  </li>
</ol>

<h2 id="use-case-example-running-our-researcher-and-writer">Use Case Example: Running Our Researcher and Writer</h2>

<p>Let’s finally run the Researcher/Writer scenario from Chapters 1 and 2. We need the <code class="language-plaintext highlighter-rouge">AgentRuntime</code> to make it happen.</p>

<p><strong>Goal:</strong></p>
<ol>
  <li>Create a runtime.</li>
  <li>Register factories for a ‘researcher’ and a ‘writer’ agent.</li>
  <li>Tell the runtime that ‘writer’ agents are interested in “research.facts.available” topics (add subscription).</li>
  <li>Start the runtime.</li>
  <li>Send an initial <code class="language-plaintext highlighter-rouge">ResearchTopic</code> message to a ‘researcher’ agent.</li>
  <li>Let the system run (Researcher publishes facts, Runtime delivers to Writer via subscription, Writer processes).</li>
  <li>Stop the runtime when idle.</li>
</ol>

<p><strong>Code Snippets (Simplified):</strong></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 0. Imports and Message Definitions (from previous chapters)
</span><span class="kn">import</span> <span class="nn">asyncio</span>
<span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span> <span class="nn">autogen_core</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">AgentId</span><span class="p">,</span> <span class="n">BaseAgent</span><span class="p">,</span> <span class="n">SingleThreadedAgentRuntime</span><span class="p">,</span> <span class="n">TopicId</span><span class="p">,</span>
    <span class="n">MessageContext</span><span class="p">,</span> <span class="n">TypeSubscription</span><span class="p">,</span> <span class="n">AgentInstantiationContext</span>
<span class="p">)</span>

<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">ResearchTopic</span><span class="p">:</span> <span class="n">topic</span><span class="p">:</span> <span class="nb">str</span>
<span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">ResearchFacts</span><span class="p">:</span> <span class="n">topic</span><span class="p">:</span> <span class="nb">str</span><span class="p">;</span> <span class="n">facts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
</code></pre></div></div>
<p>These are the messages our agents will exchange.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 1. Define Agent Logic (using BaseAgent)
</span>
<span class="k">class</span> <span class="nc">ResearcherAgent</span><span class="p">(</span><span class="n">BaseAgent</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_message_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">ResearchTopic</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">MessageContext</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Researcher (</span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="s">) got topic: </span><span class="si">{</span><span class="n">message</span><span class="p">.</span><span class="n">topic</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="n">facts</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s">"Fact 1 about </span><span class="si">{</span><span class="n">message</span><span class="p">.</span><span class="n">topic</span><span class="si">}</span><span class="s">"</span><span class="p">,</span> <span class="sa">f</span><span class="s">"Fact 2"</span><span class="p">]</span>
        <span class="n">results_topic</span> <span class="o">=</span> <span class="n">TopicId</span><span class="p">(</span><span class="s">"research.facts.available"</span><span class="p">,</span> <span class="n">message</span><span class="p">.</span><span class="n">topic</span><span class="p">)</span>
        <span class="c1"># Use the runtime (via self.publish_message helper) to publish
</span>        <span class="k">await</span> <span class="bp">self</span><span class="p">.</span><span class="n">publish_message</span><span class="p">(</span>
            <span class="n">ResearchFacts</span><span class="p">(</span><span class="n">topic</span><span class="o">=</span><span class="n">message</span><span class="p">.</span><span class="n">topic</span><span class="p">,</span> <span class="n">facts</span><span class="o">=</span><span class="n">facts</span><span class="p">),</span> <span class="n">results_topic</span>
        <span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Researcher (</span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="s">) published facts to </span><span class="si">{</span><span class="n">results_topic</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">WriterAgent</span><span class="p">(</span><span class="n">BaseAgent</span><span class="p">):</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_message_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">ResearchFacts</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="n">MessageContext</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Writer (</span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="s">) received facts via topic '</span><span class="si">{</span><span class="n">ctx</span><span class="p">.</span><span class="n">topic_id</span><span class="si">}</span><span class="s">': </span><span class="si">{</span><span class="n">message</span><span class="p">.</span><span class="n">facts</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="n">draft</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"Draft for </span><span class="si">{</span><span class="n">message</span><span class="p">.</span><span class="n">topic</span><span class="si">}</span><span class="s">: </span><span class="si">{</span><span class="s">'; '</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">message</span><span class="p">.</span><span class="n">facts</span><span class="p">)</span><span class="si">}</span><span class="s">"</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Writer (</span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="s">) created draft: '</span><span class="si">{</span><span class="n">draft</span><span class="si">}</span><span class="s">'"</span><span class="p">)</span>
        <span class="c1"># This agent doesn't send further messages in this example
</span></code></pre></div></div>
<p>Here we define the behavior of our two agent types, inheriting from <code class="language-plaintext highlighter-rouge">BaseAgent</code> which gives us <code class="language-plaintext highlighter-rouge">self.id</code>, <code class="language-plaintext highlighter-rouge">self.publish_message</code>, etc.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 2. Define Agent Factories
</span>
<span class="k">def</span> <span class="nf">researcher_factory</span><span class="p">():</span>
    <span class="c1"># Gets runtime/id via AgentInstantiationContext inside BaseAgent.__init__
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"Runtime is creating a ResearcherAgent..."</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ResearcherAgent</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s">"I research topics."</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">writer_factory</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Runtime is creating a WriterAgent..."</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">WriterAgent</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s">"I write drafts from facts."</span><span class="p">)</span>
</code></pre></div></div>
<p>These simple functions tell the runtime <em>how</em> to create instances of our agents when needed.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># 3. Setup and Run the Runtime
</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Create the runtime (the office manager)
</span>    <span class="n">runtime</span> <span class="o">=</span> <span class="n">SingleThreadedAgentRuntime</span><span class="p">()</span>

    <span class="c1"># Register the factories (tell the manager how to hire)
</span>    <span class="k">await</span> <span class="n">runtime</span><span class="p">.</span><span class="n">register_factory</span><span class="p">(</span><span class="s">"researcher"</span><span class="p">,</span> <span class="n">researcher_factory</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">runtime</span><span class="p">.</span><span class="n">register_factory</span><span class="p">(</span><span class="s">"writer"</span><span class="p">,</span> <span class="n">writer_factory</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Registered agent factories."</span><span class="p">)</span>

    <span class="c1"># Add the subscription (tell manager who listens to which announcements)
</span>    <span class="c1"># Rule: Messages to topics of type "research.facts.available"
</span>    <span class="c1"># should go to a "writer" agent whose key matches the topic source.
</span>    <span class="n">writer_sub</span> <span class="o">=</span> <span class="n">TypeSubscription</span><span class="p">(</span><span class="n">topic_type</span><span class="o">=</span><span class="s">"research.facts.available"</span><span class="p">,</span> <span class="n">agent_type</span><span class="o">=</span><span class="s">"writer"</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">runtime</span><span class="p">.</span><span class="n">add_subscription</span><span class="p">(</span><span class="n">writer_sub</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Added subscription: </span><span class="si">{</span><span class="n">writer_sub</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

    <span class="c1"># Start the runtime (open the office)
</span>    <span class="n">runtime</span><span class="p">.</span><span class="n">start</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Runtime started."</span><span class="p">)</span>

    <span class="c1"># Send the initial message to kick things off
</span>    <span class="n">research_task_topic</span> <span class="o">=</span> <span class="s">"AutoGen Agents"</span>
    <span class="n">researcher_instance_id</span> <span class="o">=</span> <span class="n">AgentId</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">"researcher"</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">research_task_topic</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Sending initial topic '</span><span class="si">{</span><span class="n">research_task_topic</span><span class="si">}</span><span class="s">' to </span><span class="si">{</span><span class="n">researcher_instance_id</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">runtime</span><span class="p">.</span><span class="n">send_message</span><span class="p">(</span>
        <span class="n">message</span><span class="o">=</span><span class="n">ResearchTopic</span><span class="p">(</span><span class="n">topic</span><span class="o">=</span><span class="n">research_task_topic</span><span class="p">),</span>
        <span class="n">recipient</span><span class="o">=</span><span class="n">researcher_instance_id</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Wait until all messages are processed (wait for work day to end)
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"Waiting for runtime to become idle..."</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">runtime</span><span class="p">.</span><span class="n">stop_when_idle</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Runtime stopped."</span><span class="p">)</span>

<span class="c1"># Run the main function
</span><span class="n">asyncio</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div></div>
<p>This script sets up the <code class="language-plaintext highlighter-rouge">SingleThreadedAgentRuntime</code>, registers the blueprints (factories) and communication rules (subscription), starts the process, and then shuts down cleanly.</p>

<p><strong>Expected Output (Conceptual Order):</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Registered agent factories.
Added subscription: type=research.facts.available=&gt;agent=writer
Runtime started.
Sending initial topic 'AutoGen Agents' to researcher/AutoGen Agents
Waiting for runtime to become idle...
Runtime is creating a ResearcherAgent...  # First time researcher/AutoGen Agents is needed
Researcher (researcher/AutoGen Agents) got topic: AutoGen Agents
Researcher (researcher/AutoGen Agents) published facts to research.facts.available/AutoGen Agents
Runtime is creating a WriterAgent...      # First time writer/AutoGen Agents is needed (due to subscription)
Writer (writer/AutoGen Agents) received facts via topic 'research.facts.available/AutoGen Agents': ['Fact 1 about AutoGen Agents', 'Fact 2']
Writer (writer/AutoGen Agents) created draft: 'Draft for AutoGen Agents: Fact 1 about AutoGen Agents; Fact 2'
Runtime stopped.
</code></pre></div></div>
<p>You can see the runtime orchestrating the creation of agents and the flow of messages based on the initial request and the subscription rule.</p>

<h2 id="under-the-hood-how-the-manager-works">Under the Hood: How the Manager Works</h2>

<p>Let’s peek inside the <code class="language-plaintext highlighter-rouge">SingleThreadedAgentRuntime</code> (a common implementation provided by AutoGen Core) to understand the flow.</p>

<p><strong>Core Idea:</strong> It uses an internal queue (<code class="language-plaintext highlighter-rouge">_message_queue</code>) to hold incoming requests (<code class="language-plaintext highlighter-rouge">send_message</code>, <code class="language-plaintext highlighter-rouge">publish_message</code>). A background task continuously takes items from the queue and processes them one by one (though the <em>handling</em> of a message might involve <code class="language-plaintext highlighter-rouge">await</code> and allow other tasks to run).</p>

<p><strong>1. Agent Creation (<code class="language-plaintext highlighter-rouge">_get_agent</code>, <code class="language-plaintext highlighter-rouge">_invoke_agent_factory</code>)</strong></p>

<p>When the runtime needs an agent instance (e.g., to deliver a message) that hasn’t been created yet:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Runtime as AgentRuntime
    participant Factory as Agent Factory Func
    participant AgentCtx as AgentInstantiationContext
    participant Agent as New Agent Instance

    Runtime-&gt;&gt;Runtime: Check if agent instance exists (e.g., in `_instantiated_agents` dict)
    alt Agent Not Found
        Runtime-&gt;&gt;Runtime: Find registered factory for agent type
        Runtime-&gt;&gt;AgentCtx: Set current runtime &amp; agent_id
        activate AgentCtx
        Runtime-&gt;&gt;Factory: Call factory function()
        activate Factory
        Factory-&gt;&gt;AgentCtx: (Inside Agent.__init__) Get current runtime
        AgentCtx--&gt;&gt;Factory: Return runtime
        Factory-&gt;&gt;AgentCtx: (Inside Agent.__init__) Get current agent_id
        AgentCtx--&gt;&gt;Factory: Return agent_id
        Factory--&gt;&gt;Runtime: Return new Agent instance
        deactivate Factory
        Runtime-&gt;&gt;AgentCtx: Clear context
        deactivate AgentCtx
        Runtime-&gt;&gt;Runtime: Store new agent instance
    end
    Runtime-&gt;&gt;Runtime: Return agent instance
</code></pre>

<ul>
  <li>The runtime looks up the factory function registered for the required <code class="language-plaintext highlighter-rouge">AgentId.type</code>.</li>
  <li>It uses <code class="language-plaintext highlighter-rouge">AgentInstantiationContext.populate_context</code> to temporarily store its own reference and the target <code class="language-plaintext highlighter-rouge">AgentId</code>.</li>
  <li>It calls the factory function.</li>
  <li>Inside the agent’s <code class="language-plaintext highlighter-rouge">__init__</code> (usually via <code class="language-plaintext highlighter-rouge">BaseAgent</code>), <code class="language-plaintext highlighter-rouge">AgentInstantiationContext.current_runtime()</code> and <code class="language-plaintext highlighter-rouge">AgentInstantiationContext.current_agent_id()</code> are called to retrieve the context set by the runtime.</li>
  <li>The factory returns the fully initialized agent instance.</li>
  <li>The runtime stores this instance for future use.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># From: _agent_instantiation.py (Simplified)
</span><span class="k">class</span> <span class="nc">AgentInstantiationContext</span><span class="p">:</span>
    <span class="n">_CONTEXT_VAR</span> <span class="o">=</span> <span class="n">ContextVar</span><span class="p">(</span><span class="s">"agent_context"</span><span class="p">)</span> <span class="c1"># Stores (runtime, agent_id)
</span>
    <span class="o">@</span><span class="nb">classmethod</span>
    <span class="o">@</span><span class="n">contextmanager</span>
    <span class="k">def</span> <span class="nf">populate_context</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">ctx</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">AgentRuntime</span><span class="p">,</span> <span class="n">AgentId</span><span class="p">]):</span>
        <span class="n">token</span> <span class="o">=</span> <span class="n">cls</span><span class="p">.</span><span class="n">_CONTEXT_VAR</span><span class="p">.</span><span class="nb">set</span><span class="p">(</span><span class="n">ctx</span><span class="p">)</span> <span class="c1"># Store context for this block
</span>        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span> <span class="c1"># Code inside the 'with' block runs here
</span>        <span class="k">finally</span><span class="p">:</span>
            <span class="n">cls</span><span class="p">.</span><span class="n">_CONTEXT_VAR</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="c1"># Clean up context
</span>
    <span class="o">@</span><span class="nb">classmethod</span>
    <span class="k">def</span> <span class="nf">current_runtime</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AgentRuntime</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">.</span><span class="n">_CONTEXT_VAR</span><span class="p">.</span><span class="n">get</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Retrieve runtime from context
</span>
    <span class="o">@</span><span class="nb">classmethod</span>
    <span class="k">def</span> <span class="nf">current_agent_id</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AgentId</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cls</span><span class="p">.</span><span class="n">_CONTEXT_VAR</span><span class="p">.</span><span class="n">get</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># Retrieve agent_id from context
</span></code></pre></div></div>
<p>This context manager pattern ensures the correct runtime and ID are available <em>only</em> during the agent’s creation by the runtime.</p>

<p><strong>2. Direct Messaging (<code class="language-plaintext highlighter-rouge">send_message</code> -&gt; <code class="language-plaintext highlighter-rouge">_process_send</code>)</strong></p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Sender as Sending Agent/Code
    participant Runtime as AgentRuntime
    participant Queue as Internal Queue
    participant Recipient as Recipient Agent

    Sender-&gt;&gt;+Runtime: send_message(msg, recipient_id, ...)
    Runtime-&gt;&gt;Runtime: Create Future (for response)
    Runtime-&gt;&gt;+Queue: Put SendMessageEnvelope(msg, recipient_id, future)
    Runtime--&gt;&gt;-Sender: Return awaitable Future
    Note over Queue, Runtime: Background task picks up envelope
    Runtime-&gt;&gt;Runtime: _process_send(envelope)
    Runtime-&gt;&gt;+Recipient: _get_agent(recipient_id) (creates if needed)
    Recipient--&gt;&gt;-Runtime: Return Agent instance
    Runtime-&gt;&gt;+Recipient: on_message(msg, context)
    Recipient-&gt;&gt;Recipient: Process message...
    Recipient--&gt;&gt;-Runtime: Return response value
    Runtime-&gt;&gt;Runtime: Set Future result with response value
</code></pre>

<ul>
  <li><code class="language-plaintext highlighter-rouge">send_message</code> creates a <code class="language-plaintext highlighter-rouge">Future</code> object (a placeholder for the eventual result) and wraps the message details in a <code class="language-plaintext highlighter-rouge">SendMessageEnvelope</code>.</li>
  <li>This envelope is put onto the internal <code class="language-plaintext highlighter-rouge">_message_queue</code>.</li>
  <li>The background task picks up the envelope.</li>
  <li><code class="language-plaintext highlighter-rouge">_process_send</code> gets the recipient agent instance (using <code class="language-plaintext highlighter-rouge">_get_agent</code>).</li>
  <li>It calls the recipient’s <code class="language-plaintext highlighter-rouge">on_message</code> method.</li>
  <li>When <code class="language-plaintext highlighter-rouge">on_message</code> returns a result, <code class="language-plaintext highlighter-rouge">_process_send</code> sets the result on the <code class="language-plaintext highlighter-rouge">Future</code> object, which makes the original <code class="language-plaintext highlighter-rouge">await runtime.send_message(...)</code> call return the value.</li>
</ul>

<p><strong>3. Publish/Subscribe (<code class="language-plaintext highlighter-rouge">publish_message</code> -&gt; <code class="language-plaintext highlighter-rouge">_process_publish</code>)</strong></p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Publisher as Publishing Agent/Code
    participant Runtime as AgentRuntime
    participant Queue as Internal Queue
    participant SubManager as SubscriptionManager
    participant Subscriber as Subscribed Agent

    Publisher-&gt;&gt;+Runtime: publish_message(msg, topic_id, ...)
    Runtime-&gt;&gt;+Queue: Put PublishMessageEnvelope(msg, topic_id)
    Runtime--&gt;&gt;-Publisher: Return (None for publish)
    Note over Queue, Runtime: Background task picks up envelope
    Runtime-&gt;&gt;Runtime: _process_publish(envelope)
    Runtime-&gt;&gt;+SubManager: get_subscribed_recipients(topic_id)
    SubManager-&gt;&gt;SubManager: Find matching subscriptions
    SubManager-&gt;&gt;SubManager: Map subscriptions to AgentIds
    SubManager--&gt;&gt;-Runtime: Return list of recipient AgentIds
    loop For each recipient AgentId
        Runtime-&gt;&gt;+Subscriber: _get_agent(recipient_id) (creates if needed)
        Subscriber--&gt;&gt;-Runtime: Return Agent instance
        Runtime-&gt;&gt;+Subscriber: on_message(msg, context with topic_id)
        Subscriber-&gt;&gt;Subscriber: Process message...
        Subscriber--&gt;&gt;-Runtime: Return (usually None for publish)
    end
</code></pre>

<ul>
  <li><code class="language-plaintext highlighter-rouge">publish_message</code> wraps the message in a <code class="language-plaintext highlighter-rouge">PublishMessageEnvelope</code> and puts it on the queue.</li>
  <li>The background task picks it up.</li>
  <li><code class="language-plaintext highlighter-rouge">_process_publish</code> asks the <code class="language-plaintext highlighter-rouge">SubscriptionManager</code> (<code class="language-plaintext highlighter-rouge">_subscription_manager</code>) for all <code class="language-plaintext highlighter-rouge">AgentId</code>s that are subscribed to the given <code class="language-plaintext highlighter-rouge">topic_id</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">SubscriptionManager</code> checks its registered <code class="language-plaintext highlighter-rouge">Subscription</code> objects (<code class="language-plaintext highlighter-rouge">_subscriptions</code> list, added via <code class="language-plaintext highlighter-rouge">add_subscription</code>). For each <code class="language-plaintext highlighter-rouge">Subscription</code> where <code class="language-plaintext highlighter-rouge">is_match(topic_id)</code> is true, it calls <code class="language-plaintext highlighter-rouge">map_to_agent(topic_id)</code> to get the target <code class="language-plaintext highlighter-rouge">AgentId</code>.</li>
  <li>For each resulting <code class="language-plaintext highlighter-rouge">AgentId</code>, the runtime gets the agent instance and calls its <code class="language-plaintext highlighter-rouge">on_message</code> method, providing the <code class="language-plaintext highlighter-rouge">topic_id</code> in the <code class="language-plaintext highlighter-rouge">MessageContext</code>.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># From: _runtime_impl_helpers.py (SubscriptionManager simplified)
</span><span class="k">class</span> <span class="nc">SubscriptionManager</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_subscriptions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Subscription</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Optimization cache can be added here
</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">add_subscription</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subscription</span><span class="p">:</span> <span class="n">Subscription</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_subscriptions</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">subscription</span><span class="p">)</span>
        <span class="c1"># Clear cache if any
</span>
    <span class="k">async</span> <span class="k">def</span> <span class="nf">get_subscribed_recipients</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topic</span><span class="p">:</span> <span class="n">TopicId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">AgentId</span><span class="p">]:</span>
        <span class="n">recipients</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sub</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">_subscriptions</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sub</span><span class="p">.</span><span class="n">is_match</span><span class="p">(</span><span class="n">topic</span><span class="p">):</span>
                <span class="n">recipients</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">sub</span><span class="p">.</span><span class="n">map_to_agent</span><span class="p">(</span><span class="n">topic</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">recipients</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">SubscriptionManager</code> simply iterates through registered subscriptions to find matches when a message is published.</p>

<h2 id="next-steps">Next Steps</h2>

<p>You now understand the <code class="language-plaintext highlighter-rouge">AgentRuntime</code> - the essential coordinator that brings Agents to life, manages their communication, and runs the entire show. It handles agent creation via factories, routes direct and published messages, and manages the system’s lifecycle.</p>

<p>With the core concepts of <code class="language-plaintext highlighter-rouge">Agent</code>, <code class="language-plaintext highlighter-rouge">Messaging</code>, and <code class="language-plaintext highlighter-rouge">AgentRuntime</code> covered, we can start looking at more specialized building blocks. Next, we’ll explore how agents can use external capabilities:</p>

<ul>
  <li><a href="04_tool.md">Chapter 4: Tool</a>: How to give agents tools (like functions or APIs) to perform specific actions beyond just processing messages.</li>
</ul>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
