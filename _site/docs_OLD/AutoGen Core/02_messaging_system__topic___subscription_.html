<h1 id="chapter-2-messaging-system-topic--subscription">Chapter 2: Messaging System (Topic &amp; Subscription)</h1>

<p>In <a href="01_agent.md">Chapter 1: Agent</a>, we learned about Agents as individual workers. But how do they coordinate when one agent doesn’t know exactly <em>who</em> needs the information it produces? Imagine our Researcher finds some facts. Maybe the Writer needs them, but maybe a Fact-Checker agent or a Summary agent also needs them later. How can the Researcher just announce “Here are the facts!” without needing a specific mailing list?</p>

<p>This is where the <strong>Messaging System</strong>, specifically <strong>Topics</strong> and <strong>Subscriptions</strong>, comes in. It allows agents to broadcast messages to anyone interested, like posting on a company announcement board.</p>

<h2 id="motivation-broadcasting-information">Motivation: Broadcasting Information</h2>

<p>Let’s refine our blog post example:</p>

<ol>
  <li>The <code class="language-plaintext highlighter-rouge">Researcher</code> agent finds facts about “AutoGen Agents”.</li>
  <li>Instead of sending <em>directly</em> to the <code class="language-plaintext highlighter-rouge">Writer</code>, the <code class="language-plaintext highlighter-rouge">Researcher</code> <strong>publishes</strong> these facts to a general “research-results” <strong>Topic</strong>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">Writer</code> agent has previously told the system it’s <strong>subscribed</strong> to the “research-results” Topic.</li>
  <li>The system sees the new message on the Topic and delivers it to the <code class="language-plaintext highlighter-rouge">Writer</code> (and any other subscribers).</li>
</ol>

<p>This way, the <code class="language-plaintext highlighter-rouge">Researcher</code> doesn’t need to know who the <code class="language-plaintext highlighter-rouge">Writer</code> is, or even if a <code class="language-plaintext highlighter-rouge">Writer</code> exists! It just broadcasts the results. If we later add a <code class="language-plaintext highlighter-rouge">FactChecker</code> agent that also needs the results, it simply subscribes to the same Topic.</p>

<h2 id="key-concepts-topics-and-subscriptions">Key Concepts: Topics and Subscriptions</h2>

<p>Let’s break down the components of this broadcasting system:</p>

<ol>
  <li><strong>Topic (<code class="language-plaintext highlighter-rouge">TopicId</code>): The Announcement Board</strong>
    <ul>
      <li>A <code class="language-plaintext highlighter-rouge">TopicId</code> represents a specific channel or category for messages. Think of it like the name of an announcement board (e.g., “Project Updates”, “General Announcements”).</li>
      <li>It has two main parts:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">type</code>: What <em>kind</em> of event or information is this? (e.g., “research.completed”, “user.request”). This helps categorize messages.</li>
          <li><code class="language-plaintext highlighter-rouge">source</code>: <em>Where</em> or <em>why</em> did this event originate? Often, this relates to the specific task or context (e.g., the specific blog post being researched like “autogen-agents-blog-post”, or the team generating the event like “research-team”).</li>
        </ul>
      </li>
    </ul>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># From: _topic.py (Simplified)
</span><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="o">@</span><span class="n">dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span> <span class="c1"># Immutable: can't change after creation
</span><span class="k">class</span> <span class="nc">TopicId</span><span class="p">:</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">source</span><span class="p">:</span> <span class="nb">str</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># Creates an id like "research.completed/autogen-agents-blog-post"
</span>        <span class="k">return</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="nb">type</span><span class="si">}</span><span class="s">/</span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">source</span><span class="si">}</span><span class="s">"</span>
</code></pre></div>    </div>
    <p>This structure allows for flexible filtering. Agents might subscribe to all topics of a certain <code class="language-plaintext highlighter-rouge">type</code>, regardless of the <code class="language-plaintext highlighter-rouge">source</code>, or only to topics with a specific <code class="language-plaintext highlighter-rouge">source</code>.</p>
  </li>
  <li><strong>Publishing: Posting the Announcement</strong>
    <ul>
      <li>When an agent has information to share broadly, it <em>publishes</em> a message to a specific <code class="language-plaintext highlighter-rouge">TopicId</code>.</li>
      <li>This is like pinning a note to the designated announcement board. The agent doesn’t need to know who will read it.</li>
    </ul>
  </li>
  <li><strong>Subscription (<code class="language-plaintext highlighter-rouge">Subscription</code>): Signing Up for Updates</strong>
    <ul>
      <li>A <code class="language-plaintext highlighter-rouge">Subscription</code> is how an agent declares its interest in certain <code class="language-plaintext highlighter-rouge">TopicId</code>s.</li>
      <li>It acts like a rule: “If a message is published to a Topic that matches <em>this pattern</em>, please deliver it to <em>this kind of agent</em>”.</li>
      <li>The <code class="language-plaintext highlighter-rouge">Subscription</code> links a <code class="language-plaintext highlighter-rouge">TopicId</code> pattern (e.g., “all topics with type <code class="language-plaintext highlighter-rouge">research.completed</code>”) to an <code class="language-plaintext highlighter-rouge">AgentId</code> (or a way to determine the <code class="language-plaintext highlighter-rouge">AgentId</code>).</li>
    </ul>
  </li>
  <li><strong>Routing: Delivering the Mail</strong>
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">AgentRuntime</code> (the system manager we’ll meet in <a href="03_agentruntime.md">Chapter 3: AgentRuntime</a>) keeps track of all active <code class="language-plaintext highlighter-rouge">Subscription</code>s.</li>
      <li>When a message is published to a <code class="language-plaintext highlighter-rouge">TopicId</code>, the <code class="language-plaintext highlighter-rouge">AgentRuntime</code> checks which <code class="language-plaintext highlighter-rouge">Subscription</code>s match that <code class="language-plaintext highlighter-rouge">TopicId</code>.</li>
      <li>For each match, it uses the <code class="language-plaintext highlighter-rouge">Subscription</code>’s rule to figure out which specific <code class="language-plaintext highlighter-rouge">AgentId</code> should receive the message and delivers it.</li>
    </ul>
  </li>
</ol>

<h2 id="use-case-example-researcher-publishes-writer-subscribes">Use Case Example: Researcher Publishes, Writer Subscribes</h2>

<p>Let’s see how our Researcher and Writer can use this system.</p>

<p><strong>Goal:</strong> Researcher publishes facts to a topic, Writer receives them via subscription.</p>

<p><strong>1. Define the Topic:</strong>
We need a <code class="language-plaintext highlighter-rouge">TopicId</code> for research results. Let’s say the <code class="language-plaintext highlighter-rouge">type</code> is “research.facts.available” and the <code class="language-plaintext highlighter-rouge">source</code> identifies the specific research task (e.g., “blog-post-autogen”).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># From: _topic.py
</span><span class="kn">from</span> <span class="nn">autogen_core</span> <span class="kn">import</span> <span class="n">TopicId</span>

<span class="c1"># Define the topic for this specific research task
</span><span class="n">research_topic_id</span> <span class="o">=</span> <span class="n">TopicId</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">"research.facts.available"</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s">"blog-post-autogen"</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Topic ID: </span><span class="si">{</span><span class="n">research_topic_id</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Output: Topic ID: research.facts.available/blog-post-autogen
</span></code></pre></div></div>
<p>This defines the “announcement board” we’ll use.</p>

<p><strong>2. Researcher Publishes:</strong>
The <code class="language-plaintext highlighter-rouge">Researcher</code> agent, after finding facts, will use its <code class="language-plaintext highlighter-rouge">agent_context</code> (provided by the runtime) to publish the <code class="language-plaintext highlighter-rouge">ResearchFacts</code> message to this topic.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified concept - Researcher agent logic
# Assume 'agent_context' and 'message' (ResearchTopic) are provided
</span>
<span class="c1"># Define the facts message (from Chapter 1)
</span><span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">ResearchFacts</span><span class="p">:</span>
    <span class="n">topic</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">facts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>

<span class="k">async</span> <span class="k">def</span> <span class="nf">researcher_publish_logic</span><span class="p">(</span><span class="n">agent_context</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">ResearchTopic</span><span class="p">,</span> <span class="n">msg_context</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Researcher working on: </span><span class="si">{</span><span class="n">message</span><span class="p">.</span><span class="n">topic</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="n">facts_data</span> <span class="o">=</span> <span class="n">ResearchFacts</span><span class="p">(</span>
        <span class="n">topic</span><span class="o">=</span><span class="n">message</span><span class="p">.</span><span class="n">topic</span><span class="p">,</span>
        <span class="n">facts</span><span class="o">=</span><span class="p">[</span><span class="sa">f</span><span class="s">"Fact A about </span><span class="si">{</span><span class="n">message</span><span class="p">.</span><span class="n">topic</span><span class="si">}</span><span class="s">"</span><span class="p">,</span> <span class="sa">f</span><span class="s">"Fact B about </span><span class="si">{</span><span class="n">message</span><span class="p">.</span><span class="n">topic</span><span class="si">}</span><span class="s">"</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Define the specific topic for this task's results
</span>    <span class="n">results_topic</span> <span class="o">=</span> <span class="n">TopicId</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s">"research.facts.available"</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">message</span><span class="p">.</span><span class="n">topic</span><span class="p">)</span> <span class="c1"># Use message topic as source
</span>
    <span class="c1"># Publish the facts to the topic
</span>    <span class="k">await</span> <span class="n">agent_context</span><span class="p">.</span><span class="n">publish_message</span><span class="p">(</span><span class="n">message</span><span class="o">=</span><span class="n">facts_data</span><span class="p">,</span> <span class="n">topic_id</span><span class="o">=</span><span class="n">results_topic</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Researcher published facts to topic: </span><span class="si">{</span><span class="n">results_topic</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="c1"># No direct reply needed
</span>    <span class="k">return</span> <span class="bp">None</span>
</code></pre></div></div>
<p>Notice the <code class="language-plaintext highlighter-rouge">agent_context.publish_message</code> call. The Researcher doesn’t specify a recipient, only the topic.</p>

<p><strong>3. Writer Subscribes:</strong>
The <code class="language-plaintext highlighter-rouge">Writer</code> agent needs to tell the system it’s interested in messages on topics like “research.facts.available”. We can use a predefined <code class="language-plaintext highlighter-rouge">Subscription</code> type called <code class="language-plaintext highlighter-rouge">TypeSubscription</code>. This subscription typically means: “I am interested in all topics with this <em>exact type</em>. When a message arrives, create/use an agent of <em>my type</em> whose <code class="language-plaintext highlighter-rouge">key</code> matches the topic’s <code class="language-plaintext highlighter-rouge">source</code>.”</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># From: _type_subscription.py (Simplified Concept)
</span><span class="kn">from</span> <span class="nn">autogen_core</span> <span class="kn">import</span> <span class="n">TypeSubscription</span><span class="p">,</span> <span class="n">BaseAgent</span>

<span class="k">class</span> <span class="nc">WriterAgent</span><span class="p">(</span><span class="n">BaseAgent</span><span class="p">):</span>
    <span class="c1"># ... agent implementation ...
</span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_message_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">ResearchFacts</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span>
        <span class="c1"># This method gets called when a subscribed message arrives
</span>        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Writer (</span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="nb">id</span><span class="si">}</span><span class="s">) received facts via subscription: </span><span class="si">{</span><span class="n">message</span><span class="p">.</span><span class="n">facts</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="c1"># ... process facts and write draft ...
</span>
<span class="c1"># How the Writer subscribes (usually done during runtime setup - Chapter 3)
# This tells the runtime: "Messages on topics with type 'research.facts.available'
# should go to a 'writer' agent whose key matches the topic source."
</span><span class="n">writer_subscription</span> <span class="o">=</span> <span class="n">TypeSubscription</span><span class="p">(</span>
    <span class="n">topic_type</span><span class="o">=</span><span class="s">"research.facts.available"</span><span class="p">,</span>
    <span class="n">agent_type</span><span class="o">=</span><span class="s">"writer"</span> <span class="c1"># The type of agent that should handle this
</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Writer subscription created for topic type: </span><span class="si">{</span><span class="n">writer_subscription</span><span class="p">.</span><span class="n">topic_type</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># Output: Writer subscription created for topic type: research.facts.available
</span></code></pre></div></div>
<p>When the <code class="language-plaintext highlighter-rouge">Researcher</code> publishes to <code class="language-plaintext highlighter-rouge">TopicId(type="research.facts.available", source="blog-post-autogen")</code>, the <code class="language-plaintext highlighter-rouge">AgentRuntime</code> will see that <code class="language-plaintext highlighter-rouge">writer_subscription</code> matches the <code class="language-plaintext highlighter-rouge">topic_type</code>. It will then use the rule: “Find (or create) an agent with <code class="language-plaintext highlighter-rouge">AgentId(type='writer', key='blog-post-autogen')</code> and deliver the message.”</p>

<p><strong>Benefit:</strong> Decoupling! The Researcher just broadcasts. The Writer just listens for relevant broadcasts. We can add more listeners (like a <code class="language-plaintext highlighter-rouge">FactChecker</code> subscribing to the same <code class="language-plaintext highlighter-rouge">topic_type</code>) without changing the <code class="language-plaintext highlighter-rouge">Researcher</code> at all.</p>

<h2 id="under-the-hood-how-publishing-works">Under the Hood: How Publishing Works</h2>

<p>Let’s trace the journey of a published message.</p>

<p><strong>Conceptual Flow:</strong></p>

<pre><code class="language-mermaid">sequenceDiagram
    participant Publisher as Publisher Agent
    participant Runtime as AgentRuntime
    participant SubRegistry as Subscription Registry
    participant Subscriber as Subscriber Agent

    Publisher-&gt;&gt;+Runtime: publish_message(message, topic_id)
    Runtime-&gt;&gt;+SubRegistry: Find subscriptions matching topic_id
    SubRegistry--&gt;&gt;-Runtime: Return list of matching Subscriptions
    loop For each matching Subscription
        Runtime-&gt;&gt;Subscription: map_to_agent(topic_id)
        Subscription--&gt;&gt;Runtime: Return target AgentId
        Runtime-&gt;&gt;+Subscriber: Locate/Create Agent instance by AgentId
        Runtime-&gt;&gt;Subscriber: on_message(message, context)
        Subscriber--&gt;&gt;-Runtime: Process message (optional return)
    end
    Runtime--&gt;&gt;-Publisher: Return (usually None for publish)
</code></pre>

<ol>
  <li><strong>Publish:</strong> An agent calls <code class="language-plaintext highlighter-rouge">agent_context.publish_message(message, topic_id)</code>. This internally calls the <code class="language-plaintext highlighter-rouge">AgentRuntime</code>’s publish method.</li>
  <li><strong>Lookup:</strong> The <code class="language-plaintext highlighter-rouge">AgentRuntime</code> takes the <code class="language-plaintext highlighter-rouge">topic_id</code> and consults its internal <code class="language-plaintext highlighter-rouge">Subscription Registry</code>.</li>
  <li><strong>Match:</strong> The Registry checks all registered <code class="language-plaintext highlighter-rouge">Subscription</code> objects. Each <code class="language-plaintext highlighter-rouge">Subscription</code> has an <code class="language-plaintext highlighter-rouge">is_match(topic_id)</code> method. The registry finds all subscriptions where <code class="language-plaintext highlighter-rouge">is_match</code> returns <code class="language-plaintext highlighter-rouge">True</code>.</li>
  <li><strong>Map:</strong> For each matching <code class="language-plaintext highlighter-rouge">Subscription</code>, the Runtime calls its <code class="language-plaintext highlighter-rouge">map_to_agent(topic_id)</code> method. This method returns the specific <code class="language-plaintext highlighter-rouge">AgentId</code> that should handle this message based on the subscription rule and the topic details.</li>
  <li><strong>Deliver:</strong> The <code class="language-plaintext highlighter-rouge">AgentRuntime</code> finds the agent instance corresponding to the returned <code class="language-plaintext highlighter-rouge">AgentId</code> (potentially creating it if it doesn’t exist yet, especially with <code class="language-plaintext highlighter-rouge">TypeSubscription</code>). It then calls that agent’s <code class="language-plaintext highlighter-rouge">on_message</code> method, delivering the original published <code class="language-plaintext highlighter-rouge">message</code>.</li>
</ol>

<p><strong>Code Glimpse:</strong></p>

<ul>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">TopicId</code> (<code class="language-plaintext highlighter-rouge">_topic.py</code>):</strong> As shown before, a simple dataclass holding <code class="language-plaintext highlighter-rouge">type</code> and <code class="language-plaintext highlighter-rouge">source</code>. It includes validation to ensure the <code class="language-plaintext highlighter-rouge">type</code> follows certain naming conventions.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># From: _topic.py
</span><span class="o">@</span><span class="n">dataclass</span><span class="p">(</span><span class="n">eq</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">frozen</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">TopicId</span><span class="p">:</span>
    <span class="nb">type</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">source</span><span class="p">:</span> <span class="nb">str</span>
    <span class="c1"># ... validation and __str__ ...
</span>
    <span class="o">@</span><span class="nb">classmethod</span>
    <span class="k">def</span> <span class="nf">from_str</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">topic_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
        <span class="c1"># Helper to parse "type/source" string
</span>        <span class="c1"># ... implementation ...
</span></code></pre></div>    </div>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">Subscription</code> Protocol (<code class="language-plaintext highlighter-rouge">_subscription.py</code>):</strong> This defines the <em>contract</em> for any subscription rule.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># From: _subscription.py (Simplified Protocol)
</span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Protocol</span>
<span class="c1"># ... other imports
</span>
<span class="k">class</span> <span class="nc">Subscription</span><span class="p">(</span><span class="n">Protocol</span><span class="p">):</span>
    <span class="o">@</span><span class="nb">property</span>
    <span class="k">def</span> <span class="nf">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span> <span class="p">...</span> <span class="c1"># Unique ID for this subscription instance
</span>
    <span class="k">def</span> <span class="nf">is_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topic_id</span><span class="p">:</span> <span class="n">TopicId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="s">"""Check if a topic matches this subscription's rule."""</span>
        <span class="p">...</span>

    <span class="k">def</span> <span class="nf">map_to_agent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topic_id</span><span class="p">:</span> <span class="n">TopicId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AgentId</span><span class="p">:</span>
        <span class="s">"""Determine the target AgentId if is_match was True."""</span>
        <span class="p">...</span>
</code></pre></div>    </div>
    <p>Any class implementing these methods can act as a subscription rule.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">TypeSubscription</code> (<code class="language-plaintext highlighter-rouge">_type_subscription.py</code>):</strong> A common implementation of the <code class="language-plaintext highlighter-rouge">Subscription</code> protocol.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># From: _type_subscription.py (Simplified)
</span><span class="k">class</span> <span class="nc">TypeSubscription</span><span class="p">(</span><span class="n">Subscription</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topic_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">agent_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="p">...):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_topic_type</span> <span class="o">=</span> <span class="n">topic_type</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">_agent_type</span> <span class="o">=</span> <span class="n">agent_type</span>
        <span class="c1"># ... generates a unique self._id ...
</span>
    <span class="k">def</span> <span class="nf">is_match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topic_id</span><span class="p">:</span> <span class="n">TopicId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Matches if the topic's type is exactly the one we want
</span>        <span class="k">return</span> <span class="n">topic_id</span><span class="p">.</span><span class="nb">type</span> <span class="o">==</span> <span class="bp">self</span><span class="p">.</span><span class="n">_topic_type</span>

    <span class="k">def</span> <span class="nf">map_to_agent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">topic_id</span><span class="p">:</span> <span class="n">TopicId</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AgentId</span><span class="p">:</span>
        <span class="c1"># Maps to an agent of the specified type, using the
</span>        <span class="c1"># topic's source as the agent's unique key.
</span>        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="p">.</span><span class="n">is_match</span><span class="p">(</span><span class="n">topic_id</span><span class="p">):</span>
             <span class="k">raise</span> <span class="n">CantHandleException</span><span class="p">(...)</span> <span class="c1"># Should not happen if used correctly
</span>        <span class="k">return</span> <span class="n">AgentId</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">_agent_type</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">topic_id</span><span class="p">.</span><span class="n">source</span><span class="p">)</span>
    <span class="c1"># ... id property ...
</span></code></pre></div>    </div>
    <p>This implementation provides the “one agent instance per source” behavior for a specific topic type.</p>
  </li>
  <li>
    <p><strong><code class="language-plaintext highlighter-rouge">DefaultSubscription</code> (<code class="language-plaintext highlighter-rouge">_default_subscription.py</code>):</strong> This is often used via a decorator (<code class="language-plaintext highlighter-rouge">@default_subscription</code>) and provides a convenient way to create a <code class="language-plaintext highlighter-rouge">TypeSubscription</code> where the <code class="language-plaintext highlighter-rouge">agent_type</code> is automatically inferred from the agent class being defined, and the <code class="language-plaintext highlighter-rouge">topic_type</code> defaults to “default” (but can be overridden). It simplifies common use cases.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># From: _default_subscription.py (Conceptual Usage)
</span><span class="kn">from</span> <span class="nn">autogen_core</span> <span class="kn">import</span> <span class="n">BaseAgent</span><span class="p">,</span> <span class="n">default_subscription</span><span class="p">,</span> <span class="n">ResearchFacts</span>

<span class="o">@</span><span class="n">default_subscription</span> <span class="c1"># Uses 'default' topic type, infers agent type 'writer'
</span><span class="k">class</span> <span class="nc">WriterAgent</span><span class="p">(</span><span class="n">BaseAgent</span><span class="p">):</span>
    <span class="c1"># Agent logic here...
</span>    <span class="k">async</span> <span class="k">def</span> <span class="nf">on_message_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">ResearchFacts</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span> <span class="p">...</span>

<span class="c1"># Or specify the topic type
</span><span class="o">@</span><span class="n">default_subscription</span><span class="p">(</span><span class="n">topic_type</span><span class="o">=</span><span class="s">"research.facts.available"</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">SpecificWriterAgent</span><span class="p">(</span><span class="n">BaseAgent</span><span class="p">):</span>
     <span class="c1"># Agent logic here...
</span>     <span class="k">async</span> <span class="k">def</span> <span class="nf">on_message_impl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="n">ResearchFacts</span><span class="p">,</span> <span class="n">ctx</span><span class="p">):</span> <span class="p">...</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>The actual sending (<code class="language-plaintext highlighter-rouge">publish_message</code>) and routing logic reside within the <code class="language-plaintext highlighter-rouge">AgentRuntime</code>, which we’ll explore next.</p>

<h2 id="next-steps">Next Steps</h2>

<p>You’ve learned how AutoGen Core uses a publish/subscribe system (<code class="language-plaintext highlighter-rouge">TopicId</code>, <code class="language-plaintext highlighter-rouge">Subscription</code>) to allow agents to communicate without direct coupling. This is crucial for building flexible and scalable multi-agent applications.</p>

<ul>
  <li><strong>Topic (<code class="language-plaintext highlighter-rouge">TopicId</code>):</strong> Named channels (<code class="language-plaintext highlighter-rouge">type</code>/<code class="language-plaintext highlighter-rouge">source</code>) for broadcasting messages.</li>
  <li><strong>Publish:</strong> Sending a message to a Topic.</li>
  <li><strong>Subscription:</strong> An agent’s declared interest in messages on certain Topics, defining a routing rule.</li>
</ul>

<p>Now, let’s dive into the orchestrator that manages agents and makes this messaging system work:</p>

<ul>
  <li><a href="03_agentruntime.md">Chapter 3: AgentRuntime</a>: The manager responsible for creating, running, and connecting agents, including handling message publishing and subscription routing.</li>
</ul>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
