<h1 id="chapter-5-authentication-handlers---showing-your-id-card">Chapter 5: Authentication Handlers - Showing Your ID Card</h1>

<p>In <a href="04_cookie_jar.md">Chapter 4: The Cookie Jar</a>, we learned how <code class="language-plaintext highlighter-rouge">requests</code> uses <code class="language-plaintext highlighter-rouge">Session</code> objects and cookie jars to automatically remember things like login cookies. This is great for websites that use cookies to manage sessions after you log in.</p>

<p>But what about websites or APIs that require you to prove who you are <em>every time</em> you make a request, or use different methods than cookies? For example, some services need a username and password sent directly with the request, not just a cookie.</p>

<h2 id="the-problem-accessing-protected-resources">The Problem: Accessing Protected Resources</h2>

<p>Imagine a website has a special members-only area. To access pages in this area, the server needs to know you’re a valid member <em>right when you ask for the page</em>. It won’t just let anyone in. It needs some form of identification, like a username and password.</p>

<p>How do we tell <code class="language-plaintext highlighter-rouge">requests</code> to include this identification with our request?</p>

<p>This is where <strong>Authentication Handlers</strong> come in.</p>

<h2 id="what-are-authentication-handlers">What are Authentication Handlers?</h2>

<p>Think of authentication handlers as different types of <strong>ID badges</strong> you can attach to your web requests. Just like you might need a specific badge to get into different parts of a building, different web services might require different types of authentication.</p>

<p><code class="language-plaintext highlighter-rouge">Requests</code> has built-in support for common types (schemes) of HTTP authentication, and you can even create your own custom badges.</p>

<p><strong>Common ID Badges (Authentication Schemes):</strong></p>

<ol>
  <li><strong>HTTP Basic Auth:</strong> This is the simplest type. It’s like a badge with your username and password written directly on it (encoded, but easily decoded). It’s common but not very secure over plain HTTP (HTTPS makes it safer).
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Requests</code> provides: A simple <code class="language-plaintext highlighter-rouge">(username, password)</code> tuple or the <code class="language-plaintext highlighter-rouge">HTTPBasicAuth</code> class.</li>
    </ul>
  </li>
  <li><strong>HTTP Digest Auth:</strong> This is a bit more secure than Basic. Instead of sending your password directly, it involves a challenge-response process, like the server asking a secret question based on your password, and your request providing the answer. It’s more complex but avoids sending the password openly.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Requests</code> provides: The <code class="language-plaintext highlighter-rouge">HTTPDigestAuth</code> class.</li>
    </ul>
  </li>
  <li><strong>Custom Auth:</strong> Some services use unique authentication methods (like OAuth1, OAuth2, custom API keys).
    <ul>
      <li><code class="language-plaintext highlighter-rouge">Requests</code> allows you to create your own auth handlers by subclassing <code class="language-plaintext highlighter-rouge">AuthBase</code>. Many other libraries provide handlers for common schemes like OAuth.</li>
    </ul>
  </li>
</ol>

<p>When you provide authentication details to <code class="language-plaintext highlighter-rouge">requests</code>, it automatically figures out how to create and attach the correct <code class="language-plaintext highlighter-rouge">Authorization</code> header (or sometimes <code class="language-plaintext highlighter-rouge">Proxy-Authorization</code> for proxies) to your request. It’s like pinning the right ID badge onto your request before sending it off.</p>

<h2 id="using-authentication-handlers">Using Authentication Handlers</h2>

<p>The easiest way to add authentication is by using the <code class="language-plaintext highlighter-rouge">auth</code> parameter when making a request, either with the functional API or with a <a href="03_session.md">Session</a> object.</p>

<h3 id="http-basic-auth-the-easiest-way">HTTP Basic Auth (The Easiest Way)</h3>

<p>For Basic Auth, you can simply pass a tuple <code class="language-plaintext highlighter-rouge">(username, password)</code> to the <code class="language-plaintext highlighter-rouge">auth</code> argument.</p>

<p>Let’s try accessing a test endpoint from <code class="language-plaintext highlighter-rouge">httpbin.org</code> that’s protected with Basic Auth. The username is <code class="language-plaintext highlighter-rouge">testuser</code> and the password is <code class="language-plaintext highlighter-rouge">testpass</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">requests</span>

<span class="c1"># This URL requires Basic Auth with user='testuser', pass='testpass'
</span><span class="n">url</span> <span class="o">=</span> <span class="s">'https://httpbin.org/basic-auth/testuser/testpass'</span>

<span class="c1"># Try without authentication first (should fail with 401 Unauthorized)
</span><span class="k">print</span><span class="p">(</span><span class="s">"Attempting without authentication..."</span><span class="p">)</span>
<span class="n">response_fail</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Status Code (fail): </span><span class="si">{</span><span class="n">response_fail</span><span class="p">.</span><span class="n">status_code</span><span class="si">}</span><span class="s">"</span><span class="p">)</span> <span class="c1"># Expect 401
</span>
<span class="c1"># Now, provide the username and password tuple to the 'auth' parameter
</span><span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Attempting with Basic Auth tuple..."</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">response_ok</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">auth</span><span class="o">=</span><span class="p">(</span><span class="s">'testuser'</span><span class="p">,</span> <span class="s">'testpass'</span><span class="p">))</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Status Code (ok): </span><span class="si">{</span><span class="n">response_ok</span><span class="p">.</span><span class="n">status_code</span><span class="si">}</span><span class="s">"</span><span class="p">)</span> <span class="c1"># Expect 200
</span>    <span class="c1"># Check the response content (httpbin echoes auth info)
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"Response JSON:"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">response_ok</span><span class="p">.</span><span class="n">json</span><span class="p">())</span>
<span class="k">except</span> <span class="n">requests</span><span class="p">.</span><span class="n">exceptions</span><span class="p">.</span><span class="n">RequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"An error occurred: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

</code></pre></div></div>

<p><strong>Output:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Attempting without authentication...
Status Code (fail): 401

Attempting with Basic Auth tuple...
Status Code (ok): 200
Response JSON:
{'authenticated': True, 'user': 'testuser'}
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li>The first request failed with <code class="language-plaintext highlighter-rouge">401 Unauthorized</code> because we didn’t provide credentials.</li>
  <li>In the second request, we added <code class="language-plaintext highlighter-rouge">auth=('testuser', 'testpass')</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">Requests</code> automatically recognized this tuple, created the necessary <code class="language-plaintext highlighter-rouge">Authorization: Basic dGVzdHVzZXI6dGVzdHBhc3M=</code> header (where <code class="language-plaintext highlighter-rouge">dGVzdHVzZXI6dGVzdHBhc3M=</code> is the Base64 encoding of <code class="language-plaintext highlighter-rouge">testuser:testpass</code>), and added it to the request.</li>
  <li>The server validated the credentials and granted access, returning a <code class="language-plaintext highlighter-rouge">200 OK</code> status. The response body confirms we were authenticated as <code class="language-plaintext highlighter-rouge">testuser</code>.</li>
</ol>

<h3 id="using-the-httpbasicauth-class">Using the <code class="language-plaintext highlighter-rouge">HTTPBasicAuth</code> Class</h3>

<p>Passing a tuple is a shortcut specifically for Basic Auth. For clarity, or if you want to reuse the authentication details, you can use the <code class="language-plaintext highlighter-rouge">HTTPBasicAuth</code> class explicitly. It does exactly the same thing internally.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">requests.auth</span> <span class="kn">import</span> <span class="n">HTTPBasicAuth</span> <span class="c1"># Import the class
</span>
<span class="n">url</span> <span class="o">=</span> <span class="s">'https://httpbin.org/basic-auth/testuser/testpass'</span>

<span class="c1"># Create an HTTPBasicAuth object
</span><span class="n">basic_auth</span> <span class="o">=</span> <span class="n">HTTPBasicAuth</span><span class="p">(</span><span class="s">'testuser'</span><span class="p">,</span> <span class="s">'testpass'</span><span class="p">)</span>

<span class="c1"># Pass the auth object to the 'auth' parameter
</span><span class="k">print</span><span class="p">(</span><span class="s">"Attempting with HTTPBasicAuth object..."</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">auth</span><span class="o">=</span><span class="n">basic_auth</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Status Code: </span><span class="si">{</span><span class="n">response</span><span class="p">.</span><span class="n">status_code</span><span class="si">}</span><span class="s">"</span><span class="p">)</span> <span class="c1"># Expect 200
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"Response JSON:"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">json</span><span class="p">())</span>
<span class="k">except</span> <span class="n">requests</span><span class="p">.</span><span class="n">exceptions</span><span class="p">.</span><span class="n">RequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"An error occurred: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

</code></pre></div></div>

<p><strong>Output:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Attempting with HTTPBasicAuth object...
Status Code: 200
Response JSON:
{'authenticated': True, 'user': 'testuser'}
</code></pre></div></div>

<p>This achieves the same result as the tuple, but <code class="language-plaintext highlighter-rouge">HTTPBasicAuth(user, pass)</code> is more explicit about the type of authentication being used.</p>

<h3 id="http-digest-auth">HTTP Digest Auth</h3>

<p>Digest Auth is more complex, involving a challenge from the server. <code class="language-plaintext highlighter-rouge">Requests</code> handles this complexity for you with the <code class="language-plaintext highlighter-rouge">HTTPDigestAuth</code> class. You use it similarly to <code class="language-plaintext highlighter-rouge">HTTPBasicAuth</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">requests.auth</span> <span class="kn">import</span> <span class="n">HTTPDigestAuth</span> <span class="c1"># Import the class
</span>
<span class="c1"># httpbin has a digest auth endpoint
# user='testuser', pass='testpass'
</span><span class="n">url</span> <span class="o">=</span> <span class="s">'https://httpbin.org/digest-auth/auth/testuser/testpass'</span>

<span class="c1"># Create an HTTPDigestAuth object
</span><span class="n">digest_auth</span> <span class="o">=</span> <span class="n">HTTPDigestAuth</span><span class="p">(</span><span class="s">'testuser'</span><span class="p">,</span> <span class="s">'testpass'</span><span class="p">)</span>

<span class="c1"># Pass the auth object to the 'auth' parameter
</span><span class="k">print</span><span class="p">(</span><span class="s">"Attempting with HTTPDigestAuth object..."</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">auth</span><span class="o">=</span><span class="n">digest_auth</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Status Code: </span><span class="si">{</span><span class="n">response</span><span class="p">.</span><span class="n">status_code</span><span class="si">}</span><span class="s">"</span><span class="p">)</span> <span class="c1"># Expect 200
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"Response JSON:"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">json</span><span class="p">())</span>
    <span class="c1"># Note: It might take two requests internally for Digest Auth
</span>    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Request History (if any): </span><span class="si">{</span><span class="n">response</span><span class="p">.</span><span class="n">history</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">except</span> <span class="n">requests</span><span class="p">.</span><span class="n">exceptions</span><span class="p">.</span><span class="n">RequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"An error occurred: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

</code></pre></div></div>

<p><strong>Output:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Attempting with HTTPDigestAuth object...
Status Code: 200
Response JSON:
{'authenticated': True, 'user': 'testuser'}
Request History (if any): [&lt;Response [401]&gt;]
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li>We used <code class="language-plaintext highlighter-rouge">HTTPDigestAuth</code> this time.</li>
  <li>When <code class="language-plaintext highlighter-rouge">requests</code> first tries to access the URL, the server challenges it with a <code class="language-plaintext highlighter-rouge">401 Unauthorized</code> response containing details needed for Digest Auth (like a <code class="language-plaintext highlighter-rouge">nonce</code> and <code class="language-plaintext highlighter-rouge">realm</code>). You can see this <code class="language-plaintext highlighter-rouge">401</code> response in <code class="language-plaintext highlighter-rouge">response.history</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">HTTPDigestAuth</code> handler catches this <code class="language-plaintext highlighter-rouge">401</code>, uses the challenge information and your password to calculate the correct response, and automatically sends a <em>second</em> request with the proper <code class="language-plaintext highlighter-rouge">Authorization: Digest ...</code> header.</li>
  <li>This second request succeeds, and you get the final <code class="language-plaintext highlighter-rouge">200 OK</code> response.</li>
</ol>

<p><code class="language-plaintext highlighter-rouge">Requests</code> handles the two-step process automatically when you use <code class="language-plaintext highlighter-rouge">HTTPDigestAuth</code>.</p>

<h3 id="persistent-authentication-with-sessions">Persistent Authentication with Sessions</h3>

<p>If you need to make multiple requests to the same server using the same authentication, it’s much more efficient to set the authentication on a <a href="03_session.md">Session</a> object. The session will then automatically apply the authentication to <em>all</em> requests made through it.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">requests.auth</span> <span class="kn">import</span> <span class="n">HTTPBasicAuth</span>

<span class="n">basic_auth_url</span> <span class="o">=</span> <span class="s">'https://httpbin.org/basic-auth/testuser/testpass'</span>
<span class="n">headers_url</span> <span class="o">=</span> <span class="s">'https://httpbin.org/headers'</span> <span class="c1"># Just to see headers sent
</span>
<span class="c1"># Create a session
</span><span class="k">with</span> <span class="n">requests</span><span class="p">.</span><span class="n">Session</span><span class="p">()</span> <span class="k">as</span> <span class="n">s</span><span class="p">:</span>
    <span class="c1"># Set the authentication ONCE on the session
</span>    <span class="n">s</span><span class="p">.</span><span class="n">auth</span> <span class="o">=</span> <span class="n">HTTPBasicAuth</span><span class="p">(</span><span class="s">'testuser'</span><span class="p">,</span> <span class="s">'testpass'</span><span class="p">)</span>
    <span class="c1"># Or: s.auth = ('testuser', 'testpass')
</span>
    <span class="c1"># Make the first request (auth will be added automatically)
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"Making first request using session auth..."</span><span class="p">)</span>
    <span class="n">response1</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">basic_auth_url</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Status Code 1: </span><span class="si">{</span><span class="n">response1</span><span class="p">.</span><span class="n">status_code</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

    <span class="c1"># Make a second request to a different endpoint (auth will also be added)
</span>    <span class="c1"># We use /headers to see the Authorization header being sent
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Making second request using session auth..."</span><span class="p">)</span>
    <span class="n">response2</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">headers_url</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Status Code 2: </span><span class="si">{</span><span class="n">response2</span><span class="p">.</span><span class="n">status_code</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Headers sent in second request:"</span><span class="p">)</span>
    <span class="c1"># Look for the 'Authorization' header in the output
</span>    <span class="k">print</span><span class="p">(</span><span class="n">response2</span><span class="p">.</span><span class="n">json</span><span class="p">()[</span><span class="s">'headers'</span><span class="p">])</span>
</code></pre></div></div>

<p><strong>Output:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Making first request using session auth...
Status Code 1: 200

Making second request using session auth...
Status Code 2: 200
Headers sent in second request:
{
  "Accept": "*/*",
  "Accept-Encoding": "gzip, deflate",
  "Authorization": "Basic dGVzdHVzZXI6dGVzdHBhc3M=", // &lt;-- Auth header added automatically!
  "Host": "httpbin.org",
  "User-Agent": "python-requests/2.x.y",
  "X-Amzn-Trace-Id": "Root=..."
}
</code></pre></div></div>

<p>By setting <code class="language-plaintext highlighter-rouge">s.auth = ...</code>, we ensured that <em>both</em> requests sent the <code class="language-plaintext highlighter-rouge">Authorization</code> header without needing to specify it in each <code class="language-plaintext highlighter-rouge">s.get()</code> call.</p>

<h3 id="custom-authentication">Custom Authentication</h3>

<p>What if a service uses a completely different way to authenticate? <code class="language-plaintext highlighter-rouge">Requests</code> allows you to create your own authentication handler by writing a class that inherits from <code class="language-plaintext highlighter-rouge">requests.auth.AuthBase</code> and implements the <code class="language-plaintext highlighter-rouge">__call__</code> method. This method receives the <code class="language-plaintext highlighter-rouge">PreparedRequest</code> object and should modify it (usually by adding headers) as needed.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">requests.auth</span> <span class="kn">import</span> <span class="n">AuthBase</span>

<span class="k">class</span> <span class="nc">MyCustomApiKeyAuth</span><span class="p">(</span><span class="n">AuthBase</span><span class="p">):</span>
    <span class="s">"""Attaches a custom API Key header to the request."""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">api_key</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">api_key</span> <span class="o">=</span> <span class="n">api_key</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="c1"># 'r' is the PreparedRequest object
</span>        <span class="c1"># Modify the request 'r' here. We'll add a header.
</span>        <span class="n">r</span><span class="p">.</span><span class="n">headers</span><span class="p">[</span><span class="s">'X-API-Key'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">api_key</span>
        <span class="c1"># We MUST return the modified request object
</span>        <span class="k">return</span> <span class="n">r</span>

<span class="c1"># Usage:
# api_key = "YOUR_SECRET_API_KEY"
# response = requests.get(some_url, auth=MyCustomApiKeyAuth(api_key))
</span></code></pre></div></div>

<p>This is more advanced, but it shows the flexibility of the <code class="language-plaintext highlighter-rouge">requests</code> auth system. Many third-party libraries use this pattern to provide auth helpers for specific services (like OAuth).</p>

<h2 id="how-it-works-internally">How It Works Internally</h2>

<p>How does <code class="language-plaintext highlighter-rouge">requests</code> take the <code class="language-plaintext highlighter-rouge">auth</code> parameter and turn it into the correct <code class="language-plaintext highlighter-rouge">Authorization</code> header?</p>

<ol>
  <li><strong>Preparation Step:</strong> When you make a request (e.g., <code class="language-plaintext highlighter-rouge">requests.get(url, auth=...)</code> or <code class="language-plaintext highlighter-rouge">s.request(...)</code>), the <code class="language-plaintext highlighter-rouge">Request</code> object is turned into a <code class="language-plaintext highlighter-rouge">PreparedRequest</code> as we saw in <a href="02_request___response_models.md">Chapter 2: Request &amp; Response Models</a>. Part of this preparation involves the <code class="language-plaintext highlighter-rouge">prepare_auth</code> method.</li>
  <li><strong>Check Auth Type:</strong> Inside <code class="language-plaintext highlighter-rouge">prepare_auth</code>, <code class="language-plaintext highlighter-rouge">requests</code> checks the <code class="language-plaintext highlighter-rouge">auth</code> parameter.
    <ul>
      <li>If <code class="language-plaintext highlighter-rouge">auth</code> is a tuple <code class="language-plaintext highlighter-rouge">(user, pass)</code>, it automatically wraps it in an <code class="language-plaintext highlighter-rouge">HTTPBasicAuth(user, pass)</code> object.</li>
      <li>If <code class="language-plaintext highlighter-rouge">auth</code> is already an object (like <code class="language-plaintext highlighter-rouge">HTTPBasicAuth</code>, <code class="language-plaintext highlighter-rouge">HTTPDigestAuth</code>, or a custom one inheriting from <code class="language-plaintext highlighter-rouge">AuthBase</code>), it uses that object directly.</li>
    </ul>
  </li>
  <li><strong>Call the Auth Object:</strong> All authentication handler objects (including the built-in ones) are <strong>callable</strong>. This means they have a <code class="language-plaintext highlighter-rouge">__call__</code> method. The <code class="language-plaintext highlighter-rouge">prepare_auth</code> step <em>calls</em> the auth object, passing the <code class="language-plaintext highlighter-rouge">PreparedRequest</code> object (<code class="language-plaintext highlighter-rouge">p</code>) to it: <code class="language-plaintext highlighter-rouge">auth(p)</code>.</li>
  <li><strong>Modify the Request:</strong> The <code class="language-plaintext highlighter-rouge">__call__</code> method of the auth object does the actual work.
    <ul>
      <li>For <code class="language-plaintext highlighter-rouge">HTTPBasicAuth</code>, the <code class="language-plaintext highlighter-rouge">__call__</code> method calculates the <code class="language-plaintext highlighter-rouge">Basic base64(user:pass)</code> string and sets <code class="language-plaintext highlighter-rouge">p.headers['Authorization'] = ...</code>.</li>
      <li>For <code class="language-plaintext highlighter-rouge">HTTPDigestAuth</code>, the <code class="language-plaintext highlighter-rouge">__call__</code> method might initially set up hooks to handle the <code class="language-plaintext highlighter-rouge">401</code> challenge, or if it already has the necessary info (like a <code class="language-plaintext highlighter-rouge">nonce</code>), it calculates the <code class="language-plaintext highlighter-rouge">Digest ...</code> header and sets <code class="language-plaintext highlighter-rouge">p.headers['Authorization']</code>.</li>
      <li>For a custom auth object, its <code class="language-plaintext highlighter-rouge">__call__</code> method performs whatever modifications are needed (e.g., adding an <code class="language-plaintext highlighter-rouge">X-API-Key</code> header).</li>
    </ul>
  </li>
  <li><strong>Return Modified Request:</strong> The <code class="language-plaintext highlighter-rouge">__call__</code> method <em>must</em> return the modified <code class="language-plaintext highlighter-rouge">PreparedRequest</code> object.</li>
  <li><strong>Send Request:</strong> The <code class="language-plaintext highlighter-rouge">PreparedRequest</code>, now potentially including an <code class="language-plaintext highlighter-rouge">Authorization</code> header, is sent to the server.</li>
</ol>

<p>Here’s a simplified sequence diagram for Basic Auth:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant UserCode as Your Code
    participant ReqFunc as requests.get / Session.request
    participant PrepReq as PreparedRequest
    participant AuthObj as HTTPBasicAuth Instance
    participant Server

    UserCode-&gt;&gt;ReqFunc: Call get(url, auth=('user', 'pass'))
    ReqFunc-&gt;&gt;PrepReq: Create PreparedRequest (p)
    ReqFunc-&gt;&gt;PrepReq: Call p.prepare_auth(auth=...)
    Note over PrepReq: Detects tuple, creates HTTPBasicAuth('user', 'pass')
    PrepReq-&gt;&gt;AuthObj: Call auth_obj(p)
    activate AuthObj
    AuthObj-&gt;&gt;AuthObj: Calculate 'Basic ...' string
    AuthObj-&gt;&gt;PrepReq: Set p.headers['Authorization'] = 'Basic ...'
    AuthObj--&gt;&gt;PrepReq: Return modified p
    deactivate AuthObj
    PrepReq--&gt;&gt;ReqFunc: Return prepared request p
    ReqFunc-&gt;&gt;Server: Send HTTP Request (with Authorization header)
    Server--&gt;&gt;ReqFunc: Send HTTP Response
    ReqFunc--&gt;&gt;UserCode: Return Response
</code></pre>

<p>Let’s look at the simplified code in <code class="language-plaintext highlighter-rouge">requests/auth.py</code> for <code class="language-plaintext highlighter-rouge">HTTPBasicAuth</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File: requests/auth.py (Simplified)
</span>
<span class="kn">from</span> <span class="nn">base64</span> <span class="kn">import</span> <span class="n">b64encode</span>
<span class="kn">from</span> <span class="nn">._internal_utils</span> <span class="kn">import</span> <span class="n">to_native_string</span>

<span class="k">def</span> <span class="nf">_basic_auth_str</span><span class="p">(</span><span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="p">):</span>
    <span class="s">"""Returns a Basic Auth string."""</span>
    <span class="c1"># ... (handle encoding username/password to bytes) ...
</span>    <span class="n">auth_bytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s">":"</span><span class="p">.</span><span class="n">join</span><span class="p">((</span><span class="n">username_bytes</span><span class="p">,</span> <span class="n">password_bytes</span><span class="p">))</span>
    <span class="n">auth_b64</span> <span class="o">=</span> <span class="n">b64encode</span><span class="p">(</span><span class="n">auth_bytes</span><span class="p">).</span><span class="n">strip</span><span class="p">()</span>
    <span class="c1"># Return native string (str in Py3) e.g., "Basic dXNlcjpwYXNz"
</span>    <span class="k">return</span> <span class="s">"Basic "</span> <span class="o">+</span> <span class="n">to_native_string</span><span class="p">(</span><span class="n">auth_b64</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">AuthBase</span><span class="p">:</span>
    <span class="s">"""Base class that all auth implementations derive from"""</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="c1"># This method MUST be overridden by subclasses
</span>        <span class="k">raise</span> <span class="nb">NotImplementedError</span><span class="p">(</span><span class="s">"Auth hooks must be callable."</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">HTTPBasicAuth</span><span class="p">(</span><span class="n">AuthBase</span><span class="p">):</span>
    <span class="s">"""Attaches HTTP Basic Authentication to the given Request object."""</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">username</span> <span class="o">=</span> <span class="n">username</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">password</span> <span class="o">=</span> <span class="n">password</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="c1"># 'r' is the PreparedRequest object passed in by requests
</span>        <span class="c1"># Calculate the Basic auth string
</span>        <span class="n">auth_header_value</span> <span class="o">=</span> <span class="n">_basic_auth_str</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">username</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">password</span><span class="p">)</span>
        <span class="c1"># Modify the request's headers
</span>        <span class="n">r</span><span class="p">.</span><span class="n">headers</span><span class="p">[</span><span class="s">'Authorization'</span><span class="p">]</span> <span class="o">=</span> <span class="n">auth_header_value</span>
        <span class="c1"># Return the modified request
</span>        <span class="k">return</span> <span class="n">r</span>

<span class="k">class</span> <span class="nc">HTTPProxyAuth</span><span class="p">(</span><span class="n">HTTPBasicAuth</span><span class="p">):</span>
    <span class="s">"""Attaches HTTP Proxy Authentication to a given Request object."""</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="c1"># Same as Basic Auth, but sets the Proxy-Authorization header
</span>        <span class="n">r</span><span class="p">.</span><span class="n">headers</span><span class="p">[</span><span class="s">'Proxy-Authorization'</span><span class="p">]</span> <span class="o">=</span> <span class="n">_basic_auth_str</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">username</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">password</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>

<span class="c1"># HTTPDigestAuth is more complex, involving state and hooks for the 401 challenge
</span><span class="k">class</span> <span class="nc">HTTPDigestAuth</span><span class="p">(</span><span class="n">AuthBase</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">username</span><span class="p">,</span> <span class="n">password</span><span class="p">):</span>
        <span class="c1"># ... store username/password ...
</span>        <span class="c1"># ... initialize state (nonce, etc.) ...
</span>        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">build_digest_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="c1"># ... complex calculation based on nonce, realm, qop, etc. ...
</span>        <span class="k">return</span> <span class="s">"Digest ..."</span> <span class="c1"># Calculated digest header
</span>
    <span class="k">def</span> <span class="nf">handle_401</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Hook called when a 401 response is received
</span>        <span class="c1"># 1. Parse challenge ('WWW-Authenticate' header)
</span>        <span class="c1"># 2. Store nonce, realm etc.
</span>        <span class="c1"># 3. Prepare a *new* request with the calculated digest header
</span>        <span class="c1"># 4. Send the new request
</span>        <span class="c1"># 5. Return the response to the *new* request
</span>        <span class="k">pass</span> <span class="c1"># Simplified
</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="c1"># 'r' is the PreparedRequest
</span>        <span class="c1"># If we already have a nonce, add the Authorization header directly
</span>        <span class="k">if</span> <span class="bp">self</span><span class="p">.</span><span class="n">has_nonce</span><span class="p">():</span>
            <span class="n">r</span><span class="p">.</span><span class="n">headers</span><span class="p">[</span><span class="s">'Authorization'</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">build_digest_header</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">method</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">url</span><span class="p">)</span>
        <span class="c1"># Register the handle_401 hook to handle the server challenge if needed
</span>        <span class="n">r</span><span class="p">.</span><span class="n">register_hook</span><span class="p">(</span><span class="s">'response'</span><span class="p">,</span> <span class="bp">self</span><span class="p">.</span><span class="n">handle_401</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>
</code></pre></div></div>

<p>And in <code class="language-plaintext highlighter-rouge">requests/models.py</code>, the <code class="language-plaintext highlighter-rouge">PreparedRequest</code> calls the auth object:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File: requests/models.py (Simplified View)
</span>
<span class="kn">from</span> <span class="nn">.auth</span> <span class="kn">import</span> <span class="n">HTTPBasicAuth</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">get_auth_from_url</span>

<span class="k">class</span> <span class="nc">PreparedRequest</span><span class="p">(</span><span class="n">RequestEncodingMixin</span><span class="p">,</span> <span class="n">RequestHooksMixin</span><span class="p">):</span>
    <span class="c1"># ... (other prepare methods like prepare_url, prepare_headers) ...
</span>
    <span class="k">def</span> <span class="nf">prepare_auth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">auth</span><span class="p">,</span> <span class="n">url</span><span class="o">=</span><span class="s">""</span><span class="p">):</span>
        <span class="s">"""Prepares the given HTTP auth data."""</span>

        <span class="c1"># If no Auth provided, maybe get it from the URL (e.g., http://user:pass@host)
</span>        <span class="k">if</span> <span class="n">auth</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">url_auth</span> <span class="o">=</span> <span class="n">get_auth_from_url</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">url</span><span class="p">)</span>
            <span class="n">auth</span> <span class="o">=</span> <span class="n">url_auth</span> <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">url_auth</span><span class="p">)</span> <span class="k">else</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">auth</span><span class="p">:</span>
            <span class="c1"># If auth is a ('user', 'pass') tuple, wrap it in HTTPBasicAuth
</span>            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">auth</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">auth</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">auth</span> <span class="o">=</span> <span class="n">HTTPBasicAuth</span><span class="p">(</span><span class="o">*</span><span class="n">auth</span><span class="p">)</span>

            <span class="c1"># --- The Core Step ---
</span>            <span class="c1"># Call the auth object (which must be callable, like AuthBase subclasses)
</span>            <span class="c1"># Pass 'self' (the PreparedRequest instance) to the auth object's __call__
</span>            <span class="n">r</span> <span class="o">=</span> <span class="n">auth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

            <span class="c1"># Update self to reflect any changes made by the auth object
</span>            <span class="c1"># (Auth objects typically just modify headers, but could do more)
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">__dict__</span><span class="p">.</span><span class="n">update</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">__dict__</span><span class="p">)</span>

            <span class="c1"># Recompute Content-Length in case auth modified the body (unlikely for Basic/Digest)
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">prepare_content_length</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">body</span><span class="p">)</span>

    <span class="c1"># ... (rest of PreparedRequest) ...
</span></code></pre></div></div>

<p>The key is the <code class="language-plaintext highlighter-rouge">r = auth(self)</code> line, where the <code class="language-plaintext highlighter-rouge">PreparedRequest</code> delegates the task of adding authentication details to the specific authentication handler object provided.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve learned how <code class="language-plaintext highlighter-rouge">requests</code> handles HTTP authentication using <strong>Authentication Handlers</strong>.</p>

<ul>
  <li>You saw that authentication is like providing an <strong>ID badge</strong> with your request.</li>
  <li>You learned about common schemes like <strong>Basic Auth</strong> (using a simple <code class="language-plaintext highlighter-rouge">(user, pass)</code> tuple or <code class="language-plaintext highlighter-rouge">HTTPBasicAuth</code>) and <strong>Digest Auth</strong> (<code class="language-plaintext highlighter-rouge">HTTPDigestAuth</code>).</li>
  <li>You know how to apply authentication to single requests or persistently using a <a href="03_session.md">Session</a> object via the <code class="language-plaintext highlighter-rouge">auth</code> parameter.</li>
  <li>You understand that internally, <code class="language-plaintext highlighter-rouge">requests</code> calls the provided auth object, which modifies the <code class="language-plaintext highlighter-rouge">PreparedRequest</code> (usually by adding an <code class="language-plaintext highlighter-rouge">Authorization</code> header) before sending it.</li>
  <li>You got a glimpse of how custom authentication can be built using <code class="language-plaintext highlighter-rouge">AuthBase</code>.</li>
</ul>

<p>Authentication is crucial for accessing protected resources. But what happens when things go wrong? A server might be down, a URL might be invalid, or authentication might fail. How does <code class="language-plaintext highlighter-rouge">requests</code> tell you about these problems?</p>

<p><strong>Next:</strong> <a href="06_exception_hierarchy.md">Chapter 6: Exception Hierarchy</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
