<h1 id="chapter-7-transport-adapters---custom-delivery-routes">Chapter 7: Transport Adapters - Custom Delivery Routes</h1>

<p>In the previous chapter, <a href="06_exception_hierarchy.md">Chapter 6: Exception Hierarchy</a>, we learned how <code class="language-plaintext highlighter-rouge">requests</code> signals problems like network errors or bad responses. Most of the time, we rely on the default way <code class="language-plaintext highlighter-rouge">requests</code> handles sending our requests and managing connections.</p>

<p>But what if the default way isn’t quite right for a specific website or service? What if you need to tell <code class="language-plaintext highlighter-rouge">requests</code> <em>exactly</em> how to handle connections or retries for URLs starting with <code class="language-plaintext highlighter-rouge">http://</code> or <code class="language-plaintext highlighter-rouge">https://</code>, or maybe even for a completely custom scheme like <code class="language-plaintext highlighter-rouge">myprotocol://</code>?</p>

<h2 id="the-problem-needing-special-handling">The Problem: Needing Special Handling</h2>

<p>Imagine you’re interacting with an API that’s known to be a bit unreliable. Sometimes requests to it fail temporarily, but succeed if you just try again a second later. The default <code class="language-plaintext highlighter-rouge">requests</code> behavior might not retry enough times, or maybe you want to retry only on specific error codes.</p>

<p>Or perhaps you need to connect to a server using very specific security settings (SSL/TLS versions or ciphers) that aren’t the default.</p>

<p>How can you customize <em>how</em> <code class="language-plaintext highlighter-rouge">requests</code> sends requests and manages connections for specific types of URLs?</p>

<h2 id="meet-transport-adapters-the-delivery-services">Meet Transport Adapters: The Delivery Services</h2>

<p>This is where <strong>Transport Adapters</strong> come in!</p>

<p>Think of a <code class="language-plaintext highlighter-rouge">requests</code> <a href="03_session.md">Session</a> object like a customer ordering packages online. The customer (Session) wants to send a package (a web request) to a specific address (a URL).</p>

<p><strong>Transport Adapters</strong> are like the different <strong>delivery services</strong> (like FedEx, UPS, USPS, or maybe a specialized local courier) that the customer can choose from.</p>

<ul>
  <li>Each delivery service specializes in certain types of addresses or delivery methods.</li>
  <li>When the customer has a package for a specific address (e.g., starting with <code class="language-plaintext highlighter-rouge">https://</code>), they pick the appropriate delivery service registered for that address type.</li>
  <li>That delivery service then handles all the details of picking up, transporting, and delivering the package (sending the request, managing connections, handling retries, etc.).</li>
</ul>

<p>In <code class="language-plaintext highlighter-rouge">requests</code>, a Transport Adapter defines <em>how</em> requests are actually sent and connections are managed for specific <strong>URL schemes</strong> (like <code class="language-plaintext highlighter-rouge">http://</code> or <code class="language-plaintext highlighter-rouge">https://</code>).</p>

<h2 id="the-default-delivery-service-httpadapter">The Default Delivery Service: <code class="language-plaintext highlighter-rouge">HTTPAdapter</code></h2>

<p>By default, when you create a <code class="language-plaintext highlighter-rouge">Session</code> object, it automatically sets up the standard “delivery services” for web addresses:</p>

<ul>
  <li>For URLs starting with <code class="language-plaintext highlighter-rouge">https://</code>, it uses the built-in <code class="language-plaintext highlighter-rouge">requests.adapters.HTTPAdapter</code>.</li>
  <li>For URLs starting with <code class="language-plaintext highlighter-rouge">http://</code>, it also uses the <code class="language-plaintext highlighter-rouge">requests.adapters.HTTPAdapter</code>.</li>
</ul>

<p>This <code class="language-plaintext highlighter-rouge">HTTPAdapter</code> is the workhorse. It doesn’t handle the network sockets directly; instead, it uses another powerful library called <code class="language-plaintext highlighter-rouge">urllib3</code> under the hood.</p>

<p>The <code class="language-plaintext highlighter-rouge">HTTPAdapter</code> (via <code class="language-plaintext highlighter-rouge">urllib3</code>) is responsible for:</p>

<ol>
  <li><strong>Connection Pooling:</strong> Reusing existing network connections to the same host for better performance (like the delivery service keeping its trucks warm and ready for the next delivery to the same neighborhood). We saw the benefits of this in <a href="03_session.md">Chapter 3: Session</a>.</li>
  <li><strong>HTTP/HTTPS Details:</strong> Handling the specifics of the HTTP and HTTPS protocols.</li>
  <li><strong>SSL Verification:</strong> Making sure the website’s security certificate is valid for HTTPS connections.</li>
  <li><strong>Basic Retries:</strong> Handling some low-level connection retries (though often you might want more control).</li>
</ol>

<p>So, when you use a <code class="language-plaintext highlighter-rouge">Session</code> and make a <code class="language-plaintext highlighter-rouge">GET</code> request to <code class="language-plaintext highlighter-rouge">https://example.com</code>, the Session looks up the adapter for <code class="language-plaintext highlighter-rouge">https://</code>, finds the default <code class="language-plaintext highlighter-rouge">HTTPAdapter</code>, and hands the request off to it for delivery.</p>

<h2 id="mounting-adapters-choosing-your-delivery-service">Mounting Adapters: Choosing Your Delivery Service</h2>

<p>How does a <code class="language-plaintext highlighter-rouge">Session</code> know which adapter to use for which URL prefix? It uses a mechanism called <strong>mounting</strong>.</p>

<p>Think of it like telling your <code class="language-plaintext highlighter-rouge">Session</code> customer: “For any address starting with <code class="language-plaintext highlighter-rouge">https://</code>, use this specific delivery service (adapter).”</p>

<p>A <code class="language-plaintext highlighter-rouge">Session</code> object has an <code class="language-plaintext highlighter-rouge">adapters</code> attribute, which is an ordered dictionary. You use the <code class="language-plaintext highlighter-rouge">session.mount(prefix, adapter)</code> method to register an adapter for a given URL prefix.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">requests.adapters</span> <span class="kn">import</span> <span class="n">HTTPAdapter</span>

<span class="c1"># Create a session
</span><span class="n">s</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">Session</span><span class="p">()</span>

<span class="c1"># See the default adapters that are already mounted
</span><span class="k">print</span><span class="p">(</span><span class="s">"Default Adapters:"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">adapters</span><span class="p">)</span>

<span class="c1"># Create a *new* instance of the default HTTPAdapter
# (Maybe we'll configure it later)
</span><span class="n">custom_adapter</span> <span class="o">=</span> <span class="n">HTTPAdapter</span><span class="p">()</span>

<span class="c1"># Mount this adapter for a specific website
# Now, any request to this specific host via HTTPS will use our custom_adapter
</span><span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Mounting custom adapter for https://httpbin.org"</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="n">mount</span><span class="p">(</span><span class="s">'https://httpbin.org'</span><span class="p">,</span> <span class="n">custom_adapter</span><span class="p">)</span>

<span class="c1"># Let's mount another one for all HTTP traffic
</span><span class="n">plain_http_adapter</span> <span class="o">=</span> <span class="n">HTTPAdapter</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Mounting another adapter for all http://"</span><span class="p">)</span>
<span class="n">s</span><span class="p">.</span><span class="n">mount</span><span class="p">(</span><span class="s">'http://'</span><span class="p">,</span> <span class="n">plain_http_adapter</span><span class="p">)</span>

<span class="c1"># Check the adapters again (they are ordered by prefix length, longest first)
</span><span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Adapters after mounting:"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">adapters</span><span class="p">)</span>

<span class="c1"># When we make a request, the session finds the best matching prefix
</span><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">Adapter for 'https://httpbin.org/get': </span><span class="si">{</span><span class="n">s</span><span class="p">.</span><span class="n">get_adapter</span><span class="p">(</span><span class="s">'https</span><span class="si">:</span><span class="o">//</span><span class="n">httpbin</span><span class="p">.</span><span class="n">org</span><span class="o">/</span><span class="n">get</span><span class="s">')</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Adapter for 'http://example.com': </span><span class="si">{</span><span class="n">s</span><span class="p">.</span><span class="n">get_adapter</span><span class="p">(</span><span class="s">'http</span><span class="si">:</span><span class="o">//</span><span class="n">example</span><span class="p">.</span><span class="n">com</span><span class="s">')</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Adapter for 'https://google.com': </span><span class="si">{</span><span class="n">s</span><span class="p">.</span><span class="n">get_adapter</span><span class="p">(</span><span class="s">'https</span><span class="si">:</span><span class="o">//</span><span class="n">google</span><span class="p">.</span><span class="n">com</span><span class="s">')</span><span class="si">}</span><span class="s">"</span><span class="p">)</span> <span class="c1"># Uses default https://
</span></code></pre></div></div>

<p><strong>Output:</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Default Adapters:
OrderedDict([('https://', &lt;requests.adapters.HTTPAdapter object at 0x...&gt;), ('http://', &lt;requests.adapters.HTTPAdapter object at 0x...&gt;)])

Mounting custom adapter for https://httpbin.org
Mounting another adapter for all http://

Adapters after mounting:
OrderedDict([('https://httpbin.org', &lt;requests.adapters.HTTPAdapter object at 0x...&gt;), ('https://', &lt;requests.adapters.HTTPAdapter object at 0x...&gt;), ('http://', &lt;requests.adapters.HTTPAdapter object at 0x...&gt;)])

Adapter for 'https://httpbin.org/get': &lt;requests.adapters.HTTPAdapter object at 0x...&gt;
Adapter for 'http://example.com': &lt;requests.adapters.HTTPAdapter object at 0x...&gt;
Adapter for 'https://google.com': &lt;requests.adapters.HTTPAdapter object at 0x...&gt;
</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li>Initially, the session has default <code class="language-plaintext highlighter-rouge">HTTPAdapter</code> instances mounted for <code class="language-plaintext highlighter-rouge">https://</code> and <code class="language-plaintext highlighter-rouge">http://</code>.</li>
  <li>We created new <code class="language-plaintext highlighter-rouge">HTTPAdapter</code> instances.</li>
  <li>We used <code class="language-plaintext highlighter-rouge">s.mount('https://httpbin.org', custom_adapter)</code>. Now, requests to <code class="language-plaintext highlighter-rouge">https://httpbin.org/anything</code> will use <code class="language-plaintext highlighter-rouge">custom_adapter</code>.</li>
  <li>We used <code class="language-plaintext highlighter-rouge">s.mount('http://', plain_http_adapter)</code>. This <em>replaced</em> the original default adapter for <code class="language-plaintext highlighter-rouge">http://</code>.</li>
  <li>Requests to other HTTPS sites like <code class="language-plaintext highlighter-rouge">https://google.com</code> will still use the original default adapter mounted for the shorter <code class="language-plaintext highlighter-rouge">https://</code> prefix.</li>
  <li>The <code class="language-plaintext highlighter-rouge">s.get_adapter(url)</code> method shows how the session selects the adapter based on the longest matching prefix.</li>
</ol>

<h2 id="use-case-customizing-retries">Use Case: Customizing Retries</h2>

<p>Let’s go back to the unreliable API example. We want to configure <code class="language-plaintext highlighter-rouge">requests</code> to automatically retry requests to <code class="language-plaintext highlighter-rouge">https://flaky-api.example.com</code> up to 5 times if certain errors occur (like temporary server errors or connection issues).</p>

<p>The <code class="language-plaintext highlighter-rouge">HTTPAdapter</code>’s retry logic is controlled by a <code class="language-plaintext highlighter-rouge">Retry</code> object from the underlying <code class="language-plaintext highlighter-rouge">urllib3</code> library. We can create our own <code class="language-plaintext highlighter-rouge">Retry</code> object with custom settings and pass it to a <em>new</em> <code class="language-plaintext highlighter-rouge">HTTPAdapter</code> instance.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">requests.adapters</span> <span class="kn">import</span> <span class="n">HTTPAdapter</span>
<span class="kn">from</span> <span class="nn">urllib3.util.retry</span> <span class="kn">import</span> <span class="n">Retry</span> <span class="c1"># Import the Retry class
</span>
<span class="c1"># 1. Configure the retry strategy
#    - total=5: Try up to 5 times in total
#    - backoff_factor=0.5: Wait 0.5s, 1s, 2s, 4s between retries
#    - status_forcelist=[500, 502, 503, 504]: Only retry on these HTTP status codes
#    - allowed_methods=False: Retry for all methods (GET, POST, etc.) by default. Use ["GET", "POST"] to restrict.
</span><span class="n">retry_strategy</span> <span class="o">=</span> <span class="n">Retry</span><span class="p">(</span>
    <span class="n">total</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span>
    <span class="n">backoff_factor</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
    <span class="n">status_forcelist</span><span class="o">=</span><span class="p">[</span><span class="mi">500</span><span class="p">,</span> <span class="mi">502</span><span class="p">,</span> <span class="mi">503</span><span class="p">,</span> <span class="mi">504</span><span class="p">],</span>
    <span class="c1"># allowed_methods=False # Default includes most common methods
</span><span class="p">)</span>

<span class="c1"># 2. Create an HTTPAdapter with this retry strategy
#    The 'max_retries' argument accepts a Retry object
</span><span class="n">adapter_with_retries</span> <span class="o">=</span> <span class="n">HTTPAdapter</span><span class="p">(</span><span class="n">max_retries</span><span class="o">=</span><span class="n">retry_strategy</span><span class="p">)</span>

<span class="c1"># 3. Create a Session
</span><span class="n">session</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">Session</span><span class="p">()</span>

<span class="c1"># 4. Mount the adapter for the specific API prefix
</span><span class="n">api_base_url</span> <span class="o">=</span> <span class="s">'https://flaky-api.example.com/'</span> <span class="c1"># Use the base URL prefix
</span><span class="n">session</span><span class="p">.</span><span class="n">mount</span><span class="p">(</span><span class="n">api_base_url</span><span class="p">,</span> <span class="n">adapter_with_retries</span><span class="p">)</span>

<span class="c1"># 5. Now, use the session to make requests to the flaky API
</span><span class="n">api_endpoint</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">api_base_url</span><span class="si">}</span><span class="s">data"</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Making request to </span><span class="si">{</span><span class="n">api_endpoint</span><span class="si">}</span><span class="s"> with custom retries..."</span><span class="p">)</span>

<span class="k">try</span><span class="p">:</span>
    <span class="c1"># Imagine this API sometimes returns 503 Service Unavailable
</span>    <span class="n">response</span> <span class="o">=</span> <span class="n">session</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">api_endpoint</span><span class="p">)</span>
    <span class="n">response</span><span class="p">.</span><span class="n">raise_for_status</span><span class="p">()</span> <span class="c1"># Check for HTTP errors
</span>    <span class="k">print</span><span class="p">(</span><span class="s">"Success!"</span><span class="p">)</span>
    <span class="c1"># print(response.json()) # Process the successful response
</span><span class="k">except</span> <span class="n">requests</span><span class="p">.</span><span class="n">exceptions</span><span class="p">.</span><span class="n">RequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Request failed after retries: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

<span class="c1"># Requests to other domains will use the default adapter/retries
</span><span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">Making request to a different site (default retries)..."</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">response_other</span> <span class="o">=</span> <span class="n">session</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">'https://httpbin.org/get'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Status for httpbin: </span><span class="si">{</span><span class="n">response_other</span><span class="p">.</span><span class="n">status_code</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">except</span> <span class="n">requests</span><span class="p">.</span><span class="n">exceptions</span><span class="p">.</span><span class="n">RequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Httpbin request failed: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>

</code></pre></div></div>

<p><strong>Explanation:</strong></p>

<ol>
  <li>We defined our desired retry behavior using <code class="language-plaintext highlighter-rouge">urllib3.util.retry.Retry</code>.</li>
  <li>We created a <em>new</em> <code class="language-plaintext highlighter-rouge">HTTPAdapter</code>, passing our <code class="language-plaintext highlighter-rouge">retry_strategy</code> to its <code class="language-plaintext highlighter-rouge">max_retries</code> parameter during initialization.</li>
  <li>We created a <code class="language-plaintext highlighter-rouge">Session</code>.</li>
  <li>Crucially, we <code class="language-plaintext highlighter-rouge">mount</code>ed our <code class="language-plaintext highlighter-rouge">adapter_with_retries</code> specifically to the base URL of the flaky API (<code class="language-plaintext highlighter-rouge">https://flaky-api.example.com/</code>).</li>
  <li>When <code class="language-plaintext highlighter-rouge">session.get(api_endpoint)</code> is called, the Session sees that the URL starts with the mounted prefix, so it uses our <code class="language-plaintext highlighter-rouge">adapter_with_retries</code>. If the server returns a <code class="language-plaintext highlighter-rouge">503</code> error, this adapter (using the <code class="language-plaintext highlighter-rouge">Retry</code> object) will automatically wait and try again, up to 5 times.</li>
  <li>Requests to <code class="language-plaintext highlighter-rouge">https://httpbin.org</code> don’t match the specific prefix, so they fall back to the default adapter mounted for <code class="language-plaintext highlighter-rouge">https://</code>, which has default retry behavior.</li>
</ol>

<p>This allows fine-grained control over connection handling for different destinations.</p>

<h2 id="how-it-works-internally-the-session-adapter-dance">How It Works Internally: The Session-Adapter Dance</h2>

<p>Let’s trace the steps when you call <code class="language-plaintext highlighter-rouge">session.get(url)</code>:</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">Session.request</code>:</strong> Your <code class="language-plaintext highlighter-rouge">session.get(url, ...)</code> call ends up in the main <code class="language-plaintext highlighter-rouge">Session.request</code> method.</li>
  <li><strong>Prepare Request:</strong> <code class="language-plaintext highlighter-rouge">Session.request</code> creates a <code class="language-plaintext highlighter-rouge">Request</code> object and calls <code class="language-plaintext highlighter-rouge">self.prepare_request(req)</code> to turn it into a <code class="language-plaintext highlighter-rouge">PreparedRequest</code>, merging session-level settings like headers and cookies (as seen in <a href="03_session.md">Chapter 3: Session</a>).</li>
  <li><strong>Merge Environment Settings:</strong> <code class="language-plaintext highlighter-rouge">Session.request</code> calls <code class="language-plaintext highlighter-rouge">self.merge_environment_settings(...)</code> to figure out final settings for proxies, SSL verification (<code class="language-plaintext highlighter-rouge">verify</code>), etc.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Session.send</code>:</strong> The prepared request (<code class="language-plaintext highlighter-rouge">prep</code>) and final settings (<code class="language-plaintext highlighter-rouge">send_kwargs</code>) are passed to <code class="language-plaintext highlighter-rouge">self.send(prep, **send_kwargs)</code>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">get_adapter</code>:</strong> Inside <code class="language-plaintext highlighter-rouge">Session.send</code>, the first crucial step is <code class="language-plaintext highlighter-rouge">adapter = self.get_adapter(url=request.url)</code>. This method looks through the <code class="language-plaintext highlighter-rouge">self.adapters</code> dictionary (which is ordered from longest prefix to shortest) and returns the <em>first</em> adapter whose mounted prefix matches the beginning of the request’s URL.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">adapter.send</code>:</strong> The <code class="language-plaintext highlighter-rouge">Session</code> then calls the <code class="language-plaintext highlighter-rouge">send</code> method <em>on the chosen adapter</em>: <code class="language-plaintext highlighter-rouge">r = adapter.send(request, **kwargs)</code>. <strong>This is the handover!</strong> The Session delegates the actual sending to the Transport Adapter.</li>
  <li><strong>Adapter Does the Work:</strong> The adapter (e.g., <code class="language-plaintext highlighter-rouge">HTTPAdapter</code>) takes over.
    <ul>
      <li>It interacts with its <code class="language-plaintext highlighter-rouge">urllib3.PoolManager</code> to get a connection from the pool (or create one).</li>
      <li>It configures SSL/TLS context based on <code class="language-plaintext highlighter-rouge">verify</code> and <code class="language-plaintext highlighter-rouge">cert</code> parameters.</li>
      <li>It uses <code class="language-plaintext highlighter-rouge">urllib3</code> to send the actual HTTP request bytes over the network.</li>
      <li>It applies retry logic (using the <code class="language-plaintext highlighter-rouge">Retry</code> object if configured) if <code class="language-plaintext highlighter-rouge">urllib3</code> reports certain connection errors or status codes.</li>
      <li>It receives the raw HTTP response bytes from <code class="language-plaintext highlighter-rouge">urllib3</code>.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">adapter.build_response</code>:</strong> The adapter takes the raw response data from <code class="language-plaintext highlighter-rouge">urllib3</code> and constructs a <code class="language-plaintext highlighter-rouge">requests.Response</code> object using its <code class="language-plaintext highlighter-rouge">build_response(request, raw_urllib3_response)</code> method. This involves parsing status codes, headers, and making the response body available.</li>
  <li><strong>Return Response:</strong> The <code class="language-plaintext highlighter-rouge">adapter.send</code> method returns the fully formed <code class="language-plaintext highlighter-rouge">Response</code> object back to the <code class="language-plaintext highlighter-rouge">Session.send</code> method.</li>
  <li><strong>Post-Processing:</strong> <code class="language-plaintext highlighter-rouge">Session.send</code> does some final steps, like extracting cookies from the response into the session’s <a href="04_cookie_jar.md">Cookie Jar</a> and handling redirects (which might involve calling <code class="language-plaintext highlighter-rouge">send</code> again).</li>
  <li><strong>Final Return:</strong> The final <code class="language-plaintext highlighter-rouge">Response</code> object is returned to your original <code class="language-plaintext highlighter-rouge">session.get(url)</code> call.</li>
</ol>

<p>Here’s a simplified diagram:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant UserCode as Your Code
    participant Session as Session Object
    participant Adapter as Transport Adapter
    participant Urllib3 as urllib3 Library
    participant Server

    UserCode-&gt;&gt;Session: session.get(url)
    Session-&gt;&gt;Session: prepare_request(req) -&gt; PreparedRequest (prep)
    Session-&gt;&gt;Session: merge_environment_settings() -&gt; send_kwargs
    Session-&gt;&gt;Session: get_adapter(url) -&gt; adapter_instance
    Session-&gt;&gt;Adapter: adapter_instance.send(prep, **send_kwargs)
    activate Adapter
    Adapter-&gt;&gt;Urllib3: Get connection from PoolManager
    Adapter-&gt;&gt;Urllib3: urlopen(prep.method, url, ..., retries=..., timeout=...)
    activate Urllib3
    Urllib3-&gt;&gt;Server: Send HTTP Request Bytes
    Server--&gt;&gt;Urllib3: Receive HTTP Response Bytes
    Urllib3--&gt;&gt;Adapter: Return raw urllib3 response
    deactivate Urllib3
    Adapter-&gt;&gt;Adapter: build_response(prep, raw_response) -&gt; Response (r)
    Adapter--&gt;&gt;Session: Return Response (r)
    deactivate Adapter
    Session-&gt;&gt;Session: Extract cookies, handle redirects...
    Session--&gt;&gt;UserCode: Return final Response
</code></pre>

<p>Let’s peek at the relevant code snippets:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># File: requests/sessions.py (Simplified View)
</span>
<span class="k">class</span> <span class="nc">Session</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># ... other defaults ...
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">adapters</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span> <span class="c1"># The mounted adapters
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">mount</span><span class="p">(</span><span class="s">'https://'</span><span class="p">,</span> <span class="n">HTTPAdapter</span><span class="p">())</span> <span class="c1"># Mount default HTTPS adapter
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">mount</span><span class="p">(</span><span class="s">'http://'</span><span class="p">,</span> <span class="n">HTTPAdapter</span><span class="p">())</span>  <span class="c1"># Mount default HTTP adapter
</span>
    <span class="k">def</span> <span class="nf">get_adapter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">):</span>
        <span class="s">"""Returns the appropriate connection adapter for the given URL."""</span>
        <span class="k">for</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">adapter</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">adapters</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Find the longest prefix that matches the URL
</span>            <span class="k">if</span> <span class="n">url</span><span class="p">.</span><span class="n">lower</span><span class="p">().</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">.</span><span class="n">lower</span><span class="p">()):</span>
                <span class="k">return</span> <span class="n">adapter</span>
        <span class="c1"># No match found
</span>        <span class="k">raise</span> <span class="n">InvalidSchema</span><span class="p">(</span><span class="sa">f</span><span class="s">"No connection adapters were found for </span><span class="si">{</span><span class="n">url</span><span class="si">!r}</span><span class="s">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">mount</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">adapter</span><span class="p">):</span>
        <span class="s">"""Registers a connection adapter to a prefix."""</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">adapters</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="n">adapter</span>
        <span class="c1"># Sort adapters by prefix length, descending (longest first)
</span>        <span class="c1"># Simplified: Real code sorts keys and rebuilds OrderedDict
</span>        <span class="n">keys_to_move</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">.</span><span class="n">adapters</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys_to_move</span><span class="p">:</span>
             <span class="bp">self</span><span class="p">.</span><span class="n">adapters</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">adapters</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># ... setup kwargs (stream, verify, cert, proxies) ...
</span>
        <span class="c1"># === GET THE ADAPTER ===
</span>        <span class="n">adapter</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_adapter</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="n">url</span><span class="p">)</span>

        <span class="c1"># === DELEGATE TO THE ADAPTER ===
</span>        <span class="c1"># Start timer
</span>        <span class="n">start</span> <span class="o">=</span> <span class="n">preferred_clock</span><span class="p">()</span>
        <span class="c1"># Call the adapter's send method
</span>        <span class="n">r</span> <span class="o">=</span> <span class="n">adapter</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Stop timer
</span>        <span class="n">elapsed</span> <span class="o">=</span> <span class="n">preferred_clock</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
        <span class="n">r</span><span class="p">.</span><span class="n">elapsed</span> <span class="o">=</span> <span class="n">timedelta</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="n">elapsed</span><span class="p">)</span>

        <span class="c1"># ... dispatch response hooks ...
</span>        <span class="c1"># ... persist cookies (extract_cookies_to_jar) ...
</span>        <span class="c1"># ... handle redirects (resolve_redirects, might call send again) ...
</span>
        <span class="c1"># ... maybe read content if stream=False ...
</span>        <span class="k">return</span> <span class="n">r</span>

<span class="c1"># File: requests/adapters.py (Simplified View)
</span>
<span class="kn">from</span> <span class="nn">urllib3.util.retry</span> <span class="kn">import</span> <span class="n">Retry</span>
<span class="kn">from</span> <span class="nn">urllib3.poolmanager</span> <span class="kn">import</span> <span class="n">PoolManager</span> <span class="c1"># Used internally by HTTPAdapter
</span>
<span class="k">class</span> <span class="nc">BaseAdapter</span><span class="p">:</span>
    <span class="s">"""The Base Transport Adapter"""</span>
    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">cert</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">proxies</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nb">NotImplementedError</span>
    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="nb">NotImplementedError</span>

<span class="k">class</span> <span class="nc">HTTPAdapter</span><span class="p">(</span><span class="n">BaseAdapter</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pool_connections</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">pool_maxsize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">max_retries</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pool_block</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="c1"># === STORE RETRY CONFIGURATION ===
</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">max_retries</span><span class="p">,</span> <span class="n">Retry</span><span class="p">):</span>
            <span class="bp">self</span><span class="p">.</span><span class="n">max_retries</span> <span class="o">=</span> <span class="n">max_retries</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Convert integer retries to a basic Retry object
</span>            <span class="bp">self</span><span class="p">.</span><span class="n">max_retries</span> <span class="o">=</span> <span class="n">Retry</span><span class="p">(</span><span class="n">total</span><span class="o">=</span><span class="n">max_retries</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">connect</span><span class="o">=</span><span class="n">max_retries</span><span class="p">)</span>

        <span class="c1"># ... configure pooling options ...
</span>
        <span class="c1"># === INITIALIZE URLIB3 POOL MANAGER ===
</span>        <span class="c1"># This object manages connections using urllib3
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">poolmanager</span> <span class="o">=</span> <span class="n">PoolManager</span><span class="p">(</span><span class="n">num_pools</span><span class="o">=</span><span class="n">pool_connections</span><span class="p">,</span> <span class="n">maxsize</span><span class="o">=</span><span class="n">pool_maxsize</span><span class="p">,</span> <span class="n">block</span><span class="o">=</span><span class="n">pool_block</span><span class="p">)</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">proxy_manager</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1"># For handling proxies
</span>
    <span class="k">def</span> <span class="nf">send</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">stream</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">verify</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">cert</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">proxies</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="s">"""Sends PreparedRequest object using urllib3."""</span>
        <span class="c1"># ... determine connection pool (conn) based on URL, proxies, SSL context ...
</span>        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">get_connection_with_tls_context</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">verify</span><span class="p">,</span> <span class="n">proxies</span><span class="o">=</span><span class="n">proxies</span><span class="p">,</span> <span class="n">cert</span><span class="o">=</span><span class="n">cert</span><span class="p">)</span>
        <span class="c1"># ... determine URL to use (might be different for proxies) ...
</span>        <span class="n">url</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">request_url</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">proxies</span><span class="p">)</span>
        <span class="c1"># ... configure timeout object for urllib3 ...
</span>        <span class="n">timeout_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_build_timeout</span><span class="p">(</span><span class="n">timeout</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># === CALL URLIB3 ===
</span>            <span class="c1"># This is the core network call
</span>            <span class="n">resp</span> <span class="o">=</span> <span class="n">conn</span><span class="p">.</span><span class="n">urlopen</span><span class="p">(</span>
                <span class="n">method</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="n">method</span><span class="p">,</span>
                <span class="n">url</span><span class="o">=</span><span class="n">url</span><span class="p">,</span>
                <span class="n">body</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="n">body</span><span class="p">,</span>
                <span class="n">headers</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="n">headers</span><span class="p">,</span>
                <span class="n">redirect</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="c1"># Requests handles redirects
</span>                <span class="n">assert_same_host</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                <span class="n">preload_content</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="c1"># Requests streams content
</span>                <span class="n">decode_content</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="c1"># Requests handles decoding
</span>                <span class="n">retries</span><span class="o">=</span><span class="bp">self</span><span class="p">.</span><span class="n">max_retries</span><span class="p">,</span> <span class="c1"># Pass configured retries
</span>                <span class="n">timeout</span><span class="o">=</span><span class="n">timeout_obj</span><span class="p">,</span>     <span class="c1"># Pass configured timeout
</span>                <span class="n">chunked</span><span class="o">=</span><span class="p">...</span> <span class="c1"># Determine if chunked encoding is needed
</span>            <span class="p">)</span>

        <span class="k">except</span> <span class="p">(</span><span class="n">urllib3_exceptions</span><span class="p">...)</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
            <span class="c1"># === WRAP URLIB3 EXCEPTIONS ===
</span>            <span class="c1"># Catch exceptions from urllib3 and raise corresponding
</span>            <span class="c1"># requests.exceptions (ConnectionError, Timeout, SSLError, etc.)
</span>            <span class="c1"># See Chapter 6 for details.
</span>            <span class="k">raise</span> <span class="n">MappedRequestsException</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">request</span><span class="o">=</span><span class="n">request</span><span class="p">)</span>

        <span class="c1"># === BUILD RESPONSE OBJECT ===
</span>        <span class="c1"># Convert the raw urllib3 response into a requests.Response
</span>        <span class="n">response</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">build_response</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">resp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">response</span>

    <span class="k">def</span> <span class="nf">build_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">req</span><span class="p">,</span> <span class="n">resp</span><span class="p">):</span>
        <span class="s">"""Builds a requests.Response from a urllib3 response."""</span>
        <span class="n">response</span> <span class="o">=</span> <span class="n">Response</span><span class="p">()</span>
        <span class="n">response</span><span class="p">.</span><span class="n">status_code</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">resp</span><span class="p">,</span> <span class="s">'status'</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">response</span><span class="p">.</span><span class="n">headers</span> <span class="o">=</span> <span class="n">CaseInsensitiveDict</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">resp</span><span class="p">,</span> <span class="s">'headers'</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="n">response</span><span class="p">.</span><span class="n">raw</span> <span class="o">=</span> <span class="n">resp</span> <span class="c1"># The raw urllib3 response object
</span>        <span class="n">response</span><span class="p">.</span><span class="n">reason</span> <span class="o">=</span> <span class="n">response</span><span class="p">.</span><span class="n">raw</span><span class="p">.</span><span class="n">reason</span>
        <span class="n">response</span><span class="p">.</span><span class="n">url</span> <span class="o">=</span> <span class="n">req</span><span class="p">.</span><span class="n">url</span>
        <span class="c1"># ... extract cookies, set encoding, link request ...
</span>        <span class="n">response</span><span class="p">.</span><span class="n">request</span> <span class="o">=</span> <span class="n">req</span>
        <span class="n">response</span><span class="p">.</span><span class="n">connection</span> <span class="o">=</span> <span class="bp">self</span> <span class="c1"># Link back to this adapter
</span>        <span class="k">return</span> <span class="n">response</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s">"""Close the underlying PoolManager."""</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">poolmanager</span><span class="p">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="c1"># ... close proxy managers ...
</span>
    <span class="c1"># ... other helper methods (cert_verify, proxy_manager_for, request_url) ...
</span>
</code></pre></div></div>

<p>The key idea is that the <code class="language-plaintext highlighter-rouge">Session</code> finds the right <code class="language-plaintext highlighter-rouge">Adapter</code> using <code class="language-plaintext highlighter-rouge">mount</code> prefixes, and then the <code class="language-plaintext highlighter-rouge">Adapter</code> uses <code class="language-plaintext highlighter-rouge">urllib3</code> to handle the low-level details of connection pooling, retries, and HTTP communication.</p>

<h2 id="other-use-cases">Other Use Cases</h2>

<p>Besides custom retries, you might use Transport Adapters for:</p>

<ul>
  <li><strong>Custom SSL/TLS Contexts:</strong> Create an <code class="language-plaintext highlighter-rouge">HTTPAdapter</code> and initialize its <code class="language-plaintext highlighter-rouge">PoolManager</code> with a custom <code class="language-plaintext highlighter-rouge">ssl.SSLContext</code> for fine-grained control over TLS versions, ciphers, or certificate verification logic.</li>
  <li><strong>SOCKS Proxies:</strong> While <code class="language-plaintext highlighter-rouge">requests</code> doesn’t support SOCKS natively, you can install a third-party library (like <code class="language-plaintext highlighter-rouge">requests-socks</code>) which provides a <code class="language-plaintext highlighter-rouge">SOCKSAdapter</code> that you can mount onto a session.</li>
  <li><strong>Testing:</strong> You could create a custom adapter that doesn’t actually make network requests but returns predefined responses, useful for testing your application without hitting real servers.</li>
  <li><strong>Custom Protocols:</strong> If you needed to interact with a non-HTTP protocol, you could theoretically write a custom <code class="language-plaintext highlighter-rouge">BaseAdapter</code> subclass to handle it.</li>
</ul>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve learned about <strong>Transport Adapters</strong>, the pluggable backends that <code class="language-plaintext highlighter-rouge">requests</code> uses to handle the actual sending of requests and management of connections for different URL schemes (<code class="language-plaintext highlighter-rouge">http://</code>, <code class="language-plaintext highlighter-rouge">https://</code>, etc.).</p>

<ul>
  <li>You saw the default adapter is <code class="language-plaintext highlighter-rouge">HTTPAdapter</code>, which uses <code class="language-plaintext highlighter-rouge">urllib3</code> for connection pooling, retries, and SSL.</li>
  <li>You learned how <code class="language-plaintext highlighter-rouge">Session</code> objects <code class="language-plaintext highlighter-rouge">mount</code> adapters to specific URL prefixes.</li>
  <li>You practiced customizing retry behavior by creating a new <code class="language-plaintext highlighter-rouge">HTTPAdapter</code> with a <code class="language-plaintext highlighter-rouge">urllib3.util.retry.Retry</code> object and mounting it to a session.</li>
  <li>You traced how a <code class="language-plaintext highlighter-rouge">Session</code> finds and delegates work to the appropriate adapter via <code class="language-plaintext highlighter-rouge">adapter.send</code>.</li>
</ul>

<p>Transport Adapters give you powerful, low-level control over how <code class="language-plaintext highlighter-rouge">requests</code> interacts with the network, allowing you to tailor its behavior for specific needs.</p>

<p>Adapters let you customize <em>how</em> requests are sent. What if you want to simply <em>react</em> to a request being sent or a response being received, perhaps to log it or modify it slightly on the fly? <code class="language-plaintext highlighter-rouge">Requests</code> has another mechanism for that.</p>

<p><strong>Next:</strong> <a href="08_hook_system.md">Chapter 8: The Hook System</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
