<h1 id="system-design-codebase-knowledge-builder">System Design: Codebase Knowledge Builder</h1>

<blockquote>
  <p>Please DON’T remove notes for AI</p>
</blockquote>

<h2 id="requirements">Requirements</h2>

<blockquote>
  <p>Notes for AI: Keep it simple and clear.
If the requirements are abstract, write concrete user stories</p>
</blockquote>

<p><strong>User Story:</strong> As a developer onboarding to a new codebase, I want a tutorial automatically generated from its GitHub repository or local directory, optionally in a specific language. This tutorial should explain the core abstractions, their relationships (visualized), and how they work together, using beginner-friendly language, analogies, and multi-line descriptions where needed, so I can understand the project structure and key concepts quickly without manually digging through all the code.</p>

<p><strong>Input:</strong></p>
<ul>
  <li>A publicly accessible GitHub repository URL or a local directory path.</li>
  <li>A project name (optional, will be derived from the URL/directory if not provided).</li>
  <li>Desired language for the tutorial (optional, defaults to English).</li>
</ul>

<p><strong>Output:</strong></p>
<ul>
  <li>A directory named after the project containing:
    <ul>
      <li>An <code class="language-plaintext highlighter-rouge">index.md</code> file with:
        <ul>
          <li>A high-level project summary (potentially translated).</li>
          <li>A Mermaid flowchart diagram visualizing relationships between abstractions (using potentially translated names/labels).</li>
          <li>An ordered list of links to chapter files (using potentially translated names).</li>
        </ul>
      </li>
      <li>Individual Markdown files for each chapter (<code class="language-plaintext highlighter-rouge">01_chapter_one.md</code>, <code class="language-plaintext highlighter-rouge">02_chapter_two.md</code>, etc.) detailing core abstractions in a logical order (potentially translated content).</li>
    </ul>
  </li>
</ul>

<h2 id="flow-design">Flow Design</h2>

<blockquote>
  <p>Notes for AI:</p>
  <ol>
    <li>Consider the design patterns of agent, map-reduce, rag, and workflow. Apply them if they fit.</li>
    <li>Present a concise, high-level description of the workflow.</li>
  </ol>
</blockquote>

<h3 id="applicable-design-pattern">Applicable Design Pattern:</h3>

<p>This project primarily uses a <strong>Workflow</strong> pattern to decompose the tutorial generation process into sequential steps. The chapter writing step utilizes a <strong>BatchNode</strong> (a form of MapReduce) to process each abstraction individually.</p>

<ol>
  <li><strong>Workflow:</strong> The overall process follows a defined sequence: fetch code -&gt; identify abstractions -&gt; analyze relationships -&gt; determine order -&gt; write chapters -&gt; combine tutorial into files.</li>
  <li><strong>Batch Processing:</strong> The <code class="language-plaintext highlighter-rouge">WriteChapters</code> node processes each identified abstraction independently (map) before the final tutorial files are structured (reduce).</li>
</ol>

<h3 id="flow-high-level-design">Flow high-level Design:</h3>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">FetchRepo</code></strong>: Crawls the specified GitHub repository URL or local directory using appropriate utility (<code class="language-plaintext highlighter-rouge">crawl_github_files</code> or <code class="language-plaintext highlighter-rouge">crawl_local_files</code>), retrieving relevant source code file contents.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">IdentifyAbstractions</code></strong>: Analyzes the codebase using an LLM to identify up to 10 core abstractions, generate beginner-friendly descriptions (potentially translated if language != English), and list the <em>indices</em> of files related to each abstraction.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">AnalyzeRelationships</code></strong>: Uses an LLM to analyze the identified abstractions (referenced by index) and their related code to generate a high-level project summary and describe the relationships/interactions between these abstractions (summary and labels potentially translated if language != English), specifying <em>source</em> and <em>target</em> abstraction indices and a concise label for each interaction.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">OrderChapters</code></strong>: Determines the most logical order (as indices) to present the abstractions in the tutorial, considering input context which might be translated. The output order itself is language-independent.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">WriteChapters</code> (BatchNode)</strong>: Iterates through the ordered list of abstraction indices. For each abstraction, it calls an LLM to write a detailed, beginner-friendly chapter (content potentially fully translated if language != English), using the relevant code files (accessed via indices) and summaries of previously generated chapters (potentially translated) as context.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">CombineTutorial</code></strong>: Creates an output directory, generates a Mermaid diagram from the relationship data (using potentially translated names/labels), and writes the project summary (potentially translated), relationship diagram, chapter links (using potentially translated names), and individually generated chapter files (potentially translated content) into it. Fixed text like “Chapters”, “Source Repository”, and the attribution footer remain in English.</li>
</ol>

<pre><code class="language-mermaid">flowchart TD
    A[FetchRepo] --&gt; B[IdentifyAbstractions];
    B --&gt; C[AnalyzeRelationships];
    C --&gt; D[OrderChapters];
    D --&gt; E[Batch WriteChapters];
    E --&gt; F[CombineTutorial];
</code></pre>

<h2 id="utility-functions">Utility Functions</h2>

<blockquote>
  <p>Notes for AI:</p>
  <ol>
    <li>Understand the utility function definition thoroughly by reviewing the doc.</li>
    <li>Include only the necessary utility functions, based on nodes in the flow.</li>
  </ol>
</blockquote>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">crawl_github_files</code></strong> (<code class="language-plaintext highlighter-rouge">utils/crawl_github_files.py</code>) - <em>External Dependency: requests, gitpython (optional for SSH)</em>
    <ul>
      <li><em>Input</em>: <code class="language-plaintext highlighter-rouge">repo_url</code> (str), <code class="language-plaintext highlighter-rouge">token</code> (str, optional), <code class="language-plaintext highlighter-rouge">max_file_size</code> (int, optional), <code class="language-plaintext highlighter-rouge">use_relative_paths</code> (bool, optional), <code class="language-plaintext highlighter-rouge">include_patterns</code> (set, optional), <code class="language-plaintext highlighter-rouge">exclude_patterns</code> (set, optional)</li>
      <li><em>Output</em>: <code class="language-plaintext highlighter-rouge">dict</code> containing <code class="language-plaintext highlighter-rouge">files</code> (dict[str, str]) and <code class="language-plaintext highlighter-rouge">stats</code>.</li>
      <li><em>Necessity</em>: Required by <code class="language-plaintext highlighter-rouge">FetchRepo</code> to download and read source code from GitHub if a <code class="language-plaintext highlighter-rouge">repo_url</code> is provided. Handles API calls or SSH cloning, filtering, and file reading.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">crawl_local_files</code></strong> (<code class="language-plaintext highlighter-rouge">utils/crawl_local_files.py</code>) - <em>External Dependency: None</em>
    <ul>
      <li><em>Input</em>: <code class="language-plaintext highlighter-rouge">directory</code> (str), <code class="language-plaintext highlighter-rouge">max_file_size</code> (int, optional), <code class="language-plaintext highlighter-rouge">use_relative_paths</code> (bool, optional), <code class="language-plaintext highlighter-rouge">include_patterns</code> (set, optional), <code class="language-plaintext highlighter-rouge">exclude_patterns</code> (set, optional)</li>
      <li><em>Output</em>: <code class="language-plaintext highlighter-rouge">dict</code> containing <code class="language-plaintext highlighter-rouge">files</code> (dict[str, str]).</li>
      <li><em>Necessity</em>: Required by <code class="language-plaintext highlighter-rouge">FetchRepo</code> to read source code from a local directory if a <code class="language-plaintext highlighter-rouge">local_dir</code> path is provided. Handles directory walking, filtering, and file reading.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">call_llm</code></strong> (<code class="language-plaintext highlighter-rouge">utils/call_llm.py</code>) - <em>External Dependency: LLM Provider API (e.g., Google GenAI)</em>
    <ul>
      <li><em>Input</em>: <code class="language-plaintext highlighter-rouge">prompt</code> (str), <code class="language-plaintext highlighter-rouge">use_cache</code> (bool, optional)</li>
      <li><em>Output</em>: <code class="language-plaintext highlighter-rouge">response</code> (str)</li>
      <li><em>Necessity</em>: Used by <code class="language-plaintext highlighter-rouge">IdentifyAbstractions</code>, <code class="language-plaintext highlighter-rouge">AnalyzeRelationships</code>, <code class="language-plaintext highlighter-rouge">OrderChapters</code>, and <code class="language-plaintext highlighter-rouge">WriteChapters</code> for code analysis and content generation. Needs careful prompt engineering and YAML validation (implicit via <code class="language-plaintext highlighter-rouge">yaml.safe_load</code> which raises errors).</li>
    </ul>
  </li>
</ol>

<h2 id="node-design">Node Design</h2>

<h3 id="shared-store">Shared Store</h3>

<blockquote>
  <p>Notes for AI: Try to minimize data redundancy</p>
</blockquote>

<p>The shared Store structure is organized as follows:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">shared</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># --- Inputs ---
</span>    <span class="s">"repo_url"</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="c1"># Provided by the user/main script if using GitHub
</span>    <span class="s">"local_dir"</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="c1"># Provided by the user/main script if using local directory
</span>    <span class="s">"project_name"</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="c1"># Optional, derived from repo_url/local_dir if not provided
</span>    <span class="s">"github_token"</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="c1"># Optional, from argument or environment variable
</span>    <span class="s">"output_dir"</span><span class="p">:</span> <span class="s">"output"</span><span class="p">,</span> <span class="c1"># Default or user-specified base directory for output
</span>    <span class="s">"include_patterns"</span><span class="p">:</span> <span class="nb">set</span><span class="p">(),</span> <span class="c1"># File patterns to include
</span>    <span class="s">"exclude_patterns"</span><span class="p">:</span> <span class="nb">set</span><span class="p">(),</span> <span class="c1"># File patterns to exclude
</span>    <span class="s">"max_file_size"</span><span class="p">:</span> <span class="mi">100000</span><span class="p">,</span> <span class="c1"># Default or user-specified max file size
</span>    <span class="s">"language"</span><span class="p">:</span> <span class="s">"english"</span><span class="p">,</span> <span class="c1"># Default or user-specified language for the tutorial
</span>
    <span class="c1"># --- Intermediate/Output Data ---
</span>    <span class="s">"files"</span><span class="p">:</span> <span class="p">[],</span> <span class="c1"># Output of FetchRepo: List of tuples (file_path: str, file_content: str)
</span>    <span class="s">"abstractions"</span><span class="p">:</span> <span class="p">[],</span> <span class="c1"># Output of IdentifyAbstractions: List of {"name": str (potentially translated), "description": str (potentially translated), "files": [int]} (indices into shared["files"])
</span>    <span class="s">"relationships"</span><span class="p">:</span> <span class="p">{</span> <span class="c1"># Output of AnalyzeRelationships
</span>         <span class="s">"summary"</span><span class="p">:</span> <span class="bp">None</span><span class="p">,</span> <span class="c1"># Overall project summary (potentially translated)
</span>         <span class="s">"details"</span><span class="p">:</span> <span class="p">[]</span> <span class="c1"># List of {"from": int, "to": int, "label": str (potentially translated)} describing relationships between abstraction indices.
</span>     <span class="p">},</span>
    <span class="s">"chapter_order"</span><span class="p">:</span> <span class="p">[],</span> <span class="c1"># Output of OrderChapters: List of indices into shared["abstractions"], determining tutorial order
</span>    <span class="s">"chapters"</span><span class="p">:</span> <span class="p">[],</span> <span class="c1"># Output of WriteChapters: List of chapter content strings (Markdown, potentially translated), ordered according to chapter_order
</span>    <span class="s">"final_output_dir"</span><span class="p">:</span> <span class="bp">None</span> <span class="c1"># Output of CombineTutorial: Path to the final generated tutorial directory (e.g., "output/my_project")
</span><span class="p">}</span>
</code></pre></div></div>

<h3 id="node-steps">Node Steps</h3>

<blockquote>
  <p>Notes for AI: Carefully decide whether to use Batch/Async Node/Flow. Removed explicit try/except in exec, relying on Node’s built-in fault tolerance.</p>
</blockquote>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">FetchRepo</code></strong>
    <ul>
      <li><em>Purpose</em>: Download the repository code (from GitHub) or read from a local directory, loading relevant files into memory using the appropriate crawler utility.</li>
      <li><em>Type</em>: Regular</li>
      <li><em>Steps</em>:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">prep</code>: Read <code class="language-plaintext highlighter-rouge">repo_url</code>, <code class="language-plaintext highlighter-rouge">local_dir</code>, <code class="language-plaintext highlighter-rouge">project_name</code>, <code class="language-plaintext highlighter-rouge">github_token</code>, <code class="language-plaintext highlighter-rouge">output_dir</code>, <code class="language-plaintext highlighter-rouge">include_patterns</code>, <code class="language-plaintext highlighter-rouge">exclude_patterns</code>, <code class="language-plaintext highlighter-rouge">max_file_size</code> from shared store. Determine <code class="language-plaintext highlighter-rouge">project_name</code> from <code class="language-plaintext highlighter-rouge">repo_url</code> or <code class="language-plaintext highlighter-rouge">local_dir</code> if not present in shared. Set <code class="language-plaintext highlighter-rouge">use_relative_paths</code> flag.</li>
          <li><code class="language-plaintext highlighter-rouge">exec</code>: If <code class="language-plaintext highlighter-rouge">repo_url</code> is present, call <code class="language-plaintext highlighter-rouge">crawl_github_files(...)</code>. Otherwise, call <code class="language-plaintext highlighter-rouge">crawl_local_files(...)</code>. Convert the resulting <code class="language-plaintext highlighter-rouge">files</code> dictionary into a list of <code class="language-plaintext highlighter-rouge">(path, content)</code> tuples.</li>
          <li><code class="language-plaintext highlighter-rouge">post</code>: Write the list of <code class="language-plaintext highlighter-rouge">files</code> tuples and the derived <code class="language-plaintext highlighter-rouge">project_name</code> (if applicable) to the shared store.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">IdentifyAbstractions</code></strong>
    <ul>
      <li><em>Purpose</em>: Analyze the code to identify key concepts/abstractions using indices. Generates potentially translated names and descriptions if language is not English.</li>
      <li><em>Type</em>: Regular</li>
      <li><em>Steps</em>:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">prep</code>: Read <code class="language-plaintext highlighter-rouge">files</code> (list of tuples), <code class="language-plaintext highlighter-rouge">project_name</code>, and <code class="language-plaintext highlighter-rouge">language</code> from shared store. Create context using <code class="language-plaintext highlighter-rouge">create_llm_context</code> helper which adds file indices. Format the list of <code class="language-plaintext highlighter-rouge">index # path</code> for the prompt.</li>
          <li><code class="language-plaintext highlighter-rouge">exec</code>: Construct a prompt for <code class="language-plaintext highlighter-rouge">call_llm</code>. If language is not English, add instructions to generate <code class="language-plaintext highlighter-rouge">name</code> and <code class="language-plaintext highlighter-rouge">description</code> in the target language. Ask LLM to identify ~5-10 core abstractions, provide a simple description for each, and list the relevant <em>file indices</em> (e.g., <code class="language-plaintext highlighter-rouge">- 0 # path/to/file.py</code>). Request YAML list output. Parse and validate the YAML, ensuring indices are within bounds and converting entries like <code class="language-plaintext highlighter-rouge">0 # path...</code> to just the integer <code class="language-plaintext highlighter-rouge">0</code>.</li>
          <li><code class="language-plaintext highlighter-rouge">post</code>: Write the validated list of <code class="language-plaintext highlighter-rouge">abstractions</code> (e.g., <code class="language-plaintext highlighter-rouge">[{"name": "Node", "description": "...", "files": [0, 3, 5]}, ...]</code>) containing file <em>indices</em> and potentially translated <code class="language-plaintext highlighter-rouge">name</code>/<code class="language-plaintext highlighter-rouge">description</code> to the shared store.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">AnalyzeRelationships</code></strong>
    <ul>
      <li><em>Purpose</em>: Generate a project summary and describe how the identified abstractions interact using indices and concise labels. Generates potentially translated summary and labels if language is not English.</li>
      <li><em>Type</em>: Regular</li>
      <li><em>Steps</em>:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">prep</code>: Read <code class="language-plaintext highlighter-rouge">abstractions</code>, <code class="language-plaintext highlighter-rouge">files</code>, <code class="language-plaintext highlighter-rouge">project_name</code>, and <code class="language-plaintext highlighter-rouge">language</code> from shared store. Format context for the LLM, including potentially translated abstraction names <em>and indices</em>, potentially translated descriptions, and content snippets from related files (referenced by <code class="language-plaintext highlighter-rouge">index # path</code> using <code class="language-plaintext highlighter-rouge">get_content_for_indices</code> helper). Prepare the list of <code class="language-plaintext highlighter-rouge">index # AbstractionName</code> (potentially translated) for the prompt.</li>
          <li><code class="language-plaintext highlighter-rouge">exec</code>: Construct a prompt for <code class="language-plaintext highlighter-rouge">call_llm</code>. If language is not English, add instructions to generate <code class="language-plaintext highlighter-rouge">summary</code> and <code class="language-plaintext highlighter-rouge">label</code> in the target language, and note that input names might be translated. Ask for (1) a high-level summary and (2) a list of relationships, each specifying <code class="language-plaintext highlighter-rouge">from_abstraction</code> (e.g., <code class="language-plaintext highlighter-rouge">0 # Abstraction1</code>), <code class="language-plaintext highlighter-rouge">to_abstraction</code> (e.g., <code class="language-plaintext highlighter-rouge">1 # Abstraction2</code>), and a concise <code class="language-plaintext highlighter-rouge">label</code>. Request structured YAML output. Parse and validate, converting referenced abstractions to indices (<code class="language-plaintext highlighter-rouge">from: 0, to: 1</code>).</li>
          <li><code class="language-plaintext highlighter-rouge">post</code>: Parse the LLM response and write the <code class="language-plaintext highlighter-rouge">relationships</code> dictionary (<code class="language-plaintext highlighter-rouge">{"summary": "...", "details": [{"from": 0, "to": 1, "label": "..."}, ...]}</code>) with indices and potentially translated <code class="language-plaintext highlighter-rouge">summary</code>/<code class="language-plaintext highlighter-rouge">label</code> to the shared store.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">OrderChapters</code></strong>
    <ul>
      <li><em>Purpose</em>: Determine the sequence (as indices) in which abstractions should be presented. Considers potentially translated input context.</li>
      <li><em>Type</em>: Regular</li>
      <li><em>Steps</em>:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">prep</code>: Read <code class="language-plaintext highlighter-rouge">abstractions</code>, <code class="language-plaintext highlighter-rouge">relationships</code>, <code class="language-plaintext highlighter-rouge">project_name</code>, and <code class="language-plaintext highlighter-rouge">language</code> from the shared store. Prepare context including the list of <code class="language-plaintext highlighter-rouge">index # AbstractionName</code> (potentially translated) and textual descriptions of relationships referencing indices and using the potentially translated <code class="language-plaintext highlighter-rouge">label</code>. Note in context if summary/names might be translated.</li>
          <li><code class="language-plaintext highlighter-rouge">exec</code>: Construct a prompt for <code class="language-plaintext highlighter-rouge">call_llm</code> asking it to order the abstractions based on importance, foundational concepts, or dependencies. Request output as an ordered YAML list of <code class="language-plaintext highlighter-rouge">index # AbstractionName</code>. Parse and validate, extracting only the indices and ensuring all are present exactly once.</li>
          <li><code class="language-plaintext highlighter-rouge">post</code>: Write the validated ordered list of indices (<code class="language-plaintext highlighter-rouge">chapter_order</code>) to the shared store.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">WriteChapters</code></strong>
    <ul>
      <li><em>Purpose</em>: Generate the detailed content for each chapter of the tutorial. Generates potentially fully translated chapter content if language is not English.</li>
      <li><em>Type</em>: <strong>BatchNode</strong></li>
      <li><em>Steps</em>:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">prep</code>: Read <code class="language-plaintext highlighter-rouge">chapter_order</code> (indices), <code class="language-plaintext highlighter-rouge">abstractions</code>, <code class="language-plaintext highlighter-rouge">files</code>, <code class="language-plaintext highlighter-rouge">project_name</code>, and <code class="language-plaintext highlighter-rouge">language</code> from shared store. Initialize an empty instance variable <code class="language-plaintext highlighter-rouge">self.chapters_written_so_far</code>. Return an iterable list where each item corresponds to an <em>abstraction index</em> from <code class="language-plaintext highlighter-rouge">chapter_order</code>. Each item should contain chapter number, potentially translated abstraction details, a map of related file content (<code class="language-plaintext highlighter-rouge">{ "idx # path": content }</code>), full chapter listing (potentially translated names), chapter filename map, previous/next chapter info (potentially translated names), and language.</li>
          <li><code class="language-plaintext highlighter-rouge">exec(item)</code>: Construct a prompt for <code class="language-plaintext highlighter-rouge">call_llm</code>. If language is not English, add detailed instructions to write the <em>entire</em> chapter in the target language, translating explanations, examples, etc., while noting which input context might already be translated. Ask LLM to write a beginner-friendly Markdown chapter. Provide potentially translated concept details. Include a summary of previously written chapters (potentially translated). Provide relevant code snippets. Add the generated (potentially translated) chapter content to <code class="language-plaintext highlighter-rouge">self.chapters_written_so_far</code> for the next iteration’s context. Return the chapter content.</li>
          <li><code class="language-plaintext highlighter-rouge">post(shared, prep_res, exec_res_list)</code>: <code class="language-plaintext highlighter-rouge">exec_res_list</code> contains the generated chapter Markdown content strings (potentially translated), ordered correctly. Assign this list directly to <code class="language-plaintext highlighter-rouge">shared["chapters"]</code>. Clean up <code class="language-plaintext highlighter-rouge">self.chapters_written_so_far</code>.</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">CombineTutorial</code></strong>
    <ul>
      <li><em>Purpose</em>: Assemble the final tutorial files, including a Mermaid diagram using potentially translated labels/names. Fixed text remains English.</li>
      <li><em>Type</em>: Regular</li>
      <li><em>Steps</em>:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">prep</code>: Read <code class="language-plaintext highlighter-rouge">project_name</code>, <code class="language-plaintext highlighter-rouge">relationships</code> (potentially translated summary/labels), <code class="language-plaintext highlighter-rouge">chapter_order</code> (indices), <code class="language-plaintext highlighter-rouge">abstractions</code> (potentially translated name/desc), <code class="language-plaintext highlighter-rouge">chapters</code> (list of potentially translated content), <code class="language-plaintext highlighter-rouge">repo_url</code>, and <code class="language-plaintext highlighter-rouge">output_dir</code> from shared store. Generate a Mermaid <code class="language-plaintext highlighter-rouge">flowchart TD</code> string based on <code class="language-plaintext highlighter-rouge">relationships["details"]</code>, using indices to identify nodes (potentially translated names) and the concise <code class="language-plaintext highlighter-rouge">label</code> (potentially translated) for edges. Construct the content for <code class="language-plaintext highlighter-rouge">index.md</code> (including potentially translated summary, Mermaid diagram, and ordered links to chapters using potentially translated names derived using <code class="language-plaintext highlighter-rouge">chapter_order</code> and <code class="language-plaintext highlighter-rouge">abstractions</code>). Define the output directory path (e.g., <code class="language-plaintext highlighter-rouge">./output_dir/project_name</code>). Prepare a list of <code class="language-plaintext highlighter-rouge">{ "filename": "01_...", "content": "..." }</code> for chapters, adding the English attribution footer to each chapter’s content. Add the English attribution footer to the index content.</li>
          <li><code class="language-plaintext highlighter-rouge">exec</code>: Create the output directory. Write the generated <code class="language-plaintext highlighter-rouge">index.md</code> content. Iterate through the prepared chapter file list and write each chapter’s content to its corresponding <code class="language-plaintext highlighter-rouge">.md</code> file in the output directory.</li>
          <li><code class="language-plaintext highlighter-rouge">post</code>: Write the final <code class="language-plaintext highlighter-rouge">output_path</code> to <code class="language-plaintext highlighter-rouge">shared["final_output_dir"]</code>. Log completion.</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>
