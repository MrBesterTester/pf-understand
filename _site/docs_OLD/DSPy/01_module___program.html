<h1 id="chapter-1-modules-and-programs-building-blocks-of-dspy">Chapter 1: Modules and Programs: Building Blocks of DSPy</h1>

<p>Welcome to the first chapter of our journey into DSPy! We’re excited to have you here.</p>

<p>Imagine you want to build something cool with AI, like a smart assistant that can answer questions based on your documents. This involves several steps: understanding the question, finding the right information in the documents, and then crafting a clear answer. How do you organize all these steps in your code?</p>

<p>That’s where <strong>Modules</strong> and <strong>Programs</strong> come in! They are the fundamental building blocks in DSPy, helping you structure your AI applications cleanly and effectively.</p>

<p>Think of it like building with <strong>Lego bricks</strong>:</p>

<ul>
  <li>A <strong><code class="language-plaintext highlighter-rouge">Module</code></strong> is like a single Lego brick. It’s a basic unit that performs a specific, small task.</li>
  <li>A <strong><code class="language-plaintext highlighter-rouge">Program</code></strong> is like your final Lego creation (a car, a house). It’s built by combining several Lego bricks (<code class="language-plaintext highlighter-rouge">Module</code>s) together in a specific way to achieve a bigger goal.</li>
</ul>

<p>In this chapter, we’ll learn:</p>

<ul>
  <li>What a <code class="language-plaintext highlighter-rouge">Module</code> is and what it does.</li>
  <li>How <code class="language-plaintext highlighter-rouge">Program</code>s use <code class="language-plaintext highlighter-rouge">Module</code>s to solve complex tasks.</li>
  <li>How they create structure and manage the flow of information.</li>
</ul>

<p>Let’s start building!</p>

<h2 id="what-is-a-module">What is a <code class="language-plaintext highlighter-rouge">Module</code>?</h2>

<p>A <code class="language-plaintext highlighter-rouge">dspy.Module</code> is the most basic building block in DSPy. Think of it as:</p>

<ul>
  <li><strong>A Function:</strong> Like a function in Python, it takes some input, does something, and produces an output.</li>
  <li><strong>A Lego Brick:</strong> It performs one specific job.</li>
  <li><strong>A Specialist:</strong> It often specializes in one task, frequently involving interaction with a powerful AI model like a Language Model (<a href="05_lm__language_model_client_.md">LM</a>) or a Retrieval Model (<a href="06_rm__retrieval_model_client_.md">RM</a>). We’ll learn more about LMs and RMs later!</li>
</ul>

<p>The key idea is <strong>encapsulation</strong>. A <code class="language-plaintext highlighter-rouge">Module</code> bundles a piece of logic together, hiding the internal complexity. You just need to know what it does, not necessarily <em>every single detail</em> of how it does it.</p>

<p>Every <code class="language-plaintext highlighter-rouge">Module</code> has two main parts:</p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">__init__</code>: This is where you set up the module, like defining any internal components or settings it needs.</li>
  <li><code class="language-plaintext highlighter-rouge">forward</code>: This is where the main logic happens. It defines <em>what the module does</em> when you call it with some input.</li>
</ol>

<p>Let’s look at a conceptual example. DSPy provides pre-built modules. One common one is <code class="language-plaintext highlighter-rouge">dspy.Predict</code>, which is designed to call a Language Model to generate an output based on some input, following specific instructions.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dspy</span>

<span class="c1"># Conceptual structure of a simple Module like dspy.Predict
</span><span class="k">class</span> <span class="nc">BasicPredict</span><span class="p">(</span><span class="n">dspy</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span> <span class="c1"># Inherits from dspy.Module
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instructions</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span> <span class="c1"># Important initialization
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">instructions</span> <span class="o">=</span> <span class="n">instructions</span>
        <span class="c1"># In a real DSPy module, we'd set up LM connection here
</span>        <span class="c1"># self.lm = ... (connect to language model)
</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="p">):</span>
        <span class="c1"># 1. Combine instructions and input_data
</span>        <span class="n">prompt</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">instructions</span> <span class="o">+</span> <span class="s">"</span><span class="se">\n</span><span class="s">Input: "</span> <span class="o">+</span> <span class="n">input_data</span> <span class="o">+</span> <span class="s">"</span><span class="se">\n</span><span class="s">Output:"</span>

        <span class="c1"># 2. Call the Language Model (LM) with the prompt
</span>        <span class="c1"># lm_output = self.lm(prompt) # Simplified call
</span>        <span class="n">lm_output</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"Generated answer for '</span><span class="si">{</span><span class="n">input_data</span><span class="si">}</span><span class="s">' based on instructions."</span> <span class="c1"># Dummy output
</span>
        <span class="c1"># 3. Return the result
</span>        <span class="k">return</span> <span class="n">lm_output</span>

<span class="c1"># How you might use it (conceptual)
# predictor = BasicPredict(instructions="Translate the input to French.")
# french_text = predictor(input_data="Hello")
# print(french_text) # Might output: "Generated answer for 'Hello' based on instructions."
</span></code></pre></div></div>

<p>In this simplified view:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">BasicPredict</code> inherits from <code class="language-plaintext highlighter-rouge">dspy.Module</code>. All your custom modules will do this.</li>
  <li><code class="language-plaintext highlighter-rouge">__init__</code> stores the <code class="language-plaintext highlighter-rouge">instructions</code>. Real DSPy modules might initialize connections to LMs or load settings here.</li>
  <li><code class="language-plaintext highlighter-rouge">forward</code> defines the core task: combining instructions and input, (conceptually) calling an LM, and returning the result.</li>
</ul>

<p>Don’t worry about the LM details yet! The key takeaway is that a <code class="language-plaintext highlighter-rouge">Module</code> wraps a specific piece of work, defined in its <code class="language-plaintext highlighter-rouge">forward</code> method. DSPy provides useful pre-built modules like <code class="language-plaintext highlighter-rouge">dspy.Predict</code> and <code class="language-plaintext highlighter-rouge">dspy.ChainOfThought</code> (which encourages step-by-step reasoning), and you can also build your own.</p>

<h2 id="what-is-a-program">What is a <code class="language-plaintext highlighter-rouge">Program</code>?</h2>

<p>Now, what if your task is more complex than a single LM call? For instance, answering a question based on documents might involve:</p>

<ol>
  <li>Understanding the <code class="language-plaintext highlighter-rouge">question</code>.</li>
  <li>Generating search queries based on the <code class="language-plaintext highlighter-rouge">question</code>.</li>
  <li>Using a Retrieval Model (<a href="06_rm__retrieval_model_client_.md">RM</a>) to find relevant <code class="language-plaintext highlighter-rouge">context</code> documents using the queries.</li>
  <li>Using a Language Model (<a href="05_lm__language_model_client_.md">LM</a>) to generate the final <code class="language-plaintext highlighter-rouge">answer</code> based on the <code class="language-plaintext highlighter-rouge">question</code> and <code class="language-plaintext highlighter-rouge">context</code>.</li>
</ol>

<p>This is too much for a single simple <code class="language-plaintext highlighter-rouge">Module</code>. We need to combine multiple modules!</p>

<p>This is where a <code class="language-plaintext highlighter-rouge">Program</code> comes in. <strong>Technically, a <code class="language-plaintext highlighter-rouge">Program</code> in DSPy is also just a <code class="language-plaintext highlighter-rouge">dspy.Module</code>!</strong> The difference is in how we use it: a <code class="language-plaintext highlighter-rouge">Program</code> is typically a <code class="language-plaintext highlighter-rouge">Module</code> that <em>contains and coordinates other <code class="language-plaintext highlighter-rouge">Module</code>s</em>.</p>

<p>Think back to the Lego analogy:</p>

<ul>
  <li>Small <code class="language-plaintext highlighter-rouge">Module</code>s are like bricks for the engine, wheels, and chassis.</li>
  <li>The <code class="language-plaintext highlighter-rouge">Program</code> is the main <code class="language-plaintext highlighter-rouge">Module</code> representing the whole car, defining how the engine, wheels, and chassis bricks connect and work together in its <code class="language-plaintext highlighter-rouge">forward</code> method.</li>
</ul>

<p>A <code class="language-plaintext highlighter-rouge">Program</code> defines the <strong>data flow</strong> between its sub-modules. It orchestrates the sequence of operations.</p>

<p>Let’s sketch out a simple <code class="language-plaintext highlighter-rouge">Program</code> for our question-answering example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dspy</span>

<span class="c1"># Assume we have these pre-built or custom Modules (simplified)
</span><span class="k">class</span> <span class="nc">GenerateSearchQuery</span><span class="p">(</span><span class="n">dspy</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question</span><span class="p">):</span>
        <span class="c1"># Logic to create search queries from the question
</span>        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Generating query for: </span><span class="si">{</span><span class="n">question</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s">"search query for '</span><span class="si">{</span><span class="n">question</span><span class="si">}</span><span class="s">'"</span>

<span class="k">class</span> <span class="nc">RetrieveContext</span><span class="p">(</span><span class="n">dspy</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">):</span>
        <span class="c1"># Logic to find documents using the query
</span>        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Retrieving context for: </span><span class="si">{</span><span class="n">query</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s">"Relevant context document about '</span><span class="si">{</span><span class="n">query</span><span class="si">}</span><span class="s">'"</span>

<span class="k">class</span> <span class="nc">GenerateAnswer</span><span class="p">(</span><span class="n">dspy</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
        <span class="c1"># Logic to generate answer using question and context
</span>        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Generating answer for: </span><span class="si">{</span><span class="n">question</span><span class="si">}</span><span class="s"> using context: </span><span class="si">{</span><span class="n">context</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s">"Final answer about '</span><span class="si">{</span><span class="n">question</span><span class="si">}</span><span class="s">' based on context."</span>

<span class="c1"># Now, let's build the Program (which is also a Module!)
</span><span class="k">class</span> <span class="nc">RAG</span><span class="p">(</span><span class="n">dspy</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span> <span class="c1"># RAG = Retrieval-Augmented Generation
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>
        <span class="c1"># Initialize the sub-modules it will use
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">generate_query</span> <span class="o">=</span> <span class="n">GenerateSearchQuery</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">retrieve</span> <span class="o">=</span> <span class="n">RetrieveContext</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">generate_answer</span> <span class="o">=</span> <span class="n">GenerateAnswer</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question</span><span class="p">):</span>
        <span class="c1"># Define the flow of data through the sub-modules
</span>        <span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">--- RAG Program Start ---"</span><span class="p">)</span>
        <span class="n">search_query</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">generate_query</span><span class="p">(</span><span class="n">question</span><span class="o">=</span><span class="n">question</span><span class="p">)</span>
        <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">retrieve</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">search_query</span><span class="p">)</span>
        <span class="n">answer</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">generate_answer</span><span class="p">(</span><span class="n">question</span><span class="o">=</span><span class="n">question</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"--- RAG Program End ---"</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">answer</span>

<span class="c1"># How to use the Program
</span><span class="n">rag_program</span> <span class="o">=</span> <span class="n">RAG</span><span class="p">()</span>
<span class="n">final_answer</span> <span class="o">=</span> <span class="n">rag_program</span><span class="p">(</span><span class="n">question</span><span class="o">=</span><span class="s">"What is DSPy?"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"</span><span class="se">\n</span><span class="s">Final Output: </span><span class="si">{</span><span class="n">final_answer</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p>If you run this conceptual code, you’d see output like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--- RAG Program Start ---
Generating query for: What is DSPy?
Retrieving context for: search query for 'What is DSPy?'
Generating answer for: What is DSPy? using context: Relevant context document about 'search query for 'What is DSPy?''
--- RAG Program End ---

Final Output: Final answer about 'What is DSPy?' based on context.
</code></pre></div></div>

<p>See how the <code class="language-plaintext highlighter-rouge">RAG</code> program works?</p>

<ol>
  <li>In <code class="language-plaintext highlighter-rouge">__init__</code>, it creates instances of the smaller modules it needs (<code class="language-plaintext highlighter-rouge">GenerateSearchQuery</code>, <code class="language-plaintext highlighter-rouge">RetrieveContext</code>, <code class="language-plaintext highlighter-rouge">GenerateAnswer</code>).</li>
  <li>In <code class="language-plaintext highlighter-rouge">forward</code>, it calls these modules <em>in order</em>, passing the output of one as the input to the next. It defines the workflow!</li>
</ol>

<h2 id="hierarchical-structure">Hierarchical Structure</h2>

<p>Modules can contain other modules, which can contain <em>even more</em> modules! This allows you to build complex systems by breaking them down into manageable, hierarchical parts.</p>

<p>Imagine our <code class="language-plaintext highlighter-rouge">GenerateAnswer</code> module was actually quite complex. Maybe it first summarizes the context, then drafts an answer, then refines it. We could implement <code class="language-plaintext highlighter-rouge">GenerateAnswer</code> as <em>another</em> program containing these sub-modules!</p>

<pre><code class="language-mermaid">graph TD
    A[RAG Program] --&gt; B(GenerateSearchQuery Module);
    A --&gt; C(RetrieveContext Module);
    A --&gt; D(GenerateAnswer Module / Program);
    D --&gt; D1(SummarizeContext Module);
    D --&gt; D2(DraftAnswer Module);
    D --&gt; D3(RefineAnswer Module);
</code></pre>

<p>This diagram shows how the <code class="language-plaintext highlighter-rouge">RAG</code> program uses <code class="language-plaintext highlighter-rouge">GenerateAnswer</code>, which itself could be composed of smaller modules like <code class="language-plaintext highlighter-rouge">SummarizeContext</code>, <code class="language-plaintext highlighter-rouge">DraftAnswer</code>, and <code class="language-plaintext highlighter-rouge">RefineAnswer</code>. This nesting makes complex systems easier to design, understand, and debug.</p>

<h2 id="how-it-works-under-the-hood-a-tiny-peek">How It Works Under the Hood (A Tiny Peek)</h2>

<p>You don’t need to know the deep internals right now, but it’s helpful to have a basic mental model.</p>

<ol>
  <li><strong>Foundation:</strong> All DSPy modules, whether simple bricks or complex programs, inherit from a base class (<code class="language-plaintext highlighter-rouge">dspy.primitives.module.BaseModule</code>). This provides common functionality like saving, loading, and finding internal parameters (we’ll touch on saving/loading later).</li>
  <li><strong>Execution:</strong> When you call a module (e.g., <code class="language-plaintext highlighter-rouge">rag_program(question="...")</code>), Python executes its <code class="language-plaintext highlighter-rouge">__call__</code> method. In DSPy, this typically just calls the <code class="language-plaintext highlighter-rouge">forward</code> method you defined.</li>
  <li><strong>Orchestration:</strong> If a module’s <code class="language-plaintext highlighter-rouge">forward</code> method calls other modules (like in our <code class="language-plaintext highlighter-rouge">RAG</code> example), it simply executes their <code class="language-plaintext highlighter-rouge">forward</code> methods in turn, passing the data as defined in the code.</li>
</ol>

<p>Here’s a simplified sequence of what happens when we call <code class="language-plaintext highlighter-rouge">rag_program("What is DSPy?")</code>:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant RAGProgram as RAG Program (forward)
    participant GenQuery as GenerateQuery (forward)
    participant Retrieve as RetrieveContext (forward)
    participant GenAnswer as GenerateAnswer (forward)

    User-&gt;&gt;RAGProgram: Call with "What is DSPy?"
    RAGProgram-&gt;&gt;GenQuery: Call with question="What is DSPy?"
    GenQuery--&gt;&gt;RAGProgram: Return "search query..."
    RAGProgram-&gt;&gt;Retrieve: Call with query="search query..."
    Retrieve--&gt;&gt;RAGProgram: Return "Relevant context..."
    RAGProgram-&gt;&gt;GenAnswer: Call with question, context
    GenAnswer--&gt;&gt;RAGProgram: Return "Final answer..."
    RAGProgram--&gt;&gt;User: Return "Final answer..."
</code></pre>

<p>The core files involved are:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">primitives/module.py</code>: Defines the <code class="language-plaintext highlighter-rouge">BaseModule</code> class, the ancestor of all modules.</li>
  <li><code class="language-plaintext highlighter-rouge">primitives/program.py</code>: Defines the <code class="language-plaintext highlighter-rouge">Module</code> class (which you inherit from) itself, adding core methods like <code class="language-plaintext highlighter-rouge">__call__</code> that invokes <code class="language-plaintext highlighter-rouge">forward</code>.</li>
</ul>

<p>You can see from the code snippets provided earlier (like <code class="language-plaintext highlighter-rouge">ChainOfThought</code> or <code class="language-plaintext highlighter-rouge">Predict</code>) that they inherit from <code class="language-plaintext highlighter-rouge">dspy.Module</code> and define <code class="language-plaintext highlighter-rouge">__init__</code> and <code class="language-plaintext highlighter-rouge">forward</code>, just like our examples.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Snippet from dspy/primitives/program.py (Simplified)
</span><span class="kn">from</span> <span class="nn">dspy.primitives.module</span> <span class="kn">import</span> <span class="n">BaseModule</span>

<span class="k">class</span> <span class="nc">Module</span><span class="p">(</span><span class="n">BaseModule</span><span class="p">):</span> <span class="c1"># Inherits from BaseModule
</span>    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">_base_init</span><span class="p">()</span>
        <span class="c1"># ... initialization ...
</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># This is where the main logic of the module goes.
</span>        <span class="c1"># Users override this method in their own modules.
</span>        <span class="k">raise</span> <span class="nb">NotImplementedError</span> <span class="c1"># Needs to be implemented by subclasses
</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># When you call module_instance(), this runs...
</span>        <span class="c1"># ...and typically calls self.forward()
</span>        <span class="k">return</span> <span class="bp">self</span><span class="p">.</span><span class="n">forward</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="c1"># You write classes like this:
</span><span class="k">class</span> <span class="nc">MyModule</span><span class="p">(</span><span class="n">dspy</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>
        <span class="c1"># Your setup
</span>
    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_data</span><span class="p">):</span>
        <span class="c1"># Your logic
</span>        <span class="n">result</span> <span class="o">=</span> <span class="p">...</span>
        <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>The important part is the pattern: inherit from <code class="language-plaintext highlighter-rouge">dspy.Module</code>, set things up in <code class="language-plaintext highlighter-rouge">__init__</code>, and define the core logic in <code class="language-plaintext highlighter-rouge">forward</code>.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Congratulations! You’ve learned about the fundamental organizing principle in DSPy: <strong>Modules</strong> and <strong>Programs</strong>.</p>

<ul>
  <li><strong>Modules</strong> are the basic building blocks, like Lego bricks, often handling a specific task (maybe calling an <a href="05_lm__language_model_client_.md">LM</a> or <a href="06_rm__retrieval_model_client_.md">RM</a>).</li>
  <li><strong>Programs</strong> are also Modules, but they typically combine <em>other</em> modules to orchestrate a more complex workflow, defining how data flows between them.</li>
  <li>The <code class="language-plaintext highlighter-rouge">forward</code> method is key – it contains the logic of what a module <em>does</em>.</li>
  <li>This structure allows you to build complex AI systems in a clear, manageable, and hierarchical way.</li>
</ul>

<p>Now that we understand how modules provide structure, how do they know what kind of input data they expect and what kind of output data they should produce? That’s where <strong>Signatures</strong> come in!</p>

<p>Let’s dive into that next!</p>

<p><strong>Next:</strong> <a href="02_signature.md">Chapter 2: Signature</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
