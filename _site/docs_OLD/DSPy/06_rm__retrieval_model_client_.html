<h1 id="chapter-6-rm-retrieval-model-client---your-programs-librarian">Chapter 6: RM (Retrieval Model Client) - Your Program’s Librarian</h1>

<p>In <a href="05_lm__language_model_client_.md">Chapter 5: LM (Language Model Client)</a>, we learned how to connect our DSPy programs to the powerful “brain” of a Language Model (LM) using the LM Client. The LM is great at generating creative text, answering questions based on its vast training data, and reasoning.</p>

<p>But what if your program needs information that the LM wasn’t trained on?</p>
<ul>
  <li>Maybe it’s very recent news (LMs often have knowledge cut-offs).</li>
  <li>Maybe it’s private information from your company’s documents.</li>
  <li>Maybe it’s specific details from a large technical manual.</li>
</ul>

<p>LMs can’t know <em>everything</em>. Sometimes, your program needs to <strong>look things up</strong> in an external knowledge source before it can generate an answer.</p>

<p>Imagine you’re building a chatbot that answers questions about your company’s latest product manuals. The LM itself probably hasn’t read them. Your program needs a way to:</p>
<ol>
  <li>Receive the user’s question (e.g., “How do I reset the Frobozz device?”).</li>
  <li><strong>Search</strong> through the product manuals for relevant sections about resetting the Frobozz.</li>
  <li>Give those relevant sections to the LM as <strong>context</strong>.</li>
  <li>Ask the LM to generate a final answer based on the user’s question <em>and</em> the context it just found.</li>
</ol>

<p>This “search” step is where the <strong>RM (Retrieval Model Client)</strong> comes in!</p>

<p>Think of the RM as:</p>

<ul>
  <li><strong>A Specialized Librarian:</strong> Your program asks it to find relevant information on a topic (the query).</li>
  <li><strong>A Search Engine Interface:</strong> It connects your DSPy program to an external search system or database.</li>
  <li><strong>The Knowledge Fetcher:</strong> It retrieves relevant text snippets (passages) to help the LM.</li>
</ul>

<p>In this chapter, you’ll learn:</p>

<ul>
  <li>What an RM Client does and why it’s essential for knowledge-intensive tasks.</li>
  <li>How to configure DSPy to use a specific Retrieval Model.</li>
  <li>How DSPy modules can use the configured RM to find information.</li>
  <li>A glimpse into how the RM fetches data behind the scenes.</li>
</ul>

<p>Let’s give our program access to external knowledge!</p>

<h2 id="what-does-the-rm-client-do">What Does the RM Client Do?</h2>

<p>The RM Client acts as a bridge between your DSPy program and an external knowledge source. Its main job is to:</p>

<ol>
  <li><strong>Receive a Search Query:</strong> Your program gives it a text query (e.g., “reset Frobozz device”).</li>
  <li><strong>Interface with a Retrieval System:</strong> It talks to the actual search engine or database. This could be:
    <ul>
      <li>A <strong>Vector Database:</strong> Like Pinecone, Weaviate, Chroma, Milvus (great for searching based on meaning).</li>
      <li>A <strong>Specialized Retrieval API:</strong> Like ColBERTv2 (a powerful neural search model), You.com Search API, or a custom company search API.</li>
      <li>A <strong>Local Index:</strong> A search index built over your own files (e.g., using ColBERT locally).</li>
    </ul>
  </li>
  <li><strong>Fetch Relevant Passages:</strong> It asks the retrieval system to find the top <code class="language-plaintext highlighter-rouge">k</code> most relevant text documents or passages based on the query.</li>
  <li><strong>Return the Passages:</strong> It gives these retrieved passages back to your DSPy program, usually as a list of text strings or structured objects.</li>
</ol>

<p>The key goal is to provide <strong>relevant context</strong> that the <a href="05_lm__language_model_client_.md">LM (Language Model Client)</a> can then use to perform its task more accurately, often within a structure called Retrieval-Augmented Generation (RAG).</p>

<h2 id="configuring-which-rm-to-use">Configuring Which RM to Use</h2>

<p>Just like we configured the LM in the previous chapter, we need to tell DSPy which RM to use. This is done using <code class="language-plaintext highlighter-rouge">dspy.settings.configure</code>.</p>

<p>First, you import and create an instance of the specific RM client you want to use. DSPy has built-in clients for several common retrieval systems.</p>

<p><strong>Example: Configuring ColBERTv2 (a hosted endpoint)</strong></p>

<p>ColBERTv2 is a powerful retrieval model. Let’s imagine there’s a public server running ColBERTv2 that has indexed Wikipedia.</p>

<ol>
  <li><strong>Import the client:</strong>
    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dspy</span>
</code></pre></div>    </div>
    <p><em>(For many RMs like ColBERTv2, Pinecone, Weaviate, the client is directly available under <code class="language-plaintext highlighter-rouge">dspy</code> or <code class="language-plaintext highlighter-rouge">dspy.retrieve</code>)</em></p>
  </li>
  <li>
    <p><strong>Create an instance:</strong> You need to provide the URL and port (if applicable) of the ColBERTv2 server.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Assume a ColBERTv2 server is running at this URL indexing Wikipedia
</span><span class="n">colbertv2_wiki</span> <span class="o">=</span> <span class="n">dspy</span><span class="p">.</span><span class="n">ColBERTv2</span><span class="p">(</span><span class="n">url</span><span class="o">=</span><span class="s">'http://your-colbertv2-endpoint.com:8893'</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
</code></pre></div>    </div>
    <p>This creates an object <code class="language-plaintext highlighter-rouge">colbertv2_wiki</code> that knows how to talk to that specific ColBERTv2 server.</p>
  </li>
  <li>
    <p><strong>Configure DSPy settings:</strong> Tell DSPy globally that this is the RM to use.</p>

    <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dspy</span><span class="p">.</span><span class="n">settings</span><span class="p">.</span><span class="n">configure</span><span class="p">(</span><span class="n">rm</span><span class="o">=</span><span class="n">colbertv2_wiki</span><span class="p">)</span>
</code></pre></div>    </div>
    <p>Now, any DSPy module that needs to retrieve information will automatically use the <code class="language-plaintext highlighter-rouge">colbertv2_wiki</code> instance.</p>
  </li>
</ol>

<p><strong>Using Other RMs (e.g., Pinecone, Weaviate)</strong></p>

<p>Configuring other RMs follows a similar pattern. You’ll typically need to provide details like index names, API keys (often via environment variables), and the client object for that specific service.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Example: Configuring Pinecone (Conceptual - requires setup)
# from dspy.retrieve.pinecone_rm import PineconeRM
# Assumes PINECONE_API_KEY and PINECONE_ENVIRONMENT are set in environment
# pinecone_retriever = PineconeRM(
#     pinecone_index_name='my-company-docs-index',
#     # Assuming embeddings are done via OpenAI's model
#     openai_embed_model='text-embedding-ada-002'
# )
# dspy.settings.configure(rm=pinecone_retriever)
</span>
<span class="c1"># Example: Configuring Weaviate (Conceptual - requires setup)
# import weaviate
# from dspy.retrieve.weaviate_rm import WeaviateRM
# weaviate_client = weaviate.connect_to_local() # Or connect_to_wcs, etc.
# weaviate_retriever = WeaviateRM(
#     weaviate_collection_name='my_manuals',
#     weaviate_client=weaviate_client
# )
# dspy.settings.configure(rm=weaviate_retriever)
</span></code></pre></div></div>
<p><em>(Don’t worry about the specifics of connecting to Pinecone or Weaviate here; the key takeaway is the <code class="language-plaintext highlighter-rouge">dspy.settings.configure(rm=...)</code> pattern.)</em></p>

<h2 id="how-modules-use-the-configured-rm-dspyretrieve">How Modules Use the Configured RM: <code class="language-plaintext highlighter-rouge">dspy.Retrieve</code></h2>

<p>Usually, you don’t call <code class="language-plaintext highlighter-rouge">dspy.settings.rm(...)</code> directly in your main program logic. Instead, you use a DSPy module designed for retrieval. The most basic one is <code class="language-plaintext highlighter-rouge">dspy.Retrieve</code>.</p>

<p>The <code class="language-plaintext highlighter-rouge">dspy.Retrieve</code> module is a simple <a href="01_module___program.md">Module</a> whose job is to:</p>
<ol>
  <li>Take a query as input.</li>
  <li>Call the currently configured RM (<code class="language-plaintext highlighter-rouge">dspy.settings.rm</code>).</li>
  <li>Return the retrieved passages.</li>
</ol>

<p>Here’s how you typically use it within a DSPy <code class="language-plaintext highlighter-rouge">Program</code>:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dspy</span>

<span class="c1"># Assume RM is already configured (e.g., colbertv2_wiki from before)
# dspy.settings.configure(rm=colbertv2_wiki)
</span>
<span class="k">class</span> <span class="nc">SimpleRAG</span><span class="p">(</span><span class="n">dspy</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_passages</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>
        <span class="c1"># Initialize the Retrieve module, asking for top 3 passages
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">retrieve</span> <span class="o">=</span> <span class="n">dspy</span><span class="p">.</span><span class="n">Retrieve</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">num_passages</span><span class="p">)</span>
        <span class="c1"># Initialize a Predict module to generate the answer
</span>        <span class="bp">self</span><span class="p">.</span><span class="n">generate_answer</span> <span class="o">=</span> <span class="n">dspy</span><span class="p">.</span><span class="n">Predict</span><span class="p">(</span><span class="s">'context, question -&gt; answer'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">question</span><span class="p">):</span>
        <span class="c1"># 1. Retrieve relevant context using the configured RM
</span>        <span class="n">context</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">retrieve</span><span class="p">(</span><span class="n">query</span><span class="o">=</span><span class="n">question</span><span class="p">).</span><span class="n">passages</span> <span class="c1"># Note: Pass query=...
</span>
        <span class="c1"># 2. Generate the answer using the LM, providing context
</span>        <span class="n">prediction</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">generate_answer</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">context</span><span class="p">,</span> <span class="n">question</span><span class="o">=</span><span class="n">question</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">prediction</span>

<span class="c1"># --- Let's try it ---
# Assume LM is also configured (e.g., gpt3_turbo from Chapter 5)
# dspy.settings.configure(lm=gpt3_turbo)
</span>
<span class="n">rag_program</span> <span class="o">=</span> <span class="n">SimpleRAG</span><span class="p">()</span>
<span class="n">question</span> <span class="o">=</span> <span class="s">"What is the largest rodent?"</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">rag_program</span><span class="p">(</span><span class="n">question</span><span class="o">=</span><span class="n">question</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Question: </span><span class="si">{</span><span class="n">question</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="c1"># The retrieve module would fetch passages about rodents...
# print(f"Context: {context}") # (Would show passages about capybaras, etc.)
</span><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Answer: </span><span class="si">{</span><span class="n">result</span><span class="p">.</span><span class="n">answer</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>What’s happening?</strong></p>

<ol>
  <li><code class="language-plaintext highlighter-rouge">self.retrieve = dspy.Retrieve(k=3)</code>: Inside our <code class="language-plaintext highlighter-rouge">SimpleRAG</code> program, we create an instance of <code class="language-plaintext highlighter-rouge">dspy.Retrieve</code>. We tell it we want the top <code class="language-plaintext highlighter-rouge">k=3</code> passages.</li>
  <li><code class="language-plaintext highlighter-rouge">context = self.retrieve(query=question).passages</code>: In the <code class="language-plaintext highlighter-rouge">forward</code> method, we call the <code class="language-plaintext highlighter-rouge">retrieve</code> module with the input <code class="language-plaintext highlighter-rouge">question</code> as the <code class="language-plaintext highlighter-rouge">query</code>.
    <ul>
      <li><strong>Crucially:</strong> The <code class="language-plaintext highlighter-rouge">dspy.Retrieve</code> module automatically looks up <code class="language-plaintext highlighter-rouge">dspy.settings.rm</code> (our configured <code class="language-plaintext highlighter-rouge">colbertv2_wiki</code>).</li>
      <li>It calls <code class="language-plaintext highlighter-rouge">colbertv2_wiki(question, k=3)</code>.</li>
      <li>The RM client fetches the passages.</li>
      <li><code class="language-plaintext highlighter-rouge">dspy.Retrieve</code> returns a <code class="language-plaintext highlighter-rouge">dspy.Prediction</code> object, and we access the list of passage texts using <code class="language-plaintext highlighter-rouge">.passages</code>.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">self.generate_answer(context=context, question=question)</code>: We then pass the fetched <code class="language-plaintext highlighter-rouge">context</code> (along with the original <code class="language-plaintext highlighter-rouge">question</code>) to our <code class="language-plaintext highlighter-rouge">generate_answer</code> module (a <code class="language-plaintext highlighter-rouge">dspy.Predict</code> instance), which uses the configured <a href="05_lm__language_model_client_.md">LM</a> to produce the final answer.</li>
</ol>

<p><strong>Expected Output (using a Wikipedia RM and a capable LM):</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Question: What is the largest rodent?
Answer: The largest rodent is the capybara.
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">dspy.Retrieve</code> module handles the interaction with the configured RM seamlessly.</p>

<h2 id="calling-the-rm-directly-for-testing">Calling the RM Directly (for Testing)</h2>

<p>While <code class="language-plaintext highlighter-rouge">dspy.Retrieve</code> is the standard way, you <em>can</em> call the configured RM directly if you want to quickly test it or see what it returns.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dspy</span>

<span class="c1"># Assume colbertv2_wiki is configured as the RM
# dspy.settings.configure(rm=colbertv2_wiki)
</span>
<span class="n">query</span> <span class="o">=</span> <span class="s">"Stanford University mascot"</span>
<span class="n">k</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># Ask for top 2 passages
</span>
<span class="c1"># Call the configured RM directly
</span><span class="n">retrieved_passages</span> <span class="o">=</span> <span class="n">dspy</span><span class="p">.</span><span class="n">settings</span><span class="p">.</span><span class="n">rm</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>

<span class="c1"># Print the results
</span><span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Query: </span><span class="si">{</span><span class="n">query</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Retrieved Passages (Top </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s">):"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">passage</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">retrieved_passages</span><span class="p">):</span>
    <span class="c1"># RM clients often return dotdict objects with 'long_text'
</span>    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"--- Passage </span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s"> ---"</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">passage</span><span class="p">.</span><span class="n">long_text</span><span class="p">)</span> <span class="c1"># Access the text content
</span></code></pre></div></div>

<p><strong>Expected Output (might vary depending on the RM and its index):</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Query: Stanford University mascot
Retrieved Passages (Top 2):
--- Passage 1 ---
Stanford Tree | Stanford University Athletics The Stanford Tree is the Stanford Band's mascot and the unofficial mascot of Stanford University. Stanford's team name is "Cardinal", referring to the vivid red color (not the bird as at several other schools). The Tree, in various versions, has been called one of America's most bizarre and controversial college mascots. The tree costume is created anew by the Band member selected to be the Tree each year. The Tree appears at football games, basketball games, and other Stanford Athletic events. Any current student may petition to become the Tree for the following year....
--- Passage 2 ---
Stanford Cardinal | The Official Site of Stanford Athletics Stanford University is home to 36 varsity sports programs, 20 for women and 16 for men. Stanford participates in the NCAA's Division I (Football Bowl Subdivision subdivision for football). Stanford is a member of the Pac-12 Conference in most sports; the men's and women's water polo teams are members of the Mountain Pacific Sports Federation, the men's volleyball team is a member of the Mountain Pacific Sports Federation, the field hockey team is a member of the America East Conference, and the sailing team competes in the Pacific Coast Collegiate Sailing Conference....
</code></pre></div></div>

<p>This shows how you can directly interact with the RM client configured in <code class="language-plaintext highlighter-rouge">dspy.settings</code>. Notice the output is often a list of <code class="language-plaintext highlighter-rouge">dspy.dsp.utils.dotdict</code> objects, where the actual text is usually in the <code class="language-plaintext highlighter-rouge">long_text</code> attribute. <code class="language-plaintext highlighter-rouge">dspy.Retrieve</code> conveniently extracts just the text into its <code class="language-plaintext highlighter-rouge">.passages</code> list.</p>

<h2 id="how-it-works-under-the-hood">How It Works Under the Hood</h2>

<p>Let’s trace the journey of a query when using <code class="language-plaintext highlighter-rouge">dspy.Retrieve</code> within our <code class="language-plaintext highlighter-rouge">SimpleRAG</code> program:</p>

<ol>
  <li><strong>Module Call:</strong> The <code class="language-plaintext highlighter-rouge">SimpleRAG</code> program’s <code class="language-plaintext highlighter-rouge">forward</code> method calls <code class="language-plaintext highlighter-rouge">self.retrieve(query="What is the largest rodent?")</code>.</li>
  <li><strong>Get RM Client:</strong> The <code class="language-plaintext highlighter-rouge">dspy.Retrieve</code> module (<code class="language-plaintext highlighter-rouge">self.retrieve</code>) needs an RM. It looks up <code class="language-plaintext highlighter-rouge">dspy.settings.rm</code>. This returns the configured RM client object (e.g., our <code class="language-plaintext highlighter-rouge">colbertv2_wiki</code> instance).</li>
  <li><strong>RM Client Call:</strong> The <code class="language-plaintext highlighter-rouge">Retrieve</code> module calls the RM client object’s <code class="language-plaintext highlighter-rouge">forward</code> (or <code class="language-plaintext highlighter-rouge">__call__</code>) method, passing the query and <code class="language-plaintext highlighter-rouge">k</code> (e.g., <code class="language-plaintext highlighter-rouge">colbertv2_wiki("What is the largest rodent?", k=3)</code>).</li>
  <li><strong>External Interaction (Inside RM Client):</strong>
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">colbertv2_wiki</code> object (an instance of <code class="language-plaintext highlighter-rouge">dspy.ColBERTv2</code>) constructs an HTTP request to the ColBERTv2 server URL (<code class="language-plaintext highlighter-rouge">http://your-colbertv2-endpoint.com:8893</code>). The request includes the query and <code class="language-plaintext highlighter-rouge">k</code>.</li>
      <li>It sends the request over the network.</li>
      <li>The external ColBERTv2 server receives the request, searches its index (e.g., Wikipedia), and finds the top 3 relevant passages.</li>
      <li>The server sends the passages back in the HTTP response (often as JSON).</li>
    </ul>
  </li>
  <li><strong>Parse Response (Inside RM Client):</strong> The <code class="language-plaintext highlighter-rouge">colbertv2_wiki</code> client receives the response, parses the JSON, and converts the passages into a list of <code class="language-plaintext highlighter-rouge">dspy.dsp.utils.dotdict</code> objects (each containing <code class="language-plaintext highlighter-rouge">long_text</code>, potentially <code class="language-plaintext highlighter-rouge">pid</code>, <code class="language-plaintext highlighter-rouge">score</code>, etc.).</li>
  <li><strong>Return to Module:</strong> The RM client returns this list of <code class="language-plaintext highlighter-rouge">dotdict</code> passages back to the <code class="language-plaintext highlighter-rouge">dspy.Retrieve</code> module.</li>
  <li><strong>Extract Text:</strong> The <code class="language-plaintext highlighter-rouge">Retrieve</code> module takes the list of <code class="language-plaintext highlighter-rouge">dotdict</code> objects and extracts the <code class="language-plaintext highlighter-rouge">long_text</code> from each, creating a simple list of strings.</li>
  <li><strong>Return Prediction:</strong> It packages this list of strings into a <code class="language-plaintext highlighter-rouge">dspy.Prediction</code> object under the <code class="language-plaintext highlighter-rouge">passages</code> key and returns it to the <code class="language-plaintext highlighter-rouge">SimpleRAG</code> program.</li>
</ol>

<p>Here’s a simplified sequence diagram:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant RAGProgram as SimpleRAG (forward)
    participant RetrieveMod as dspy.Retrieve
    participant Settings as dspy.settings
    participant RMClient as RM Client (e.g., ColBERTv2)
    participant ExtSearch as External Search (e.g., ColBERT Server)

    User-&gt;&gt;RAGProgram: Call with question="..."
    RAGProgram-&gt;&gt;RetrieveMod: Call retrieve(query=question)
    RetrieveMod-&gt;&gt;Settings: Get configured rm
    Settings--&gt;&gt;RetrieveMod: Return RMClient instance
    RetrieveMod-&gt;&gt;RMClient: __call__(query, k=3)
    RMClient-&gt;&gt;ExtSearch: Send Search Request (query, k)
    ExtSearch--&gt;&gt;RMClient: Return Found Passages
    RMClient-&gt;&gt;RMClient: Parse Response into dotdicts
    RMClient--&gt;&gt;RetrieveMod: Return list[dotdict]
    RetrieveMod-&gt;&gt;RetrieveMod: Extract 'long_text' into list[str]
    RetrieveMod--&gt;&gt;RAGProgram: Return Prediction(passages=list[str])
    RAGProgram-&gt;&gt;RAGProgram: Use context for LM call...
    RAGProgram--&gt;&gt;User: Return final answer
</code></pre>

<p><strong>Relevant Code Files:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">dspy/retrieve/retrieve.py</code>: Defines the <code class="language-plaintext highlighter-rouge">dspy.Retrieve</code> module. Its <code class="language-plaintext highlighter-rouge">forward</code> method gets the query, retrieves the RM from <code class="language-plaintext highlighter-rouge">dspy.settings</code>, calls the RM, and processes the results into a <code class="language-plaintext highlighter-rouge">Prediction</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">dspy/dsp/colbertv2.py</code>: Defines the <code class="language-plaintext highlighter-rouge">dspy.ColBERTv2</code> client. Its <code class="language-plaintext highlighter-rouge">__call__</code> method makes HTTP requests (<code class="language-plaintext highlighter-rouge">requests.get</code> or <code class="language-plaintext highlighter-rouge">requests.post</code>) to a ColBERTv2 endpoint and parses the JSON response. (Other clients like <code class="language-plaintext highlighter-rouge">dspy/retrieve/pinecone_rm.py</code> or <code class="language-plaintext highlighter-rouge">dspy/retrieve/weaviate_rm.py</code> contain logic specific to those services).</li>
  <li><code class="language-plaintext highlighter-rouge">dspy/dsp/utils/settings.py</code>: Where the configured <code class="language-plaintext highlighter-rouge">rm</code> instance is stored and accessed globally (as seen in <a href="05_lm__language_model_client_.md">Chapter 5: LM (Language Model Client)</a>).</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified view from dspy/retrieve/retrieve.py
</span>
<span class="kn">import</span> <span class="nn">dspy</span>
<span class="kn">from</span> <span class="nn">dspy.primitives.prediction</span> <span class="kn">import</span> <span class="n">Prediction</span>

<span class="k">class</span> <span class="nc">Retrieve</span><span class="p">(</span><span class="n">dspy</span><span class="p">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">().</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">k</span>

    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Prediction</span><span class="p">:</span>
        <span class="c1"># Determine how many passages to retrieve
</span>        <span class="n">k</span> <span class="o">=</span> <span class="n">k</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">self</span><span class="p">.</span><span class="n">k</span>

        <span class="c1"># Get the configured RM client from global settings
</span>        <span class="n">rm_client</span> <span class="o">=</span> <span class="n">dspy</span><span class="p">.</span><span class="n">settings</span><span class="p">.</span><span class="n">rm</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">rm_client</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">AssertionError</span><span class="p">(</span><span class="s">"No RM is loaded. Configure with dspy.settings.configure(rm=...)."</span><span class="p">)</span>

        <span class="c1"># Call the RM client instance
</span>        <span class="c1"># The RM client handles communication with the actual search system
</span>        <span class="n">passages_or_dotdicts</span> <span class="o">=</span> <span class="n">rm_client</span><span class="p">(</span><span class="n">query</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span> <span class="c1"># e.g., calls colbertv2_wiki(query, k=k)
</span>
        <span class="c1"># Ensure output is iterable and extract text
</span>        <span class="c1"># (Simplified - handles different return types from RMs)
</span>        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">passages_or_dotdicts</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">passages_or_dotdicts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">'long_text'</span><span class="p">):</span>
            <span class="n">passages</span> <span class="o">=</span> <span class="p">[</span><span class="n">psg</span><span class="p">.</span><span class="n">long_text</span> <span class="k">for</span> <span class="n">psg</span> <span class="ow">in</span> <span class="n">passages_or_dotdicts</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
             <span class="c1"># Assume it's already a list of strings or handle other cases
</span>             <span class="n">passages</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">passages_or_dotdicts</span><span class="p">)</span>

        <span class="c1"># Return passages wrapped in a Prediction object
</span>        <span class="k">return</span> <span class="n">Prediction</span><span class="p">(</span><span class="n">passages</span><span class="o">=</span><span class="n">passages</span><span class="p">)</span>

<span class="c1"># Simplified view from dspy/dsp/colbertv2.py
</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">from</span> <span class="nn">dspy.dsp.utils</span> <span class="kn">import</span> <span class="n">dotdict</span>

<span class="k">class</span> <span class="nc">ColBERTv2</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">url</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">port</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">url</span> <span class="o">=</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">port</span><span class="si">}</span><span class="s">"</span> <span class="k">if</span> <span class="n">port</span> <span class="k">else</span> <span class="n">url</span>
        <span class="c1"># ... other init ...
</span>
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">query</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">dotdict</span><span class="p">]:</span>
        <span class="c1"># Construct the payload for the API request
</span>        <span class="n">payload</span> <span class="o">=</span> <span class="p">{</span><span class="s">"query"</span><span class="p">:</span> <span class="n">query</span><span class="p">,</span> <span class="s">"k"</span><span class="p">:</span> <span class="n">k</span><span class="p">}</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Make the HTTP GET request to the ColBERTv2 server
</span>            <span class="n">res</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">url</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">payload</span><span class="p">,</span> <span class="n">timeout</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
            <span class="n">res</span><span class="p">.</span><span class="n">raise_for_status</span><span class="p">()</span> <span class="c1"># Raise an exception for bad status codes
</span>
            <span class="c1"># Parse the JSON response
</span>            <span class="n">json_response</span> <span class="o">=</span> <span class="n">res</span><span class="p">.</span><span class="n">json</span><span class="p">()</span>
            <span class="n">topk</span> <span class="o">=</span> <span class="n">json_response</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"topk"</span><span class="p">,</span> <span class="p">[])[:</span><span class="n">k</span><span class="p">]</span>

            <span class="c1"># Convert results into dotdict objects for consistency
</span>            <span class="n">passages</span> <span class="o">=</span> <span class="p">[</span><span class="n">dotdict</span><span class="p">({</span><span class="o">**</span><span class="n">d</span><span class="p">,</span> <span class="s">"long_text"</span><span class="p">:</span> <span class="n">d</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"text"</span><span class="p">,</span> <span class="s">""</span><span class="p">)})</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">topk</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">passages</span>

        <span class="k">except</span> <span class="n">requests</span><span class="p">.</span><span class="n">exceptions</span><span class="p">.</span><span class="n">RequestException</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">"Error calling ColBERTv2 server: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span> <span class="c1"># Return empty list on error
</span></code></pre></div></div>

<p>The key idea is abstraction: <code class="language-plaintext highlighter-rouge">dspy.Retrieve</code> uses whatever RM is configured in <code class="language-plaintext highlighter-rouge">dspy.settings</code>, and the specific RM client hides the details of talking to its particular backend search system.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve now met the <strong>RM (Retrieval Model Client)</strong>, your DSPy program’s connection to external knowledge sources!</p>

<ul>
  <li>An RM acts like a <strong>librarian</strong> or <strong>search engine interface</strong>.</li>
  <li>It takes a <strong>query</strong> and fetches <strong>relevant text passages</strong> from systems like vector databases (Pinecone, Weaviate) or APIs (ColBERTv2).</li>
  <li>It provides crucial <strong>context</strong> for LMs, enabling tasks like answering questions about recent events or private documents (Retrieval-Augmented Generation - RAG).</li>
  <li>You configure it globally using <code class="language-plaintext highlighter-rouge">dspy.settings.configure(rm=...)</code>.</li>
  <li>The <code class="language-plaintext highlighter-rouge">dspy.Retrieve</code> module is the standard way to use the configured RM within your programs.</li>
</ul>

<p>With LMs providing reasoning and RMs providing knowledge, we can build powerful DSPy programs. But how do we know if our program is actually working well? How do we measure its performance? That’s where evaluation comes in!</p>

<p><strong>Next:</strong> <a href="07_evaluate.md">Chapter 7: Evaluate</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
