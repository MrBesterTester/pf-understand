<h1 id="chapter-9-adapter---the-universal-translator">Chapter 9: Adapter - The Universal Translator</h1>

<p>Welcome to Chapter 9! In <a href="08_teleprompter___optimizer.md">Chapter 8: Teleprompter / Optimizer</a>, we saw how DSPy can automatically optimize our programs by finding better prompts or few-shot examples. We ended up with a <code class="language-plaintext highlighter-rouge">compiled_program</code> that should perform better.</p>

<p>Now, this optimized program needs to communicate with a Language Model (<a href="05_lm__language_model_client_.md">LM</a>) to actually do its work. But here’s a potential challenge: different types of LMs expect different kinds of input!</p>
<ul>
  <li>Older <strong>Completion Models</strong> (like GPT-3 <code class="language-plaintext highlighter-rouge">davinci</code>) expect a single, long text prompt.</li>
  <li>Newer <strong>Chat Models</strong> (like GPT-4, Claude 3, Llama 3 Chat) expect a structured list of messages, each with a role (like “system”, “user”, or “assistant”).</li>
</ul>

<p>Our DSPy program, using its <a href="02_signature.md">Signature</a>, defines the task in an abstract way (inputs, outputs, instructions). How does this abstract definition get translated into the specific format required by the LM we’re using, especially these modern chat models?</p>

<p>That’s where the <strong><code class="language-plaintext highlighter-rouge">Adapter</code></strong> comes in! It acts like a universal translator.</p>

<p>Think of it like this:</p>
<ul>
  <li>Your DSPy program (using a <code class="language-plaintext highlighter-rouge">Signature</code>) has a message it wants to send to the LM.</li>
  <li>The LM speaks a specific language (e.g., “chat message list” language).</li>
  <li>The <code class="language-plaintext highlighter-rouge">Adapter</code> translates your program’s message into the LM’s language, handles the conversation, and translates the LM’s reply back into a format your DSPy program understands.</li>
</ul>

<p>In this chapter, you’ll learn:</p>

<ul>
  <li>What problem Adapters solve.</li>
  <li>What an <code class="language-plaintext highlighter-rouge">Adapter</code> does (formatting and parsing).</li>
  <li>How they allow your DSPy code to work with different LMs seamlessly.</li>
  <li>How they work behind the scenes (mostly automatically!).</li>
</ul>

<p>Let’s meet the translator!</p>

<h2 id="the-problem-different-lms-different-languages">The Problem: Different LMs, Different Languages</h2>

<p>Imagine you have a DSPy Signature for summarizing text:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dspy</span>

<span class="k">class</span> <span class="nc">Summarize</span><span class="p">(</span><span class="n">dspy</span><span class="p">.</span><span class="n">Signature</span><span class="p">):</span>
  <span class="s">"""Summarize the given text."""</span>
  <span class="n">text</span> <span class="o">=</span> <span class="n">dspy</span><span class="p">.</span><span class="n">InputField</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="s">"The text to summarize."</span><span class="p">)</span>
  <span class="n">summary</span> <span class="o">=</span> <span class="n">dspy</span><span class="p">.</span><span class="n">OutputField</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="s">"A concise summary."</span><span class="p">)</span>
</code></pre></div></div>

<p>And you use it in a <code class="language-plaintext highlighter-rouge">dspy.Predict</code> module:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Assume LM is configured (Chapter 5)
</span><span class="n">summarizer</span> <span class="o">=</span> <span class="n">dspy</span><span class="p">.</span><span class="n">Predict</span><span class="p">(</span><span class="n">Summarize</span><span class="p">)</span>
<span class="n">long_text</span> <span class="o">=</span> <span class="s">"DSPy is a framework for programming foundation models..."</span> <span class="c1"># (imagine longer text)
</span><span class="n">result</span> <span class="o">=</span> <span class="n">summarizer</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">long_text</span><span class="p">)</span>
<span class="c1"># We expect result.summary to contain the summary
</span></code></pre></div></div>

<p>Now, if the configured LM is a <strong>completion model</strong>, the <code class="language-plaintext highlighter-rouge">summarizer</code> needs to create a single prompt like:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Summarize the given text.

---

Follow the following format.

Text: ${text}
Summary: ${summary}

---

Text: DSPy is a framework for programming foundation models...
Summary: 
</code></pre></div></div>

<p>But if the configured LM is a <strong>chat model</strong>, it needs a structured list of messages, perhaps like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span>
  <span class="p">{</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"system"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="s">"Summarize the given text.</span><span class="se">\n\n</span><span class="s">Follow the following format.</span><span class="se">\n\n</span><span class="s">Text: ${text}</span><span class="se">\n</span><span class="s">Summary: ${summary}"</span><span class="p">},</span>
  <span class="p">{</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"user"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="s">"Text: DSPy is a framework for programming foundation models...</span><span class="se">\n</span><span class="s">Summary:"</span><span class="p">}</span>
<span class="p">]</span>
</code></pre></div></div>
<p><em>(Simplified - actual chat formatting can be more complex)</em></p>

<p>How does <code class="language-plaintext highlighter-rouge">dspy.Predict</code> know which format to use? And how does it extract the <code class="language-plaintext highlighter-rouge">summary</code> from the potentially differently formatted responses? It doesn’t! That’s the job of the <strong>Adapter</strong>.</p>

<h2 id="what-does-an-adapter-do">What Does an Adapter Do?</h2>

<p>An <code class="language-plaintext highlighter-rouge">Adapter</code> is a component that sits between your DSPy module (like <code class="language-plaintext highlighter-rouge">dspy.Predict</code>) and the <a href="05_lm__language_model_client_.md">LM Client</a>. Its main tasks are:</p>

<ol>
  <li><strong>Formatting:</strong> It takes the abstract information from DSPy – the <a href="02_signature.md">Signature</a> (instructions, input/output fields), any few-shot <code class="language-plaintext highlighter-rouge">demos</code> (<a href="03_example.md">Example</a>), and the current <code class="language-plaintext highlighter-rouge">inputs</code> – and <strong>formats</strong> it into the specific structure the target LM expects (either a single string or a list of chat messages).</li>
  <li><strong>Parsing:</strong> After the LM generates its response (which is usually just raw text), the <code class="language-plaintext highlighter-rouge">Adapter</code> <strong>parses</strong> this text to extract the values for the output fields defined in the <code class="language-plaintext highlighter-rouge">Signature</code> (like extracting the generated <code class="language-plaintext highlighter-rouge">summary</code> text).</li>
</ol>

<p>The most common adapter is the <code class="language-plaintext highlighter-rouge">dspy.adapters.ChatAdapter</code>, which is specifically designed to translate between the DSPy format and the message list format expected by chat models.</p>

<h2 id="why-use-adapters-flexibility">Why Use Adapters? Flexibility!</h2>

<p>The main benefit of using Adapters is <strong>flexibility</strong>.</p>

<ul>
  <li><strong>Write Once, Run Anywhere:</strong> Your core DSPy program logic (your <code class="language-plaintext highlighter-rouge">Module</code>s, <code class="language-plaintext highlighter-rouge">Program</code>s, and <code class="language-plaintext highlighter-rouge">Signature</code>s) remains the same regardless of whether you’re using a completion LM or a chat LM.</li>
  <li><strong>Easy Switching:</strong> You can switch the underlying <a href="05_lm__language_model_client_.md">LM Client</a> (e.g., from OpenAI GPT-3 to Anthropic Claude 3) in <code class="language-plaintext highlighter-rouge">dspy.settings</code>, and the appropriate Adapter (usually the default <code class="language-plaintext highlighter-rouge">ChatAdapter</code>) handles the communication differences automatically.</li>
  <li><strong>Standard Interface:</strong> Adapters ensure that modules like <code class="language-plaintext highlighter-rouge">dspy.Predict</code> have a consistent way to interact with LMs, hiding the complexities of different API formats.</li>
</ul>

<h2 id="how-adapters-work-format-and-parse">How Adapters Work: Format and Parse</h2>

<p>Let’s look conceptually at what the <code class="language-plaintext highlighter-rouge">ChatAdapter</code> does:</p>

<p><strong>1. Formatting (<code class="language-plaintext highlighter-rouge">format</code> method):</strong></p>

<p>Imagine calling our <code class="language-plaintext highlighter-rouge">summarizer</code> with one demo example:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Demo example
</span><span class="n">demo</span> <span class="o">=</span> <span class="n">dspy</span><span class="p">.</span><span class="n">Example</span><span class="p">(</span>
    <span class="n">text</span><span class="o">=</span><span class="s">"Long article about cats."</span><span class="p">,</span>
    <span class="n">summary</span><span class="o">=</span><span class="s">"Cats are popular pets."</span>
<span class="p">).</span><span class="n">with_inputs</span><span class="p">(</span><span class="s">"text"</span><span class="p">)</span>

<span class="c1"># Call the summarizer with the demo
</span><span class="n">result</span> <span class="o">=</span> <span class="n">summarizer</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">long_text</span><span class="p">,</span> <span class="n">demos</span><span class="o">=</span><span class="p">[</span><span class="n">demo</span><span class="p">])</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ChatAdapter</code>’s <code class="language-plaintext highlighter-rouge">format</code> method might take the <code class="language-plaintext highlighter-rouge">Summarize</code> signature, the <code class="language-plaintext highlighter-rouge">demo</code>, and the <code class="language-plaintext highlighter-rouge">long_text</code> input and produce a list of messages like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Conceptual Output of ChatAdapter.format()
</span><span class="p">[</span>
  <span class="c1"># 1. System message from Signature instructions
</span>  <span class="p">{</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"system"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="s">"Summarize the given text.</span><span class="se">\n\n</span><span class="s">---</span><span class="se">\n\n</span><span class="s">Follow the following format.</span><span class="se">\n\n</span><span class="s">Text: ${text}</span><span class="se">\n</span><span class="s">Summary: ${summary}</span><span class="se">\n\n</span><span class="s">---</span><span class="se">\n\n</span><span class="s">"</span><span class="p">},</span>

  <span class="c1"># 2. User turn for the demo input
</span>  <span class="p">{</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"user"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="s">"Text: Long article about cats.</span><span class="se">\n</span><span class="s">Summary:"</span><span class="p">},</span>

  <span class="c1"># 3. Assistant turn for the demo output
</span>  <span class="p">{</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"assistant"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="s">"Summary: Cats are popular pets."</span><span class="p">},</span> <span class="c1"># (Might use special markers like [[ ## Summary ## ]])
</span>
  <span class="c1"># 4. User turn for the actual input
</span>  <span class="p">{</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"user"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="s">"Text: DSPy is a framework for programming foundation models...</span><span class="se">\n</span><span class="s">Summary:"</span><span class="p">}</span>
<span class="p">]</span>
</code></pre></div></div>
<p><em>(Note: <code class="language-plaintext highlighter-rouge">ChatAdapter</code> uses specific markers like <code class="language-plaintext highlighter-rouge">[[ ## field_name ## ]]</code> to clearly separate fields in the content, making parsing easier)</em></p>

<p>This message list is then passed to the chat-based LM Client.</p>

<p><strong>2. Parsing (<code class="language-plaintext highlighter-rouge">parse</code> method):</strong></p>

<p>The chat LM responds, likely mimicking the format. Its response might be a string like:</p>

<div class="language-text highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[[ ## summary ## ]]
DSPy helps build and optimize language model pipelines.
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">ChatAdapter</code>’s <code class="language-plaintext highlighter-rouge">parse</code> method takes this string. It looks for the markers (<code class="language-plaintext highlighter-rouge">[[ ## summary ## ]]</code>) defined by the <code class="language-plaintext highlighter-rouge">Summarize</code> signature’s output fields. It extracts the content associated with each marker and returns a dictionary:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Conceptual Output of ChatAdapter.parse()
</span><span class="p">{</span>
  <span class="s">"summary"</span><span class="p">:</span> <span class="s">"DSPy helps build and optimize language model pipelines."</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This dictionary is then packaged into the <code class="language-plaintext highlighter-rouge">dspy.Prediction</code> object (as <code class="language-plaintext highlighter-rouge">result.summary</code>) that your <code class="language-plaintext highlighter-rouge">summarizer</code> module returns.</p>

<h2 id="using-adapters-its-often-automatic">Using Adapters (It’s Often Automatic!)</h2>

<p>The good news is that you usually don’t interact with Adapters directly. Modules like <code class="language-plaintext highlighter-rouge">dspy.Predict</code> are designed to use the currently configured adapter automatically.</p>

<p>DSPy sets a default adapter (usually <code class="language-plaintext highlighter-rouge">ChatAdapter</code>) in its global <code class="language-plaintext highlighter-rouge">dspy.settings</code>. When you configure your <a href="05_lm__language_model_client_.md">LM Client</a> like this:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">dspy</span>

<span class="c1"># Configure LM (Chapter 5)
# turbo = dspy.LM(model='openai/gpt-3.5-turbo')
# dspy.settings.configure(lm=turbo)
</span>
<span class="c1"># Default Adapter (ChatAdapter) is usually active automatically!
# You typically DON'T need to configure it unless you want a different one.
# dspy.settings.configure(adapter=dspy.adapters.ChatAdapter())
</span></code></pre></div></div>

<p>Now, when you use <code class="language-plaintext highlighter-rouge">dspy.Predict</code> or other modules that call LMs, they will internally use <code class="language-plaintext highlighter-rouge">dspy.settings.adapter</code> (the <code class="language-plaintext highlighter-rouge">ChatAdapter</code> in this case) to handle the formatting and parsing needed to talk to the configured <code class="language-plaintext highlighter-rouge">dspy.settings.lm</code> (<code class="language-plaintext highlighter-rouge">turbo</code>).</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># The summarizer automatically uses the configured LM and Adapter
</span><span class="n">summarizer</span> <span class="o">=</span> <span class="n">dspy</span><span class="p">.</span><span class="n">Predict</span><span class="p">(</span><span class="n">Summarize</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">summarizer</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">long_text</span><span class="p">)</span> <span class="c1"># Adapter works its magic here!
</span><span class="k">print</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">summary</span><span class="p">)</span>
</code></pre></div></div>

<p>You write your DSPy code at a higher level of abstraction, and the Adapter handles the translation details for you.</p>

<h2 id="how-it-works-under-the-hood">How It Works Under the Hood</h2>

<p>Let’s trace the flow when <code class="language-plaintext highlighter-rouge">summarizer(text=long_text)</code> is called, assuming a chat LM and the <code class="language-plaintext highlighter-rouge">ChatAdapter</code> are configured:</p>

<ol>
  <li><strong><code class="language-plaintext highlighter-rouge">Predict.__call__</code>:</strong> The <code class="language-plaintext highlighter-rouge">summarizer</code> (<code class="language-plaintext highlighter-rouge">dspy.Predict</code>) instance is called.</li>
  <li><strong>Get Components:</strong> It retrieves the <code class="language-plaintext highlighter-rouge">Signature</code> (<code class="language-plaintext highlighter-rouge">Summarize</code>), <code class="language-plaintext highlighter-rouge">demos</code>, <code class="language-plaintext highlighter-rouge">inputs</code> (<code class="language-plaintext highlighter-rouge">text</code>), the configured <code class="language-plaintext highlighter-rouge">LM</code> client, and the configured <code class="language-plaintext highlighter-rouge">Adapter</code> (e.g., <code class="language-plaintext highlighter-rouge">ChatAdapter</code>) from <code class="language-plaintext highlighter-rouge">dspy.settings</code>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Adapter.__call__</code>:</strong> <code class="language-plaintext highlighter-rouge">Predict</code> calls the <code class="language-plaintext highlighter-rouge">Adapter</code> instance, passing it the LM, signature, demos, and inputs.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Adapter.format</code>:</strong> The <code class="language-plaintext highlighter-rouge">Adapter</code>’s <code class="language-plaintext highlighter-rouge">__call__</code> method first calls its own <code class="language-plaintext highlighter-rouge">format</code> method. <code class="language-plaintext highlighter-rouge">ChatAdapter.format</code> generates the list of chat messages (system prompt, demo turns, final user turn).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">LM.__call__</code>:</strong> The <code class="language-plaintext highlighter-rouge">Adapter</code>’s <code class="language-plaintext highlighter-rouge">__call__</code> method then passes the formatted messages to the <code class="language-plaintext highlighter-rouge">LM</code> client instance (e.g., <code class="language-plaintext highlighter-rouge">turbo(messages=...)</code>).</li>
  <li><strong>API Call:</strong> The <code class="language-plaintext highlighter-rouge">LM</code> client sends the messages to the actual LM API (e.g., OpenAI API).</li>
  <li><strong>API Response:</strong> The LM API returns the generated completion text (e.g., <code class="language-plaintext highlighter-rouge">[[ ## summary ## ]]\nDSPy helps...</code>).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">LM.__call__</code> Returns:</strong> The <code class="language-plaintext highlighter-rouge">LM</code> client returns the raw completion string(s) back to the <code class="language-plaintext highlighter-rouge">Adapter</code>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Adapter.parse</code>:</strong> The <code class="language-plaintext highlighter-rouge">Adapter</code>’s <code class="language-plaintext highlighter-rouge">__call__</code> method calls its own <code class="language-plaintext highlighter-rouge">parse</code> method with the completion string. <code class="language-plaintext highlighter-rouge">ChatAdapter.parse</code> extracts the content based on the <code class="language-plaintext highlighter-rouge">[[ ## ... ## ]]</code> markers and the <code class="language-plaintext highlighter-rouge">Signature</code>’s output fields.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Adapter.__call__</code> Returns:</strong> The <code class="language-plaintext highlighter-rouge">Adapter</code> returns a list of dictionaries, each representing a parsed completion (e.g., <code class="language-plaintext highlighter-rouge">[{'summary': 'DSPy helps...'}]</code>).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">Predict.__call__</code> Returns:</strong> <code class="language-plaintext highlighter-rouge">Predict</code> packages these parsed dictionaries into <code class="language-plaintext highlighter-rouge">dspy.Prediction</code> objects and returns the result.</li>
</ol>

<p>Here’s a simplified sequence diagram:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant User
    participant PredictMod as dspy.Predict (summarizer)
    participant Adapter as Adapter (e.g., ChatAdapter)
    participant LMClient as LM Client (e.g., turbo)
    participant LMApi as Actual LM API

    User-&gt;&gt;PredictMod: Call summarizer(text=...)
    PredictMod-&gt;&gt;Adapter: __call__(lm=LMClient, signature, demos, inputs)
    Adapter-&gt;&gt;Adapter: format(signature, demos, inputs)
    Adapter--&gt;&gt;Adapter: Return formatted_messages (list)
    Adapter-&gt;&gt;LMClient: __call__(messages=formatted_messages)
    LMClient-&gt;&gt;LMApi: Send API Request
    LMApi--&gt;&gt;LMClient: Return raw_completion_text
    LMClient--&gt;&gt;Adapter: Return raw_completion_text
    Adapter-&gt;&gt;Adapter: parse(signature, raw_completion_text)
    Adapter--&gt;&gt;Adapter: Return parsed_output (dict)
    Adapter--&gt;&gt;PredictMod: Return list[parsed_output]
    PredictMod-&gt;&gt;PredictMod: Create Prediction object(s)
    PredictMod--&gt;&gt;User: Return Prediction object(s)
</code></pre>

<p><strong>Relevant Code Files:</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">dspy/adapters/base.py</code>: Defines the abstract <code class="language-plaintext highlighter-rouge">Adapter</code> class.
    <ul>
      <li>Requires subclasses to implement <code class="language-plaintext highlighter-rouge">format</code> and <code class="language-plaintext highlighter-rouge">parse</code>.</li>
      <li>The <code class="language-plaintext highlighter-rouge">__call__</code> method orchestrates the format -&gt; LM call -&gt; parse sequence.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">dspy/adapters/chat_adapter.py</code>: Defines <code class="language-plaintext highlighter-rouge">ChatAdapter</code>, the default implementation.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">format</code>: Implements logic to create the system/user/assistant message list, using <code class="language-plaintext highlighter-rouge">[[ ## ... ## ]]</code> markers. Includes helper functions like <code class="language-plaintext highlighter-rouge">format_turn</code> and <code class="language-plaintext highlighter-rouge">prepare_instructions</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">parse</code>: Implements logic to find the <code class="language-plaintext highlighter-rouge">[[ ## ... ## ]]</code> markers in the LM’s output string and extract the corresponding values.</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">dspy/predict/predict.py</code>: The <code class="language-plaintext highlighter-rouge">Predict</code> module’s <code class="language-plaintext highlighter-rouge">forward</code> method retrieves the adapter from <code class="language-plaintext highlighter-rouge">dspy.settings</code> and calls it.</li>
</ul>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified view from dspy/adapters/base.py
</span><span class="kn">from</span> <span class="nn">abc</span> <span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="c1"># ... other imports ...
</span>
<span class="k">class</span> <span class="nc">Adapter</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
    <span class="c1"># ... init ...
</span>
    <span class="c1"># The main orchestration method
</span>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lm</span><span class="p">:</span> <span class="s">"LM"</span><span class="p">,</span>
        <span class="n">lm_kwargs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">signature</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Signature</span><span class="p">],</span>
        <span class="n">demos</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]],</span>
        <span class="n">inputs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="c1"># 1. Format the inputs for the LM
</span>        <span class="c1">#    Returns either a string or list[dict] (for chat)
</span>        <span class="n">formatted_input</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">demos</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span>

        <span class="c1"># Prepare arguments for the LM call
</span>        <span class="n">lm_call_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">prompt</span><span class="o">=</span><span class="n">formatted_input</span><span class="p">)</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">formatted_input</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="nb">dict</span><span class="p">(</span><span class="n">messages</span><span class="o">=</span><span class="n">formatted_input</span><span class="p">)</span>

        <span class="c1"># 2. Call the Language Model Client
</span>        <span class="n">outputs</span> <span class="o">=</span> <span class="n">lm</span><span class="p">(</span><span class="o">**</span><span class="n">lm_call_args</span><span class="p">,</span> <span class="o">**</span><span class="n">lm_kwargs</span><span class="p">)</span> <span class="c1"># Returns list of strings or dicts
</span>
        <span class="c1"># 3. Parse the LM outputs
</span>        <span class="n">parsed_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">output</span> <span class="ow">in</span> <span class="n">outputs</span><span class="p">:</span>
            <span class="c1"># Extract raw text (simplified)
</span>            <span class="n">raw_text</span> <span class="o">=</span> <span class="n">output</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">output</span><span class="p">[</span><span class="s">"text"</span><span class="p">]</span>
            <span class="c1"># Parse the raw text based on the signature
</span>            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">raw_text</span><span class="p">)</span>
            <span class="c1"># Validate fields (simplified)
</span>            <span class="c1"># ...
</span>            <span class="n">parsed_values</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">parsed_values</span>

    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">demos</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">|</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># Subclasses must implement this to format input for the LM
</span>        <span class="k">raise</span> <span class="nb">NotImplementedError</span>

    <span class="o">@</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signature</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Signature</span><span class="p">],</span> <span class="n">completion</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="c1"># Subclasses must implement this to parse the LM's output string
</span>        <span class="k">raise</span> <span class="nb">NotImplementedError</span>

    <span class="c1"># ... other helper methods (format_fields, format_turn, etc.) ...
</span>

<span class="c1"># Simplified view from dspy/adapters/chat_adapter.py
# ... imports ...
</span><span class="kn">import</span> <span class="nn">re</span>

<span class="n">field_header_pattern</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="nb">compile</span><span class="p">(</span><span class="sa">r</span><span class="s">"\[\[ ## (\w+) ## \]\]"</span><span class="p">)</span> <span class="c1"># Matches [[ ## field_name ## ]]
</span>
<span class="k">class</span> <span class="nc">ChatAdapter</span><span class="p">(</span><span class="n">Adapter</span><span class="p">):</span>
    <span class="c1"># ... init ...
</span>
    <span class="k">def</span> <span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signature</span><span class="p">,</span> <span class="n">demos</span><span class="p">,</span> <span class="n">inputs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
        <span class="n">messages</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># 1. Create system message from signature instructions
</span>        <span class="c1">#    (Uses helper `prepare_instructions`)
</span>        <span class="n">prepared_instructions</span> <span class="o">=</span> <span class="n">prepare_instructions</span><span class="p">(</span><span class="n">signature</span><span class="p">)</span>
        <span class="n">messages</span><span class="p">.</span><span class="n">append</span><span class="p">({</span><span class="s">"role"</span><span class="p">:</span> <span class="s">"system"</span><span class="p">,</span> <span class="s">"content"</span><span class="p">:</span> <span class="n">prepared_instructions</span><span class="p">})</span>

        <span class="c1"># 2. Format demos into user/assistant turns
</span>        <span class="c1">#    (Uses helper `format_turn`)
</span>        <span class="k">for</span> <span class="n">demo</span> <span class="ow">in</span> <span class="n">demos</span><span class="p">:</span>
            <span class="n">messages</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">format_turn</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">demo</span><span class="p">,</span> <span class="n">role</span><span class="o">=</span><span class="s">"user"</span><span class="p">))</span>
            <span class="n">messages</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">format_turn</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">demo</span><span class="p">,</span> <span class="n">role</span><span class="o">=</span><span class="s">"assistant"</span><span class="p">))</span>

        <span class="c1"># 3. Format final input into a user turn
</span>        <span class="c1">#    (Handles chat history if present, uses `format_turn`)
</span>        <span class="c1"># ... logic for chat history or simple input ...
</span>        <span class="n">messages</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">.</span><span class="n">format_turn</span><span class="p">(</span><span class="n">signature</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">role</span><span class="o">=</span><span class="s">"user"</span><span class="p">))</span>

        <span class="c1"># Expand image tags if needed
</span>        <span class="n">messages</span> <span class="o">=</span> <span class="n">try_expand_image_tags</span><span class="p">(</span><span class="n">messages</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">messages</span>

    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signature</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Signature</span><span class="p">],</span> <span class="n">completion</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="c1"># Logic to split completion string by [[ ## field_name ## ]] markers
</span>        <span class="c1"># Finds matches using `field_header_pattern`
</span>        <span class="n">sections</span> <span class="o">=</span> <span class="bp">self</span><span class="p">.</span><span class="n">_split_completion_by_markers</span><span class="p">(</span><span class="n">completion</span><span class="p">)</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">field_content</span> <span class="ow">in</span> <span class="n">sections</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="n">signature</span><span class="p">.</span><span class="n">output_fields</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Use helper `parse_value` to cast string to correct type
</span>                    <span class="n">fields</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">parse_value</span><span class="p">(</span><span class="n">field_content</span><span class="p">,</span> <span class="n">signature</span><span class="p">.</span><span class="n">output_fields</span><span class="p">[</span><span class="n">field_name</span><span class="p">].</span><span class="n">annotation</span><span class="p">)</span>
                <span class="k">except</span> <span class="nb">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="c1"># Handle parsing errors
</span>                    <span class="c1"># ...
</span>                    <span class="k">pass</span>

        <span class="c1"># Check if all expected output fields were found
</span>        <span class="c1"># ...
</span>
        <span class="k">return</span> <span class="n">fields</span>

    <span class="c1"># ... helper methods: format_turn, format_fields, _split_completion_by_markers ...
</span></code></pre></div></div>

<p>The key takeaway is that <code class="language-plaintext highlighter-rouge">Adapter</code> subclasses provide concrete implementations for <code class="language-plaintext highlighter-rouge">format</code> (DSPy -&gt; LM format) and <code class="language-plaintext highlighter-rouge">parse</code> (LM output -&gt; DSPy format), enabling smooth communication.</p>

<h2 id="conclusion">Conclusion</h2>

<p>You’ve now met the <strong><code class="language-plaintext highlighter-rouge">Adapter</code></strong>, DSPy’s universal translator!</p>

<ul>
  <li>Adapters solve the problem of <strong>different LMs expecting different input formats</strong> (e.g., completion prompts vs. chat messages).</li>
  <li>They act as a bridge, <strong>formatting</strong> DSPy’s abstract <a href="02_signature.md">Signature</a>, demos, and inputs into the LM-specific format, and <strong>parsing</strong> the LM’s raw output back into structured DSPy data.</li>
  <li>The primary benefit is <strong>flexibility</strong>, allowing you to use the same DSPy program with various LM types without changing your core logic.</li>
  <li>Adapters like <code class="language-plaintext highlighter-rouge">ChatAdapter</code> usually work <strong>automatically</strong> behind the scenes, configured via <code class="language-plaintext highlighter-rouge">dspy.settings</code>.</li>
</ul>

<p>With Adapters handling the translation, LM Clients providing the connection, and RMs fetching knowledge, we have a powerful toolkit. But how do we manage all these configurations globally? That’s the role of <code class="language-plaintext highlighter-rouge">dspy.settings</code>.</p>

<p><strong>Next:</strong> <a href="10_settings.md">Chapter 10: Settings</a></p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
