<h1 id="chapter-4-strides-and-offset-computation">Chapter 4: Strides and Offset Computation</h1>

<p>Okay, here’s Chapter 4 of the Mojo tutorial, focusing on Strides and Offset Computation, designed to be very beginner-friendly.</p>

<h1 id="chapter-4-finding-your-way---strides-and-offset-computation">Chapter 4: Finding Your Way - Strides and Offset Computation</h1>

<p>In the previous chapters, we’ve learned a lot about <code class="language-plaintext highlighter-rouge">NDBuffer</code>:</p>
<ul>
  <li>It uses an <code class="language-plaintext highlighter-rouge">UnsafePointer</code> (its <code class="language-plaintext highlighter-rouge">data</code> field) to know the memory address where its elements begin (<a href="01_unsafepointer__as_used_by_ndbuffer__.md">Chapter 1</a>).</li>
  <li>It uses <code class="language-plaintext highlighter-rouge">DimList</code> to define its <code class="language-plaintext highlighter-rouge">shape</code> (the size of each dimension), which can be static or dynamic (<a href="02_dimlist_and_dim_.md">Chapter 2</a>).</li>
  <li>The <code class="language-plaintext highlighter-rouge">NDBuffer</code> struct itself combines these pieces of information to act as a “lens” on N-dimensional data (<a href="03_ndbuffer_.md">Chapter 3</a>), storing the actual runtime shape in its <code class="language-plaintext highlighter-rouge">dynamic_shape</code> field and, as we’ll see, runtime strides in <code class="language-plaintext highlighter-rouge">dynamic_stride</code>.</li>
</ul>

<p>Now, a crucial question arises: if an <code class="language-plaintext highlighter-rouge">NDBuffer</code> represents a 2D grid (like a matrix <code class="language-plaintext highlighter-rouge">matrix[row, col]</code>) or even a 3D cube, but computer memory is just one long, flat line of storage cells, how does <code class="language-plaintext highlighter-rouge">NDBuffer</code> find the exact memory location for a specific element, say, at <code class="language-plaintext highlighter-rouge">matrix[1, 2]</code>?</p>

<p>This is where <strong>strides</strong> and <strong>offset computation</strong> come into play. They are the magic map <code class="language-plaintext highlighter-rouge">NDBuffer</code> uses to navigate its N-dimensional view of 1D memory.</p>

<p>As the project overview puts it:</p>
<blockquote>
  <p>This refers to the core mechanism <code class="language-plaintext highlighter-rouge">NDBuffer</code> uses to locate any specific element within its N-dimensional view of memory. Given an N-dimensional index (e.g., <code class="language-plaintext highlighter-rouge">[row, col]</code>), the <code class="language-plaintext highlighter-rouge">NDBuffer</code> calculates a 1D offset from its base <code class="language-plaintext highlighter-rouge">data</code> pointer. This calculation relies on <code class="language-plaintext highlighter-rouge">strides</code>: an array where each element specifies how many memory items to skip to advance one step along the corresponding dimension.</p>
</blockquote>

<h2 id="the-memory-maze-from-n-dimensions-to-one-dimension">The Memory Maze: From N-Dimensions to One Dimension</h2>

<p>Imagine your computer’s memory as a single, incredibly long bookshelf. Each spot on the shelf can hold one data element (like one number). This bookshelf is 1-dimensional.</p>

<p>However, we often want to work with data in more dimensions:</p>
<ul>
  <li>A list of numbers (1D)</li>
  <li>A table or spreadsheet (2D)</li>
  <li>A stack of images, forming a video (3D)</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">NDBuffer</code> allows us to <em>think</em> about our data in these convenient N-dimensional ways. But underneath, the data still lives on that 1D bookshelf. The challenge is to create a system that can translate an N-dimensional coordinate (like “row 2, column 5”) into a single, unique position on the 1D bookshelf.</p>

<h2 id="introducing-strides-your-memory-navigation-map">Introducing Strides: Your Memory Navigation Map</h2>

<p><strong>Strides</strong> are the key to this translation. For an N-dimensional <code class="language-plaintext highlighter-rouge">NDBuffer</code>, the strides are a list of numbers, with one number for each dimension. Each number in the strides list tells you:</p>

<blockquote>
  <p>“To move one step forward in <em>this particular dimension</em>, while keeping your position in all other dimensions the same, how many actual items do you need to skip over in the 1D memory?”</p>
</blockquote>

<p>Let’s use the <strong>multi-story car park analogy</strong> from the project description:
Imagine your <code class="language-plaintext highlighter-rouge">NDBuffer.data</code> pointer is the entrance to a vast, continuous parking lot (our 1D memory). You want to <em>organize</em> this flat lot to represent a multi-story car park with levels, rows within levels, and spots within rows (your N-D view).</p>

<p>Let’s say you want to find your car using its <code class="language-plaintext highlighter-rouge">[level_index, row_index, spot_index]</code>.</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">NDBuffer.data</code></strong>: The entrance to the entire car park.</li>
  <li><strong>N-D Index (e.g., <code class="language-plaintext highlighter-rouge">[level, row, spot]</code>)</strong>: How you conceptually remember your car’s location.</li>
  <li><strong>Shape (e.g., <code class="language-plaintext highlighter-rouge">[num_levels, num_rows_per_level, num_spots_per_row]</code>)</strong>: The capacity and structure of your conceptual car park.</li>
  <li><strong>Strides</strong>: This is your navigation guide.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">stride_spot</code>: How many actual 1D parking spaces do you move to get from <code class="language-plaintext highlighter-rouge">spot_X</code> to <code class="language-plaintext highlighter-rouge">spot_X+1</code> <em>in the same row and on the same level</em>? (This is usually 1, as spots are typically side-by-side).</li>
      <li><code class="language-plaintext highlighter-rouge">stride_row</code>: How many actual 1D parking spaces do you move to get from <code class="language-plaintext highlighter-rouge">spot_X</code> in <code class="language-plaintext highlighter-rouge">row_Y</code> to <code class="language-plaintext highlighter-rouge">spot_X</code> in <code class="language-plaintext highlighter-rouge">row_Y+1</code> <em>on the same level</em>? (This would be the total number of spots in one complete row, e.g., <code class="language-plaintext highlighter-rouge">num_spots_per_row</code>).</li>
      <li><code class="language-plaintext highlighter-rouge">stride_level</code>: How many actual 1D parking spaces do you move to get from <code class="language-plaintext highlighter-rouge">spot_X</code> in <code class="language-plaintext highlighter-rouge">row_Y</code> on <code class="language-plaintext highlighter-rouge">level_Z</code> to <code class="language-plaintext highlighter-rouge">spot_X</code> in <code class="language-plaintext highlighter-rouge">row_Y</code> on <code class="language-plaintext highlighter-rouge">level_Z+1</code>? (This would be the total number of spots on one entire level, e.g., <code class="language-plaintext highlighter-rouge">num_spots_per_row * num_rows_per_level</code>).</li>
    </ul>
  </li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">NDBuffer</code> stores these runtime stride values in its <code class="language-plaintext highlighter-rouge">dynamic_stride</code> field (which is an <code class="language-plaintext highlighter-rouge">IndexList</code>, similar to <code class="language-plaintext highlighter-rouge">dynamic_shape</code>).</p>

<h2 id="contiguous-memory-and-calculating-default-strides-_compute_ndbuffer_stride">Contiguous Memory and Calculating Default Strides (<code class="language-plaintext highlighter-rouge">_compute_ndbuffer_stride</code>)</h2>

<p>Often, N-dimensional data is stored “contiguously” in memory. This means the elements are packed tightly together without any gaps, in a predictable order. A very common contiguous layout is <strong>row-major order</strong> (also known as C-style order for arrays).</p>

<p><strong>Row-Major Order (Example: 2D Matrix)</strong>
Imagine a 2x3 matrix (2 rows, 3 columns):</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A = | a b c |
    | d e f |
</code></pre></div></div>
<p>In row-major order, this matrix would be stored in memory as a flat sequence: <code class="language-plaintext highlighter-rouge">a, b, c, d, e, f</code>.
The first row (<code class="language-plaintext highlighter-rouge">a, b, c</code>) is laid out completely, followed by the second row (<code class="language-plaintext highlighter-rouge">d, e, f</code>).</p>

<p>For such a contiguous, row-major layout, <code class="language-plaintext highlighter-rouge">NDBuffer</code> can calculate default strides. The Mojo standard library provides the <code class="language-plaintext highlighter-rouge">_compute_ndbuffer_stride</code> function (found in <code class="language-plaintext highlighter-rouge">stdlib/src/buffer/buffer.mojo</code>) for this. Here’s how it generally works:</p>

<ol>
  <li>The stride for the <strong>innermost (last) dimension</strong> is always <strong>1</strong>. (To go to the next column in the same row, you just move to the very next element in memory).</li>
  <li>For any other dimension <code class="language-plaintext highlighter-rouge">d</code>, its stride is calculated by taking the size (from the <code class="language-plaintext highlighter-rouge">shape</code>) of the <em>next</em> dimension (<code class="language-plaintext highlighter-rouge">d+1</code>) and multiplying it by the stride of that <em>next</em> dimension (<code class="language-plaintext highlighter-rouge">d+1</code>). You work your way from the inside out.</li>
</ol>

<p>Let’s calculate default strides for our 2x3 matrix <code class="language-plaintext highlighter-rouge">A</code>.</p>
<ul>
  <li>Shape: <code class="language-plaintext highlighter-rouge">[2, 3]</code> (rows=2, columns=3)</li>
  <li>Rank (number of dimensions): 2</li>
</ul>

<ol>
  <li>
    <p><strong>Innermost dimension (columns, dimension index 1)</strong>:
<code class="language-plaintext highlighter-rouge">stride_col = dynamic_stride[1] = 1</code></p>
  </li>
  <li>
    <p><strong>Next dimension moving outwards (rows, dimension index 0)</strong>:
<code class="language-plaintext highlighter-rouge">stride_row = dynamic_stride[0] = shape[1] * dynamic_stride[1]</code>
<code class="language-plaintext highlighter-rouge">stride_row = 3 * 1 = 3</code></p>
  </li>
</ol>

<p>So, for a 2x3 row-major matrix, the default strides are <code class="language-plaintext highlighter-rouge">[3, 1]</code>.</p>
<ul>
  <li>To move to the next element in the same row (advance one column), you jump 1 memory spot.</li>
  <li>To move to the same column position in the next row (advance one row), you jump 3 memory spots (which is the entire length of a row).</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">_compute_ndbuffer_stride</code> function in <code class="language-plaintext highlighter-rouge">buffer.mojo</code> implements this logic:</p>
<pre><code class="language-mojo">@always_inline
fn _compute_ndbuffer_stride[
    rank: Int
](shape: IndexList[rank, **_]) -&gt; __type_of(shape):
    """Computes the NDBuffer's default dynamic strides using the input shape.
    The default strides correspond to contiguous memory layout.
    ...
    """
    constrained[rank &gt; 0]()

    @parameter
    if rank == 1: // Special case for 1D arrays
        return __type_of(shape)(1) // Stride is just 1

    var stride = shape // Temporary, will be overwritten
    stride[rank - 1] = 1 // Stride for the innermost dimension is 1

    // Iterate from the second-to-last dimension backwards to the first
    @parameter
    for i in reversed(range(rank - 1)): // Correctly iterates i from rank-2 down to 0
                                         // Example: rank=2, i=0. stride[0]=shape[1]*stride[1]
                                         // Example: rank=3, i=1,0. stride[1]=shape[2]*stride[2], then stride[0]=shape[1]*stride[1]
        stride[i] = shape[i + 1] * stride[i + 1]

    return stride
</code></pre>
<p>When you create an <code class="language-plaintext highlighter-rouge">NDBuffer</code> and don’t explicitly provide strides, this function is typically used to calculate them based on the shape, assuming a contiguous, row-major layout.</p>

<h2 id="calculating-the-offset-finding-the-exact-spot-_compute_ndbuffer_offset">Calculating the Offset: Finding the Exact Spot (<code class="language-plaintext highlighter-rouge">_compute_ndbuffer_offset</code>)</h2>

<p>Once an <code class="language-plaintext highlighter-rouge">NDBuffer</code> has:</p>
<ol>
  <li>Its <code class="language-plaintext highlighter-rouge">data</code> pointer (the starting address of the memory block).</li>
  <li>The N-dimensional <code class="language-plaintext highlighter-rouge">index</code> of the element you want (e.g., <code class="language-plaintext highlighter-rouge">[row_idx, col_idx]</code>).</li>
  <li>Its <code class="language-plaintext highlighter-rouge">dynamic_stride</code> list (e.g., <code class="language-plaintext highlighter-rouge">[stride_for_row, stride_for_col]</code>).</li>
</ol>

<p>It can calculate the 1D <strong>offset</strong> from the <code class="language-plaintext highlighter-rouge">data</code> pointer to your desired element. The formula is a sum of products:</p>

<p><code class="language-plaintext highlighter-rouge">offset = (index_dim0 * stride_dim0) + (index_dim1 * stride_dim1) + ... + (index_dimN-1 * stride_dimN-1)</code></p>

<p>Let’s use our 2x3 matrix <code class="language-plaintext highlighter-rouge">A</code> again:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">data</code> points to where <code class="language-plaintext highlighter-rouge">a</code> is stored.</li>
  <li>Shape <code class="language-plaintext highlighter-rouge">[2, 3]</code>.</li>
  <li>Strides <code class="language-plaintext highlighter-rouge">[3, 1]</code>. (i.e., <code class="language-plaintext highlighter-rouge">stride_row = 3</code>, <code class="language-plaintext highlighter-rouge">stride_col = 1</code>)</li>
</ul>

<p>Suppose we want to find element <code class="language-plaintext highlighter-rouge">A[1, 2]</code> (this is element <code class="language-plaintext highlighter-rouge">f</code> in <code class="language-plaintext highlighter-rouge">[[a,b,c], [d,e,f]]</code>).
The N-D index is <code class="language-plaintext highlighter-rouge">[1, 2]</code>.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">row_idx = 1</code></li>
  <li><code class="language-plaintext highlighter-rouge">col_idx = 2</code></li>
</ul>

<p><code class="language-plaintext highlighter-rouge">offset = (row_idx * stride_row) + (col_idx * stride_col)</code>
<code class="language-plaintext highlighter-rouge">offset = (1 * 3) + (2 * 1)</code>
<code class="language-plaintext highlighter-rouge">offset = 3 + 2</code>
<code class="language-plaintext highlighter-rouge">offset = 5</code></p>

<p>This means element <code class="language-plaintext highlighter-rouge">A[1, 2]</code> is 5 memory spots away from the start (<code class="language-plaintext highlighter-rouge">data</code>). If <code class="language-plaintext highlighter-rouge">data</code> points to memory location <code class="language-plaintext highlighter-rouge">P</code>:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">P+0</code>: <code class="language-plaintext highlighter-rouge">a</code> (<code class="language-plaintext highlighter-rouge">A[0,0]</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">P+1</code>: <code class="language-plaintext highlighter-rouge">b</code> (<code class="language-plaintext highlighter-rouge">A[0,1]</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">P+2</code>: <code class="language-plaintext highlighter-rouge">c</code> (<code class="language-plaintext highlighter-rouge">A[0,2]</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">P+3</code>: <code class="language-plaintext highlighter-rouge">d</code> (<code class="language-plaintext highlighter-rouge">A[1,0]</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">P+4</code>: <code class="language-plaintext highlighter-rouge">e</code> (<code class="language-plaintext highlighter-rouge">A[1,1]</code>)</li>
  <li><code class="language-plaintext highlighter-rouge">P+5</code>: <code class="language-plaintext highlighter-rouge">f</code> (<code class="language-plaintext highlighter-rouge">A[1,2]</code>)  &lt;– We found it!</li>
</ul>

<p>The <code class="language-plaintext highlighter-rouge">NDBuffer</code> method <code class="language-plaintext highlighter-rouge">_offset()</code> uses the helper function <code class="language-plaintext highlighter-rouge">_compute_ndbuffer_offset</code> to do exactly this. Here’s a simplified look at <code class="language-plaintext highlighter-rouge">_compute_ndbuffer_offset</code> from <code class="language-plaintext highlighter-rouge">buffer.mojo</code>:</p>

<pre><code class="language-mojo">@always_inline
fn _compute_ndbuffer_offset(
    buf: NDBuffer,
    index: VariadicList[Int], // Could also be StaticTuple or IndexList
) -&gt; Int:
    """Computes the NDBuffer's offset using the index positions provided.
    ...
    """
    // ... (rank 0 and 32-bit indexing checks omitted for simplicity) ...

    var result: Int = 0
    @parameter
    for i in range(buf.rank):
        // buf.stride[i]() gets the stride for the i-th dimension
        // index[i] gets the index for the i-th dimension
        // fma(a, b, c) is "fused multiply-add", calculates (a*b) + c efficiently
        result = fma(buf.stride[i](), index[i], result)
    return result
</code></pre>
<p>This function iterates through each dimension, multiplies the index for that dimension by its corresponding stride, and adds it to the accumulating <code class="language-plaintext highlighter-rouge">result</code>. This is the heart of how <code class="language-plaintext highlighter-rouge">NDBuffer</code> navigates its data.</p>

<h2 id="the-power-of-strides-more-than-just-contiguous">The Power of Strides: More Than Just Contiguous</h2>

<p>The really cool thing about strides is that they aren’t limited to describing just standard row-major (or column-major) layouts. By manually defining or manipulating the strides, an <code class="language-plaintext highlighter-rouge">NDBuffer</code> can represent many different views of the same underlying memory <em>without copying any data</em>.</p>

<ol>
  <li><strong>Column-Major Order (Fortran-style)</strong>:
For our 2x3 matrix <code class="language-plaintext highlighter-rouge">A</code>, if it were stored column-by-column (<code class="language-plaintext highlighter-rouge">a, d, b, e, c, f</code>), the strides would be <code class="language-plaintext highlighter-rouge">[1, 2]</code>.
    <ul>
      <li><code class="language-plaintext highlighter-rouge">stride_row = 1</code>: To get to the next row in the same column, jump 1 spot.</li>
      <li><code class="language-plaintext highlighter-rouge">stride_col = 2</code>: To get to the next column, jump 2 spots (the length of a column).</li>
    </ul>
  </li>
  <li><strong>Slices (Views of Data)</strong>:
Imagine you have a large 10x10 matrix, but you only want to work with a 3x3 sub-section of it (a slice). You can create a new <code class="language-plaintext highlighter-rouge">NDBuffer</code> for this 3x3 slice. This new <code class="language-plaintext highlighter-rouge">NDBuffer</code> would:
    <ul>
      <li>Have its <code class="language-plaintext highlighter-rouge">data</code> pointer offset to the start of the 3x3 region within the original 10x10 data.</li>
      <li>Have a <code class="language-plaintext highlighter-rouge">shape</code> of <code class="language-plaintext highlighter-rouge">[3, 3]</code>.</li>
      <li>Use the <strong>same strides</strong> as the original 10x10 matrix!
No data is copied; the slice is just a different “lens” on the existing memory.</li>
    </ul>
  </li>
  <li>
    <p><strong>Transposed Matrices</strong>:
You can “transpose” a matrix (swap its rows and columns) simply by changing its shape and strides, without moving data.
If matrix <code class="language-plaintext highlighter-rouge">M</code> has shape <code class="language-plaintext highlighter-rouge">[R, C]</code> and strides <code class="language-plaintext highlighter-rouge">[stride_R, stride_C]</code>.
Its transpose <code class="language-plaintext highlighter-rouge">M_T</code> will have shape <code class="language-plaintext highlighter-rouge">[C, R]</code> and strides <code class="language-plaintext highlighter-rouge">[stride_C, stride_R]</code>.
Again, it’s a new view on the same data.</p>
  </li>
  <li><strong>Broadcasting</strong>:
Sometimes in numerical computing, you want to operate between arrays of different shapes (e.g., adding a vector to each row of a matrix). Strides can help represent this. If a dimension has a stride of <code class="language-plaintext highlighter-rouge">0</code>, accessing any index along that “broadcasted” dimension will always return data from the same memory location(s). This effectively makes that dimension appear to repeat its data.</li>
</ol>

<p>This flexibility to represent various data layouts and views through strides makes <code class="language-plaintext highlighter-rouge">NDBuffer</code> incredibly efficient and powerful for tasks in scientific computing, machine learning, and data analysis, where avoiding data copies is crucial for performance.</p>

<h2 id="key-takeaways-for-chapter-4">Key Takeaways for Chapter 4</h2>

<ul>
  <li><strong>Strides</strong> define how many memory items to skip to advance one step along each dimension of an <code class="language-plaintext highlighter-rouge">NDBuffer</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">NDBuffer</code> uses the N-D index provided by you (e.g., <code class="language-plaintext highlighter-rouge">my_buffer[r,c]</code>) and its internal <code class="language-plaintext highlighter-rouge">dynamic_stride</code> values to calculate a 1D <strong>offset</strong> from its base <code class="language-plaintext highlighter-rouge">data</code> pointer.</li>
  <li>The function <code class="language-plaintext highlighter-rouge">_compute_ndbuffer_stride</code> (in <code class="language-plaintext highlighter-rouge">stdlib/src/buffer/buffer.mojo</code>) can calculate default strides for a contiguous, row-major memory layout based on the <code class="language-plaintext highlighter-rouge">NDBuffer</code>’s shape.</li>
  <li>The function <code class="language-plaintext highlighter-rouge">_compute_ndbuffer_offset</code> (in <code class="language-plaintext highlighter-rouge">stdlib/src/buffer/buffer.mojo</code>) performs the actual calculation: <code class="language-plaintext highlighter-rouge">offset = sum(index_dim_i * stride_dim_i)</code>.</li>
  <li>Strides are powerful because they allow <code class="language-plaintext highlighter-rouge">NDBuffer</code> to represent various memory layouts (row-major, column-major, slices, transposes, broadcasted arrays) efficiently, often without needing to copy the underlying data.</li>
</ul>

<h2 id="whats-next">What’s Next?</h2>

<p>We now understand how <code class="language-plaintext highlighter-rouge">NDBuffer</code> can pinpoint any individual element within its N-dimensional view. But in high-performance computing, we often want to read or write <em>multiple</em> elements at once to take advantage of modern CPU capabilities. This is where SIMD (Single Instruction, Multiple Data) operations come in.</p>

<p>In the next chapter, <a href="05_simd_data_access_.md">Chapter 5: SIMD Data Access</a>, we’ll explore how <code class="language-plaintext highlighter-rouge">NDBuffer</code> allows you to load and store data in chunks, further boosting performance.</p>

<hr />
<p><em>Navigation</em></p>
<ol>
  <li><a href="01_unsafepointer__as_used_by_ndbuffer__.md">UnsafePointer (as used by NDBuffer)</a></li>
  <li><a href="02_dimlist_and_dim_.md">DimList and Dim</a></li>
  <li><a href="03_ndbuffer_.md">NDBuffer</a></li>
  <li><strong>Strides and Offset Computation (You are here)</strong></li>
  <li><a href="05_simd_data_access_.md">SIMD Data Access</a>
```</li>
</ol>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
