<h1 id="chapter-4-dimlist">Chapter 4: DimList</h1>

<p>Okay, here is Chapter 4 on <code class="language-plaintext highlighter-rouge">DimList</code> in Markdown format, designed to be very beginner-friendly.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># Chapter 4: Describing Dimensions with `Dim` and `DimList`</span>

In <span class="p">[</span><span class="nv">Chapter 3: Working with Multiple Dimensions: `IndexList`</span><span class="p">](</span><span class="sx">03_indexlist_.md</span><span class="p">)</span>, we learned about <span class="sb">`IndexList`</span>, a handy tool for representing coordinates or shapes with a fixed number of dimensions, where each dimension's size was a concrete number.

Now, we're going to explore a more specialized way to describe dimensions, particularly for <span class="sb">`NDBuffer`</span> (which we'll cover in the next chapter). Meet <span class="sb">`Dim`</span> and <span class="sb">`DimList`</span>!

The official description puts it well:
<span class="gt">&gt; `DimList` is a specialized list used by `NDBuffer` to define its structural properties, specifically its shape (the size of each dimension) and strides (the memory step size for each dimension). Imagine building with LEGOs; `DimList` would be like the part of the instructions telling you the length, width, and height of a particular block (shape) and how many studs to count in the flat array of all LEGO pieces to find the next piece in each respective direction (strides). `DimList` can handle both compile-time known (static) dimensions and runtime-defined (dynamic) dimensions, offering flexibility in defining tensor structures.</span>

This means <span class="sb">`DimList`</span> is super useful because sometimes we know the exact size of our data when we write our code (static), and sometimes we only find out when the program runs (dynamic), like when loading an image file.

<span class="gu">## The Building Block: `Dim`</span>

Before we jump into <span class="sb">`DimList`</span>, let's understand its fundamental component: <span class="sb">`Dim`</span>.

A <span class="sb">`Dim`</span> represents a <span class="gs">**single dimension's size**</span>. The cool part is that this size can either be:
<span class="p">1.</span>  <span class="gs">**Statically Known**</span>: The size is a specific number known when you compile your code (e.g., a dimension of size 5).
<span class="p">2.</span>  <span class="gs">**Dynamic (Unknown at Compile Time)**</span>: The size isn't known until the program is running (e.g., the width of an image loaded from a file).

You'll need to import <span class="sb">`Dim`</span> (and <span class="sb">`DimList`</span>) from the <span class="sb">`buffer.dimlist`</span> module:
<span class="p">```</span><span class="nl">mojo
</span><span class="sb">from buffer.dimlist import Dim, DimList
</span></code></pre></div></div>

<h3 id="creating-dims">Creating <code class="language-plaintext highlighter-rouge">Dim</code>s</h3>

<ul>
  <li><strong>Dynamic <code class="language-plaintext highlighter-rouge">Dim</code></strong>: If a dimension’s size is unknown at compile time, you create a <code class="language-plaintext highlighter-rouge">Dim</code> without an argument:
    <pre><code class="language-mojo">var dynamic_dim = Dim()
print(dynamic_dim) # Output: ?
</code></pre>
    <p>The <code class="language-plaintext highlighter-rouge">?</code> tells us this dimension’s size is dynamic.</p>
  </li>
  <li><strong>Static <code class="language-plaintext highlighter-rouge">Dim</code></strong>: If the size is known, you provide it as an argument:
    <pre><code class="language-mojo">var static_dim = Dim(8)
print(static_dim) # Output: 8
</code></pre>
  </li>
</ul>

<h3 id="checking-dim-properties">Checking <code class="language-plaintext highlighter-rouge">Dim</code> Properties</h3>

<p><code class="language-plaintext highlighter-rouge">Dim</code> has helpful methods to tell you about its nature:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">has_value() -&gt; Bool</code>: Returns <code class="language-plaintext highlighter-rouge">True</code> if the <code class="language-plaintext highlighter-rouge">Dim</code> has a static value, <code class="language-plaintext highlighter-rouge">False</code> if it’s dynamic.</li>
  <li><code class="language-plaintext highlighter-rouge">is_dynamic() -&gt; Bool</code>: Returns <code class="language-plaintext highlighter-rouge">True</code> if the <code class="language-plaintext highlighter-rouge">Dim</code> is dynamic, <code class="language-plaintext highlighter-rouge">False</code> if it has a static value. (This is the opposite of <code class="language-plaintext highlighter-rouge">has_value()</code>).</li>
  <li><code class="language-plaintext highlighter-rouge">get() -&gt; Int</code>: If the <code class="language-plaintext highlighter-rouge">Dim</code> has a static value (<code class="language-plaintext highlighter-rouge">has_value()</code> is <code class="language-plaintext highlighter-rouge">True</code>), <code class="language-plaintext highlighter-rouge">get()</code> returns that integer value. <strong>Caution</strong>: Calling <code class="language-plaintext highlighter-rouge">get()</code> on a dynamic <code class="language-plaintext highlighter-rouge">Dim</code> might lead to unexpected results or errors; it’s best to check <code class="language-plaintext highlighter-rouge">has_value()</code> first.</li>
</ul>

<p>Let’s see them in action:</p>
<pre><code class="language-mojo">fn demo_dim_properties():
    var d_known = Dim(42)
    var d_unknown = Dim()

    print("d_known:")
    print("  Value:", d_known)             # Output: 42
    print("  Has value?", d_known.has_value()) # Output: True
    print("  Is dynamic?", d_known.is_dynamic())# Output: False
    if d_known.has_value():
        print("  Actual value:", d_known.get())# Output: 42

    print("d_unknown:")
    print("  Value:", d_unknown)             # Output: ?
    print("  Has value?", d_unknown.has_value()) # Output: False
    print("  Is dynamic?", d_unknown.is_dynamic())# Output: True
    if d_unknown.has_value(): # This block won't execute
        print("  Actual value:", d_unknown.get())
    else:
        print("  Actual value: Not available (dynamic)")

# To run the demo:
# demo_dim_properties()
</code></pre>

<h3 id="dim-operations"><code class="language-plaintext highlighter-rouge">Dim</code> Operations</h3>

<p><code class="language-plaintext highlighter-rouge">Dim</code> objects can also be part of simple arithmetic:</p>
<pre><code class="language-mojo">fn demo_dim_ops():
    var dim8 = Dim(8)
    var dim2 = Dim(2)
    var dim_unknown = Dim()

    var dim_product = dim8 * dim2
    print(dim_product) # Output: 16 (because 8 * 2 = 16)

    var dim_product_with_unknown = dim8 * dim_unknown
    print(dim_product_with_unknown) # Output: ? (if one is unknown, result is unknown)

    var dim_div = dim8 // dim2
    print(dim_div)     # Output: 4 (because 8 // 2 = 4)
    print(dim_div.get()) # Output: 4
</code></pre>
<p>If any <code class="language-plaintext highlighter-rouge">Dim</code> in an operation is dynamic (<code class="language-plaintext highlighter-rouge">?</code>), the result is usually also dynamic.</p>

<h2 id="the-list-of-dimensions-dimlist">The List of Dimensions: <code class="language-plaintext highlighter-rouge">DimList</code></h2>

<p>Now that we understand <code class="language-plaintext highlighter-rouge">Dim</code>, a <code class="language-plaintext highlighter-rouge">DimList</code> is simply a list of <code class="language-plaintext highlighter-rouge">Dim</code> objects. It’s used to represent a collection of dimension sizes, typically for the <strong>shape</strong> (e.g., height, width, channels of an image) or <strong>strides</strong> (how many steps to take in memory to get to the next element in each dimension) of an N-dimensional piece of data.</p>

<h3 id="creating-dimlists">Creating <code class="language-plaintext highlighter-rouge">DimList</code>s</h3>

<p>You can create a <code class="language-plaintext highlighter-rouge">DimList</code> by providing <code class="language-plaintext highlighter-rouge">Dim</code> objects or integers (which will be converted to static <code class="language-plaintext highlighter-rouge">Dim</code>s) as arguments:</p>

<pre><code class="language-mojo">fn demo_dimlist_creation():
    // All dimensions known
    var lst0 = DimList(1, 2, 3, 4)
    print("lst0:", lst0) # Output: lst0: [1, 2, 3, 4]

    // Some dimensions dynamic
    var lst1 = DimList(Dim(), 2, Dim(3), 4) // Dim() is dynamic, Dim(3) is static
    print("lst1:", lst1) # Output: lst1: [?, 2, 3, 4]

    // You can also create a DimList with all dimensions dynamic using `create_unknown`.
    // The number in the square brackets `[N]` must be known at compile time.
    // It tells Mojo how many dynamic dimensions to create.
    var lst_unknown = DimList.create_unknown[3]()
    print("lst_unknown:", lst_unknown) # Output: lst_unknown: [?, ?, ?]
</code></pre>

<h3 id="dimlist-properties-and-operations"><code class="language-plaintext highlighter-rouge">DimList</code> Properties and Operations</h3>

<p><code class="language-plaintext highlighter-rouge">DimList</code> offers several ways to inspect and work with its dimensions:</p>

<ul>
  <li><strong>Length</strong>: <code class="language-plaintext highlighter-rouge">len(my_dimlist)</code> gives you the number of dimensions (the rank).
    <pre><code class="language-mojo">var dl = DimList(5, 10, Dim())
print("Length of dl:", len(dl)) # Output: Length of dl: 3
</code></pre>
  </li>
  <li><strong>Accessing <code class="language-plaintext highlighter-rouge">Dim</code>s</strong>: <code class="language-plaintext highlighter-rouge">.at[index]()</code> returns the <code class="language-plaintext highlighter-rouge">Dim</code> object at a specific index. The <code class="language-plaintext highlighter-rouge">index</code> must be known at compile time.
    <pre><code class="language-mojo">var dl = DimList(10, Dim(), 30)
var first_dim = dl.at[0]()
var second_dim = dl.at[1]()
print("First Dim:", first_dim)   # Output: First Dim: 10
print("Second Dim:", second_dim) # Output: Second Dim: ?
</code></pre>
  </li>
  <li><strong>Accessing Static Values</strong>: <code class="language-plaintext highlighter-rouge">.get[index]()</code> returns the integer value of the <code class="language-plaintext highlighter-rouge">Dim</code> at <code class="language-plaintext highlighter-rouge">index</code>, but <em>only if it’s static</em>. Like <code class="language-plaintext highlighter-rouge">Dim.get()</code>, use with caution or after checking.
    <pre><code class="language-mojo">var dl = DimList(10, Dim(), 30)
if dl.at[0]().has_value():
    print("Value of first dim:", dl.get[0]()) # Output: Value of first dim: 10
</code></pre>
  </li>
  <li><strong>Checking for Static Values</strong>:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">.has_value[index]() -&gt; Bool</code>: Checks if the <code class="language-plaintext highlighter-rouge">Dim</code> at a specific <code class="language-plaintext highlighter-rouge">index</code> (compile-time known) has a static value.
        <pre><code class="language-mojo">var dl = DimList(Dim(), 20)
print("dl.has_value[0]():", dl.has_value[0]()) # Output: dl.has_value[0](): False
print("dl.has_value[1]():", dl.has_value[1]()) # Output: dl.has_value[1](): True
</code></pre>
      </li>
      <li><code class="language-plaintext highlighter-rouge">.all_known[count]() -&gt; Bool</code>: Checks if the first <code class="language-plaintext highlighter-rouge">count</code> dimensions are all static. <code class="language-plaintext highlighter-rouge">count</code> must be known at compile time.</li>
      <li><code class="language-plaintext highlighter-rouge">.all_known[start, end]() -&gt; Bool</code>: Checks if dimensions in the range <code class="language-plaintext highlighter-rouge">[start, end)</code> are all static. <code class="language-plaintext highlighter-rouge">start</code> and <code class="language-plaintext highlighter-rouge">end</code> must be compile-time known.
        <pre><code class="language-mojo">var lst_all_known = DimList(1, 2, 3, 4)
var lst_some_unknown = DimList(Dim(), 2, 3, 4)

print("lst_all_known.all_known[4]():", lst_all_known.all_known[4]()) # Output: True
print("lst_some_unknown.all_known[4]():", lst_some_unknown.all_known[4]()) # Output: False
// Check only from index 1 up to (but not including) index 4
print("lst_some_unknown.all_known[1, 4]():", lst_some_unknown.all_known[1, 4]()) # Output: True (dims at 1,2,3 are 2,3,4)
</code></pre>
      </li>
    </ul>
  </li>
  <li><strong>Product of Dimensions</strong>: <code class="language-plaintext highlighter-rouge">.product()</code> calculates the total number of elements if all dimensions were multiplied together.
    <ul>
      <li>If all dimensions involved are static, it returns a static <code class="language-plaintext highlighter-rouge">Dim</code> with the product.</li>
      <li>If any dimension involved is dynamic (<code class="language-plaintext highlighter-rouge">?</code>), it returns a dynamic <code class="language-plaintext highlighter-rouge">Dim (</code>?`).</li>
      <li>You can also get the product of a sub-range: <code class="language-plaintext highlighter-rouge">.product[count]()</code> or <code class="language-plaintext highlighter-rouge">.product[start, end]()</code>.
```mojo
var dl_static = DimList(2, 3, 4) # Product = 2<em>3</em>4 = 24
print(“Product of dl_static:”, dl_static.product())             # Output: Product of dl_static: 24
print(“Product of dl_static:”, dl_static.product().get())       # Output: Product of dl_static: 24</li>
    </ul>

    <p>var dl_dynamic = DimList(2, Dim(), 4)
print(“Product of dl_dynamic:”, dl_dynamic.product())           # Output: Product of dl_dynamic: ?</p>

    <h1 id="product-of-the-first-2-elements-of-dl_static-236">Product of the first 2 elements of dl_static (2*3=6)</h1>
    <p>print(“Product of dl_static[0..1]:”, dl_static.product<a href="">2</a>)    # Output: Product of dl_static[0..1]: 6
```</p>
  </li>
  <li><strong>Comparing <code class="language-plaintext highlighter-rouge">DimList</code>s</strong>: You can check if two <code class="language-plaintext highlighter-rouge">DimList</code>s are equal (<code class="language-plaintext highlighter-rouge">==</code>). They are equal if they have the same length, and for each position, their <code class="language-plaintext highlighter-rouge">Dim</code>s are equal. (A static <code class="language-plaintext highlighter-rouge">Dim</code> is only equal to another static <code class="language-plaintext highlighter-rouge">Dim</code> with the same value. A dynamic <code class="language-plaintext highlighter-rouge">Dim</code> is equal to another dynamic <code class="language-plaintext highlighter-rouge">Dim</code>.)
    <pre><code class="language-mojo">fn demo_dimlist_eq():
    var d1 = DimList(Dim(), 42, Dim())
    var d2 = DimList(Dim(), 42, Dim())
    var d3 = DimList(1, 42, Dim())

    print("d1 == d2:", d1 == d2) # Output: d1 == d2: True
    print("d1 == d3:", d1 == d3) # Output: d1 == d3: False
</code></pre>
  </li>
</ul>

<h2 id="why-dimlist-the-power-of-static-and-dynamic">Why <code class="language-plaintext highlighter-rouge">DimList</code>? The Power of Static and Dynamic</h2>

<p>The real strength of <code class="language-plaintext highlighter-rouge">Dim</code> and <code class="language-plaintext highlighter-rouge">DimList</code> comes from this ability to mix compile-time (static) and runtime (dynamic) information.</p>

<ul>
  <li><strong>Static Dimensions = Optimization</strong>: If Mojo knows the exact shape of your data when it compiles your code (e.g., <code class="language-plaintext highlighter-rouge">DimList(10, 20, 3)</code>), it can perform many powerful optimizations. It can unroll loops, calculate memory offsets precisely, and generate highly efficient machine code.</li>
  <li><strong>Dynamic Dimensions = Flexibility</strong>: If your data’s shape isn’t known until your program runs (e.g., you ask the user for dimensions, or load a file), <code class="language-plaintext highlighter-rouge">DimList(Dim(), Dim(), Dim())</code> can represent this. Your code can then adapt to the actual sizes encountered at runtime.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">NDBuffer</code>, which we’ll see next, uses <code class="language-plaintext highlighter-rouge">DimList</code> for its <code class="language-plaintext highlighter-rouge">shape</code> and <code class="language-plaintext highlighter-rouge">strides</code> parameters. This allows you to create <code class="language-plaintext highlighter-rouge">NDBuffer</code>s that are either fully optimized for a known shape or flexible enough to handle shapes determined on the fly.</p>

<h2 id="examples-from-tests">Examples from Tests</h2>

<p>Let’s look at a combined example inspired by <code class="language-plaintext highlighter-rouge">stdlib/test/buffer/test_dimlist.mojo</code>:</p>

<pre><code class="language-mojo">from buffer.dimlist import Dim, DimList
from testing import assert_equal // A helper for tests, not strictly needed for understanding

fn main_dimlist_showcase():
    print("== DimList Showcase ==")

    var lst0 = DimList(1, 2, 3, 4)
    var lst1 = DimList(Dim(), 2, 3, 4) # First dimension is dynamic

    print("lst0:", lst0) # Output: lst0: [1, 2, 3, 4]
    print("lst1:", lst1) # Output: lst1: [?, 2, 3, 4]

    # Product
    # For lst0, all are known, so 1*2*3*4 = 24
    print("lst0.product[4]().get():", lst0.product[4]().get()) # Output: 24
    # For lst1, the first Dim is unknown, so product involving it is unknown
    # But product of lst1[1,4) (dims at index 1,2,3 -&gt; 2,3,4) is 2*3*4 = 24
    print("lst1.product[1,4]().get():", lst1.product[1,4]().get()) # Output: 24
    # Overall product of lst1 is dynamic
    print("lst1.product():", lst1.product()) # Output: ?

    # all_known
    print("lst0.all_known[4]():", lst0.all_known[4]()) # Output: True
    print("lst1.all_known[4]():", lst1.all_known[4]()) # Output: False (due to first Dim)
    print("lst1.all_known[1, 4]():", lst1.all_known[1, 4]()) # Output: True (dims at 1,2,3 are known)

    # has_value for specific elements
    print("lst1.has_value[0]():", lst1.has_value[0]()) # Output: False (Dim() at index 0)
    print("lst1.has_value[1]():", lst1.has_value[1]()) # Output: True (Dim(2) at index 1)

    # String representations
    print("String(Dim()):", String(Dim()))                 # Output: ?
    print("String(Dim(33)):", String(Dim(33)))             # Output: 33
    print("String(DimList(2, Dim(), 3)):", String(DimList(2, Dim(), 3))) # Output: [2, ?, 3]

    # Creating fully unknown DimList
    var unknown_list = DimList.create_unknown[5]()
    print("DimList.create_unknown[5]():", unknown_list) # Output: [?, ?, ?, ?, ?]

# To run this example:
# main_dimlist_showcase()
</code></pre>

<h2 id="summary">Summary</h2>

<ul>
  <li>A <code class="language-plaintext highlighter-rouge">Dim</code> represents a single dimension’s size, which can be <strong>static</strong> (known at compile time, e.g., <code class="language-plaintext highlighter-rouge">Dim(5)</code>) or <strong>dynamic</strong> (unknown until runtime, e.g., <code class="language-plaintext highlighter-rouge">Dim()</code>).</li>
  <li>A <code class="language-plaintext highlighter-rouge">DimList</code> is a list of <code class="language-plaintext highlighter-rouge">Dim</code>s, used to define properties like <code class="language-plaintext highlighter-rouge">shape</code> and <code class="language-plaintext highlighter-rouge">strides</code> for multi-dimensional data structures.</li>
  <li><code class="language-plaintext highlighter-rouge">DimList</code> allows mixing static and dynamic dimensions, giving you both <strong>optimization potential</strong> and <strong>runtime flexibility</strong>.</li>
  <li>Key <code class="language-plaintext highlighter-rouge">Dim</code> methods: <code class="language-plaintext highlighter-rouge">has_value()</code>, <code class="language-plaintext highlighter-rouge">is_dynamic()</code>, <code class="language-plaintext highlighter-rouge">get()</code>. Prints as a number or <code class="language-plaintext highlighter-rouge">?</code>.</li>
  <li>Key <code class="language-plaintext highlighter-rouge">DimList</code> methods: <code class="language-plaintext highlighter-rouge">len()</code>, <code class="language-plaintext highlighter-rouge">.at[idx]()</code>, <code class="language-plaintext highlighter-rouge">.get[idx]()</code>, <code class="language-plaintext highlighter-rouge">.has_value[idx]()</code>, <code class="language-plaintext highlighter-rouge">.all_known[...]</code>, <code class="language-plaintext highlighter-rouge">.product[...]</code>. Prints as <code class="language-plaintext highlighter-rouge">[val1, ?, val3, ...]</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">DimList.create_unknown[N]()</code> creates a list of <code class="language-plaintext highlighter-rouge">N</code> dynamic dimensions.</li>
</ul>

<h2 id="whats-next">What’s Next?</h2>

<p>With <code class="language-plaintext highlighter-rouge">Dim</code> and <code class="language-plaintext highlighter-rouge">DimList</code> under our belt, we’re now perfectly equipped to understand how Mojo’s primary N-dimensional data structure, <code class="language-plaintext highlighter-rouge">NDBuffer</code>, is defined and how it uses these tools to manage data of various (and variably known) shapes. Get ready for <code class="language-plaintext highlighter-rouge">NDBuffer</code> in Chapter 5!</p>

<hr />
<p><strong>Table of Contents</strong></p>
<ol>
  <li><a href="01_addressspace_.md">Chapter 1: Understanding Memory Neighborhoods with <code class="language-plaintext highlighter-rouge">AddressSpace</code></a></li>
  <li><a href="02_unsafepointer_.md">Chapter 2: Peeking into Memory with <code class="language-plaintext highlighter-rouge">UnsafePointer</code></a></li>
  <li><a href="03_indexlist_.md">Chapter 3: Working with Multiple Dimensions: <code class="language-plaintext highlighter-rouge">IndexList</code></a></li>
  <li><strong>Chapter 4: Describing Dimensions with <code class="language-plaintext highlighter-rouge">Dim</code> and <code class="language-plaintext highlighter-rouge">DimList</code></strong> (You are here)</li>
  <li><em>Coming Soon: Chapter 5: The N-Dimensional Buffer: <code class="language-plaintext highlighter-rouge">NDBuffer</code></em></li>
  <li><em>Coming Soon: Chapter 6: N-D to 1D Indexing Logic (Strided Memory Access)</em>
```</li>
</ol>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
