<h1 id="chapter-2-unsafepointer">Chapter 2: UnsafePointer</h1>

<p>Welcome back! In <a href="01_addressspace_.md">Chapter 1: Understanding Memory Neighborhoods with <code class="language-plaintext highlighter-rouge">AddressSpace</code></a>, we learned how Mojo categorizes memory into different “neighborhoods” using <code class="language-plaintext highlighter-rouge">AddressSpace</code>. This helps Mojo optimize how data is handled, especially with hardware like GPUs.</p>

<p>Now, we’re going to zoom in and look at how Mojo can directly refer to a specific spot in memory. Get ready to meet <code class="language-plaintext highlighter-rouge">UnsafePointer</code>!</p>

<h2 id="whats-a-pointer-anyway">What’s a Pointer Anyway?</h2>

<p>Imagine you have a giant warehouse full of mailboxes (this is your computer’s memory). Each mailbox has a unique address. A <strong>pointer</strong> is like a slip of paper that holds the address of one specific mailbox. It doesn’t hold the mail (the data) itself, but it tells you <em>where</em> to find the mail.</p>

<p>An <code class="language-plaintext highlighter-rouge">UnsafePointer</code> in Mojo is exactly this: a raw, direct reference to a location in memory. It stores the memory address where some data begins.</p>

<p>The <code class="language-plaintext highlighter-rouge">NDBuffer</code> type we’ll explore later uses an <code class="language-plaintext highlighter-rouge">UnsafePointer</code> internally (in its <code class="language-plaintext highlighter-rouge">data</code> field) to know the starting memory address of the data it manages.</p>

<h2 id="why-unsafe">Why “Unsafe”?</h2>

<p>The “unsafe” part of <code class="language-plaintext highlighter-rouge">UnsafePointer</code> is a bit like having a very precise GPS coordinate but no map, no road signs, and no safety barriers.</p>
<ul>
  <li><strong>No Automatic Memory Management</strong>: If you ask for memory using an <code class="language-plaintext highlighter-rouge">UnsafePointer</code> (like reserving a mailbox), Mojo won’t automatically clean it up for you when you’re done. You have to do it manually. Forget, and you get a “memory leak” (mailboxes that are reserved but unused, eventually running out of space).</li>
  <li><strong>No Automatic Bounds Checking</strong>: If you have a pointer to a mailbox and you try to access the mailbox 10 doors down, but you only reserved the first one, <code class="language-plaintext highlighter-rouge">UnsafePointer</code> won’t stop you. This can lead to reading garbage data or corrupting other data, often causing your program to crash or behave strangely.</li>
  <li><strong>No Automatic Initialization</strong>: When you get memory, it’s just raw space. An <code class="language-plaintext highlighter-rouge">UnsafePointer</code> won’t ensure it contains meaningful data until you explicitly put something there.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">UnsafePointer</code> gives you maximum control and performance by stripping away these safety nets. This is powerful but means <em>you</em>, the programmer, are responsible for using it correctly.</p>

<h2 id="meet-unsafepointert">Meet <code class="language-plaintext highlighter-rouge">UnsafePointer[T]</code></h2>

<p>In Mojo, an <code class="language-plaintext highlighter-rouge">UnsafePointer</code> is always tied to a specific data <strong>type</strong>. You’d write <code class="language-plaintext highlighter-rouge">UnsafePointer[Int]</code> for a pointer to an integer, or <code class="language-plaintext highlighter-rouge">UnsafePointer[String]</code> for a pointer to a string. The <code class="language-plaintext highlighter-rouge">T</code> in <code class="language-plaintext highlighter-rouge">UnsafePointer[T]</code> tells Mojo what kind of data to expect at that memory address.</p>

<p>Let’s look at its definition from <code class="language-plaintext highlighter-rouge">stdlib/src/memory/unsafe_pointer.mojo</code> (simplified):</p>

<pre><code class="language-mojo">@register_passable("trivial")
struct UnsafePointer[
    type: AnyType, // The type of data it points to (e.g., Int, Float32)
    *,
    address_space: AddressSpace = AddressSpace.GENERIC, // Where is this memory? (from Ch 1)
    alignment: Int = _default_alignment[type](),    // How data is arranged for efficiency
    mut: Bool = True,                                // Can we change the data via this pointer?
    origin: Origin[mut] = Origin[mut].cast_from[MutableAnyOrigin].result, // Advanced: Tracks memory validity
](...)
</code></pre>
<p>Don’t worry about all the details yet! The key things are:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">type</code>: What kind of data this pointer “points to.”</li>
  <li><code class="language-plaintext highlighter-rouge">address_space</code>: This links back to Chapter 1! It tells Mojo if this memory is in the CPU’s main area (<code class="language-plaintext highlighter-rouge">AddressSpace.GENERIC</code>), on a GPU, etc.</li>
  <li><code class="language-plaintext highlighter-rouge">alignment</code>: A performance detail about how data should be positioned in memory. Usually handled by default.</li>
  <li><code class="language-plaintext highlighter-rouge">mut</code>: Short for “mutable.” If <code class="language-plaintext highlighter-rouge">True</code>, you can change the data the pointer points to.</li>
  <li><code class="language-plaintext highlighter-rouge">origin</code>: An advanced feature for tracking where the memory came from and if it’s still valid.</li>
</ul>

<p>Internally, an <code class="language-plaintext highlighter-rouge">UnsafePointer</code> just holds the numerical memory address.</p>

<h2 id="key-operations-with-unsafepointer">Key Operations with <code class="language-plaintext highlighter-rouge">UnsafePointer</code></h2>

<p>Let’s see how you can use <code class="language-plaintext highlighter-rouge">UnsafePointer</code>. We’ll use examples inspired by <code class="language-plaintext highlighter-rouge">stdlib/test/memory/test_unsafepointer.mojo</code>.</p>

<h3 id="1-getting-memory-allocation">1. Getting Memory: Allocation</h3>

<p>To point to new memory, you first need to “allocate” it. This is like reserving one or more mailboxes.
The <code class="language-plaintext highlighter-rouge">alloc()</code> method is used for this. It needs to know how many items of <code class="language-plaintext highlighter-rouge">type</code> you want space for.</p>

<pre><code class="language-mojo">from memory import UnsafePointer

// Allocate memory for 1 integer
var p_int = UnsafePointer[Int].alloc(1)

// Allocate memory for 5 Float32 values
var p_floats = UnsafePointer[Float32].alloc(5)
</code></pre>
<p>After <code class="language-plaintext highlighter-rouge">alloc()</code>, <code class="language-plaintext highlighter-rouge">p_int</code> holds the starting address of a memory block big enough for one <code class="language-plaintext highlighter-rouge">Int</code>. <code class="language-plaintext highlighter-rouge">p_floats</code> holds the starting address for five <code class="language-plaintext highlighter-rouge">Float32</code>s.
<strong>Important</strong>: This memory is <strong>uninitialized</strong>. It contains garbage data.</p>

<h3 id="2-initializing-and-writing-to-memory">2. Initializing and Writing to Memory</h3>

<p>Once you have allocated memory, you need to put meaningful data into it.</p>

<ul>
  <li>
    <p><strong>For simple types (like <code class="language-plaintext highlighter-rouge">Int</code>, <code class="language-plaintext highlighter-rouge">Float32</code>):</strong>
You can often use the subscript operator <code class="language-plaintext highlighter-rouge">[]</code> to write values, similar to how you’d use it with an array. <code class="language-plaintext highlighter-rouge">ptr[0]</code> refers to the first item, <code class="language-plaintext highlighter-rouge">ptr[1]</code> to the second, and so on. <code class="language-plaintext highlighter-rouge">ptr[]</code> is a shorthand for <code class="language-plaintext highlighter-rouge">ptr[0]</code>.</p>

    <pre><code class="language-mojo">// Continuing from above:
p_int[0] = 100 // Put 100 into the memory p_int points to
// or p_int[] = 100

p_floats[0] = 1.0
p_floats[1] = 2.5
// ... and so on for p_floats[2] through p_floats[4]
</code></pre>
  </li>
  <li>
    <p><strong>For more complex types (structs, objects):</strong>
Mojo provides special methods to initialize the memory location (the “pointee” - what’s being pointed to):</p>
    <ul>
      <li><code class="language-plaintext highlighter-rouge">init_pointee_move(value)</code>: Moves <code class="language-plaintext highlighter-rouge">value</code> into the memory. The original <code class="language-plaintext highlighter-rouge">value</code> is no longer valid. This is for types that are <code class="language-plaintext highlighter-rouge">Movable</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">init_pointee_copy(value)</code>: Copies <code class="language-plaintext highlighter-rouge">value</code> into the memory. The original <code class="language-plaintext highlighter-rouge">value</code> is still valid. This is for types that are <code class="language-plaintext highlighter-rouge">Copyable</code>.</li>
      <li><code class="language-plaintext highlighter-rouge">init_pointee_explicit_copy(value)</code>: Similar to copy, for types that require an explicit <code class="language-plaintext highlighter-rouge">.copy()</code> call.</li>
    </ul>

    <p>Here’s an example with a <code class="language-plaintext highlighter-rouge">List[String]</code> (which is a more complex type) from <code class="language-plaintext highlighter-rouge">stdlib/test/memory/test_unsafepointer.mojo</code>:</p>
    <pre><code class="language-mojo">from memory import UnsafePointer // Assuming List and String are available
from collections import List // For List
// In a real scenario, ensure String is also imported if not built-in for this context

fn demo_complex_type_init():
    var list_ptr = UnsafePointer[List[String]].alloc(1)
    // Create an empty List[String] and move it into the memory list_ptr points to
    list_ptr.init_pointee_move(List[String]())
        
    // Now list_ptr[0] is an initialized, empty List[String]
    list_ptr[0].append("Hello")
    print(list_ptr[0][0]) // Prints "Hello"

    // Proper cleanup for complex types:
    var taken_list = list_ptr.take_pointee() // Move the list out
    list_ptr.free()                          // Free the raw memory slot
    // taken_list will be destroyed when it goes out of scope, or manage it further.
</code></pre>
    <p>For beginners, knowing these <code class="language-plaintext highlighter-rouge">init_pointee_*</code> methods exist is important, especially if you work with types beyond simple numbers. The crucial part is that <em>uninitialized</em> memory from <code class="language-plaintext highlighter-rouge">alloc()</code> <em>must be initialized</em> before it’s reliably read.</p>
  </li>
</ul>

<h3 id="3-reading-from-memory">3. Reading from Memory</h3>

<p>To read the value stored at the memory location, you also use the <code class="language-plaintext highlighter-rouge">[]</code> operator:</p>

<pre><code class="language-mojo">var my_val = p_int[0] // my_val will be 100, assuming p_int[0] was set to 100
print(p_int[])      // Prints 100

var first_float = p_floats[0] // first_float will be 1.0, assuming p_floats[0] was set to 1.0
print(p_floats[1])          // Prints 2.5, assuming p_floats[1] was set to 2.5
</code></pre>

<h3 id="4-pointer-arithmetic-moving-around">4. Pointer Arithmetic: Moving Around</h3>

<p>You can perform arithmetic on pointers to access adjacent memory locations.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ptr + offset</code>: Gives a new pointer <code class="language-plaintext highlighter-rouge">offset</code> elements away from <code class="language-plaintext highlighter-rouge">ptr</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">ptr - offset</code>: Gives a new pointer <code class="language-plaintext highlighter-rouge">offset</code> elements before <code class="language-plaintext highlighter-rouge">ptr</code>.</li>
  <li><code class="language-plaintext highlighter-rouge">ptr.offset(idx)</code>: Another way to get an offset pointer.</li>
</ul>

<pre><code class="language-mojo">// Assuming p_floats points to memory for 5 Float32s, initialized earlier
var p_item1 = p_floats + 1 // p_item1 now points to p_floats[1]
print(p_item1[0])        // This is equivalent to p_floats[1]

// You can iterate through allocated memory:
for i in range(5):
    p_floats[i] = Float32(i * 10) // Initialize
for i in range(5):
    print((p_floats + i)[0])    // Read using pointer arithmetic and dereference
    // or simply: print(p_floats[i])
</code></pre>

<h3 id="5-getting-a-pointer-to-existing-data">5. Getting a Pointer to Existing Data</h3>

<p>Sometimes, you want a pointer to a variable that already exists. You can use the <code class="language-plaintext highlighter-rouge">UnsafePointer(to=...)</code> constructor.</p>

<pre><code class="language-mojo">var my_local_var: Int = 42
var ptr_to_local = UnsafePointer[Int](to=my_local_var)

print(ptr_to_local[]) // Prints 42

// You can modify the original variable through the pointer (if mut is True)
ptr_to_local[] = 50
print(my_local_var) // Prints 50!
</code></pre>
<p><strong>Big Safety Note</strong>: This is very “unsafe”! If <code class="language-plaintext highlighter-rouge">my_local_var</code> goes out of scope (e.g., the function ends) but you still have <code class="language-plaintext highlighter-rouge">ptr_to_local</code> somewhere, <code class="language-plaintext highlighter-rouge">ptr_to_local</code> becomes a “dangling pointer.” Using it will lead to undefined behavior. The <code class="language-plaintext highlighter-rouge">UnsafePointer</code> does <em>not</em> keep <code class="language-plaintext highlighter-rouge">my_local_var</code> alive.</p>

<h3 id="6-null-pointers">6. Null Pointers</h3>

<p>A null pointer is a pointer that doesn’t point to any valid memory location. It’s like an address slip that’s intentionally blank or points to an invalid address (e.g., address 0).
You can create a null <code class="language-plaintext highlighter-rouge">UnsafePointer</code>:</p>
<pre><code class="language-mojo">var null_ptr = UnsafePointer[Int]() // Creates a null pointer
print(null_ptr)                   // Usually prints something like 0x0
</code></pre>
<p>You can check if a pointer is null. An <code class="language-plaintext highlighter-rouge">UnsafePointer</code> behaves like <code class="language-plaintext highlighter-rouge">False</code> in a boolean context if it’s null, and <code class="language-plaintext highlighter-rouge">True</code> if it’s not.</p>
<pre><code class="language-mojo">if null_ptr:
    print("This won't print, null_ptr is null.")
else:
    print("null_ptr is indeed null.")

// Assuming p_int was allocated:
if p_int: 
    print("p_int is not null.")
</code></pre>
<p>Attempting to read or write through a null pointer will usually crash your program.</p>

<h3 id="7-releasing-memory-free">7. Releasing Memory: <code class="language-plaintext highlighter-rouge">free()</code></h3>

<p>When you’re done with memory you allocated with <code class="language-plaintext highlighter-rouge">alloc()</code>, you <strong>must</strong> release it using the <code class="language-plaintext highlighter-rouge">free()</code> method. This returns the “mailboxes” to the system so they can be reused.</p>

<pre><code class="language-mojo">// After you are finished using p_int and p_floats:
p_int.free()
p_floats.free()
</code></pre>
<p>If you allocated memory for complex objects (those that might have special cleanup code called a destructor, like <code class="language-plaintext highlighter-rouge">List[String]</code> in our earlier example), you need to ensure those objects are properly destroyed <em>before</em> freeing the raw memory.</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">ptr.take_pointee()</code>: Moves the value out of the pointer’s location, leaving the memory uninitialized. The moved-out value can then be managed or destroyed according to its own rules.</li>
  <li><code class="language-plaintext highlighter-rouge">ptr.destroy_pointee()</code>: Directly calls the destructor of the object at the pointer’s location. This is used when you don’t need the value anymore.</li>
</ul>

<p>For simple types like <code class="language-plaintext highlighter-rouge">Int</code> or <code class="language-plaintext highlighter-rouge">Float32</code>, just <code class="language-plaintext highlighter-rouge">free()</code>-ing the pointer is generally enough as they don’t have complex destructors.</p>

<pre><code class="language-mojo">// For the List[String] example (see full version in section 2):
// After using list_ptr:
// var taken_list = list_ptr.take_pointee() // Or list_ptr.destroy_pointee() if not needed
// list_ptr.free()
</code></pre>

<h2 id="the-programmers-responsibilities-the-unsafe-contract">The Programmer’s Responsibilities (The “Unsafe” Contract)</h2>

<p>Using <code class="language-plaintext highlighter-rouge">UnsafePointer</code> means you agree to:</p>
<ol>
  <li><strong>Manage Lifetime</strong>: You <code class="language-plaintext highlighter-rouge">alloc</code>, you <code class="language-plaintext highlighter-rouge">free</code>. If you get a pointer <code class="language-plaintext highlighter-rouge">to</code> existing data, ensure the data outlives the pointer.</li>
  <li><strong>Stay In Bounds</strong>: Only access memory you’ve actually allocated. <code class="language-plaintext highlighter-rouge">ptr[10]</code> is bad if you only <code class="language-plaintext highlighter-rouge">alloc(5)</code>.</li>
  <li><strong>Initialize Before Use</strong>: Don’t read from <code class="language-plaintext highlighter-rouge">alloc</code>‘d memory until you’ve put something valid there.</li>
  <li><strong>Handle Null Pointers</strong>: Always check if a pointer could be null before using it, if its validity isn’t guaranteed.</li>
  <li><strong>Correctly Destroy Complex Objects</strong>: If pointing to objects with destructors, ensure they are destroyed (e.g., via <code class="language-plaintext highlighter-rouge">take_pointee()</code> or <code class="language-plaintext highlighter-rouge">destroy_pointee()</code>) before <code class="language-plaintext highlighter-rouge">free</code>ing their memory.</li>
</ol>

<p>Breaking this contract leads to bugs that can be hard to find: crashes, corrupted data, or security vulnerabilities.</p>

<h2 id="a-complete-simple-example">A Complete, Simple Example</h2>

<p>Let’s tie some of this together with simple integers:</p>

<pre><code class="language-mojo">from memory import UnsafePointer

fn main():
    print("Chapter 2: UnsafePointer Simple Example")

    # 1. Allocate memory for 3 integers
    # This memory is uninitialized.
    var count = 3
    var int_ptr = UnsafePointer[Int].alloc(count)
    print("Allocated memory for", count, "integers at address:", int_ptr)

    # 2. Initialize the memory locations (pointees)
    # For simple types like Int, we can use direct assignment.
    print("Initializing values...")
    int_ptr[0] = 100
    int_ptr[1] = 200
    int_ptr[2] = 300

    # 3. Read and print the values
    print("Reading values:")
    for i in range(count):
        print("Value at index", i, ":", int_ptr[i])

    # 4. Modify a value
    print("Modifying value at index 1...")
    int_ptr[1] = 250

    # 5. Read and print again
    print("Reading values after modification:")
    for i in range(count):
        print("Value at index", i, ":", int_ptr[i])

    # 6. Free the allocated memory
    # This is crucial!
    print("Freeing memory...")
    int_ptr.free()
    print("Memory freed.")

    # Accessing int_ptr[0] now would be undefined behavior.
    # For example, this might crash or print garbage:
    # print("Trying to access freed memory (DANGEROUS):", int_ptr[0])
</code></pre>

<p>Run this example (you might need to call <code class="language-plaintext highlighter-rouge">main()</code> if it’s not in a context where <code class="language-plaintext highlighter-rouge">main</code> runs automatically), and you’ll see how you can directly manipulate memory.</p>

<h2 id="why-use-unsafepointer">Why Use <code class="language-plaintext highlighter-rouge">UnsafePointer</code>?</h2>

<p>If it’s so “unsafe,” why does <code class="language-plaintext highlighter-rouge">UnsafePointer</code> exist?</p>
<ul>
  <li><strong>Building Blocks</strong>: It’s a fundamental tool for building safer, higher-level memory abstractions (like <code class="language-plaintext highlighter-rouge">List</code>, <code class="language-plaintext highlighter-rouge">Dict</code>, and even <code class="language-plaintext highlighter-rouge">NDBuffer</code> which uses it internally for its <code class="language-plaintext highlighter-rouge">data</code> field).</li>
  <li><strong>Interfacing with C/C++</strong>: When calling code written in languages like C or C++, you often deal with raw pointers.</li>
  <li><strong>Ultimate Performance</strong>: In rare, performance-critical situations, direct memory control can eke out the last bits of speed, but only if you know <em>exactly</em> what you’re doing.</li>
</ul>

<p>For most everyday Mojo programming, you’ll use safer abstractions. But understanding <code class="language-plaintext highlighter-rouge">UnsafePointer</code> gives you insight into what’s happening “under the hood.”</p>

<h2 id="summary">Summary</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">UnsafePointer[T]</code> gives you a direct, raw memory address for data of type <code class="language-plaintext highlighter-rouge">T</code>.</li>
  <li>It’s “unsafe” because it bypasses automatic memory management and bounds checking, making you responsible for correctness.</li>
  <li>Key operations include <code class="language-plaintext highlighter-rouge">alloc</code> (get memory), <code class="language-plaintext highlighter-rouge">[]</code> (read/write), <code class="language-plaintext highlighter-rouge">init_pointee_*</code> (initialize complex types), <code class="language-plaintext highlighter-rouge">take_pointee</code>/<code class="language-plaintext highlighter-rouge">destroy_pointee</code> (handle complex type cleanup), and <code class="language-plaintext highlighter-rouge">free</code> (release memory).</li>
  <li>It’s crucial for low-level programming, interfacing with C, and building higher-level types.</li>
</ul>

<h2 id="next-steps">Next Steps</h2>

<p>We’ve seen how <code class="language-plaintext highlighter-rouge">AddressSpace</code> tells us about memory “neighborhoods” and <code class="language-plaintext highlighter-rouge">UnsafePointer</code> gives us a specific “street address.” These are low-level concepts. Next, we’ll start looking at how Mojo builds more structured and often safer ways to handle collections of data, which often use these fundamental tools internally. We’ll begin by exploring <code class="language-plaintext highlighter-rouge">IndexList</code>, a helper for working with multi-dimensional indices, essential for understanding types like <code class="language-plaintext highlighter-rouge">NDBuffer</code>.</p>

<hr />
<ol>
  <li><a href="01_addressspace_.md">Chapter 1: Understanding Memory Neighborhoods with <code class="language-plaintext highlighter-rouge">AddressSpace</code></a></li>
  <li><strong>Chapter 2: Peeking into Memory with <code class="language-plaintext highlighter-rouge">UnsafePointer</code></strong> (You are here)</li>
  <li><a href="03_indexlist_.md">Chapter 3: Working with Multiple Dimensions: <code class="language-plaintext highlighter-rouge">IndexList</code></a></li>
  <li><a href="04_dimlist_.md">Chapter 4: Describing Dimensions: <code class="language-plaintext highlighter-rouge">DimList</code></a></li>
  <li><a href="05_ndbuffer_.md">Chapter 5: The N-Dimensional Buffer: <code class="language-plaintext highlighter-rouge">NDBuffer</code></a></li>
  <li><a href="06_n_d_to_1d_indexing_logic__strided_memory_access__.md">Chapter 6: N-D to 1D Indexing Logic (Strided Memory Access)</a></li>
</ol>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
