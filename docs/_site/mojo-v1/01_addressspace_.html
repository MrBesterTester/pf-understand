<h1 id="chapter-1-understanding-memory-neighborhoods-with-addressspace">Chapter 1: Understanding Memory Neighborhoods with <code class="language-plaintext highlighter-rouge">AddressSpace</code></h1>

<p>Welcome to your first step into the world of Mojo! In this series, we’ll explore some fundamental concepts that help Mojo achieve its impressive performance, especially when dealing with different kinds of hardware like CPUs and GPUs.</p>

<p>Our first topic is <code class="language-plaintext highlighter-rouge">AddressSpace</code>. It might sound a bit technical, but we’ll break it down with simple analogies.</p>

<h2 id="what-is-addressspace">What is <code class="language-plaintext highlighter-rouge">AddressSpace</code>?</h2>

<p>Imagine a big city. This city has many different neighborhoods:</p>
<ul>
  <li><strong>Downtown (CPU RAM)</strong>: This is your general-purpose area. Lots of things happen here, it’s accessible to everyone, and it’s where most everyday tasks are carried out.</li>
  <li><strong>Industrial Zone (GPU Global Memory)</strong>: A large area on specialized hardware (like a Graphics Processing Unit, or GPU) designed for heavy-duty work.</li>
  <li><strong>Specialized Workshops (GPU Shared/Constant Memory)</strong>: Smaller, super-fast areas within the Industrial Zone, designed for specific tasks or for workers (GPU threads) to collaborate very quickly.</li>
</ul>

<p>In Mojo, <code class="language-plaintext highlighter-rouge">AddressSpace</code> is a way to tell the system <strong>which “neighborhood” in memory a piece of data lives in.</strong></p>

<p>The official description you saw earlier puts it nicely:</p>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">AddressSpace</code> is a parameter that specifies the type or region of memory where the data an <code class="language-plaintext highlighter-rouge">NDBuffer</code> (a type we’ll see later) points to is located. Think of it like different neighborhoods in a city, each with its own characteristics and accessibility rules. For instance, <code class="language-plaintext highlighter-rouge">AddressSpace.GENERIC</code> might refer to standard CPU RAM, while other address spaces like <code class="language-plaintext highlighter-rouge">_GPUAddressSpace.SHARED</code> or <code class="language-plaintext highlighter-rouge">_GPUAddressSpace.CONSTANT</code> would indicate memory on a GPU with specific properties (e.g., shared among GPU threads or read-only constant data). The choice of <code class="language-plaintext highlighter-rouge">AddressSpace</code> is critical for performance and data management in systems with diverse memory types, particularly when programming for GPUs.</p>
</blockquote>

<p>So, <code class="language-plaintext highlighter-rouge">AddressSpace</code> helps Mojo understand the properties and location of memory.</p>

<h2 id="why-do-we-need-different-memory-neighborhoods">Why Do We Need Different Memory “Neighborhoods”?</h2>

<p>Why not just have one giant memory area for everything?</p>

<ol>
  <li><strong>Speed and Performance</strong>: Different types of memory have different speeds.
    <ul>
      <li>CPU RAM (our “Downtown”) is generally fast for a wide variety of tasks.</li>
      <li>GPU memory can be incredibly fast for certain parallel computations but might have different access patterns. Specialized parts of GPU memory (like “Workshops”) are even faster for specific uses.
Telling Mojo where data is allows it to optimize how that data is accessed.</li>
    </ul>
  </li>
  <li><strong>Special Capabilities</strong>: Some memory regions have special properties.
    <ul>
      <li>For example, “shared memory” on a GPU allows multiple GPU processing units (threads) to share data very quickly, which is great for collaborative tasks.</li>
      <li>“Constant memory” on a GPU is for data that doesn’t change; the GPU can often cache this aggressively for faster reads.</li>
    </ul>
  </li>
  <li><strong>Hardware Differences</strong>: Modern computers often have both a CPU and one or more GPUs. These components have their own memory systems. <code class="language-plaintext highlighter-rouge">AddressSpace</code> helps manage data across these different pieces of hardware.</li>
</ol>

<p>Knowing the <code class="language-plaintext highlighter-rouge">AddressSpace</code> allows Mojo (and you, the programmer!) to make smart decisions about how to store and access data for optimal performance and correctness.</p>

<h2 id="addressspace-in-mojo-a-closer-look"><code class="language-plaintext highlighter-rouge">AddressSpace</code> in Mojo: A Closer Look</h2>

<p>Let’s peek at how <code class="language-plaintext highlighter-rouge">AddressSpace</code> is defined in Mojo’s standard library. You’ll find it in a file named <code class="language-plaintext highlighter-rouge">stdlib/src/memory/pointer.mojo</code>. Don’t worry about understanding all the code details yet; we’ll focus on the main ideas.</p>

<pre><code class="language-mojo">// From stdlib/src/memory/pointer.mojo

@value
@register_passable("trivial")
struct AddressSpace(...):
    """Address space of the pointer."""

    var _value: Int // Each address space has an underlying integer ID

    alias GENERIC = AddressSpace(0) // The most common one!
    """Generic address space."""

    // ... other details and functions ...

    @always_inline("builtin")
    fn __init__(out self, value: Int):
        """Initializes the address space from the underlying integral value."""
        self._value = value

    @always_inline("builtin")
    fn __init__(out self, value: _GPUAddressSpace): // Can also be made from a _GPUAddressSpace type
        """Initializes the address space from the underlying integral value."""
        self._value = value._value

// ... later in the same file ...

@value
@register_passable("trivial")
struct _GPUAddressSpace(EqualityComparable):
    var _value: Int

    // These are like pre-defined AddressSpace values for common GPU memory types
    alias GENERIC = AddressSpace(0) // GPUs can also access generic memory
    alias GLOBAL = AddressSpace(1)
    """Global address space (typically main GPU memory)."""
    alias SHARED = AddressSpace(3)
    """Shared address space (fast memory for GPU thread groups)."""
    alias CONSTANT = AddressSpace(4)
    """Constant address space (read-only, often cached)."""
    alias LOCAL = AddressSpace(5)
    """Local address space (private to a single GPU thread)."""

    // ... other details ...
</code></pre>

<p>Here’s what this means for a beginner:</p>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">struct AddressSpace</code></strong>: This defines the <code class="language-plaintext highlighter-rouge">AddressSpace</code> type.
    <ul>
      <li>The decorators <code class="language-plaintext highlighter-rouge">@value</code> and <code class="language-plaintext highlighter-rouge">@register_passable("trivial")</code> tell Mojo that <code class="language-plaintext highlighter-rouge">AddressSpace</code> is a simple value type that can be handled very efficiently. Think of it like a number.</li>
      <li><code class="language-plaintext highlighter-rouge">var _value: Int</code>: Internally, each <code class="language-plaintext highlighter-rouge">AddressSpace</code> is represented by an integer. For example, <code class="language-plaintext highlighter-rouge">0</code> means generic, <code class="language-plaintext highlighter-rouge">1</code> might mean global GPU memory, and so on.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">alias GENERIC = AddressSpace(0)</code></strong>: This is a very important line! <code class="language-plaintext highlighter-rouge">AddressSpace.GENERIC</code> is the most common address space. It usually refers to standard CPU memory. If you don’t specify an address space, this is often the default.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">struct _GPUAddressSpace</code></strong>: This struct helps define common address spaces used with GPUs.
    <ul>
      <li><strong><code class="language-plaintext highlighter-rouge">alias GLOBAL = AddressSpace(1)</code></strong>: <code class="language-plaintext highlighter-rouge">_GPUAddressSpace.GLOBAL</code> is a convenient name for <code class="language-plaintext highlighter-rouge">AddressSpace(1)</code>, which typically represents the main memory on a GPU.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">alias SHARED = AddressSpace(3)</code></strong>: <code class="language-plaintext highlighter-rouge">_GPUAddressSpace.SHARED</code> refers to <code class="language-plaintext highlighter-rouge">AddressSpace(3)</code>, a special, fast memory region that groups of GPU threads can use to share data.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">alias CONSTANT = AddressSpace(4)</code></strong>: <code class="language-plaintext highlighter-rouge">_GPUAddressSpace.CONSTANT</code> refers to <code class="language-plaintext highlighter-rouge">AddressSpace(4)</code>, used for data that won’t change during a computation. GPUs can optimize access to constant memory.</li>
      <li><strong><code class="language-plaintext highlighter-rouge">alias LOCAL = AddressSpace(5)</code></strong>: <code class="language-plaintext highlighter-rouge">_GPUAddressSpace.LOCAL</code> refers to <code class="language-plaintext highlighter-rouge">AddressSpace(5)</code>, representing memory private to individual GPU threads.</li>
    </ul>
  </li>
</ul>

<p>So, you have <code class="language-plaintext highlighter-rouge">AddressSpace.GENERIC</code> for general CPU memory. For GPU-specific memory, you can use handy aliases like <code class="language-plaintext highlighter-rouge">_GPUAddressSpace.GLOBAL</code> or <code class="language-plaintext highlighter-rouge">_GPUAddressSpace.SHARED</code>. These aliases are actually <code class="language-plaintext highlighter-rouge">AddressSpace</code> values themselves.</p>

<h2 id="how-is-addressspace-used">How is <code class="language-plaintext highlighter-rouge">AddressSpace</code> Used?</h2>

<p>You’ll encounter <code class="language-plaintext highlighter-rouge">AddressSpace</code> as a parameter when you define types that manage memory, like <code class="language-plaintext highlighter-rouge">Pointer</code> (which represents a direct memory address) and <code class="language-plaintext highlighter-rouge">NDBuffer</code> (which represents an N-dimensional array of data, like a tensor or matrix).</p>

<p>Look at how <code class="language-plaintext highlighter-rouge">Pointer</code> and <code class="language-plaintext highlighter-rouge">NDBuffer</code> use it (simplified from their definitions):</p>

<pre><code class="language-mojo">// From stdlib/src/memory/pointer.mojo
struct Pointer[
    // ... other parameters ...
    type: AnyType,
    address_space: AddressSpace = AddressSpace.GENERIC, // Default is GENERIC!
]:
    // ...

// From stdlib/src/buffer/buffer.mojo
struct NDBuffer[
    // ... other parameters ...
    type: DType,
    address_space: AddressSpace = AddressSpace.GENERIC, // Default is GENERIC!
    // ...
]:
    // ...
</code></pre>

<p>Notice the <code class="language-plaintext highlighter-rouge">address_space: AddressSpace = AddressSpace.GENERIC</code> part. This means:</p>
<ul>
  <li>Both <code class="language-plaintext highlighter-rouge">Pointer</code> and <code class="language-plaintext highlighter-rouge">NDBuffer</code> need to know the <code class="language-plaintext highlighter-rouge">AddressSpace</code> of the memory they are dealing with.</li>
  <li>By default, if you don’t specify otherwise, they assume the memory is in <code class="language-plaintext highlighter-rouge">AddressSpace.GENERIC</code> (i.e., standard CPU RAM).</li>
</ul>

<p><strong>Conceptual Example:</strong></p>

<p>Imagine you’re creating a buffer for some calculations.</p>
<pre><code class="language-mojo">// This is conceptual Mojo-like code to illustrate the idea

// A buffer in standard CPU memory (GENERIC is the default)
// let cpu_buffer = NDBuffer[Float32, ...]()

// A buffer specifically in GPU's global memory
// let gpu_global_buffer = NDBuffer[Float32, ..., address_space: _GPUAddressSpace.GLOBAL]()

// A buffer in fast GPU shared memory
// let gpu_shared_buffer = NDBuffer[Float32, ..., address_space: _GPUAddressSpace.SHARED]()
</code></pre>
<p>By specifying the <code class="language-plaintext highlighter-rouge">address_space</code>, you’re giving Mojo crucial information that it can use to manage and access the data efficiently.</p>

<p><strong>Real-world Impact in <code class="language-plaintext highlighter-rouge">NDBuffer</code>:</strong></p>

<p>The <code class="language-plaintext highlighter-rouge">NDBuffer</code> code itself makes decisions based on <code class="language-plaintext highlighter-rouge">AddressSpace</code>. For example, there’s a helper function in <code class="language-plaintext highlighter-rouge">stdlib/src/buffer/buffer.mojo</code>:</p>
<pre><code class="language-mojo">@always_inline
fn _use_32bit_indexing[address_space: AddressSpace]() -&gt; Bool:
    return is_gpu() and address_space in (
        _GPUAddressSpace.SHARED,
        _GPUAddressSpace.LOCAL,
        _GPUAddressSpace.CONSTANT,
    )
</code></pre>
<p>This function checks if the code is running on a GPU (<code class="language-plaintext highlighter-rouge">is_gpu()</code>) and if the <code class="language-plaintext highlighter-rouge">NDBuffer</code>’s data is in <code class="language-plaintext highlighter-rouge">SHARED</code>, <code class="language-plaintext highlighter-rouge">LOCAL</code>, or <code class="language-plaintext highlighter-rouge">CONSTANT</code> GPU memory. If so, it might decide to use 32-bit numbers for indexing into the buffer (which can sometimes be faster on GPUs for these memory types) instead of the usual 64-bit numbers. This is a direct example of <code class="language-plaintext highlighter-rouge">AddressSpace</code> influencing performance optimizations!</p>

<h2 id="key-takeaways">Key Takeaways</h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">AddressSpace</code> tells Mojo <strong>where data lives in memory</strong> (like different neighborhoods in a city).</li>
  <li><code class="language-plaintext highlighter-rouge">AddressSpace.GENERIC</code> is the common default, usually meaning <strong>standard CPU RAM</strong>.</li>
  <li>For GPUs, there are specific address spaces like <code class="language-plaintext highlighter-rouge">_GPUAddressSpace.GLOBAL</code> (main GPU memory), <code class="language-plaintext highlighter-rouge">_GPUAddressSpace.SHARED</code> (fast shared memory for GPU threads), and <code class="language-plaintext highlighter-rouge">_GPUAddressSpace.CONSTANT</code> (read-only cached memory).</li>
  <li>Knowing the <code class="language-plaintext highlighter-rouge">AddressSpace</code> is crucial for <strong>performance</strong> and <strong>correct data handling</strong>, especially when working with diverse hardware like GPUs.</li>
  <li>You’ll see <code class="language-plaintext highlighter-rouge">AddressSpace</code> as a parameter in memory-related types like <code class="language-plaintext highlighter-rouge">Pointer</code> and <code class="language-plaintext highlighter-rouge">NDBuffer</code>.</li>
</ul>

<p>Understanding <code class="language-plaintext highlighter-rouge">AddressSpace</code> is a foundational piece in learning how Mojo manages memory and achieves high performance. It’s all about giving the system enough information to make smart choices!</p>

<h2 id="next-steps">Next Steps</h2>

<p>Now that you have a basic understanding of <code class="language-plaintext highlighter-rouge">AddressSpace</code>, we’re ready to explore how Mojo represents direct memory locations. In the next chapter, we’ll dive into <code class="language-plaintext highlighter-rouge">UnsafePointer</code>, a fundamental building block for memory operations in Mojo.</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
