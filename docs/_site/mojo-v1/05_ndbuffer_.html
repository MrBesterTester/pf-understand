<h1 id="chapter-5-ndbuffer">Chapter 5: NDBuffer</h1>

<p>Okay, here is Chapter 5 on <code class="language-plaintext highlighter-rouge">NDBuffer</code>, designed to be very beginner-friendly and in Markdown format.</p>

<div class="language-markdown highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="gh"># Chapter 5: The N-Dimensional Buffer: `NDBuffer`</span>

Welcome to Chapter 5! So far, we've explored some fundamental Mojo concepts:
<span class="p">*</span>   <span class="p">[</span><span class="nv">Chapter 1: `AddressSpace`</span><span class="p">](</span><span class="sx">01_addressspace_.md</span><span class="p">)</span> <span class="p">(</span><span class="sx">memory</span> <span class="nn">"neighborhoods"</span><span class="p">)</span>
<span class="p">*</span>   <span class="p">[</span><span class="nv">Chapter 2: `UnsafePointer`</span><span class="p">](</span><span class="sx">02_unsafepointer_.md</span><span class="p">)</span> <span class="p">(</span><span class="sx">direct</span> memory addresses)
<span class="p">*</span>   <span class="p">[</span><span class="nv">Chapter 3: `IndexList`</span><span class="p">](</span><span class="sx">03_indexlist_.md</span><span class="p">)</span> <span class="p">(</span><span class="sx">for</span> multi-dimensional coordinates)
<span class="p">*</span>   <span class="p">[</span><span class="nv">Chapter 4: `Dim` and `DimList`</span><span class="p">](</span><span class="sx">04_dimlist_.md</span><span class="p">)</span> <span class="p">(</span><span class="sx">for</span> describing dimension sizes, statically or dynamically)

Now, we're going to put these pieces together to understand one of Mojo's most powerful data structures for numerical computing: <span class="sb">`NDBuffer`</span>.

<span class="gu">## What is `NDBuffer`?</span>

The official description states:
<span class="gt">
&gt; `NDBuffer` represents a multi-dimensional array or tensor, commonly used in numerical computing and machine learning. Think of it as a smart "view" or a "lens" that lets you interpret a flat, one-dimensional block of memory as a structured grid (like a 2D image, 3D volume, or higher-dimensional data). It doesn't own the memory itself but holds essential metadata: the data type of elements, the shape (dimensions of the grid), and strides (how many memory elements to skip to move to the next item along each dimension). This design allows for flexible data layouts (e.g., row-major, column-major) and efficient access without needing to copy the underlying data.</span>

Let's break that down:
<span class="p">
*</span>   <span class="gs">**Multi-dimensional array/tensor**</span>: Imagine a Python list, but it can have multiple dimensions.
<span class="p">    *</span>   A 1D <span class="sb">`NDBuffer`</span> is like a simple list or vector: <span class="sb">`[1, 2, 3, 4]`</span>
<span class="p">    *</span>   A 2D <span class="sb">`NDBuffer`</span> is like a grid or matrix (think spreadsheet or image):
        <span class="p">```</span><span class="nl">
</span>        [[1, 2, 3],
         [4, 5, 6]]
        <span class="p">```</span>
<span class="p">    *</span>   A 3D <span class="sb">`NDBuffer`</span> is like a cube or volume of data:
        <span class="p">```</span><span class="nl">
</span>        [[[1,2], [3,4]],
         [[5,6], [7,8]]]
        <span class="p">```</span>
    And it can go to even higher dimensions!
<span class="p">
*</span>   <span class="gs">**"View" or "Lens"**</span>: This is super important! Most of the time, an <span class="sb">`NDBuffer`</span> doesn't hold the actual data values itself. Instead, it <span class="ge">*points*</span> to some memory (managed by an <span class="sb">`UnsafePointer`</span> internally) and tells Mojo how to interpret that raw memory as a structured N-dimensional grid.
<span class="p">    *</span>   <span class="ge">*Analogy*</span>: Imagine you have a long, single line of LEGO bricks (this is your flat memory). An <span class="sb">`NDBuffer`</span> is like a special pair of glasses that lets you see those bricks as if they were arranged in a 2x2 square or a 3x4 rectangle, without actually moving the bricks.
<span class="p">
*</span>   <span class="gs">**Metadata**</span>: To act as this "lens," <span class="sb">`NDBuffer`</span> stores crucial information:
<span class="p">    *</span>   <span class="gs">**Data Type (`DType`)**</span>: What kind of data is in each cell (e.g., <span class="sb">`Float32`</span>, <span class="sb">`Int64`</span>).
<span class="p">    *</span>   <span class="gs">**Shape (`DimList`)**</span>: The size of each dimension (e.g., a 2x3 matrix has shape <span class="sb">`(2, 3)`</span>).
<span class="p">    *</span>   <span class="gs">**Strides (`DimList`)**</span>: How many actual memory slots to jump over to get to the next element along each dimension. (We'll dive deeper into strides in the next chapter, but for now, know it helps <span class="sb">`NDBuffer`</span> find elements quickly in that flat memory).

This "view" approach is very powerful because it allows for:
<span class="p">*</span>   <span class="gs">**Flexibility**</span>: The same underlying data can be viewed in different ways (e.g., as a 4x4 matrix or as a 2x8 matrix, if memory layout allows).
<span class="p">*</span>   <span class="gs">**Efficiency**</span>: You can perform operations like transposing a matrix or taking a slice (a sub-section) often without copying any data, just by creating a new <span class="sb">`NDBuffer`</span> with different shape/stride metadata.

<span class="gu">## Anatomy of an `NDBuffer`</span>

Let's look at the parameters that define an <span class="sb">`NDBuffer`</span>. You'll see how concepts from previous chapters fit in:

<span class="p">```</span><span class="nl">mojo
</span><span class="sb">struct NDBuffer[
    mut: Bool, // Is the data mutable (changeable) through this NDBuffer?
    type: DType, // The data type of each element (e.g., DType.float32)
    rank: Int, // The number of dimensions (e.g., 2 for a matrix)
    origin: Origin[mut], // Advanced: Tracks memory validity and source
    shape: DimList = DimList.create_unknown[rank](), // From Ch4: Sizes of dimensions
    strides: DimList = DimList.create_unknown[rank](), // From Ch4: Memory step sizes
    *, // Parameters below are keyword-only
    alignment: Int = 1, // Memory alignment preference
    address_space: AddressSpace = AddressSpace.GENERIC, // From Ch1: Where memory lives
    exclusive: Bool = True, // Advanced: If this is the only pointer to the memory
]
</span></code></pre></div></div>

<p>Inside an <code class="language-plaintext highlighter-rouge">NDBuffer</code>, there are important fields:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">data: UnsafePointer[...]</code>: (From Ch2) An <code class="language-plaintext highlighter-rouge">UnsafePointer</code> to the <em>actual start</em> of the data in memory.</li>
  <li><code class="language-plaintext highlighter-rouge">dynamic_shape: IndexList[...]</code>: (From Ch3) If the <code class="language-plaintext highlighter-rouge">shape</code> <code class="language-plaintext highlighter-rouge">DimList</code> had dynamic dimensions (<code class="language-plaintext highlighter-rouge">?</code>), this <code class="language-plaintext highlighter-rouge">IndexList</code> holds their actual runtime values.</li>
  <li><code class="language-plaintext highlighter-rouge">dynamic_stride: IndexList[...]</code>: (From Ch3) Similar to <code class="language-plaintext highlighter-rouge">dynamic_shape</code>, but for strides.</li>
</ul>

<p>For beginners, the most immediately important parameters are <code class="language-plaintext highlighter-rouge">type</code>, <code class="language-plaintext highlighter-rouge">rank</code>, and <code class="language-plaintext highlighter-rouge">shape</code>. <code class="language-plaintext highlighter-rouge">mut</code> determines if you can change data. <code class="language-plaintext highlighter-rouge">address_space</code> is often <code class="language-plaintext highlighter-rouge">AddressSpace.GENERIC</code> for CPU memory.</p>

<h2 id="creating-an-ndbuffer">Creating an <code class="language-plaintext highlighter-rouge">NDBuffer</code></h2>

<p>There are a few ways to create an <code class="language-plaintext highlighter-rouge">NDBuffer</code>.</p>

<h3 id="1-using-existing-memory-eg-an-inlinearray">1. Using Existing Memory (e.g., an <code class="language-plaintext highlighter-rouge">InlineArray</code>)</h3>

<p>Often, you’ll have some memory already (perhaps in an <code class="language-plaintext highlighter-rouge">InlineArray</code> which stores data directly, or from another source), and you want <code class="language-plaintext highlighter-rouge">NDBuffer</code> to provide a view over it.</p>

<p>Let’s look at the <code class="language-plaintext highlighter-rouge">test_ndbuffer</code> example from <code class="language-plaintext highlighter-rouge">stdlib/test/buffer/test_ndbuffer.mojo</code>:</p>
<pre><code class="language-mojo">from buffer import NDBuffer, DimList // Import NDBuffer and DimList
from memory import InlineArray // For stack-allocated flat array
from builtin import DType, Scalar // For data types

fn create_ndbuffer_from_inline_array():
    // First, reserve some flat memory.
    // InlineArray creates memory on the "stack" (fast, temporary memory).
    // We need space for 4*4 = 16 elements of type DType.index.
    // DType.index is Mojo's default integer type, often 64-bit.
    var matrix_data_storage = InlineArray[Scalar[DType.index], 16](uninitialized=True)

    // Now, create an NDBuffer to view this memory as a 4x4 matrix.
    var matrix = NDBuffer[
        DType.index,  // Element data type
        2,            // Rank: 2 dimensions (it's a matrix)
        _,            // Origin: We use `_` to let Mojo infer a suitable default.
                      // This is an advanced parameter for tracking memory origin.
        DimList(4, 4) // Shape: A 4x4 matrix (Static dimensions from Chapter 4)
    ](matrix_data_storage) // The NDBuffer will "view" the data in matrix_data_storage

    // At this point, 'matrix' is a 4x4 NDBuffer, but its data is uninitialized.
    // We can now fill it. For example:
    matrix[0, 0] = 0
    matrix[0, 1] = 1
    // ... and so on.
    print("Created matrix. Element at (0,0) after setting:", matrix[0,0])
</code></pre>
<p>In this case:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">matrix_data_storage</code> holds the raw, flat memory.</li>
  <li><code class="language-plaintext highlighter-rouge">matrix</code> (the <code class="language-plaintext highlighter-rouge">NDBuffer</code>) doesn’t copy the data; it just knows how to interpret the memory in <code class="language-plaintext highlighter-rouge">matrix_data_storage</code> as a 4x4 grid.</li>
  <li><code class="language-plaintext highlighter-rouge">DimList(4, 4)</code> tells Mojo the shape is fixed at compile time. If the shape were dynamic, we might use <code class="language-plaintext highlighter-rouge">DimList(Dim(), Dim())</code> and provide an <code class="language-plaintext highlighter-rouge">IndexList</code> with actual dimensions later.</li>
</ul>

<p><strong>Memory Ownership Note</strong>: When you create an <code class="language-plaintext highlighter-rouge">NDBuffer</code> this way, <em>you</em> are responsible for making sure <code class="language-plaintext highlighter-rouge">matrix_data_storage</code> (or whatever memory <code class="language-plaintext highlighter-rouge">matrix.data</code> points to) stays valid for as long as <code class="language-plaintext highlighter-rouge">matrix</code> is used. <code class="language-plaintext highlighter-rouge">NDBuffer</code> itself doesn’t manage this external memory’s lifetime.</p>

<h3 id="2-using-ndbufferstack_allocation">2. Using <code class="language-plaintext highlighter-rouge">NDBuffer.stack_allocation()</code></h3>

<p>Sometimes, you want an <code class="language-plaintext highlighter-rouge">NDBuffer</code> that also manages its own small piece of memory, allocated on the stack. This is useful for small, temporary N-dimensional arrays where you know the size at compile time.</p>

<p>From <code class="language-plaintext highlighter-rouge">test_aligned_load_store</code> in <code class="language-plaintext highlighter-rouge">stdlib/test/buffer/test_ndbuffer.mojo</code>:</p>
<pre><code class="language-mojo">from buffer import NDBuffer, DimList
from memory import MutableAnyOrigin // Needed for stack_allocation's origin
from builtin import DType

fn create_ndbuffer_on_stack():
    // Create a 4x4 NDBuffer. The memory will be allocated on the stack.
    var matrix_on_stack = NDBuffer[
        DType.index,      // Element data type
        2,                // Rank: 2 dimensions
        MutableAnyOrigin, // Origin: Special type indicating new, mutable stack memory
        DimList(4, 4)     // Shape: A 4x4 matrix (must be static for stack_allocation)
    ].stack_allocation[alignment=128]() // Allocate memory on stack, specify alignment

    // Now matrix_on_stack is ready to use.
    matrix_on_stack[0, 0] = 123
    print("Stack allocated matrix. Element at (0,0):", matrix_on_stack[0,0])

    // Memory for matrix_on_stack is automatically reclaimed when it goes out of scope.
</code></pre>
<p>Key differences:</p>
<ul>
  <li>The shape (<code class="language-plaintext highlighter-rouge">DimList(4, 4)</code>) <em>must</em> be fully static (no <code class="language-plaintext highlighter-rouge">Dim()</code>).</li>
  <li>We use <code class="language-plaintext highlighter-rouge">MutableAnyOrigin</code> to tell Mojo this is fresh memory.</li>
  <li>The <code class="language-plaintext highlighter-rouge">.stack_allocation()</code> call does the memory allocation.</li>
  <li><strong>Memory Ownership</strong>: In this case, the <code class="language-plaintext highlighter-rouge">NDBuffer</code> <em>does</em> manage the lifetime of its stack-allocated memory. It’s automatically freed when <code class="language-plaintext highlighter-rouge">matrix_on_stack</code> is no longer in use.</li>
</ul>

<h2 id="working-with-ndbuffer-elements">Working with <code class="language-plaintext highlighter-rouge">NDBuffer</code> Elements</h2>

<h3 id="setting-values">Setting Values</h3>

<p>You can set values in an <code class="language-plaintext highlighter-rouge">NDBuffer</code> using square brackets <code class="language-plaintext highlighter-rouge">[]</code>. You can provide the indices as a sequence of integers or as an <code class="language-plaintext highlighter-rouge">IndexList</code> (from Chapter 3).</p>

<pre><code class="language-mojo">from utils import IndexList // For using IndexList explicitly

// Assuming 'matrix' is our 4x4 NDBuffer from earlier:
// Method 1: Multiple integer arguments
matrix[0, 0] = 0
matrix[0, 1] = 1
matrix[0, 2] = 2
matrix[0, 3] = 3
matrix[1, 0] = 4
// ... and so on for all 16 elements.

// Method 2: Using an IndexList
matrix[IndexList[2](3, 3)] = 15 // Set the element at row 3, column 3
</code></pre>
<p>The <code class="language-plaintext highlighter-rouge">test_ndbuffer</code> function in <code class="language-plaintext highlighter-rouge">stdlib/test/buffer/test_ndbuffer.mojo</code> shows populating a 4x4 matrix like this:</p>
<pre><code class="language-mojo">    // (matrix is a 4x4 NDBuffer[DType.index, 2, _, DimList(4,4)])
    matrix[IndexList[2](0, 0)] = 0
    matrix[IndexList[2](0, 1)] = 1
    // ...
    matrix[IndexList[2](3, 3)] = 15
</code></pre>
<p>Or, more simply with multiple arguments, as shown in later parts of the same test file for reading: <code class="language-plaintext highlighter-rouge">matrix[0,0]</code>.</p>

<h3 id="getting-values">Getting Values</h3>

<p>Similarly, you use <code class="language-plaintext highlighter-rouge">[]</code> to get values:</p>
<pre><code class="language-mojo">// Assuming 'matrix' is populated
var val_0_0 = matrix[0, 0]       // val_0_0 will be 0
var val_1_2 = matrix[1, 2]       // val_1_2 will be 6
var val_3_3 = matrix[IndexList[2](3,3)] // val_3_3 will be 15

print("Value at (0,0) is:", val_0_0)
print("Value at (1,2) is:", val_1_2)
</code></pre>

<p>The <code class="language-plaintext highlighter-rouge">test_ndbuffer</code> code prints all elements this way:</p>
<pre><code class="language-mojo">// CHECK: 0
print(matrix[0, 0])
// CHECK: 1
print(matrix[0, 1])
// ...
// CHECK: 15
print(matrix[3, 3])
</code></pre>

<h2 id="common-ndbuffer-operations-and-methods">Common <code class="language-plaintext highlighter-rouge">NDBuffer</code> Operations and Methods</h2>

<p><code class="language-plaintext highlighter-rouge">NDBuffer</code> comes with many useful methods. Let’s look at some from <code class="language-plaintext highlighter-rouge">stdlib/test/buffer/test_ndbuffer.mojo</code>.</p>

<h3 id="getting-information">Getting Information</h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">get_rank() -&gt; Int</code></strong>: Returns the number of dimensions.
    <pre><code class="language-mojo">// For our 4x4 matrix:
print(matrix.get_rank()) // CHECK: 2
</code></pre>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">size() -&gt; Int</code></strong> (or <strong><code class="language-plaintext highlighter-rouge">num_elements() -&gt; Int</code></strong>): Returns the total number of elements.
    <pre><code class="language-mojo">// For our 4x4 matrix (4 * 4 = 16 elements):
print(matrix.size()) // CHECK: 16
</code></pre>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">dim[compile_time_index]() -&gt; Int</code></strong> or <strong><code class="language-plaintext highlighter-rouge">dim(runtime_index: Int) -&gt; Int</code></strong>: Gets the size of a specific dimension.
    <pre><code class="language-mojo">var shape_of_matrix = matrix.get_shape() // Returns an IndexList, e.g., (4, 4)
print("Dim 0:", matrix.dim[0]())   // Compile-time index: matrix.dim[0]() -&gt; 4
print("Dim 1:", matrix.dim(1))     // Runtime index: matrix.dim(1) -&gt; 4
</code></pre>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">get_shape() -&gt; IndexList[rank]</code></strong>: Returns the shape as an <code class="language-plaintext highlighter-rouge">IndexList</code>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">get_strides() -&gt; IndexList[rank]</code></strong>: Returns the strides (more on this in the next chapter).</li>
</ul>

<h3 id="modifying-content">Modifying Content</h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">fill(value: Scalar[type])</code></strong>: Sets all elements in the <code class="language-plaintext highlighter-rouge">NDBuffer</code> to a single <code class="language-plaintext highlighter-rouge">value</code>. The buffer must be contiguous (its elements laid out sequentially in memory, which is typical for default NDBuffers).
    <pre><code class="language-mojo">// From test_fill:
var filled_stack = InlineArray[Scalar[DType.index], 3 * 3](uninitialized=True)
var filled_buffer = NDBuffer[DType.index, 2, _, DimList(3, 3)](filled_stack)
filled_buffer.fill(1) // All 9 elements of filled_buffer become 1
// (The test then compares this to a manually filled buffer)
</code></pre>
  </li>
</ul>

<h3 id="converting-indices">Converting Indices</h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">get_nd_index(flat_index: Int) -&gt; IndexList[rank]</code></strong>: Converts a 1D “flat” index (as if all elements were in a single line) into N-Dimensional coordinates.
    <pre><code class="language-mojo">// From test_get_nd_index:
// matrix0 is a 2x3 NDBuffer (total 6 elements, indexed 0 to 5)
// [[(0,0), (0,1), (0,2)],
//  [(1,0), (1,1), (1,2)]]
// Flat indices: 0, 1, 2, 3, 4, 5
// matrix0.get_nd_index(0) -&gt; (0,0)
// matrix0.get_nd_index(1) -&gt; (0,1)
// matrix0.get_nd_index(3) -&gt; (1,0)
// matrix0.get_nd_index(5) -&gt; (1,2)

// In the test:
// var matrix0 = NDBuffer[DType.index, 2, _, DimList(2, 3)](...)
// print(matrix0.get_nd_index(3)) // CHECK: (1, 0)
// print(matrix0.get_nd_index(5)) // CHECK: (1, 2)
</code></pre>
  </li>
</ul>

<h3 id="slicing-and-viewing-creating-tiles">Slicing and Viewing (Creating Tiles)</h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">tile[*tile_sizes: Dim](tile_coords: IndexList[rank]) -&gt; NDBuffer</code></strong>: Creates a new <code class="language-plaintext highlighter-rouge">NDBuffer</code> that is a “view” (not a copy!) of a smaller N-D sub-section of the original buffer. This is powerful for working with parts of larger arrays.
<code class="language-plaintext highlighter-rouge">*tile_sizes</code> are the dimensions of the tile you want to extract.
<code class="language-plaintext highlighter-rouge">tile_coords</code> are the coordinates <em>in terms of tiles</em>.
    <pre><code class="language-mojo">// From test_ndbuffer_tile (simplified conceptual view)
// buff is an 8x8 NDBuffer
// Let's get a 4x4 tile starting at the first tile block (0,0)
// var tile_4x4 = buff.tile[4, 4](Index(0,0))
// 'tile_4x4' is now a 4x4 NDBuffer viewing the top-left 4x4 part of 'buff'.
// Changes to 'tile_4x4' will affect 'buff' and vice-versa.

// The test code iterates to show tiling:
// alias M = 8, N = 8, m0_tile_size = 4, n0_tile_size = 4
// var buff = NDBuffer[DType.float32, 2, _, DimList(M, N)](...)
// ... fill buff ...
// for tile_i in range(M // m0_tile_size): // 0 to 1
//     for tile_j in range(N // n0_tile_size): // 0 to 1
//         print("tile-0[", tile_i, tile_j, "]")
//         var tile_4x4 = buff.tile[m0_tile_size, n0_tile_size](
//             tile_coords=Index(tile_i, tile_j)
//         )
//         print_buffer(tile_4x4) // Prints the 4x4 tile
</code></pre>
    <p>This is a very efficient way to work with sub-arrays.</p>
  </li>
</ul>

<h3 id="printing">Printing</h3>

<ul>
  <li>Printing an <code class="language-plaintext highlighter-rouge">NDBuffer</code> or converting it to a <code class="language-plaintext highlighter-rouge">String</code> gives a nice, human-readable representation.
    <pre><code class="language-mojo">// From test_print:
// buffer is a 2x2x3 NDBuffer
// String(buffer) produces:
// "NDBuffer([[[0, 1, 2],
// [3, 4, 5]],
// [[6, 7, 8],
// [9, 10, 11]]], dtype=index, shape=2x2x3)"
</code></pre>
  </li>
</ul>

<h3 id="file-io">File I/O</h3>

<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">tofile(path: Path)</code></strong>: Writes the raw byte contents of the <code class="language-plaintext highlighter-rouge">NDBuffer</code> to a binary file. The buffer should be contiguous.
    <pre><code class="language-mojo">// From test_ndbuffer_tofile:
// var buf = NDBuffer[DType.float32, 2, _, DimList(2, 2)](...)
// buf.fill(2.0)
// with NamedTemporaryFile(name=String("test_ndbuffer")) as TEMP_FILE:
//     buf.tofile(TEMP_FILE.name)
//     // The test then reads it back to verify
</code></pre>
  </li>
</ul>

<h3 id="performance-features-brief-mention-for-awareness">Performance Features (Brief Mention for Awareness)</h3>

<p><code class="language-plaintext highlighter-rouge">NDBuffer</code> also has features for advanced performance tuning, which you might encounter later:</p>
<ul>
  <li><strong><code class="language-plaintext highlighter-rouge">prefetch[PrefetchOptions()](*idx: Int)</code></strong>: Hints to the CPU/GPU to start loading data from a specific index into its cache before it’s explicitly needed. (See <code class="language-plaintext highlighter-rouge">test_ndbuffer_prefetch</code>).</li>
  <li><strong><code class="language-plaintext highlighter-rouge">load[width=N](*idx: Int)</code> / <code class="language-plaintext highlighter-rouge">store[width=N](*idx: Int, value: SIMD[...])</code></strong>: Perform vectorized (SIMD) loads and stores, reading/writing multiple elements at once if the hardware supports it and memory is aligned. (See <code class="language-plaintext highlighter-rouge">test_aligned_load_store</code>). These require contiguous memory.</li>
</ul>

<h2 id="key-takeaways-for-ndbuffer">Key Takeaways for <code class="language-plaintext highlighter-rouge">NDBuffer</code></h2>

<ul>
  <li><code class="language-plaintext highlighter-rouge">NDBuffer</code> is Mojo’s primary tool for working with <strong>multi-dimensional data</strong> (vectors, matrices, tensors).</li>
  <li>It’s usually a <strong>“view” or “lens”</strong> over existing memory, defined by metadata (dtype, shape, strides).</li>
  <li>It <strong>doesn’t typically own the memory</strong> unless created with <code class="language-plaintext highlighter-rouge">stack_allocation()</code>. You must manage the lifetime of the underlying memory if <code class="language-plaintext highlighter-rouge">NDBuffer</code> is just a view.</li>
  <li>Creation involves specifying element <code class="language-plaintext highlighter-rouge">DType</code>, <code class="language-plaintext highlighter-rouge">rank</code> (number of dimensions), and <code class="language-plaintext highlighter-rouge">shape</code> (using <code class="language-plaintext highlighter-rouge">DimList</code>).</li>
  <li>Elements are accessed and modified using <code class="language-plaintext highlighter-rouge">[index0, index1, ...]</code>.</li>
  <li>Provides useful methods like <code class="language-plaintext highlighter-rouge">get_rank()</code>, <code class="language-plaintext highlighter-rouge">size()</code>, <code class="language-plaintext highlighter-rouge">fill()</code>, <code class="language-plaintext highlighter-rouge">get_nd_index()</code>, <code class="language-plaintext highlighter-rouge">tile()</code>, and <code class="language-plaintext highlighter-rouge">tofile()</code>.</li>
  <li>The ability to mix static and dynamic dimensions (via <code class="language-plaintext highlighter-rouge">DimList</code>) allows for both compile-time optimization and runtime flexibility.</li>
</ul>

<h2 id="full-example-a-simple-2x3-matrix">Full Example: A Simple 2x3 Matrix</h2>

<p>Let’s create a small 2x3 matrix, fill it, and print some info.</p>

<pre><code class="language-mojo">from buffer import NDBuffer, DimList
from memory import InlineArray, MutableAnyOrigin
from builtin import DType, Scalar
from utils import IndexList

fn main_ndbuffer_example():
    print("--- NDBuffer Simple 2x3 Matrix Example ---")

    // Method 1: View over InlineArray
    print("\n1. NDBuffer as a view over InlineArray:")
    var flat_data = InlineArray[Scalar[DType.int32], 2 * 3](uninitialized=True)
    var matrix_view = NDBuffer[
        DType.int32,
        2, // rank
        _, // origin (inferred)
        DimList(2, 3) // shape: 2 rows, 3 columns
    ](flat_data)

    // Populate matrix_view
    for r in range(2):
        for c in range(3):
            matrix_view[r, c] = r * 10 + c
    
    print("Matrix View:")
    print(matrix_view)
    print("Rank:", matrix_view.get_rank())
    print("Size:", matrix_view.size())
    print("Shape:", matrix_view.get_shape())
    print("Element (1,1):", matrix_view[1,1])


    // Method 2: Stack-allocated NDBuffer
    print("\n2. Stack-allocated NDBuffer:")
    var matrix_stack = NDBuffer[
        DType.int32,
        2, // rank
        MutableAnyOrigin,
        DimList(2,3) // shape
    ].stack_allocation()

    // Populate matrix_stack
    for r in range(2):
        for c in range(3):
            matrix_stack[r, c] = (r+1) * 100 + (c+1)

    print("Matrix Stack:")
    print(matrix_stack)
    print("Element (0,2):", matrix_stack[0,2])

    print("\n--- End of Example ---")

# To run this, you'd call main_ndbuffer_example()
# main_ndbuffer_example()
</code></pre>

<h2 id="next-steps">Next Steps</h2>

<p><code class="language-plaintext highlighter-rouge">NDBuffer</code> is incredibly versatile. A key to its power is how it uses <strong>strides</strong> to navigate its underlying flat memory. In the next chapter, we’ll delve into “N-D to 1D Indexing Logic (Strided Memory Access)” to understand how <code class="language-plaintext highlighter-rouge">NDBuffer</code> calculates the exact memory location for an element like <code class="language-plaintext highlighter-rouge">matrix[row, col, depth]</code> and how strides enable different memory layouts (like row-major vs. column-major). This will complete your foundational understanding of <code class="language-plaintext highlighter-rouge">NDBuffer</code>!</p>

<hr />
<p><strong>Table of Contents</strong></p>
<ol>
  <li><a href="01_addressspace_.md">Chapter 1: Understanding Memory Neighborhoods with <code class="language-plaintext highlighter-rouge">AddressSpace</code></a></li>
  <li><a href="02_unsafepointer_.md">Chapter 2: Peeking into Memory with <code class="language-plaintext highlighter-rouge">UnsafePointer</code></a></li>
  <li><a href="03_indexlist_.md">Chapter 3: Working with Multiple Dimensions: <code class="language-plaintext highlighter-rouge">IndexList</code></a></li>
  <li><a href="04_dimlist_.md">Chapter 4: Describing Dimensions with <code class="language-plaintext highlighter-rouge">Dim</code> and <code class="language-plaintext highlighter-rouge">DimList</code></a></li>
  <li><strong>Chapter 5: The N-Dimensional Buffer: <code class="language-plaintext highlighter-rouge">NDBuffer</code></strong> (You are here)</li>
  <li><em>Coming Soon: Chapter 6: N-D to 1D Indexing Logic (Strided Memory Access)</em>
```</li>
</ol>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
