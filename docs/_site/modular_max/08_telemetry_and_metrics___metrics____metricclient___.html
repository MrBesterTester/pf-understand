<h1 id="chapter-8-telemetry-and-metrics-metrics-metricclient">Chapter 8: Telemetry and Metrics (<code class="language-plaintext highlighter-rouge">METRICS</code>, <code class="language-plaintext highlighter-rouge">MetricClient</code>)</h1>

<p>Welcome to the final chapter of our core concepts tour! In <a href="07_enginequeue_.md">Chapter 7: EngineQueue</a>, we explored how different parts of <code class="language-plaintext highlighter-rouge">modular</code>, even across separate processes, communicate with each other. Now, with all these components working together, how do we know what’s going on inside? Is the server running smoothly? Is it fast? Are there any bottlenecks?</p>

<p>This is where <strong>Telemetry and Metrics</strong> come into play. They are like the flight data recorder and cockpit instruments of an airplane, constantly logging vital statistics and displaying real-time performance indicators to the crew (the server operators).</p>

<h2 id="what-problem-do-telemetry-and-metrics-solve">What Problem Do Telemetry and Metrics Solve?</h2>

<p>Imagine you’re running <code class="language-plaintext highlighter-rouge">modular</code> to serve a popular AI model. Users start reporting that it’s sometimes slow. How do you figure out why?</p>
<ul>
  <li>Is the server getting too many requests?</li>
  <li>Is the AI model itself taking a long time for certain prompts?</li>
  <li>Is the <a href="06_kv_cache_management_.md">KV Cache Management</a> struggling?</li>
  <li>Are prompts waiting too long in the <a href="07_enginequeue_.md">EngineQueue</a>?</li>
</ul>

<p>Without data, you’re just guessing. Telemetry and metrics provide this crucial data, giving you <strong>observability</strong> into the server’s operation. <code class="language-plaintext highlighter-rouge">modular</code>’s telemetry system collects and reports various metrics like:</p>
<ul>
  <li>Request counts and error rates.</li>
  <li>How long requests take to process (latency).</li>
  <li>How fast tokens are being generated.</li>
  <li>How well the KV cache is being utilized.</li>
  <li>The number of requests waiting in queues.</li>
</ul>

<p>This information is vital for understanding performance, debugging issues, and making informed decisions about scaling or optimizing the service.</p>

<h2 id="key-concepts-understanding-the-instruments">Key Concepts: Understanding the Instruments</h2>

<p>Let’s look at the main components of <code class="language-plaintext highlighter-rouge">modular</code>’s telemetry system:</p>

<h3 id="1-metrics-the-vital-signs">1. Metrics: The Vital Signs</h3>

<p>Metrics are specific, quantifiable measurements of the server’s behavior. For example:</p>
<ul>
  <li><code class="language-plaintext highlighter-rouge">maxserve.request_count</code>: A counter for how many HTTP requests have been received.</li>
  <li><code class="language-plaintext highlighter-rouge">maxserve.request_time</code>: A histogram (a way to track distribution of values) for how long requests take.</li>
  <li><code class="language-plaintext highlighter-rouge">maxserve.itl</code>: A histogram for “inter-token latency,” or how long it takes to generate each subsequent token.</li>
  <li><code class="language-plaintext highlighter-rouge">maxserve.cache.num_used_blocks</code>: A counter for how many KV cache blocks are currently in use.</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">modular</code> defines a set of these metrics (in <code class="language-plaintext highlighter-rouge">src/max/serve/telemetry/metrics.py</code> inside the <code class="language-plaintext highlighter-rouge">SERVE_METRICS</code> dictionary).</p>

<h3 id="2-opentelemetry-otel-a-common-language-for-metrics">2. OpenTelemetry (OTEL): A Common Language for Metrics</h3>

<p>Instead of inventing its own way to define and collect metrics, <code class="language-plaintext highlighter-rouge">modular</code> uses <strong>OpenTelemetry (OTEL)</strong>. OTEL is an open standard for collecting telemetry data (metrics, logs, and traces). Using OTEL means <code class="language-plaintext highlighter-rouge">modular</code>’s metrics can be easily understood and processed by many different monitoring tools.</p>

<h3 id="3-exporters-sending-metrics-out">3. Exporters: Sending Metrics Out</h3>

<p>Once metrics are collected, they need to be sent somewhere to be viewed and analyzed. <code class="language-plaintext highlighter-rouge">modular</code> can <strong>export</strong> these OTEL metrics to various systems. A common one is <strong>Prometheus</strong>.</p>
<ul>
  <li><strong>Prometheus</strong>: A popular open-source monitoring system. <code class="language-plaintext highlighter-rouge">modular</code> can expose an HTTP endpoint (usually on a different port, e.g., <code class="language-plaintext highlighter-rouge">8001</code>, configured by <code class="language-plaintext highlighter-rouge">metrics_port</code> in <a href="01_settings___settings__class__.md">Settings (<code class="language-plaintext highlighter-rouge">Settings</code> class)</a>) that Prometheus can “scrape” (read from) periodically to collect the latest metric values.</li>
</ul>

<h3 id="4-metrics-the-easy-button-for-recording">4. <code class="language-plaintext highlighter-rouge">METRICS</code>: The Easy Button for Recording</h3>

<p>Inside the <code class="language-plaintext highlighter-rouge">modular</code> code, when something interesting happens that should be recorded (like a request finishing), developers don’t usually interact with OTEL directly. Instead, they use a global object called <code class="language-plaintext highlighter-rouge">METRICS</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified from: src/max/serve/telemetry/metrics.py
# (This object is created and made globally available)
# METRICS = _AsyncMetrics() 
</span>
<span class="c1"># Example usage elsewhere in code:
# METRICS.request_count(responseCode=200, urlPath="/v1/chat/completions")
# METRICS.request_time(value=55.3, urlPath="/v1/chat/completions") # value in ms
</span></code></pre></div></div>
<p>This <code class="language-plaintext highlighter-rouge">METRICS</code> object (an instance of <code class="language-plaintext highlighter-rouge">_AsyncMetrics</code>) provides simple methods like <code class="language-plaintext highlighter-rouge">request_count()</code> or <code class="language-plaintext highlighter-rouge">request_time()</code> to record observations.</p>

<h3 id="5-metricclient-the-delivery-service">5. <code class="language-plaintext highlighter-rouge">MetricClient</code>: The Delivery Service</h3>

<p>The <code class="language-plaintext highlighter-rouge">METRICS</code> object itself doesn’t do the raw recording. It delegates this to a <code class="language-plaintext highlighter-rouge">MetricClient</code>. The <code class="language-plaintext highlighter-rouge">MetricClient</code> is responsible for taking the metric observation and actually processing it according to the configured method.</p>

<h3 id="6-recording-methods-how-metrics-are-processed">6. Recording Methods: How Metrics are Processed</h3>

<p>Sending metrics can take a tiny bit of time. To minimize any performance impact on the main server operations, <code class="language-plaintext highlighter-rouge">modular</code> supports different ways to record metrics, configured by the <code class="language-plaintext highlighter-rouge">metric_recording</code> setting (from <a href="01_settings___settings__class__.md">Settings (<code class="language-plaintext highlighter-rouge">Settings</code> class)</a>):</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MetricRecordingMethod.NOOP</code>: “No Operation.” Metrics are not recorded at all. Useful for maximum performance if metrics aren’t needed.</li>
  <li><code class="language-plaintext highlighter-rouge">MetricRecordingMethod.SYNC</code>: “Synchronous.” Metrics are recorded immediately in the same thread. Simplest, but can have a small performance impact.</li>
  <li><code class="language-plaintext highlighter-rouge">MetricRecordingMethod.ASYNCIO</code>: Metrics are put into an <code class="language-plaintext highlighter-rouge">asyncio</code> queue and processed by a separate <code class="language-plaintext highlighter-rouge">asyncio</code> task in the same process. This offloads the recording work from the main request path.</li>
  <li><code class="language-plaintext highlighter-rouge">MetricRecordingMethod.PROCESS</code>: Metrics are sent to a completely separate dedicated process for recording. This offers the most isolation but is more complex.</li>
</ul>

<p>The default is usually <code class="language-plaintext highlighter-rouge">ASYNCIO</code>, offering a good balance.</p>

<h3 id="7-metric-levels-controlling-detail">7. Metric Levels: Controlling Detail</h3>

<p>Some metrics are cheap to collect (e.g., incrementing a counter), while others might be more expensive or generate a lot of data. The <code class="language-plaintext highlighter-rouge">metric_level</code> setting (from <a href="01_settings___settings__class__.md">Settings (<code class="language-plaintext highlighter-rouge">Settings</code> class)</a>) controls how much detail is captured:</p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">MetricLevel.NONE</code>: No metrics (similar to <code class="language-plaintext highlighter-rouge">NOOP</code> recording).</li>
  <li><code class="language-plaintext highlighter-rouge">MetricLevel.BASIC</code>: Only essential, low-impact metrics are recorded.</li>
  <li><code class="language-plaintext highlighter-rouge">MetricLevel.DETAILED</code>: More granular metrics are recorded, which might have a slight performance cost.</li>
</ul>

<p>This allows operators to choose the trade-off between observability detail and performance.</p>

<h2 id="how-modular-uses-telemetry">How <code class="language-plaintext highlighter-rouge">modular</code> Uses Telemetry</h2>

<p>For the most part, as an end-user or even a developer working on a specific part of <code class="language-plaintext highlighter-rouge">modular</code>, you benefit from metrics automatically. Key components are already “instrumented” to record relevant data.</p>

<p>For example:</p>
<ul>
  <li>When the <a href="02_serving_api_layer__fastapi_app___routers__.md">Serving API Layer (FastAPI App &amp; Routers)</a> handles a request, it automatically records things like request count and processing time.</li>
  <li>The <a href="03_llm_pipeline_orchestrator___tokengeneratorpipeline___.md">LLM Pipeline Orchestrator (<code class="language-plaintext highlighter-rouge">TokenGeneratorPipeline</code>)</a> records time-to-first-token and inter-token latency.</li>
  <li>The <a href="05_scheduler___tokengenerationscheduler____embeddingsscheduler___.md">Scheduler (<code class="language-plaintext highlighter-rouge">TokenGenerationScheduler</code>, <code class="language-plaintext highlighter-rouge">EmbeddingsScheduler</code>)</a> records batch sizes and <a href="06_kv_cache_management_.md">KV Cache Management</a> statistics like cache hit rates.</li>
</ul>

<p><strong>Operators</strong> would typically:</p>
<ol>
  <li>Ensure <code class="language-plaintext highlighter-rouge">disable_telemetry</code> is <code class="language-plaintext highlighter-rouge">False</code> in their <a href="01_settings___settings__class__.md">Settings (<code class="language-plaintext highlighter-rouge">Settings</code> class)</a>.</li>
  <li>Set <code class="language-plaintext highlighter-rouge">metric_recording</code> and <code class="language-plaintext highlighter-rouge">metric_level</code> as desired.</li>
  <li>Configure a Prometheus server (or similar tool) to scrape the <code class="language-plaintext highlighter-rouge">/metrics</code> endpoint on the <code class="language-plaintext highlighter-rouge">metrics_port</code> (e.g., <code class="language-plaintext highlighter-rouge">http://&lt;modular_host&gt;:8001/metrics</code>).</li>
  <li>Use Prometheus’s query language (PromQL) and visualization tools (like Grafana) to create dashboards and alerts based on these metrics.</li>
</ol>

<p>For example, an operator might create a graph of <code class="language-plaintext highlighter-rouge">maxserve.request_time</code> to monitor API latency, or <code class="language-plaintext highlighter-rouge">maxserve.num_requests_queued</code> to see if the server is falling behind.</p>

<h2 id="under-the-hood-the-journey-of-a-metric">Under the Hood: The Journey of a Metric</h2>

<p>Let’s trace what happens when a metric is recorded, for instance, when a request finishes:</p>

<pre><code class="language-mermaid">sequenceDiagram
    participant AppCode as Application Code (e.g., API Router)
    participant METRICS as Global METRICS Object
    participant Client as Active MetricClient (Asyncio, Process, etc.)
    participant Recorder as Metric Recorder (e.g., Asyncio Task or Separate Process)
    participant OTELSDK as OpenTelemetry SDK
    participant Exporter as Prometheus Exporter

    AppCode-&gt;&gt;METRICS: METRICS.request_time(50.0, "/v1/chat")
    METRICS-&gt;&gt;Client: send_measurement(MaxMeasurement_object, MetricLevel.BASIC)
    alt MetricLevel.BASIC &lt;= configured_level
        Client-&gt;&gt;Recorder: Pass MaxMeasurement_object (e.g., put on a queue)
        Note over Recorder: Waits for processing slot
        Recorder-&gt;&gt;OTELSDK: MaxMeasurement_object.commit()
        OTELSDK-&gt;&gt;OTELSDK: Update internal metric representation
        OTELSDK--&gt;&gt;Exporter: Value is updated for Prometheus
    else MetricLevel.BASIC &gt; configured_level
        Client--&gt;&gt;METRICS: Metric dropped (level too high)
    end
    Note over Exporter: Later...
    MonitoringSystem-&gt;&gt;Exporter: HTTP GET /metrics (scrape)
    Exporter--&gt;&gt;MonitoringSystem: Current metric values
</code></pre>

<ol>
  <li><strong>Observation</strong>: Code in <code class="language-plaintext highlighter-rouge">modular</code> (e.g., an API endpoint handler) observes an event. It calls a method on the global <code class="language-plaintext highlighter-rouge">METRICS</code> object, like <code class="language-plaintext highlighter-rouge">METRICS.request_time(value_ms, path)</code>.</li>
  <li><strong><code class="language-plaintext highlighter-rouge">METRICS</code> Object (<code class="language-plaintext highlighter-rouge">_AsyncMetrics</code>)</strong>:
    <ul>
      <li>The <code class="language-plaintext highlighter-rouge">METRICS</code> object (an instance of <code class="language-plaintext highlighter-rouge">_AsyncMetrics</code> from <code class="language-plaintext highlighter-rouge">src/max/serve/telemetry/metrics.py</code>) receives this call.</li>
      <li>It creates a <code class="language-plaintext highlighter-rouge">MaxMeasurement</code> dataclass instance. This object holds the metric name (e.g., “maxserve.request_time”), the observed value, any attributes (like the URL path), and the current timestamp.</li>
      <li>It then calls <code class="language-plaintext highlighter-rouge">self.client.send_measurement(measurement_object, metric_level_of_this_metric)</code>. The <code class="language-plaintext highlighter-rouge">self.client</code> is the currently active <code class="language-plaintext highlighter-rouge">MetricClient</code>.</li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">MetricClient</code> (<code class="language-plaintext highlighter-rouge">send_measurement</code>)</strong>:
    <ul>
      <li>The active <code class="language-plaintext highlighter-rouge">MetricClient</code> (e.g., <code class="language-plaintext highlighter-rouge">AsyncioMetricClient</code>, <code class="language-plaintext highlighter-rouge">ProcessMetricClient</code>, <code class="language-plaintext highlighter-rouge">SyncClient</code>, or <code class="language-plaintext highlighter-rouge">NoopClient</code>) gets the <code class="language-plaintext highlighter-rouge">MaxMeasurement</code>.</li>
      <li>It first checks if the <code class="language-plaintext highlighter-rouge">metric_level_of_this_metric</code> (e.g., <code class="language-plaintext highlighter-rouge">MetricLevel.BASIC</code>) is less than or equal to the globally configured <code class="language-plaintext highlighter-rouge">metric_level</code> (from <a href="01_settings___settings__class__.md">Settings (<code class="language-plaintext highlighter-rouge">Settings</code> class)</a>). If not, the metric is dropped.</li>
      <li>If the level is appropriate, the client handles the measurement based on its type:
        <ul>
          <li><code class="language-plaintext highlighter-rouge">NoopClient</code>: Does nothing.</li>
          <li><code class="language-plaintext highlighter-rouge">SyncClient</code>: Directly calls <code class="language-plaintext highlighter-rouge">measurement_object.commit()</code>.</li>
          <li><code class="language-plaintext highlighter-rouge">AsyncioMetricClient</code>: Puts the <code class="language-plaintext highlighter-rouge">measurement_object</code> onto an <code class="language-plaintext highlighter-rouge">asyncio.Queue</code>. A background <code class="language-plaintext highlighter-rouge">asyncio</code> task will later pick it up and call <code class="language-plaintext highlighter-rouge">commit()</code>. (See <code class="language-plaintext highlighter-rouge">AsyncioMetricClient</code> in <code class="language-plaintext highlighter-rouge">src/max/serve/telemetry/asyncio_controller.py</code>)</li>
          <li><code class="language-plaintext highlighter-rouge">ProcessMetricClient</code>: Sends the <code class="language-plaintext highlighter-rouge">measurement_object</code> (possibly batched) via a <code class="language-plaintext highlighter-rouge">multiprocessing.Queue</code> to a separate telemetry worker process. That process will then call <code class="language-plaintext highlighter-rouge">commit()</code>. (See <code class="language-plaintext highlighter-rouge">ProcessMetricClient</code> in <code class="language-plaintext highlighter-rouge">src/max/serve/telemetry/process_controller.py</code>)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong><code class="language-plaintext highlighter-rouge">MaxMeasurement.commit()</code></strong>:
    <ul>
      <li>This method (defined in <code class="language-plaintext highlighter-rouge">src/max/serve/telemetry/metrics.py</code>) is where the metric observation finally interacts with the OpenTelemetry SDK.</li>
      <li>It looks up the OTEL “instrument” (like a Counter or Histogram) corresponding to <code class="language-plaintext highlighter-rouge">self.instrument_name</code> from the <code class="language-plaintext highlighter-rouge">SERVE_METRICS</code> dictionary.</li>
      <li>It creates an OTEL <code class="language-plaintext highlighter-rouge">Measurement</code> object with the value, timestamp, and attributes.</li>
      <li>It then calls the OTEL instrument’s internal consumer to record this <code class="language-plaintext highlighter-rouge">Measurement</code>.</li>
    </ul>
  </li>
  <li><strong>OpenTelemetry SDK &amp; Exporter</strong>:
    <ul>
      <li>The OTEL SDK updates its internal representation of the metric.</li>
      <li>If a Prometheus exporter is configured (via <code class="language-plaintext highlighter-rouge">configure_metrics</code> in <code class="language-plaintext highlighter-rouge">src/max/serve/telemetry/common.py</code>), this exporter makes the latest metric values available on an HTTP endpoint (e.g., <code class="language-plaintext highlighter-rouge">/metrics</code> on port <code class="language-plaintext highlighter-rouge">8001</code>).</li>
      <li>External systems like Prometheus can then scrape this endpoint.</li>
    </ul>
  </li>
</ol>

<h3 id="key-code-snippets">Key Code Snippets:</h3>

<p><strong>1. Settings for Metrics (from <code class="language-plaintext highlighter-rouge">src/max/serve/config.py</code>)</strong>
These settings from <a href="01_settings___settings__class__.md">Chapter 1: Settings (<code class="language-plaintext highlighter-rouge">Settings</code> class)</a> control telemetry behavior.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># From: src/max/serve/config.py
</span><span class="k">class</span> <span class="nc">MetricLevel</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>
    <span class="n">NONE</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">BASIC</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">DETAILED</span> <span class="o">=</span> <span class="mi">20</span>

<span class="k">class</span> <span class="nc">MetricRecordingMethod</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">NOOP</span> <span class="o">=</span> <span class="s">"NOOP"</span>
    <span class="n">SYNC</span> <span class="o">=</span> <span class="s">"SYNC"</span>
    <span class="n">ASYNCIO</span> <span class="o">=</span> <span class="s">"ASYNCIO"</span>
    <span class="n">PROCESS</span> <span class="o">=</span> <span class="s">"PROCESS"</span>

<span class="k">class</span> <span class="nc">Settings</span><span class="p">(</span><span class="n">BaseSettings</span><span class="p">):</span>
    <span class="c1"># ... other settings ...
</span>    <span class="n">metrics_port</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="mi">8001</span><span class="p">,</span> <span class="p">...)</span>
    <span class="n">disable_telemetry</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="p">...)</span>
    <span class="n">metric_recording</span><span class="p">:</span> <span class="n">MetricRecordingMethod</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">MetricRecordingMethod</span><span class="p">.</span><span class="n">ASYNCIO</span><span class="p">,</span> <span class="p">...)</span>
    <span class="n">metric_level</span><span class="p">:</span> <span class="n">MetricLevel</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">MetricLevel</span><span class="p">.</span><span class="n">BASIC</span><span class="p">,</span> <span class="p">...)</span>
    <span class="c1"># ...
</span></code></pre></div></div>
<p>This shows how metric levels and recording methods are defined as configurable options.</p>

<p><strong>2. The Global <code class="language-plaintext highlighter-rouge">METRICS</code> Object (from <code class="language-plaintext highlighter-rouge">src/max/serve/telemetry/metrics.py</code>)</strong>
This is the primary interface for code to record metrics.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified from: src/max/serve/telemetry/metrics.py
</span><span class="k">class</span> <span class="nc">_AsyncMetrics</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">client</span><span class="p">:</span> <span class="n">MetricClient</span> <span class="o">=</span> <span class="n">NoopClient</span><span class="p">()</span> <span class="c1"># Default, configured later
</span>
    <span class="k">def</span> <span class="nf">configure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">client</span><span class="p">:</span> <span class="n">MetricClient</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">client</span> <span class="o">=</span> <span class="n">client</span>

    <span class="k">def</span> <span class="nf">request_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">responseCode</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">urlPath</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">client</span><span class="p">.</span><span class="n">send_measurement</span><span class="p">(</span>
            <span class="n">MaxMeasurement</span><span class="p">(</span>
                <span class="s">"maxserve.request_count"</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s">"code"</span><span class="p">:</span> <span class="sa">f</span><span class="s">"</span><span class="si">{</span><span class="n">responseCode</span><span class="si">:</span><span class="n">d</span><span class="si">}</span><span class="s">"</span><span class="p">,</span> <span class="s">"path"</span><span class="p">:</span> <span class="n">urlPath</span><span class="p">}</span>
            <span class="p">),</span>
            <span class="n">MetricLevel</span><span class="p">.</span><span class="n">BASIC</span><span class="p">,</span> <span class="c1"># This metric is considered 'BASIC'
</span>        <span class="p">)</span>
    <span class="c1"># ... other methods like request_time, ttft, etc. ...
</span>
<span class="n">METRICS</span> <span class="o">=</span> <span class="n">_AsyncMetrics</span><span class="p">()</span> <span class="c1"># The global instance
</span></code></pre></div></div>
<p>Application code calls methods like <code class="language-plaintext highlighter-rouge">METRICS.request_count()</code>. This method creates a <code class="language-plaintext highlighter-rouge">MaxMeasurement</code> and passes it to the configured <code class="language-plaintext highlighter-rouge">MetricClient</code>.</p>

<p><strong>3. <code class="language-plaintext highlighter-rouge">MaxMeasurement</code> Dataclass (from <code class="language-plaintext highlighter-rouge">src/max/serve/telemetry/metrics.py</code>)</strong>
This holds the data for a single metric observation.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified from: src/max/serve/telemetry/metrics.py
</span><span class="o">@</span><span class="n">dataclass</span>
<span class="k">class</span> <span class="nc">MaxMeasurement</span><span class="p">:</span>
    <span class="n">instrument_name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span>
    <span class="n">attributes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">time_unix_nano</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="n">time</span><span class="p">.</span><span class="n">time_ns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">commit</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">instrument</span> <span class="o">=</span> <span class="n">SERVE_METRICS</span><span class="p">[</span><span class="bp">self</span><span class="p">.</span><span class="n">instrument_name</span><span class="p">]</span> <span class="c1"># Get OTEL instrument
</span>        <span class="c1"># ... (unwrap proxy instrument if necessary) ...
</span>        <span class="c1"># ... (create OTEL Measurement object `m`) ...
</span>        <span class="c1"># consumer = instrument._measurement_consumer
</span>        <span class="c1"># consumer.consume_measurement(m) # Record with OTEL
</span>        <span class="n">logger</span><span class="p">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s">"Committed measurement for </span><span class="si">{</span><span class="bp">self</span><span class="p">.</span><span class="n">instrument_name</span><span class="si">}</span><span class="s">"</span><span class="p">)</span>
</code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">commit()</code> method is the bridge to the OpenTelemetry SDK.</p>

<p><strong>4. <code class="language-plaintext highlighter-rouge">MetricClient</code> and its Implementations (from <code class="language-plaintext highlighter-rouge">src/max/serve/telemetry/metrics.py</code>)</strong>
This defines how measurements are handled.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified from: src/max/serve/telemetry/metrics.py
</span><span class="k">class</span> <span class="nc">MetricClient</span><span class="p">(</span><span class="n">abc</span><span class="p">.</span><span class="n">ABC</span><span class="p">):</span>
    <span class="o">@</span><span class="n">abc</span><span class="p">.</span><span class="n">abstractmethod</span>
    <span class="k">def</span> <span class="nf">send_measurement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metric</span><span class="p">:</span> <span class="n">MaxMeasurement</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">MetricLevel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="c1"># ... cross_process_factory omitted for brevity ...
</span>
<span class="k">class</span> <span class="nc">NoopClient</span><span class="p">(</span><span class="n">MetricClient</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">send_measurement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">MaxMeasurement</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">MetricLevel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">pass</span> <span class="c1"># Does nothing
</span>
<span class="k">class</span> <span class="nc">SyncClient</span><span class="p">(</span><span class="n">MetricClient</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">settings</span><span class="p">:</span> <span class="n">Settings</span><span class="p">):</span>
        <span class="bp">self</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">settings</span><span class="p">.</span><span class="n">metric_level</span> <span class="c1"># Configured detail level
</span>
    <span class="k">def</span> <span class="nf">send_measurement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="n">MaxMeasurement</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="n">MetricLevel</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="p">.</span><span class="n">level</span><span class="p">:</span> <span class="c1"># Check if this metric's level is too detailed
</span>            <span class="k">return</span>
        <span class="n">m</span><span class="p">.</span><span class="n">commit</span><span class="p">()</span> <span class="c1"># Commit synchronously
</span></code></pre></div></div>
<p>The <code class="language-plaintext highlighter-rouge">AsyncioMetricClient</code> and <code class="language-plaintext highlighter-rouge">ProcessMetricClient</code> (found in <code class="language-plaintext highlighter-rouge">asyncio_controller.py</code> and <code class="language-plaintext highlighter-rouge">process_controller.py</code> respectively) would put <code class="language-plaintext highlighter-rouge">m</code> onto a queue for later processing of <code class="language-plaintext highlighter-rouge">m.commit()</code>.</p>

<p><strong>5. Starting the Telemetry Consumer (from <code class="language-plaintext highlighter-rouge">src/max/serve/pipelines/telemetry_worker.py</code>)</strong>
This function, usually called during server startup, selects and starts the correct <code class="language-plaintext highlighter-rouge">MetricClient</code> based on settings.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified from: src/max/serve/pipelines/telemetry_worker.py
</span><span class="o">@</span><span class="n">asynccontextmanager</span>
<span class="k">async</span> <span class="k">def</span> <span class="nf">start_telemetry_consumer</span><span class="p">(</span>
    <span class="n">settings</span><span class="p">:</span> <span class="n">Settings</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AsyncGenerator</span><span class="p">[</span><span class="n">MetricClient</span><span class="p">,</span> <span class="bp">None</span><span class="p">]:</span>
    <span class="n">method</span> <span class="o">=</span> <span class="n">settings</span><span class="p">.</span><span class="n">metric_recording</span>
    <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="n">MetricRecordingMethod</span><span class="p">.</span><span class="n">NOOP</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">NoopClient</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="n">MetricRecordingMethod</span><span class="p">.</span><span class="n">SYNC</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">SyncClient</span><span class="p">(</span><span class="n">settings</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="n">MetricRecordingMethod</span><span class="p">.</span><span class="n">ASYNCIO</span><span class="p">:</span>
        <span class="c1"># async with start_asyncio_consumer(settings) as controller:
</span>        <span class="c1">#    yield controller.Client(settings)
</span>        <span class="k">pass</span> <span class="c1"># Simplified
</span>    <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="n">MetricRecordingMethod</span><span class="p">.</span><span class="n">PROCESS</span><span class="p">:</span>
        <span class="c1"># async with start_process_consumer(settings) as controller:
</span>        <span class="c1">#    yield controller.Client(settings)
</span>        <span class="k">pass</span> <span class="c1"># Simplified
</span>    <span class="c1"># ...
</span></code></pre></div></div>
<p>The chosen client is then passed to <code class="language-plaintext highlighter-rouge">METRICS.configure(chosen_client)</code>.</p>

<p><strong>6. Configuring OTEL Exporters (from <code class="language-plaintext highlighter-rouge">src/max/serve/telemetry/common.py</code>)</strong>
This function sets up OpenTelemetry to use the Prometheus exporter.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Simplified from: src/max/serve/telemetry/common.py
</span><span class="k">def</span> <span class="nf">configure_metrics</span><span class="p">(</span><span class="n">settings</span><span class="p">:</span> <span class="n">Settings</span><span class="p">):</span>
    <span class="n">egress_enabled</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">settings</span><span class="p">.</span><span class="n">disable_telemetry</span>
    <span class="n">meterProviders</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">MetricReader</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">PrometheusMetricReader</span><span class="p">(</span><span class="bp">True</span><span class="p">)]</span> <span class="c1"># For /metrics
</span>    <span class="k">if</span> <span class="n">egress_enabled</span><span class="p">:</span>
        <span class="c1"># Also add OTLPMetricExporter for remote telemetry system
</span>        <span class="c1"># meterProviders.append(PeriodicExportingMetricReader(OTLPMetricExporter(...)))
</span>        <span class="k">pass</span>
    <span class="n">set_meter_provider</span><span class="p">(</span><span class="n">MeterProvider</span><span class="p">(</span><span class="n">meterProviders</span><span class="p">,</span> <span class="n">metrics_resource</span><span class="p">))</span>
    <span class="c1"># ... (logging setup) ...
</span></code></pre></div></div>
<p>This sets up the system so OTEL metrics can be scraped by Prometheus. If <code class="language-plaintext highlighter-rouge">settings.disable_telemetry</code> is false and an OTLP endpoint is configured, metrics might also be pushed to a remote Modular telemetry service.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The Telemetry and Metrics system (<code class="language-plaintext highlighter-rouge">METRICS</code>, <code class="language-plaintext highlighter-rouge">MetricClient</code>) is crucial for providing observability into <code class="language-plaintext highlighter-rouge">modular</code>’s operations. It uses the OpenTelemetry standard to collect vital statistics about request handling, model performance, and resource utilization. By exposing these metrics (often via Prometheus), operators can monitor the server’s health, diagnose issues, and optimize performance. With configurable recording methods and detail levels, <code class="language-plaintext highlighter-rouge">modular</code> balances the need for detailed insights with the desire for minimal performance overhead.</p>

<p>This concludes our journey through the core abstractions of the <code class="language-plaintext highlighter-rouge">modular</code> serving application! You’ve seen how <a href="01_settings___settings__class__.md">Settings (<code class="language-plaintext highlighter-rouge">Settings</code> class)</a> configure the server, how the <a href="02_serving_api_layer__fastapi_app___routers__.md">Serving API Layer (FastAPI App &amp; Routers)</a> handles requests, how the <a href="03_llm_pipeline_orchestrator___tokengeneratorpipeline___.md">LLM Pipeline Orchestrator (<code class="language-plaintext highlighter-rouge">TokenGeneratorPipeline</code>)</a> manages model interactions, the role of the <a href="04_model_worker_.md">Model Worker</a> and its <a href="05_scheduler___tokengenerationscheduler____embeddingsscheduler___.md">Scheduler (<code class="language-plaintext highlighter-rouge">TokenGenerationScheduler</code>, <code class="language-plaintext highlighter-rouge">EmbeddingsScheduler</code>)</a>, the importance of <a href="06_kv_cache_management_.md">KV Cache Management</a>, the communication facilitated by the <a href="07_enginequeue_.md">EngineQueue</a>, and finally, how Telemetry keeps us informed. We hope this tour has given you a solid foundation for understanding and working with <code class="language-plaintext highlighter-rouge">modular</code>!</p>

<hr />

<p>Generated by <a href="https://github.com/The-Pocket/Tutorial-Codebase-Knowledge">AI Codebase Knowledge Builder</a></p>
